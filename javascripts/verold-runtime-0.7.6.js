window.verold = window.verold || {};
window.verold.apiBaseUrl = typeof window.verold.apiBaseUrl === 'string' ? window.verold.apiBaseUrl : "http://localhost:3000";
window.verold.assetsBaseUrl = typeof window.verold.assetsBaseUrl === 'string' ? window.verold.assetsBaseUrl : "http://verold-assets-dev.commondatastorage.googleapis.com";
window.verold.staticBaseUrl = typeof window.verold.staticBaseUrl === 'string' ? window.verold.staticBaseUrl : "http://localhost:3000";
window.verold.glAssetsBaseUrl = typeof window.verold.glAssetsBaseUrl === 'string' ? window.verold.glAssetsBaseUrl : "http://localhost:3000/assets";
window.verold.debug = true;
window.verold.bust = "8ec12a";
window.VAPI = {};
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else {
    root.VAPI = factory();
  }
}(this, function () {
/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("VeroldEngine/libs/require/almond", function(){});

/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = runInContext();

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = _;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define('underscore',[],function() {
      return _;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports && freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = _;
    }
  }
  else {
    // in a browser or Rhino
    root._ = _;
  }
}.call(this));

//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define('backbone',['underscore', 'exports'], function(_, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = [];
      for (var i = 1; i < arguments.length; i++) {
        args[i-1] = arguments[i];  
      }

      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      args.unshift(name);
      if (allEvents) triggerEvents(allEvents, args);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = setImmediate;
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                }
            }));
        });
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback(null);
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (err, v) {
                results[x.index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        if (!keys.length) {
            return callback(null);
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (_keys(results).length === keys.length) {
                callback(null, results);
                callback = function () {};
            }
        });

        _each(keys, function (k) {
            var task = (tasks[k] instanceof Function) ? [tasks[k]]: tasks[k];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor !== Array) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (tasks.constructor === Array) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (test()) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            if (!test()) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if(data.constructor !== Array) {
              data = [data];
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            }
        };
        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            push: function (data, callback) {
                if(data.constructor !== Array) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain) cargo.drain();
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                callback.apply(null, memo[key]);
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.compose = function (/* functions... */) {
        var fns = Array.prototype.reverse.call(arguments);
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // AMD / RequireJS
    if (typeof define !== 'undefined' && define.amd) {
        define('async',[], function () {
            return async;
        });
    }
    // Node.js
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

define('VeroldEngine/libs/uuid',[], function() {
  function uuid() {
    var nid = "",
        len = 0;
    while (len < 36) {
      nid = nid.concat((Math.random() * 16 | 0).toString(16));
      len++;
    }
    return nid.replace(/^(\w{8})\w(\w{4})\w\w(\w{3})\w\w(\w{3})\w(\w{12})/, "$1-$2-4$3-" + "49ab".charAt(Math.random() * 4 | 0) + "$4-$5");
  }

  return uuid;
});

define('VeroldEngine/collections/subentity',[ 'underscore', 'backbone' ], function(_, Backbone) {
  var SubEntityCollection = Backbone.Collection.extend({
    initialize: function(models, options) {
      this.model = options.model;
      this.entity = options.entity;
      this.paths = options.paths || window.VAPI.defaultPaths;
    },

    url: function() {
      return this.paths.apiBaseUrl + '/entities/' + this.entity.id + '/entities.json';
    }

  });

  return SubEntityCollection;
});

/**
 * Main source
 */

;(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('VeroldEngine/libs/backbone/deep-model',['underscore', 'backbone' ], factory);
    } else {
        // globals
        factory(_, Backbone);
    }
}(function(_, Backbone) {
    function deepClone(obj) {
      var copy;

      // Handle the 3 simple types, and null or undefined
      if (null == obj || "object" != typeof obj) {
        return obj;
      }

      if (obj instanceof Backbone.Collection || obj instanceof Backbone.Model) {
        return obj;
      }

      // Handle Date
      if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
      }

      // Handle Array
      if (obj instanceof Array) {
        return obj.slice(0);
      }

      // Handle Object
      if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
          if (obj.hasOwnProperty(attr)) {
            copy[attr] = deepClone(obj[attr]);
          }
        }
        return copy;
      }

      throw new Error("Unable to copy obj! Its type isn't supported.");
    }

    // var deepClone = function(obj) {
    //   var func, isArr;
    //   if (!_.isObject(obj) || _.isFunction(obj)) {
    //     return obj;
    //   }
    //   if (_.isDate(obj)) {
    //     return new Date(obj.getTime());
    //   }
    //   if (_.isRegExp(obj)) {
    //     return new RegExp(obj.source, obj.toString().replace(/.*\//, ""));
    //   }
    //   if (_.isFunction(obj.getEntityModel)) {
    //     return obj;
    //   }
    //   isArr = _.isArray(obj || _.isArguments(obj));
    //   func = function(memo, value, key) {
    //     if (isArr) {
    //       memo.push(deepClone(value));
    //     } else {
    //       memo[key] = deepClone(value);
    //     }
    //     return memo;
    //   };
    //   return _.reduce(obj, func, isArr ? [] : {});
    // };

    _.deepClone = _.deepClone || _.cloneDeep || deepClone;


    /**
     * Takes a nested object and returns a shallow object keyed with the path names
     * e.g. { "level1.level2": "value" }
     *
     * @param  {Object}      Nested object e.g. { level1: { level2: 'value' } }
     * @return {Object}      Shallow object with path names e.g. { 'level1.level2': 'value' }
     */
    function objToPaths(obj) {
        var ret = {},
            separator = DeepModel.keyPathSeparator;

        for (var key in obj) {
            var val = obj[key];

            if (val && val.constructor === Object && !_.isEmpty(val)) {
                //Recursion for embedded objects
                var obj2 = objToPaths(val);

                for (var key2 in obj2) {
                    var val2 = obj2[key2];

                    ret[key + separator + key2] = val2;
                }
            } else {
                ret[key] = val;
            }
        }

        return ret;
    }

    /**
     * @param {Object}  Object to fetch attribute from
     * @param {String}  Object path e.g. 'user.name'
     * @return {Mixed}
     */
    function getNested(obj, path, return_exists) {
        var separator = DeepModel.keyPathSeparator;

        var fields = path ? path.split(separator) : [];
        var result = obj;
        return_exists || (return_exists === false);
        for (var i = 0, n = fields.length; i < n; i++) {
            if (return_exists && !_.has(result, fields[i])) {
                return false;
            }
            result = result[fields[i]];

            if (result == null && i < n - 1) {
                result = {};
            }

            if (typeof result === 'undefined') {
                if (return_exists)
                {
                    return true;
                }
                return result;
            }
        }
        if (return_exists)
        {
            return true;
        }
        return result;
    }

    /**
     * @param {Object} obj                Object to fetch attribute from
     * @param {String} path               Object path e.g. 'user.name'
     * @param {Object} [options]          Options
     * @param {Boolean} [options.unset]   Whether to delete the value
     * @param {Mixed}                     Value to set
     */
    function setNested(obj, path, val, options) {
        options = options || {};

        var separator = DeepModel.keyPathSeparator;

        var fields = path ? path.split(separator) : [];
        var result = obj;
        for (var i = 0, n = fields.length; i < n && result !== undefined ; i++) {
            var field = fields[i];

            //If the last in the path, set the value
            if (i === n - 1) {
                options.unset || (_.isUndefined(val) && !options.keepUndefined) ? delete result[field] : result[field] = val;
            } else {

                //Create the child object if it doesn't exist, or isn't an object
                if (typeof result[field] === 'undefined' || ! _.isObject(result[field])) {
                    result[field] = {};
                }

                //Move onto the next part of the path
                result = result[field];
            }
        }
    }

    function deleteNested(obj, path) {
      setNested(obj, path, null, { unset: true });
    }

    var DeepModel = Backbone.Model.extend({

        // Override constructor
        // Support having nested defaults by using _.deepExtend instead of _.extend
        constructor: function(attributes, options) {
            var defaults;
            var attrs = attributes || {};
            this.cid = _.uniqueId('c');
            this.attributes = {};
            if (options && options.collection) this.collection = options.collection;
            if (options && options.parse) attrs = this.parse(attrs, options) || {};
            if (defaults = _.result(this, 'defaults')) {
                //<custom code>
                // Replaced the call to _.defaults with _.deepExtend.
                attrs = _.deepExtend({}, defaults, attrs);
                //</custom code>
            }
            this.set(attrs, options);
            this.changed = {};
            this.initialize.apply(this, arguments);
        },

        // Return a copy of the model's `attributes` object.
        toJSON: function(options) {
          return deepClone(this.attributes);
        },

        // Override get
        // Supports nested attributes via the syntax 'obj.attr' e.g. 'author.user.name'
        get: function(attr) {
            return getNested(this.attributes, attr);
        },

        // Override set
        // Supports nested attributes via the syntax 'obj.attr' e.g. 'author.user.name'
        set: function(key, val, options) {
            var attr, attrs, unset, changes, silent, changing, prev, current;
            if (key == null) return this;

            // Handle both `"key", value` and `{key: value}` -style arguments.
            if (typeof key === 'object') {
              attrs = key;
              options = val || {};
            } else {
              (attrs = {})[key] = val;
            }

            options || (options = {});

            // Run validation.
            if (!this._validate(attrs, options)) return false;

            // Extract attributes and options.
            unset           = options.unset;
            silent          = options.silent;
            changes         = [];
            changing        = this._changing;
            this._changing  = true;

            if (!changing) {
              this._previousAttributes = deepClone(this.attributes); //<custom>: Replaced _.clone with deepClone
              this.changed = {};
            }
            current = this.attributes, prev = this._previousAttributes;

            // Check for changes of `id`.
            if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

            //<custom code>
            attrs = objToPaths(attrs);
            //</custom code>

            // For each `set` attribute, update or delete the current value.
            for (attr in attrs) {
              val = attrs[attr];

              //<custom code>: Using getNested, setNested and deleteNested
              if (!_.isEqual(getNested(current, attr), val)) changes.push(attr);
              if (!_.isEqual(getNested(prev, attr), val)) {
                setNested(this.changed, attr, val, { keepUndefined : true });
              } else {
                deleteNested(this.changed, attr);
              }
              unset ? deleteNested(current, attr) : setNested(current, attr, val);
              //</custom code>
            }

            // Trigger all relevant attribute changes.
            if (!silent) {
              if (changes.length) this._pending = true;

              //<custom code>
              var separator = DeepModel.keyPathSeparator;
              var alreadyTriggered = {}; // * @restorer

              for (var i = 0, l = changes.length; i < l; i++) {
                var key = changes[i];

                if (!alreadyTriggered.hasOwnProperty(key) || !alreadyTriggered[key]) { // * @restorer
                  alreadyTriggered[key] = true; // * @restorer
                  this.trigger('change:' + key, this, getNested(current, key), options);
                } // * @restorer

                var fields = key.split(separator);

                //Trigger change events for parent keys with wildcard (*) notation
                for(var n = fields.length - 1; n > 0; n--) {
                  var parentKey = _.first(fields, n).join(separator),
                      wildcardKey = parentKey + separator + '*';

                  if (!alreadyTriggered.hasOwnProperty(wildcardKey) || !alreadyTriggered[wildcardKey]) { // * @restorer
                    alreadyTriggered[wildcardKey] = true; // * @restorer
                    this.trigger('change:' + wildcardKey, this, getNested(current, parentKey), options);
                  } // * @restorer

                  // + @restorer
                  if (!alreadyTriggered.hasOwnProperty(parentKey) || !alreadyTriggered[parentKey]) {
                    alreadyTriggered[parentKey] = true;
                    this.trigger('change:' + parentKey, this, getNested(current, parentKey), options);
                  }
                  // - @restorer
                }
                //</custom code>
              }
            }

            if (changing) return this;
            if (!silent) {
              while (this._pending) {
                this._pending = false;
                this.trigger('change', this, options);
              }
            }
            this._pending = false;
            this._changing = false;
            return this;
        },

        // Clear all attributes on the model, firing `"change"` unless you choose
        // to silence it.
        clear: function(options) {
          var attrs = {};
          var shallowAttributes = objToPaths(this.attributes);
          for (var key in shallowAttributes) attrs[key] = void 0;
          return this.set(attrs, _.extend({}, options, {unset: true}));
        },

        // Determine if the model has changed since the last `"change"` event.
        // If you specify an attribute name, determine if that attribute has changed.
        hasChanged: function(attr) {
          if (attr == null) return !_.isEmpty(this.changed);
          return getNested(this.changed, attr) !== undefined;
        },

        // Return an object containing all the attributes that have changed, or
        // false if there are no changed attributes. Useful for determining what
        // parts of a view need to be updated and/or what attributes need to be
        // persisted to the server. Unset attributes will be set to undefined.
        // You can also pass an attributes object to diff against the model,
        // determining if there *would be* a change.
        changedAttributes: function(diff) {
          //<custom code>: objToPaths
          if (!diff) return this.hasChanged() ? objToPaths(this.changed) : false;
          //</custom code>

          var old = this._changing ? this._previousAttributes : this.attributes;

          //<custom code>
          diff = objToPaths(diff);
          old = objToPaths(old);
          //</custom code>

          var val, changed = false;
          for (var attr in diff) {
            if (_.isEqual(old[attr], (val = diff[attr]))) continue;
            (changed || (changed = {}))[attr] = val;
          }
          return changed;
        },

        // Get the previous value of an attribute, recorded at the time the last
        // `"change"` event was fired.
        previous: function(attr) {
          if (attr == null || !this._previousAttributes) return null;

          //<custom code>
          return getNested(this._previousAttributes, attr);
          //</custom code>
        },

        // Get all of the attributes of the model at the time of the previous
        // `"change"` event.
        previousAttributes: function() {
          //<custom code>
          return deepClone(this._previousAttributes);
          //</custom code>
        }
    });


    //Config; override in your app to customise
    DeepModel.keyPathSeparator = '.';


    //Exports
    Backbone.DeepModel = DeepModel;

    //For use in NodeJS
    if (typeof module != 'undefined') module.exports = DeepModel;

    return Backbone;

}));

define('VeroldEngine/models/entity',[ 'underscore', 'backbone', 'VeroldEngine/libs/uuid', 'VeroldEngine/collections/subentity', 'VeroldEngine/libs/backbone/deep-model' ],
       function(_, Backbone, uuid, SubEntityCollection) {
  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Helper function to get a value from a Backbone object as a property
  // or as a function.
  var getValue = function(object, prop) {
    if (!(object && object[prop])) return null;
    return _.isFunction(object[prop]) ? object[prop]() : object[prop];
  };

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  var EntityModel = Backbone.DeepModel.extend({
    idAttribute: 'id',

    initialize: function(attributes, options) {
      this.isPersistent = true;
      this.creationCallbacks = { success: {}, failure: {}};
      this.paths = (options && options.paths) ||
          (this.collection && this.collection.paths) ||
          window.VAPI.defaultPaths;
      this.subEntities = new SubEntityCollection([], { model: EntityModel, entity: this, paths: this.paths });

      if (!this.paths) {
        throw new Error('paths not set!');
      }
    },

    url: function() {
      if (this.has('id')) {
        return this.paths.apiBaseUrl + '/entities/' + this.get('id') + '.json';
      }
      else {
        return this.paths.apiBaseUrl + '/projects/' + this.get('projectId') + '/entities.json';
      }
    },

    isAsset: function() {

      if ( this.get("parentAssetId") === this.get("id") || !this.get("parentAssetId")) {
        return true;
      }
      else {
        return false;
      }
    },

    isValidEntityId: function(str) {
      var len = str.length;
      if (len === 12 || len === 24) {
        return (/^[0-9a-fA-F]+$/).test(str);
      } else {
        return false;
      }
    },

    getPath: function( formatType ) {
      var prefix = this.get('veroldAsset') ?
          (this.paths.glAssetsBaseUrl + 
            (this.paths.glAssetsBaseUrl.substr(-1) === '/' ? '' : '/') + this.get('folder')) :
          (this.paths.assetsBaseUrl + 
            (this.paths.assetsBaseUrl.substr(-1) === '/' ? '' : '/') + 'entities/' + this.get('rootFolder') + "/" + this.get("folder"));

      var path = "path";
      var type = this.get("type");

      if ( type === "texture2D" || type === "video" ) {
        path = this.get("payload")[formatType];
        if ( path ) { path = path.path; }
        else { path = this.get("payload").path; }

        if ( path && !this.get("payload").isLocal ) {
          path = prefix + "/" + path;
        }
      }
      else if ( type === "textureCube") {
        path = this.get("payload")[formatType];
        if ( path ) { path = path.path; }
        else { path = this.get("payload").path; }

        if ( !this.get("payload").isLocal ) {
          if ( _.isArray( path )) {
            var tmpPath = path;
            path = [];
            for ( var x in tmpPath ) {
              path.push( prefix + "/" + tmpPath[x] );
            }
          }
          else {
            path = prefix + "/" + path;
          }
        }
      }
      else if ( type === "textureVideo" ) {
        var exts = [ 'mp4', 'webm' ];

        path = [];
        for ( var i in exts ) {
          var tmpPath = this.get("payload")[formatType + '_' + exts[i]];
          if ( tmpPath ) {
            tmpPath = tmpPath.path;
            if ( !this.get("payload").isLocal ) {
              tmpPath = prefix + "/" + tmpPath;
            }

            path.push(tmpPath);
          }
        }
      }
      else if ( type === "renderTexture2D" || type === "renderTextureCube") {
        path = null;
      }
      else if ( type === "mesh" || type === "skinned_mesh" ) {
        path = this.get("payload").geometry;

        if ( !this.get("payload").isLocal ) {
          path = prefix + "/" + this.get("payload").geometry;
        }
      }
      else if ( type === "audio" ) {
        var exts = [ 'mp3', 'ogg' ];

        path = [];
        for ( var i in exts ) {
          var tmpPath = this.get("payload")[formatType + '_' + exts[i]];
          if ( tmpPath ) {
            tmpPath = tmpPath.path;
            if ( !this.get("payload").isLocal ) {
              tmpPath = prefix + "/" + tmpPath;
            }

            path.push(tmpPath);
          }
        }
      }
      else {
        path = this.get("payload").path;

        if ( !this.get("payload").isLocal ) {
          path = prefix + "/" + this.get("payload").path;
        }
      }

      return path;
    },

    getResourcePathPrefix: function() {
      var prefix = '';

      if (this.get('overridePrefix')) {
        prefix = this.get('overridePrefix');
      } else if (!this.get('payload').isLocal) {
        if (this.get('veroldAsset')) {
          prefix = this.paths.glAssetsBaseUrl + '/' + this.get('folder') + '/';
        } else {
          prefix = this.paths.assetsBaseUrl + '/entities/' + this.get('rootFolder') + '/' + this.get('folder') + '/';
        }
      }
      return prefix;
    },

    getResourcePath: function(idx) {
      var resource = this.getResources()[idx];
      if ( resource ) {
        return this.getResourcePathPrefix() + resource.path;
      }
      else {
        return null;
      }
    },

    getResources: function() {
      return this.get("resources") || [];
    },

    clonePayload: function() {
      function _cloneValues( obj ) {
        var newObj, x;
        if ( _.isArray( obj )) {
          newObj = [];
          for ( x in obj) {
            newObj.push( _cloneValues( obj[x] ) );
          }
          return newObj;
        }
        else if ( _.isObject( obj )) {
          newObj = {};
          for ( x in obj) {
            newObj[x] = _cloneValues( obj[x] );
          }
          return newObj;
        }
        else {
          return obj;
        }
      }

      var newPayload = {};
      var payload = this.get("payload");
      for ( var x in payload ) {
        newPayload[x] = _cloneValues( payload[x] );
      }
      return newPayload;
    },

    cloneComponents: function() {
      function _cloneValues( obj ) {
        var newObj, x;
        if ( _.isArray( obj )) {
          newObj = [];
          for ( x in obj) {
            newObj.push( _cloneValues( obj[x] ) );
          }
          return newObj;
        }
        else if ( _.isObject( obj )) {
          newObj = {};
          for ( x in obj) {
            newObj[x] = _cloneValues( obj[x] );
          }
          return newObj;
        }
        else {
          return obj;
        }
      }

      var newComponents = {};
      var components = this.get("components");
      for ( var x in components ) {
        newComponents[x] = _cloneValues( components[x] );
      }
      return newComponents;
    },


    getInstance: function(json, fn) {
      var url = '/entities/' + this.get('id') + '/instances.json';

      Backbone.$.ajax({
        type: 'POST',
        url: url,
        data: json,
        dataType: 'json'
      }).done(function(entity) {
        fn(new EntityModel(entity, { paths: this.paths }));
      });
    },

    getClone: function(json, fn) {
      var url = '/entities/' + this.get('id') + '/clone.json';

      Backbone.$.ajax({
        type: 'POST',
        url: url,
        data: json,
        dataType: 'json'
      }).done(function(entity) {
        fn(new EntityModel(entity, { paths: this.paths }));
      }.bind(this));
    },

    clearData: function( includeLocalData ) {
      var current = this.toJSON();
      _.each( current, function( value, name ) {
        if ( includeLocalData || (name !== "dependencies" && name !== "geometries" ) ) {
          current[name] = undefined;
        }
        // if ( json[ name ] === undefined ) {
        //   json[ name ] = undefined;
        // }
        // if ( _.isObject( json[ name ] ) ) {
        //   _.each( current[ name ], function( subValue, subName ) {
        //     if ( json[name][subName] === undefined ) {
        //       json[name][subName] = undefined;
        //     }
        //   }, this );
        // }
      }, this );
    },

    // Original in Backbone.Model, modified to strip out temporary entities
    sync: function(method, model, options) {
      // if (method === 'update') {
        //console.log('save triggered');
        //console.trace();
        //debugger;
      // }

      var type = methodMap[method],
          objectIdRegex = /^[a-f0-9]{24}$/i;

      // Default options, unless specified.
      _.defaults(options || (options = {}), {
        emulateHTTP: Backbone.emulateHTTP,
        emulateJSON: Backbone.emulateJSON
      });

      // Default JSON-request options.
      var params = {type: type, dataType: 'json'};

      // Ensure that we have a URL.
      if (!options.url) {
        params.url = _.result(model, 'url') || urlError();
      }

      // Ensure that we have the appropriate request data.
      if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
        params.contentType = 'application/json';
        // REMOVE TEMPORARY ASSETS
        var obj = JSON.parse(JSON.stringify(options.attrs || model.toJSON(options)));

        for (var entityId in obj.children) {
          if (!entityId.match(objectIdRegex)) {
            delete obj.children[entityId];
          }
        }


        _.each( obj.components, function( comp, compId ) {
          var script = this.veroldEngine.assetRegistry.getAssetById( comp.scriptId );
          if ( !script || !comp.scriptId.match(objectIdRegex) && !script.entityModel.isBuiltIn) {
            delete obj.components[compId];
          }
        }, this );

        delete obj.dependencies;
        // delete obj.material_dependencies;
        // delete obj.local_dependencies;

        // use angular stringify if present to remove inspector angular data like $$hasKey
        params.data = window.angular && window.angular.toJson(obj) || JSON.stringify(obj);
        // END OF MODIFICATIONS
      }

      // For older servers, emulate JSON by encoding the request into an HTML-form.
      if (options.emulateJSON) {
        params.contentType = 'application/x-www-form-urlencoded';
        params.data = params.data ? {model: params.data} : {};
      }

      // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
      // And an `X-HTTP-Method-Override` header.
      if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
        params.type = 'POST';
        if (options.emulateJSON) params.data._method = type;
        var beforeSend = options.beforeSend;
        options.beforeSend = function(xhr) {
          xhr.setRequestHeader('X-HTTP-Method-Override', type);
          if (beforeSend) return beforeSend.apply(this, arguments);
        };
      }

      // Don't process data on a non-GET request.
      if (params.type !== 'GET' && !options.emulateJSON) {
        params.processData = false;
      }

      // If we're sending a `PATCH` request, and we're in an old Internet Explorer
      // that still has ActiveX enabled by default, override jQuery to use that
      // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
      if (params.type === 'PATCH' && window.ActiveXObject &&
            !(window.external && window.external.msActiveXFilteringEnabled)) {
        params.xhr = function() {
          return new ActiveXObject("Microsoft.XMLHTTP");
        };
      }

      // Make the request, allowing the user to override any Ajax options.
      var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
      model.trigger('request', model, xhr, options);
      return xhr;
    },

    getPreviewImageUrl: function() {
      return this.paths.assetsBaseUrl + '/previews/' + this.get('projectId') + '/' + this.id + '.png';
    },

    getDefaultPreviewImageUrl: function() {
      return EntityModel.getDefaultPreviewImageUrlByType(this.paths.staticBaseUrl, this.get('type'));
    },

    getDefaultMaterialPreviewImageUrl: function() {
      return this.paths.staticBaseUrl + '/images/assets-icons/asset-icon-material-default.png';
    },

    getPreviewImage: function(fn) {
      if (!this.get('hasPreview')) {
        return fn(new Error('Entity does not have a preview image'));
      }

      var img = new Image();
      img.crossOrigin = 'Anonymous';

      img.onload = function() {
        fn(null, img);
      };

      img.onerror = function() {
        return fn(new Error('preview image does not exist'));
      };

      img.src = this.getPreviewImageUrl();
    },

    getDefaultPreviewImage: function(fn) {
      var path = this.getDefaultPreviewImageUrl();

      if (path) {
        var img = new Image();

        img.crossOrigin = 'Anonymous';

        img.onload = function() {
          fn(null, img);
        };

        img.onerror = function() {
          return fn(new Error('default preview image does not exist'));
        };

        img.src = path;
      }
    },

    setPayloadRecursive: function(payload, fn) {
      var request = new XMLHttpRequest();
      var myTransId = uuid();
      request.open('PATCH', '/entities/' + this.get('id') + '.json', true);          
      request.setRequestHeader('Content-Type', 'application/json');
      request.setRequestHeader('X-Verold-Recursive', 'true');
      request.setRequestHeader('X-Verold-TransactionId', myTransId);
      // request.onreadystatechange = function () {
      
      //   if ( request.readyState === request.DONE ) {
      //     if (fn) {
      //       fn();
      //     }
      //   }
      // };
      function callback(transId) {
        if (transId === myTransId) {
          window.verold.veroldEvents.off('remoteScene:transactionEnd', callback);
          if (fn) {
            fn();
          }
        }
      }
      window.verold.veroldEvents.on('remoteScene:transactionEnd', callback);
      request.send(JSON.stringify({ payload: payload }));
      
    }
  });

  EntityModel.getDefaultPreviewImageUrlByType = function(staticBaseUrl, type) {
    if(type === 'geometry') {
      type = 'model';
    }

    return staticBaseUrl + '/images/assets-icons/asset-icon-' + type + '.png';
  };

  window.VAPI = window.VAPI || {};
  window.VAPI.EntityModel = EntityModel;

  return EntityModel;
});

define('VeroldEngine/collections/entity',[ 'underscore', 'backbone', 'VeroldEngine/models/entity' ], function(_, Backbone, EntityModel) {
  var EntityCollection = Backbone.Collection.extend({
    model: EntityModel,

    initialize: function(models, options) {
      this.paths = options && options.paths || 
          (this.collection && this.collection.paths) || 
          window.VAPI.defaultPaths;
      this.project = options && options.project;

      if (!this.paths) {
        throw new Error('paths not set!');  
      }
    },

    url: function() {
      return this.paths.apiBaseUrl + '/projects/' + this.project.id + '/entities.json';
    }

  });

  window.VAPI = window.VAPI || {};
  window.VAPI.EntityCollection = EntityCollection;

  return EntityCollection;
});

define('three',[], function() {
// The MIT License

// Copyright  2010-2015 three.js authors

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '70dev' };

// browserify support

if ( typeof module === 'object' ) {

	module.exports = THREE;

}

// polyfills

if ( Math.sign === undefined ) {

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;

	};

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// HDR TYPE CONSTANTS

THREE.HDRFull = 0;
THREE.HDRRGBM = 1;
THREE.HDRRGBD = 2;
THREE.HDRLOGLUV = 3;
THREE.HDRRGBE = 4;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;

// ATC compressed texture formats
THREE.RGB_ATC_Format = 2200;
THREE.RGBA_ATC_EXPLICIT_ALPHA_Format = 2201;
THREE.RGBA_ATC_INTERP_ALPHA_Format = 2202;

// DEPRECATED

THREE.Projector = function () {

	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function ( vector, camera ) {

		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

	};

};

THREE.CanvasRenderer = function () {

	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

	this.domElement = document.createElement( 'canvas' );
	this.clear = function () {};
	this.render = function () {};
	this.setClearColor = function () {};
	this.setSize = function () {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

	}

	return this.set( color )

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var hue2rgb = function ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			};

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		// rgb(255,0,0)

		if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

			var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

			return this;

		}

		// rgb(100%,0%,0%)

		if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

			var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

			return this;

		}

		// #ff0000

		if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

			var color = /^\#([0-9a-f]{6})$/i.exec( style );

			this.setHex( parseInt( color[ 1 ], 16 ) );

			return this;

		}

		// #f00

		if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

			var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

			return this;

		}

		// red

		if ( /^(\w+)$/i.test( style ) ) {

			this.setHex( THREE.ColorKeywords[ style ] );

			return this;

		}


	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array ) {

		this.r = array[ 0 ];
		this.g = array[ 1 ];
		this.b = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.r, this.g, this.b ];

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	_x: 0,_y: 0, _z: 0, _w: 0,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		if ( euler.order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function ( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			this.normalize();

			return this;

		}

	}(),

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Quaternion( this._x, this._y, this._z, this._w );

	}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;
	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	//START_VEROLD_MOD
	angleTo: function ( v ) {

		return Math.acos( this.dot( v ) / this.length() / v.length() );

	},
	//END_VEROLD_MOD

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

	    if ( offset === undefined ) offset = 0;

	    index = index * attribute.itemSize + offset;

	    this.x = attribute.array[ index ];
	    this.y = attribute.array[ index + 1 ];

	    return this;

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function ( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function ( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function ( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function ( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function ( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

		return this.setFromMatrixScale( m );
	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

	    if ( offset === undefined ) offset = 0;

	    index = index * attribute.itemSize + offset;

	    this.x = attribute.array[ index ];
	    this.y = attribute.array[ index + 1 ];
	    this.z = attribute.array[ index + 2 ];

	    return this;

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;
			this.w *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		   && ( Math.abs( m13 - m31 ) < epsilon )
		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			   && ( Math.abs( m13 + m31 ) < epsilon2 )
			   && ( Math.abs( m23 + m32 ) < epsilon2 )
			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) { // m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else { // m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						  + ( m13 - m31 ) * ( m13 - m31 )
						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		if ( this.w > v.w ) {

			this.w = v.w;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		if ( this.w < v.w ) {

			this.w = v.w;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		if ( this.w < min.w ) {

			this.w = min.w;

		} else if ( this.w > max.w ) {

			this.w = max.w;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );

		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

	    if ( offset === undefined ) offset = 0;

	    index = index * attribute.itemSize + offset;

	    this.x = attribute.array[ index ];
	    this.y = attribute.array[ index + 1 ];
	    this.z = attribute.array[ index + 2 ];
	    this.w = attribute.array[ index + 3 ];

	    return this;

	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	}

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = THREE.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix;

		return function ( q, order, update ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();
			matrix.makeRotationFromQuaternion( q );
			this.setFromRotationMatrix( matrix, order, update );

			return this;

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._order ];

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new THREE.Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {},

	clone: function () {

		return new THREE.Euler( this._x, this._y, this._z, this._order );

	}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	},

	clone: function () {

		return new THREE.Line3().copy( this );

	}

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;
	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;
	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;
	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box2().copy( this );

	}

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] )

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and childrens', world transforms

		var v1 = new THREE.Vector3();

		return function ( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry instanceof THREE.Geometry ) {

						var vertices = geometry.vertices;

						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

							v1.copy( vertices[ i ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

						var positions = geometry.attributes[ 'position' ].array;

						for ( var i = 0, il = positions.length; i < il; i += 3 ) {

							v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			} );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box3().copy( this );

	}

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function () {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1 = new THREE.Vector3();

		return function ( array, offset, length ) {

			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

				v1.x = array[ j ];
				v1.y = array[ j + 1 ];
				v1.z = array[ j + 2 ];

				v1.applyMatrix3( this );

				array[ j ]     = v1.x;
				array[ j + 1 ] = v1.y;
				array[ j + 2 ] = v1.z;

			}

			return array;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset     ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	},

	clone: function () {

		return new THREE.Matrix3().fromArray( this.elements );

	}

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {
 
 		var te = this.elements;
 
		xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
		yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
		zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );
 
 		return this;
 		
 	},
 
	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0,       0,       0,       1
		);

	    return this;

	},

	extractRotation: function () {

		var v1 = new THREE.Vector3();

		return function ( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

		return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},

	applyToVector3Array: function () {

		var v1 = new THREE.Vector3();

		return function ( array, offset, length ) {

			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {

				v1.x = array[ j ];
				v1.y = array[ j + 1 ];
				v1.z = array[ j + 2 ];

				v1.applyMatrix4( this );

				array[ j ]     = v1.x;
				array[ j + 1 ] = v1.y;
				array[ j + 2 ] = v1.z;

			}

			return array;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		var te = this.elements;

		array[ offset     ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	},

	getPosition: function () {

		var v1 = new THREE.Vector3();

		return function () {

			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det == 0 ) {

			var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.warn( 'THREE.Matrix4: .translate() has been removed.' );

	},

	rotateX: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateX() has been removed.' );

	},

	rotateY: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateY() has been removed.' );

	},

	rotateZ: function ( angle ) {

		console.warn( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},

	rotateByAxis: function ( axis, angle ) {

		console.warn( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector = new THREE.Vector3();
		var matrix = new THREE.Matrix4();

		return function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {
				sx = - sx;
			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	},

	clone: function () {

		return new THREE.Matrix4().fromArray( this.elements );

	}

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceTo( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceTo( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new THREE.Vector3();
		var segDir = new THREE.Vector3();
		var diff = new THREE.Vector3();

		return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),


	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	intersectSphere: function () {

		// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

		var v1 = new THREE.Vector3();

		return function ( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );

			var tca = v1.dot( this.direction );

			var d2 = v1.dot( v1 ) - tca * tca;

			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0 
			return this.at( t0, optionalTarget );

		}

	}(),

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator == 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) == 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;
		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {

		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	}(),

	intersectBox: function ( box , optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin,tmax,tymin,tymax,tzmin,tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;
		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;
		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;
		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;
	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	},

	clone: function () {

		return new THREE.Ray().copy( this );

	}

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;
	},

	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter )  {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

 		};

	}(),

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	},

	clone: function () {

		return new THREE.Sphere().copy( this );

	}

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function ( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}
			}

			return true;
		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	clone: function () {

		return new THREE.Frustum().copy( this );

	}

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),


	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function () {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) == 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

	},

	clone: function () {

		return new THREE.Plane().copy( this );

	}

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {

					uuid[ i ] = '-';

				} else if ( i == 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}
			}

			return uuid.join( '' );

		};

	}(),

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return Math.floor( this.randFloat( low, high ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function () {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function () {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}(),

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// colinear or singular triangle
		if ( denom == 0 ) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );
		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycoordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function () {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	},

	clone: function () {

		return new THREE.Triangle().copy( this );

	}

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance !== undefined && self.performance.now !== undefined
					 ? self.performance.now()
					 : Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance !== undefined && self.performance.now !== undefined
					 ? self.performance.now()
					 : Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {}

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [];
			var length = listenerArray.length;

			for ( var i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( var i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Sprite: {},
			Mesh: {},
			PointCloud: { threshold: 1 },
			LOD: {},
			Line: {}
		};

	};

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var intersectObject = function ( object, raycaster, intersects, recursive ) {

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	};

	//

	THREE.Raycaster.prototype = {

		constructor: THREE.Raycaster,

		precision: 0.0001,
		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			// camera is assumed _not_ to be a child of a transformed object

			if ( camera instanceof THREE.PerspectiveCamera ) {

				this.ray.origin.copy( camera.position );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();

			} else if ( camera instanceof THREE.OrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( descSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( objects instanceof Array === false ) {

				console.log( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( descSort );

			return intersects;

		}

	};

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Object3D = function () {

	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = undefined;
	this.children = [];

	this.up = THREE.Object3D.DefaultUp.clone();

	var scope = this;

	var position = new THREE.Vector3();
	var rotation = new THREE.Euler();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3( 1, 1, 1 );

	var onRotationChange = function () {
		quaternion.setFromEuler( rotation, false );
	};

	var onQuaternionChange = function () {
		rotation.setFromQuaternion( quaternion, undefined, false );
	};

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
	} );

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = false;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	get eulerOrder () {

		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {
		//Firefox doesn't like when setters don't have a parameter and minifiers strip unused parameters out. So, let's use 'value'.
		var tmp = value;
		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		}

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		}

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		};

		if ( object === this ) {

			console.error( "THREE.Object3D.add:", object, "can't be added as a child of itself." );
			return this;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add:", object, "is not an instance of THREE.Object3D." );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i++ ) {

				this.remove( arguments[ i ] );

			}

		};

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getChildByName: function ( name, recursive ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name, recursive );

	},

	getObjectById: function ( id, recursive ) {

		return this.getObjectByProperty( 'id', id, recursive );

	},

	getObjectByName: function ( name, recursive ) {

		return this.getObjectByProperty( 'name', name, recursive );

	},

	getObjectByProperty: function ( name, value, recursive ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value, recursive );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new THREE.Vector3();
		var scale = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		}

	}(),

	getWorldRotation: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		}

	}(),

	getWorldScale: function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		}

	}(),

	getWorldDirection: function () {

		var quaternion = new THREE.Quaternion();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		}

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		if ( this.parent ) {

			callback( this.parent );

			this.parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === undefined ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.3,
				type: 'Object',
				generator: 'ObjectExporter'
			}
		};

		//

		var geometries = {};

		var parseGeometry = function ( geometry ) {

			if ( output.geometries === undefined ) {

				output.geometries = [];

			}

			if ( geometries[ geometry.uuid ] === undefined ) {

				var json = geometry.toJSON();

				delete json.metadata;

				geometries[ geometry.uuid ] = json;

				output.geometries.push( json );

			}

			return geometry.uuid;

		};

		//

		var materials = {};

		var parseMaterial = function ( material ) {

			if ( output.materials === undefined ) {

				output.materials = [];

			}

			if ( materials[ material.uuid ] === undefined ) {

				var json = material.toJSON();

				delete json.metadata;

				materials[ material.uuid ] = json;

				output.materials.push( json );

			}

			return material.uuid;

		};

		//

		var parseObject = function ( object ) {

			var data = {};

			data.uuid = object.uuid;
			data.type = object.type;

			if ( object.name !== '' ) data.name = object.name;
			if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;
			if ( object.visible !== true ) data.visible = object.visible;

			if ( object instanceof THREE.PerspectiveCamera ) {

				data.fov = object.fov;
				data.aspect = object.aspect;
				data.near = object.near;
				data.far = object.far;

			} else if ( object instanceof THREE.OrthographicCamera ) {

				data.left = object.left;
				data.right = object.right;
				data.top = object.top;
				data.bottom = object.bottom;
				data.near = object.near;
				data.far = object.far;

			} else if ( object instanceof THREE.AmbientLight ) {

				data.color = object.color.getHex();

			} else if ( object instanceof THREE.DirectionalLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;

			} else if ( object instanceof THREE.PointLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;
				data.distance = object.distance;

			} else if ( object instanceof THREE.SpotLight ) {

				data.color = object.color.getHex();
				data.intensity = object.intensity;
				data.distance = object.distance;
				data.angle = object.angle;
				data.exponent = object.exponent;

			} else if ( object instanceof THREE.HemisphereLight ) {

				data.color = object.color.getHex();
				data.groundColor = object.groundColor.getHex();

			} else if ( object instanceof THREE.Mesh ) {

				data.geometry = parseGeometry( object.geometry );
				data.material = parseMaterial( object.material );

			} else if ( object instanceof THREE.Line ) {

				data.geometry = parseGeometry( object.geometry );
				data.material = parseMaterial( object.material );

			} else if ( object instanceof THREE.Sprite ) {

				data.material = parseMaterial( object.material );

			}

			data.matrix = object.matrix.toArray();

			if ( object.children.length > 0 ) {

				data.children = [];

				for ( var i = 0; i < object.children.length; i ++ ) {

					data.children.push( parseObject( object.children[ i ] ) );

				}

			}

			return data;

		}

		output.object = parseObject( this );

		return output;

	},

	clone: function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Object3D();
		if ( recursive === undefined ) recursive = true;

		object.name = this.name;

		object.up.copy( this.up );

		object.position.copy( this.position );
		object.quaternion.copy( this.quaternion );
		object.scale.copy( this.scale );

		object.rotationAutoUpdate = this.rotationAutoUpdate;

		object.matrix.copy( this.matrix );
		object.matrixWorld.copy( this.matrixWorld );

		object.matrixAutoUpdate = this.matrixAutoUpdate;
		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

		object.visible = this.visible;

		object.castShadow = this.castShadow;
		object.receiveShadow = this.receiveShadow;

		object.frustumCulled = this.frustumCulled;

		object.userData = JSON.parse( JSON.stringify( this.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < this.children.length; i ++ ) {

				var child = this.children[ i ];
				object.add( child.clone() );

			}

		}

		return object;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		var face = new THREE.Face3( this.a, this.b, this.c );

		face.normal.copy( this.normal );
		face.color.copy( this.color );

		face.materialIndex = this.materialIndex;

		for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

			face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

			face.vertexColors[ i ] = this.vertexColors[ i ].clone();

		}

		for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

			face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		}

		return face;

	}

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )
	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

	this.array = array;
	this.itemSize = itemSize;

	this.needsUpdate = false;

};

THREE.BufferAttribute.prototype = {

	constructor: THREE.BufferAttribute,

	get length () {

		return this.array.length;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

	},

	set: function ( value ) {

		this.array.set( value );

		return this;

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index     ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

	}

};

//

THREE.Int8Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint8ClampedAttribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );


};

THREE.Int16Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint16Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Int32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Uint32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float32Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

THREE.Float64Attribute = function ( data, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );
	return new THREE.BufferAttribute( data, itemSize );

};

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.attributes = {};
	this.attributesKeys = [];

	this.drawcalls = [];
	this.offsets = this.drawcalls; // backwards compatibility

	this.boundingBox = null;
	this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addAttribute: function ( name, attribute ) {

		if ( attribute instanceof THREE.BufferAttribute === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

			return;

		}

		this.attributes[ name ] = attribute;
		this.attributesKeys = Object.keys( this.attributes );

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	addDrawCall: function ( start, count, indexOffset ) {

		this.drawcalls.push( {

			start: start,
			count: count,
			index: indexOffset !== undefined ? indexOffset : 0

		} );

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

	},

	center: function () {

		// TODO

	},

	fromGeometry: function ( geometry, settings ) {

		settings = settings || { 'vertexColors': THREE.NoColors };

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var faceVertexUvs = geometry.faceVertexUvs;
		var vertexColors = settings.vertexColors;
		var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;

		var positions = new Float32Array( faces.length * 3 * 3 );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

		var normals = new Float32Array( faces.length * 3 * 3 );
		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

		if ( vertexColors !== THREE.NoColors ) {

			var colors = new Float32Array( faces.length * 3 * 3 );
			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

		}

		if ( hasFaceVertexUv === true ) {

			var uvs = new Float32Array( faces.length * 3 * 2 );
			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

		}

		for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {

			var face = faces[ i ];

			var a = vertices[ face.a ];
			var b = vertices[ face.b ];
			var c = vertices[ face.c ];

			positions[ i3     ] = a.x;
			positions[ i3 + 1 ] = a.y;
			positions[ i3 + 2 ] = a.z;

			positions[ i3 + 3 ] = b.x;
			positions[ i3 + 4 ] = b.y;
			positions[ i3 + 5 ] = b.z;

			positions[ i3 + 6 ] = c.x;
			positions[ i3 + 7 ] = c.y;
			positions[ i3 + 8 ] = c.z;

			if ( hasFaceVertexNormals === true ) {

				var na = face.vertexNormals[ 0 ];
				var nb = face.vertexNormals[ 1 ];
				var nc = face.vertexNormals[ 2 ];

				normals[ i3     ] = na.x;
				normals[ i3 + 1 ] = na.y;
				normals[ i3 + 2 ] = na.z;

				normals[ i3 + 3 ] = nb.x;
				normals[ i3 + 4 ] = nb.y;
				normals[ i3 + 5 ] = nb.z;

				normals[ i3 + 6 ] = nc.x;
				normals[ i3 + 7 ] = nc.y;
				normals[ i3 + 8 ] = nc.z;

			} else {

				var n = face.normal;

				normals[ i3     ] = n.x;
				normals[ i3 + 1 ] = n.y;
				normals[ i3 + 2 ] = n.z;

				normals[ i3 + 3 ] = n.x;
				normals[ i3 + 4 ] = n.y;
				normals[ i3 + 5 ] = n.z;

				normals[ i3 + 6 ] = n.x;
				normals[ i3 + 7 ] = n.y;
				normals[ i3 + 8 ] = n.z;

			}

			if ( vertexColors === THREE.FaceColors ) {

				var fc = face.color;

				colors[ i3     ] = fc.r;
				colors[ i3 + 1 ] = fc.g;
				colors[ i3 + 2 ] = fc.b;

				colors[ i3 + 3 ] = fc.r;
				colors[ i3 + 4 ] = fc.g;
				colors[ i3 + 5 ] = fc.b;

				colors[ i3 + 6 ] = fc.r;
				colors[ i3 + 7 ] = fc.g;
				colors[ i3 + 8 ] = fc.b;

			} else if ( vertexColors === THREE.VertexColors ) {

				var vca = face.vertexColors[ 0 ];
				var vcb = face.vertexColors[ 1 ];
				var vcc = face.vertexColors[ 2 ];

				colors[ i3     ] = vca.r;
				colors[ i3 + 1 ] = vca.g;
				colors[ i3 + 2 ] = vca.b;

				colors[ i3 + 3 ] = vcb.r;
				colors[ i3 + 4 ] = vcb.g;
				colors[ i3 + 5 ] = vcb.b;

				colors[ i3 + 6 ] = vcc.r;
				colors[ i3 + 7 ] = vcc.g;
				colors[ i3 + 8 ] = vcc.b;

			}

			if ( hasFaceVertexUv === true ) {

				var uva = faceVertexUvs[ 0 ][ i ][ 0 ];
				var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];
				var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];

				uvs[ i2     ] = uva.x;
				uvs[ i2 + 1 ] = uva.y;

				uvs[ i2 + 2 ] = uvb.x;
				uvs[ i2 + 3 ] = uvb.y;

				uvs[ i2 + 4 ] = uvc.x;
				uvs[ i2 + 5 ] = uvc.y;

			}

		}

		this.computeBoundingSphere()

		return this;

	},

	computeBoundingBox: function () {

		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new THREE.Box3();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				var bb = this.boundingBox;
				bb.makeEmpty();

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					bb.expandByPoint( vector );

				}

			}

			if ( positions === undefined || positions.length === 0 ) {

				this.boundingBox.min.set( 0, 0, 0 );
				this.boundingBox.max.set( 0, 0, 0 );

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.' );

			}

		}

	}(),

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes.position.array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					box.expandByPoint( vector );

				}

				box.center( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.' );

				}

			}

		}

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var attributes = this.attributes;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var normals = attributes.normal.array;

				for ( var i = 0, il = normals.length; i < il; i ++ ) {

					normals[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( attributes.index ) {

				var indices = attributes.index.array;

				var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

				for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

					var start = offsets[ j ].start;
					var count = offsets[ j ].count;
					var index = offsets[ j ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = ( index + indices[ i     ] ) * 3;
						vB = ( index + indices[ i + 1 ] ) * 3;
						vC = ( index + indices[ i + 2 ] ) * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA     ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB     ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC     ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i     ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( this.attributes.index === undefined ||
			 this.attributes.position === undefined ||
			 this.attributes.normal === undefined ||
			 this.attributes.uv === undefined ) {

			console.warn( 'Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
			return;

		}

		var indices = this.attributes.index.array;
		var positions = this.attributes.position.array;
		var normals = this.attributes.normal.array;
		var uvs = this.attributes.uv.array;

		var nVertices = positions.length / 3;

		if ( this.attributes.tangent === undefined ) {

			this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		var tangents = this.attributes.tangent.array;

		var tan1 = [], tan2 = [];

		for ( var k = 0; k < nVertices; k ++ ) {

			tan1[ k ] = new THREE.Vector3();
			tan2[ k ] = new THREE.Vector3();

		}

		var vA = new THREE.Vector3(),
			vB = new THREE.Vector3(),
			vC = new THREE.Vector3(),

			uvA = new THREE.Vector2(),
			uvB = new THREE.Vector2(),
			uvC = new THREE.Vector2(),

			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r;

		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;

			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;

			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;

			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			// START_VEROLD_MOD - tangents
			r = s1 * t2 - s2 * t1;

			sdir.set(
				t2 * x1 - t1 * x2,
				t2 * y1 - t1 * y2,
				t2 * z1 - t1 * z2
			);

			tdir.set(
				s1 * x2 - s2 * x1,
				s1 * y2 - s2 * y1,
				s1 * z2 - s2 * z1
			);

			sdir.divideScalar( r );
			tdir.divideScalar( r );
			// END_VEROLD_MOD - tangents

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		var i, il;
		var j, jl;
		var iA, iB, iC;

		if ( this.drawcalls.length === 0 ) {

			this.addDrawCall( 0, indices.length, 0 );

		}

		var drawcalls = this.drawcalls;

		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

			var start = drawcalls[ j ].start;
			var count = drawcalls[ j ].count;
			var index = drawcalls[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleTriangle( iA, iB, iC );

			}

		}

		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
		var n = new THREE.Vector3(), n2 = new THREE.Vector3();
		var w, t, test;

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			test = tmp2.dot( tan2[ v ] );
			w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4     ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

			var start = drawcalls[ j ].start;
			var count = drawcalls[ j ].count;
			var index = drawcalls[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleVertex( iA );
				handleVertex( iB );
				handleVertex( iC );

			}

		}

	},

	/*
		computeOffsets
		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
		indexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.
	*/
	computeOffsets: function ( indexBufferSize ) {

		var size = indexBufferSize;
		if ( indexBufferSize === undefined )
			size = 65535; //WebGL limits type of index buffer values to 16-bit.

		var s = Date.now();

		var indices = this.attributes.index.array;
		var vertices = this.attributes.position.array;

		var verticesCount = ( vertices.length / 3 );
		var facesCount = ( indices.length / 3 );

		/*
		console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
		console.log("Faces to process: "+(indices.length/3));
		console.log("Reordering "+verticesCount+" vertices.");
		*/

		var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
		var indexPtr = 0;
		var vertexPtr = 0;

		var offsets = [ { start:0, count:0, index:0 } ];
		var offset = offsets[ 0 ];

		var duplicatedVertices = 0;
		var newVerticeMaps = 0;
		var faceVertices = new Int32Array( 6 );
		var vertexMap = new Int32Array( vertices.length );
		var revVertexMap = new Int32Array( vertices.length );
		for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

		/*
			Traverse every face and reorder vertices in the proper offsets of 65k.
			We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
		*/
		for ( var findex = 0; findex < facesCount; findex ++ ) {
			newVerticeMaps = 0;

			for ( var vo = 0; vo < 3; vo ++ ) {
				var vid = indices[ findex * 3 + vo ];
				if ( vertexMap[ vid ] == - 1 ) {
					//Unmapped vertice
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = - 1;
					newVerticeMaps ++;
				} else if ( vertexMap[ vid ] < offset.index ) {
					//Reused vertices from previous block (duplicate)
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = - 1;
					duplicatedVertices ++;
				} else {
					//Reused vertice in the current block
					faceVertices[ vo * 2 ] = vid;
					faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
				}
			}

			var faceMax = vertexPtr + newVerticeMaps;
			if ( faceMax > ( offset.index + size ) ) {
				var new_offset = { start:indexPtr, count:0, index:vertexPtr };
				offsets.push( new_offset );
				offset = new_offset;

				//Re-evaluate reused vertices in light of new offset.
				for ( var v = 0; v < 6; v += 2 ) {
					var new_vid = faceVertices[ v + 1 ];
					if ( new_vid > - 1 && new_vid < offset.index )
						faceVertices[ v + 1 ] = - 1;
				}
			}

			//Reindex the face.
			for ( var v = 0; v < 6; v += 2 ) {
				var vid = faceVertices[ v ];
				var new_vid = faceVertices[ v + 1 ];

				if ( new_vid === - 1 )
					new_vid = vertexPtr ++;

				vertexMap[ vid ] = new_vid;
				revVertexMap[ new_vid ] = vid;
				sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
				offset.count ++;
			}
		}

		/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
		this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
		this.offsets = offsets;

		/*
		var orderTime = Date.now();
		console.log("Reorder time: "+(orderTime-s)+"ms");
		console.log("Duplicated "+duplicatedVertices+" vertices.");
		console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
		console.log("Draw offsets: "+offsets.length);
		*/

		return offsets;

	},

	merge: function ( geometry, offset ) {

		if ( geometry instanceof THREE.BufferGeometry === false ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) offset = 0;

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i     ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	/*
		reoderBuffers:
		Reorder attributes based on a new indexBuffer and indexMap.
		indexBuffer - Uint16Array of the new ordered indices.
		indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
		vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
	*/
	reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

		/* Create a copy of all attributes for reordering. */
		var sortedAttributes = {};
		for ( var attr in this.attributes ) {
			if ( attr == 'index' )
				continue;
			var sourceArray = this.attributes[ attr ].array;
			sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
		}

		/* Move attribute positions based on the new index map */
		for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
			var vid = indexMap[ new_vid ];
			for ( var attr in this.attributes ) {
				if ( attr == 'index' )
					continue;
				var attrArray = this.attributes[ attr ].array;
				var attrSize = this.attributes[ attr ].itemSize;
				var sortedAttr = sortedAttributes[ attr ];
				for ( var k = 0; k < attrSize; k ++ )
					sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
			}
		}

		/* Carry the new sorted buffers locally */
		this.attributes[ 'index' ].array = indexBuffer;
		for ( var attr in this.attributes ) {
			if ( attr == 'index' )
				continue;
			this.attributes[ attr ].array = sortedAttributes[ attr ];
			this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
		}
	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.0,
				type: 'BufferGeometry',
				generator: 'BufferGeometryExporter'
			},
			uuid: this.uuid,
			type: this.type,
			data: {
				attributes: {}
			}
		};

		var attributes = this.attributes;
		var offsets = this.offsets;
		var boundingSphere = this.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = [], typeArray = attribute.array;

			for ( var i = 0, l = typeArray.length; i < l; i ++ ) {

				array[ i ] = typeArray[ i ];

			}

			output.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array
			}

		}

		if ( offsets.length > 0 ) {

			output.data.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		if ( boundingSphere !== null ) {

			output.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			}

		}

		return output;

	},

	clone: function () {

		var geometry = new THREE.BufferGeometry();

		for ( var attr in this.attributes ) {

			var sourceAttr = this.attributes[ attr ];
			geometry.addAttribute( attr, sourceAttr.clone() );

		}

		for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

			var offset = this.offsets[ i ];

			geometry.offsets.push( {

				start: offset.start,
				index: offset.index,
				count: offset.count

			} );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];  // one-to-one vertex colors, used in Points and Line

	this.faces = [];

	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphColors = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.tangentsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;

	this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox instanceof THREE.Box3 ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere instanceof THREE.Sphere ) {

			this.computeBoundingSphere();

		}

	},

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var attributes = geometry.attributes;

		var vertices = attributes.position.array;
		var indices = attributes.index !== undefined ? attributes.index.array : undefined;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

		var tempNormals = [];
		var tempUVs = [];

		for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

			scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

		}

		var addFace = function ( a, b, c ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

			}

		};

		if ( indices !== undefined ) {

			for ( var i = 0; i < indices.length; i += 3 ) {

				addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

			}

		} else {

			for ( var i = 0; i < vertices.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = new THREE.Vector3();

		offset.addVectors( this.boundingBox.min, this.boundingBox.max );
		offset.multiplyScalar( - 0.5 );

		this.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
		this.computeBoundingBox();

		return offset;

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC, vD;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
			face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
			face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ];
			vB = context.vertices[ b ];
			vC = context.vertices[ c ];

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;
			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = ( test < 0.0 ) ? - 1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( geometry instanceof THREE.Geometry === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( mesh instanceof THREE.Mesh === false ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		mesh.matrixAutoUpdate && mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;
		var indices, k, j, jl, u;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {
				if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}
			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.0,
				type: 'BufferGeometry',
				generator: 'BufferGeometryExporter'
			},
			uuid: this.uuid,
			type: this.type
		};

		if ( this.name !== "" ) output.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];

			}

			return output;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = false; // face.materialIndex !== undefined;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 );
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );


			/*
			if ( hasMaterial ) {

				faces.push( face.materialIndex );

			}
			*/

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		output.data = {};

		output.data.vertices = vertices;
		output.data.normals = normals;
		if ( colors.length > 0 ) output.data.colors = colors;
		if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility
		output.data.faces = faces;

		//

		return output;

	},

	clone: function () {

		var geometry = new THREE.Geometry();

		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			geometry.vertices.push( vertices[ i ].clone() );

		}

		var faces = this.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			geometry.faces.push( faces[ i ].clone() );

		}

		for ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = this.faceVertexUvs[ i ];

			if ( geometry.faceVertexUvs[ i ] === undefined ) {

				geometry.faceVertexUvs[ i ] = [];

			}

			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				geometry.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

	var quaternion = new THREE.Quaternion();

	return function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	}

}();

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function ( camera ) {

	if ( camera === undefined ) camera = new THREE.Camera();

	THREE.Object3D.prototype.clone.call( this, camera );

	camera.matrixWorldInverse.copy( this.matrixWorldInverse );
	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.generateMipmaps;

		renderTarget.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	var dx = ( this.right - this.left ) / ( 2 * this.zoom );
	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
	var cx = ( this.right + this.left ) / 2;
	var cy = ( this.top + this.bottom ) / 2;

	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

	var camera = new THREE.OrthographicCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.zoom = this.zoom;

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;

	camera.near = this.near;
	camera.far = this.far;

	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.zoom = 1;

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
		var bottom = - top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.clone = function () {

	var camera = new THREE.PerspectiveCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.zoom = this.zoom;

	camera.fov = this.fov;
	camera.aspect = this.aspect;
	camera.near = this.near;
	camera.far = this.far;

	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

	THREE.Object3D.call( this );

	this.type = 'Light';
	
	this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

THREE.Light.prototype.clone = function ( light ) {

	if ( light === undefined ) light = new THREE.Light();

	THREE.Object3D.prototype.clone.call( this, light );

	light.color.copy( this.color );

	return light;

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

	THREE.Light.call( this, color );

	this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

THREE.AmbientLight.prototype.clone = function () {

	var light = new THREE.AmbientLight();

	THREE.Light.prototype.clone.call( this, light );

	return light;

};

// File:src/lights/AreaLight.js

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'AreaLight';

	this.normal = new THREE.Vector3( 0, - 1, 0 );
	this.right = new THREE.Vector3( 1, 0, 0 );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.width = 1.0;
	this.height = 1.0;

	this.constantAttenuation = 1.5;
	this.linearAttenuation = 0.5;
	this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );
THREE.AreaLight.prototype.constructor = THREE.AreaLight;


// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.type = 'DirectionalLight';

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;

	this.shadowCameraLeft = - 500;
	this.shadowCameraRight = 500;
	this.shadowCameraTop = 500;
	this.shadowCameraBottom = - 500;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowCascade = false;

	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
	this.shadowCascadeCount = 2;

	this.shadowCascadeBias = [ 0, 0, 0 ];
	this.shadowCascadeWidth = [ 512, 512, 512 ];
	this.shadowCascadeHeight = [ 512, 512, 512 ];

	this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

	this.shadowCascadeArray = [];

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.clone = function () {

	var light = new THREE.DirectionalLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	//

	light.shadowCameraNear = this.shadowCameraNear;
	light.shadowCameraFar = this.shadowCameraFar;

	light.shadowCameraLeft = this.shadowCameraLeft;
	light.shadowCameraRight = this.shadowCameraRight;
	light.shadowCameraTop = this.shadowCameraTop;
	light.shadowCameraBottom = this.shadowCameraBottom;

	light.shadowCameraVisible = this.shadowCameraVisible;

	light.shadowBias = this.shadowBias;
	light.shadowDarkness = this.shadowDarkness;

	light.shadowMapWidth = this.shadowMapWidth;
	light.shadowMapHeight = this.shadowMapHeight;

	//

	light.shadowCascade = this.shadowCascade;

	light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
	light.shadowCascadeCount = this.shadowCascadeCount;

	light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
	light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
	light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

	light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
	light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );

	return light;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor );

	this.type = 'HemisphereLight';

	this.position.set( 0, 100, 0 );

	this.groundColor = new THREE.Color( groundColor );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.clone = function () {

	var light = new THREE.HemisphereLight();

	THREE.Light.prototype.clone.call( this, light );

	light.groundColor.copy( this.groundColor );
	light.intensity = this.intensity;

	return light;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance ) {

	THREE.Light.call( this, color );

	this.type = 'PointLight';

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.clone = function () {

	var light = new THREE.PointLight();

	THREE.Light.prototype.clone.call( this, light );

	light.intensity = this.intensity;
	light.distance = this.distance;

	return light;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent ) {

	THREE.Light.call( this, color );

	this.type = 'SpotLight';

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.clone = function () {

	var light = new THREE.SpotLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;
	light.distance = this.distance;
	light.angle = this.angle;
	light.exponent = this.exponent;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	//

	light.shadowCameraNear = this.shadowCameraNear;
	light.shadowCameraFar = this.shadowCameraFar;
	light.shadowCameraFov = this.shadowCameraFov;

	light.shadowCameraVisible = this.shadowCameraVisible;

	light.shadowBias = this.shadowBias;
	light.shadowDarkness = this.shadowDarkness;

	light.shadowMapWidth = this.shadowMapWidth;
	light.shadowMapHeight = this.shadowMapHeight;

	return light;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = function () {

	this.files = {};

};

THREE.Cache.prototype = {

	constructor: THREE.Cache,

	add: function ( key, file ) {

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {}

	}

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.imageLoader = new THREE.ImageLoader();

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	addStatusElement: function () {

		var e = document.createElement( 'div' );

		e.style.position = 'absolute';
		e.style.right = '0px';
		e.style.top = '0px';
		e.style.fontSize = '0.8em';
		e.style.textAlign = 'left';
		e.style.background = 'rgba(0,0,0,0.25)';
		e.style.color = '#fff';
		e.style.width = '120px';
		e.style.padding = '0.5em 0.5em 0.5em 0.5em';
		e.style.zIndex = 1000;

		e.innerHTML = 'Loading ...';

		return e;

	},

	updateProgress: function ( progress ) {

		var message = 'Loaded ';

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


		} else {

			message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath );

		}

		return array;

	},

	needsTangents: function ( materials ) {

		for ( var i = 0, il = materials.length; i < il; i ++ ) {

			var m = materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texturePath ) {

		var scope = this;

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

			var fullPath = texturePath + sourceFile;

			var texture;

			var loader = THREE.Loader.Handlers.get( fullPath );

			if ( loader !== null ) {

				texture = loader.load( fullPath );

			} else {

				texture = new THREE.Texture();

				loader = scope.imageLoader;
				loader.crossOrigin = scope.crossOrigin;
				loader.load( fullPath, function ( image ) {

					if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
						 THREE.Math.isPowerOfTwo( image.height ) === false ) {

						var width = nearest_pow2( image.width );
						var height = nearest_pow2( image.height );

						var canvas = document.createElement( 'canvas' );
						canvas.width = width;
						canvas.height = height;

						var context = canvas.getContext( '2d' );
						context.drawImage( image, 0, 0, width, height );

						texture.image = canvas;

					} else {

						texture.image = image;

					}

					texture.needsUpdate = true;

				} );

			}

			texture.sourceFile = sourceFile;

			if ( repeat ) {

				texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

			}

			if ( offset ) {

				texture.offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if ( wrap ) {

				var wrapMap = {
					'repeat': THREE.RepeatWrapping,
					'mirror': THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

			}

			if ( anisotropy ) {

				texture.anisotropy = anisotropy;

			}

			where[ name ] = texture;

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		// defaults

		var mtype = 'MeshLambertMaterial';
		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

		// parameters from model file

		if ( m.shading ) {

			var shading = m.shading.toLowerCase();

			if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
			else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

		}

		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

			mpars.blending = THREE[ m.blending ];

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.depthWrite !== undefined ) {

			mpars.depthWrite = m.depthWrite;

		}

		if ( m.visible !== undefined ) {

			mpars.visible = m.visible;

		}

		if ( m.flipSided !== undefined ) {

			mpars.side = THREE.BackSide;

		}

		if ( m.doubleSided !== undefined ) {

			mpars.side = THREE.DoubleSide;

		}

		if ( m.wireframe !== undefined ) {

			mpars.wireframe = m.wireframe;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors === 'face' ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		if ( m.colorEmissive ) {

			mpars.emissive = rgb2hex( m.colorEmissive );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texturePath ) {

			create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

		}

		if ( m.mapLight && texturePath ) {

			create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

		}

		if ( m.mapBump && texturePath ) {

			create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

		}

		if ( m.mapNormal && texturePath ) {

			create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

		}

		if ( m.mapSpecular && texturePath ) {

			create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

		}

		if ( m.mapAlpha && texturePath ) {

			create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

		}

		//

		if ( m.mapBumpScale ) {

			mpars.bumpScale = m.mapBumpScale;

		}

		if ( m.mapNormalFactor ) {

			mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

		}

		var material = new THREE[ mtype ]( mpars );

		if ( m.DbgName !== undefined ) material.name = m.DbgName;

		return material;

	}

};

THREE.Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

			var regex = this.handlers[ i ];
			var loader  = this.handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.cache = new THREE.Cache();
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = scope.cache.get( url );

		if ( cached !== undefined ) {

			if ( onLoad ) onLoad( cached );
			return;

		}

		var request = new XMLHttpRequest();
		request.open( 'GET', url, true );

		request.addEventListener( 'load', function ( event ) {

			scope.cache.add( url, this.response );

			if ( onLoad ) onLoad( this.response );

			scope.manager.itemEnd( url );

		}, false );

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			request.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
		if ( this.responseType !== undefined ) request.responseType = this.responseType;

		request.send( null );

		scope.manager.itemStart( url );

	},

	setResponseType: function ( value ) {

		this.responseType = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.cache = new THREE.Cache();
	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var cached = scope.cache.get( url );

		if ( cached !== undefined ) {

			onLoad( cached );
			return;

		}

		var image = document.createElement( 'img' );

		if ( onLoad !== undefined ) {

			image.addEventListener( 'load', function ( event ) {

				scope.cache.add( url, this );

				onLoad( this );
				scope.manager.itemEnd( url );

			}, false );

		}

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			image.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		image.src = url;

		scope.manager.itemStart( url );

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

}

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );
THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var scope = this;

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === xhr.DONE ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				if ( xhr.responseText ) {

					var json = JSON.parse( xhr.responseText );

					if ( json.metadata !== undefined && json.metadata.type === 'scene' ) {

						console.error( 'THREE.JSONLoader: "' + url + '" seems to be a Scene. Use THREE.SceneLoader instead.' );
						return;

					}

					var result = context.parse( json, texturePath );
					callback( result.geometry, result.materials );

				} else {

					console.error( 'THREE.JSONLoader: "' + url + '" seems to be unreachable or the file is empty.' );

				}

				// in context of more complex asset initialization
				// do not block on single failed file
				// maybe should go even one more level up

				context.onLoadComplete();

			} else {

				console.error( 'THREE.JSONLoader: Couldn\'t load "' + url + '" (' + xhr.status + ')' );

			}

		} else if ( xhr.readyState === xhr.LOADING ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( 'Content-Length' );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

			if ( callbackProgress !== undefined ) {

				length = xhr.getResponseHeader( 'Content-Length' );

			}

		}

	};

	xhr.open( 'GET', url, true );
	xhr.withCredentials = this.withCredentials;
	xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeFaceNormals();
	geometry.computeBoundingSphere();

	function parseModel( scale ) {

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		}

		var i, j, fi,

		offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, color, hex, normal,

		uvLayer, uv, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		if ( json.uvs !== undefined ) {

			// disregard empty arrays

			for ( i = 0; i < json.uvs.length; i ++ ) {

				if ( json.uvs[ i ].length ) nUvLayers ++;

			}

			for ( i = 0; i < nUvLayers; i ++ ) {

				geometry.faceVertexUvs[ i ] = [];

			}

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vector3();

			vertex.x = vertices[ offset ++ ] * scale;
			vertex.y = vertices[ offset ++ ] * scale;
			vertex.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad              = isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	     = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				faceA = new THREE.Face3();
				faceA.a = faces[ offset ];
				faceA.b = faces[ offset + 1 ];
				faceA.c = faces[ offset + 3 ];

				faceB = new THREE.Face3();
				faceB.a = faces[ offset + 1 ];
				faceB.b = faces[ offset + 2 ];
				faceB.c = faces[ offset + 3 ];

				offset += 4;

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					faceA.materialIndex = materialIndex;
					faceB.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i ++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];
						geometry.faceVertexUvs[ i ][ fi + 1 ] = []

						for ( j = 0; j < 4; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
							if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					faceA.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

					faceB.normal.copy( faceA.normal );

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 4; i ++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);


						if ( i !== 2 ) faceA.vertexNormals.push( normal );
						if ( i !== 0 ) faceB.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					hex = colors[ colorIndex ];

					faceA.color.setHex( hex );
					faceB.color.setHex( hex );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 4; i ++ ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
						if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

					}

				}

				geometry.faces.push( faceA );
				geometry.faces.push( faceB );

			} else {

				face = new THREE.Face3();
				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					face.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i ++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];

						for ( j = 0; j < 3; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							geometry.faceVertexUvs[ i ][ fi ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					face.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 3; i ++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						face.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					face.color.setHex( colors[ colorIndex ] );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 3; i ++ ) {

						colorIndex = faces[ offset ++ ];
						face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

					}

				}

				geometry.faces.push( face );

			}

		}

	};

	function parseSkin() {
		var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

		if ( json.skinWeights ) {

			for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

				var x =                               json.skinWeights[ i     ];
				var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
				var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
				var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

				var a =                               json.skinIndices[ i     ];
				var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
				var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
				var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;

		if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

		}


		// could change this to json.animations[0] or remove completely

		geometry.animation = json.animation;
		geometry.animations = json.animations;

	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					var vertex = new THREE.Vector3();
					vertex.x = srcVertices[ v ] * scale;
					vertex.y = srcVertices[ v + 1 ] * scale;
					vertex.z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( vertex );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	if ( json.materials === undefined || json.materials.length === 0 ) {

		return { geometry: geometry };

	} else {

		var materials = this.initMaterials( json.materials, texturePath );

		if ( this.needsTangents( materials ) ) {

			geometry.computeTangents();

		}

		return { geometry: geometry, materials: materials };

	}

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var loaded = 0, total = 0;

	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		total ++;

	};

	this.itemEnd = function ( url ) {

		loaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, loaded, total );

		}

		if ( loaded === total && scope.onLoad !== undefined ) {

			scope.onLoad();

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var attributes = json.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new self[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

		}

		var offsets = json.offsets;

		if ( offsets !== undefined ) {

			geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		var boundingSphere = json.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new THREE.Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];

		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometries = this.parseGeometries( json.geometries );
		var materials = this.parseMaterials( json.materials );
		var object = this.parseObject( json.object, geometries, materials );

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':

						geometry = new THREE.PlaneGeometry(
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new THREE.BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data.data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data ).geometry;

						break;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];
				var material = loader.parse( data );

				material.uuid = data.uuid;

				if ( data.name !== undefined ) material.name = data.name;

				materials[ data.uuid ] = material;

			}

		}

		return materials;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

					}

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Mesh( geometry, material );

					break;

				case 'Line':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );

					}

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Line( geometry, material );

					break;

				case 'Sprite':

					var material = materials[ data.material ];

					if ( material === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );

					}

					object = new THREE.Sprite( material );

					break;

				case 'Group':

					object = new THREE.Group();

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			return object;

		}

	}()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.ImageLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			var texture = new THREE.Texture( image );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {

	// override in sub classes
	this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

	constructor: THREE.BinaryTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new THREE.DataTexture( );

		var loader = new THREE.XHRLoader();
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			var texData = scope._parser( buffer );

			if ( !texData ) return;

			if ( undefined !== texData.image ) {

				texture.image = texData.image;

			} else if ( undefined !== texData.data ){

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

			if ( undefined !== texData.format ) {

				texture.format = texData.format;

			}
			if ( undefined !== texData.type ) {

				texture.type = texData.type;

			}

			if ( undefined !== texData.mipmaps ) {

				texture.mipmaps = texData.mipmaps;

			}

			if ( 1 === texData.mipmapCount ) {

				texture.minFilter = THREE.LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function () {

	// override in sub classes
	this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

	constructor: THREE.CompressedTextureLoader,

	load: function ( url, onLoad, onError ) {

		var scope = this;

		var images = [];

		var texture = new THREE.CompressedTexture();
		texture.image = images;

		var loader = new THREE.XHRLoader();
		loader.setResponseType( 'arraybuffer' );

		if ( url instanceof Array ) {

			var loaded = 0;

			var loadTexture = function ( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

 						if (texDatas.mipmapCount == 1)
 							texture.minFilter = THREE.LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				} );

			};

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			} );

		}

		return texture;

	}

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.depthTest = true;
	this.depthWrite = true;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.hdrOutputEnabled = undefined; //Override for renderer's hdrOutputEnabled
	this.hdrOutputType = undefined; //Override for renderer's hdrOutputType
	this.hdrInputEnabled = undefined;

	this.needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			if ( key in this ) {

				var currentValue = this[ key ];

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key == 'overdraw' ) {

					// ensure overdraw is backwards-compatable with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		}

	},

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type
		};

		if ( this.name !== "" ) output.name = this.name;

		if ( this instanceof THREE.MeshBasicMaterial ) {

			output.color = this.color.getHex();
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshLambertMaterial ) {

			output.color = this.color.getHex();
			output.ambient = this.ambient.getHex();
			output.emissive = this.emissive.getHex();
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshPhongMaterial ) {

			output.color = this.color.getHex();
			output.ambient = this.ambient.getHex();
			output.emissive = this.emissive.getHex();
			output.specular = this.specular.getHex();
			output.shininess = this.shininess;
			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshNormalMaterial ) {

			if ( this.shading !== THREE.FlatShading ) output.shading = this.shading;
			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.MeshDepthMaterial ) {

			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;
			if ( this.side !== THREE.FrontSide ) output.side = this.side;

		} else if ( this instanceof THREE.ShaderMaterial ) {

			output.uniforms = this.uniforms;
			output.vertexShader = this.vertexShader;
			output.fragmentShader = this.fragmentShader;

		} else if ( this instanceof THREE.SpriteMaterial ) {

			output.color = this.color.getHex();

		}

		if ( this.opacity < 1 ) output.opacity = this.opacity;
		if ( this.transparent !== false ) output.transparent = this.transparent;
		if ( this.wireframe !== false ) output.wireframe = this.wireframe;

		return output;

	},

	clone: function ( material ) {

		if ( material === undefined ) material = new THREE.Material();

		material.name = this.name;

		material.side = this.side;

		material.opacity = this.opacity;
		material.transparent = this.transparent;

		material.blending = this.blending;

		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;

		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;

		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;

		material.alphaTest = this.alphaTest;

		material.overdraw = this.overdraw;

		material.visible = this.visible;

		return material;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;
	material.linecap = this.linecap;
	material.linejoin = this.linejoin;

	material.vertexColors = this.vertexColors;
	material.skinning = this.skinning;

	material.fog = this.fog;

	return material;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.clone = function () {

	var material = new THREE.LineDashedMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;

	material.scale = this.scale;
	material.dashSize = this.dashSize;
	material.gapSize = this.gapSize;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.clone = function () {

	var material = new THREE.MeshBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;

	return material;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.clone = function () {

	var material = new THREE.MeshLambertMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhongMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );
	material.specular.copy( this.specular );
	material.shininess = this.shininess;

	material.metal = this.metal;

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.specularMap = this.specularMap;

	material.alphaMap = this.alphaMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.morphTargets = false;
	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.clone = function () {

	var material = new THREE.MeshDepthMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.shading = THREE.FlatShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.clone = function () {

	var material = new THREE.MeshNormalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

// File:src/materials/MeshFaceMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

	this.uuid = THREE.Math.generateUUID();

	this.type = 'MeshFaceMaterial';
	
	this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype = {

	constructor: THREE.MeshFaceMaterial,

	toJSON: function () {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		for ( var i = 0, l = this.materials.length; i < l; i ++ ) {

			output.materials.push( this.materials[ i ].toJSON() );

		}

		return output;

	},

	clone: function () {

		var material = new THREE.MeshFaceMaterial();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		return material;

	}

};

// File:src/materials/PointCloudMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointCloudMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'PointCloudMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = THREE.NoColors;

	this.fog = true;

	this.setValues( parameters );

};

THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;

THREE.PointCloudMaterial.prototype.clone = function () {

	var material = new THREE.PointCloudMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.size = this.size;
	material.sizeAttenuation = this.sizeAttenuation;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
	return new THREE.PointCloudMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
	return new THREE.PointCloudMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};
	this.attributes = null;

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.clone = function () {

	var material = new THREE.ShaderMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.fragmentShader = this.fragmentShader;
	material.vertexShader = this.vertexShader;

	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

	material.attributes = this.attributes;
	material.defines = this.defines;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	material.fog = this.fog;

	material.lights = this.lights;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;

	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

	THREE.ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;

THREE.RawShaderMaterial.prototype.clone = function () {

	var material = new THREE.RawShaderMaterial();

	THREE.ShaderMaterial.prototype.clone.call( this, material );

	return material;

};

// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.clone = function () {

	var material = new THREE.SpriteMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;

	material.rotation = this.rotation;

	material.fog = this.fog;

	return material;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this._needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	clone: function ( texture ) {

		if ( texture === undefined ) texture = new THREE.Texture();

		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice( 0 );

		texture.mapping = this.mapping;

		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;

		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;

		texture.anisotropy = this.anisotropy;

		texture.format = this.format;
		texture.type = this.type;

		texture.offset.copy( this.offset );
		texture.repeat.copy( this.repeat );

		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;

		return texture;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;
	
	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.images = images;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.clone = function ( texture ) {

	if ( texture === undefined ) texture = new THREE.CubeTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	texture.images = this.images;

	return texture;

};

// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

THREE.CompressedTexture.prototype.clone = function () {

	var texture = new THREE.CompressedTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

THREE.DataTexture.prototype.clone = function () {

	var texture = new THREE.DataTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	var update = function () {

		requestAnimationFrame( update );

		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

			scope.needsUpdate = true;

		}

	};

	update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

	THREE.Object3D.call( this );

	this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;

// File:src/objects/PointCloud.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.PointCloud = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'PointCloud';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

};

THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );
THREE.PointCloud.prototype.constructor = THREE.PointCloud;

THREE.PointCloud.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();

	return function ( raycaster, intersects ) {

		var object = this;
		var geometry = object.geometry;
		var threshold = raycaster.params.PointCloud.threshold;

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

				return;

			}

		}

		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		var position = new THREE.Vector3();

		var testPoint = function ( point, index ) {

			var rayPointDistance = ray.distanceToPoint( point );

			if ( rayPointDistance < localThreshold ) {

				var intersectPoint = ray.closestPointToPoint( point );
				intersectPoint.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				intersects.push( {

					distance: distance,
					distanceToRay: rayPointDistance,
					point: intersectPoint.clone(),
					index: index,
					face: null,
					object: object

				} );

			}

		};

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;
			var positions = attributes.position.array;

			if ( attributes.index !== undefined ) {

				var indices = attributes.index.array;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					var offset = {
						start: 0,
						count: indices.length,
						index: 0
					};

					offsets = [ offset ];

				}

				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( var i = start, il = start + count; i < il; i ++ ) {

						var a = index + indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				}

			} else {

				var pointCount = positions.length / 3;

				for ( var i = 0; i < pointCount; i ++ ) {

					position.set(
						positions[ 3 * i ],
						positions[ 3 * i + 1 ],
						positions[ 3 * i + 2 ]
					);

					testPoint( position, i );

				}

			}

		} else {

			var vertices = this.geometry.vertices;

			for ( var i = 0; i < vertices.length; i ++ ) {

				testPoint( vertices[ i ], i );

			}

		}

	};

}() );

THREE.PointCloud.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.ParticleSystem = function ( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
	return new THREE.PointCloud( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

	THREE.Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	this.mode = ( mode !== undefined ) ? mode : THREE.LineStrip;

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	return function ( raycaster, intersects ) {

		var precision = raycaster.linePrecision;
		var precisionSq = precision * precision;

		var geometry = this.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		// Checking boundingSphere distance to ray

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		var vStart = new THREE.Vector3();
		var vEnd = new THREE.Vector3();
		var interSegment = new THREE.Vector3();
		var interRay = new THREE.Vector3();
		var step = this.mode === THREE.LineStrip ? 1 : 2;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;

			if ( attributes.index !== undefined ) {

				var indices = attributes.index.array;
				var positions = attributes.position.array;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					offsets = [ { start: 0, count: indices.length, index: 0 } ];

				}

				for ( var oi = 0; oi < offsets.length; oi++){

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( var i = start; i < start + count - 1; i += step ) {

						var a = index + indices[ i ];
						var b = index + indices[ i + 1 ];

						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						var distance = ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else {

				var positions = attributes.position.array;

				for ( var i = 0; i < positions.length / 3 - 1; i += step ) {

					vStart.fromArray( positions, 3 * i );
					vEnd.fromArray( positions, 3 * i + 3 );

					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					var distance = ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var vertices = geometry.vertices;
			var nbVertices = vertices.length;

			for ( var i = 0; i < nbVertices - 1; i += step ) {

				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

				if ( distSq > precisionSq ) continue;

				var distance = ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	};

}() );

THREE.Line.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Mesh';
	
	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = - 1;
		this.morphTargetForcedOrder = [];
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.log( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

	return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

	var inverseMatrix = new THREE.Matrix4();
	var ray = new THREE.Ray();
	var sphere = new THREE.Sphere();

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		var geometry = this.geometry;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		sphere.copy( geometry.boundingSphere );
		sphere.applyMatrix4( this.matrixWorld );

		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

			return;

		}

		// Check boundingBox before continuing

		inverseMatrix.getInverse( this.matrixWorld );
		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

		if ( geometry.boundingBox !== null ) {

			if ( ray.isIntersectionBox( geometry.boundingBox ) === false )  {

				return;

			}

		}

		if ( geometry instanceof THREE.BufferGeometry ) {

			var material = this.material;

			if ( material === undefined ) return;

			var attributes = geometry.attributes;

			var a, b, c;
			var precision = raycaster.precision;

			if ( attributes.index !== undefined ) {

				var indices = attributes.index.array;
				var positions = attributes.position.array;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					offsets = [ { start: 0, count: indices.length, index: 0 } ];

				}

				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

					var start = offsets[ oi ].start;
					var count = offsets[ oi ].count;
					var index = offsets[ oi ].index;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						a = index + indices[ i ];
						b = index + indices[ i + 1 ];
						c = index + indices[ i + 2 ];

						vA.fromArray( positions, a * 3 );
						vB.fromArray( positions, b * 3 );
						vC.fromArray( positions, c * 3 );

						if ( material.side === THREE.BackSide ) {

							var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

						} else {

							var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( this.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
							faceIndex: null,
							object: this

						} );

					}

				}

			} else {

				var positions = attributes.position.array;

				for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

					a = i;
					b = i + 1;
					c = i + 2;

					vA.fromArray( positions, j );
					vB.fromArray( positions, j + 3 );
					vC.fromArray( positions, j + 6 );

					if ( material.side === THREE.BackSide ) {

						var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

					} else {

						var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry instanceof THREE.Geometry ) {

			var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
			var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

			var a, b, c, d;
			var precision = raycaster.precision;

			var vertices = geometry.vertices;

			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

				var face = geometry.faces[ f ];

				var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

				if ( material === undefined ) continue;

				a = vertices[ face.a ];
				b = vertices[ face.b ];
				c = vertices[ face.c ];

				if ( material.morphTargets === true ) {

					var morphTargets = geometry.morphTargets;
					var morphInfluences = this.morphTargetInfluences;

					vA.set( 0, 0, 0 );
					vB.set( 0, 0, 0 );
					vC.set( 0, 0, 0 );

					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

						var influence = morphInfluences[ t ];

						if ( influence === 0 ) continue;

						var targets = morphTargets[ t ].vertices;

						vA.x += ( targets[ face.a ].x - a.x ) * influence;
						vA.y += ( targets[ face.a ].y - a.y ) * influence;
						vA.z += ( targets[ face.a ].z - a.z ) * influence;

						vB.x += ( targets[ face.b ].x - b.x ) * influence;
						vB.y += ( targets[ face.b ].y - b.y ) * influence;
						vB.z += ( targets[ face.b ].z - b.z ) * influence;

						vC.x += ( targets[ face.c ].x - c.x ) * influence;
						vC.y += ( targets[ face.c ].y - c.y ) * influence;
						vC.z += ( targets[ face.c ].z - c.z ) * influence;

					}

					vA.add( a );
					vB.add( b );
					vC.add( c );

					a = vA;
					b = vB;
					c = vC;

				}

				if ( material.side === THREE.BackSide ) {

					var intersectionPoint = ray.intersectTriangle( c, b, a, true );

				} else {

					var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

				}

				if ( intersectionPoint === null ) continue;

				intersectionPoint.applyMatrix4( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

				if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					point: intersectionPoint,
					face: face,
					faceIndex: f,
					object: this

				} );

			}

		}

	};

}() );

THREE.Mesh.prototype.clone = function ( object, recursive ) {

	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object, recursive );

	return object;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;


// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new THREE.Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
		//       16x16 pixel texture max   64 bones (16 * 16 / 4)
		//       32x32 pixel texture max  256 bones (32 * 32 / 4)
		//       64x64 pixel texture max 1024 bones (64 * 64 / 4)

		var size;

		if ( this.bones.length > 256 )
			size = 64;
		else if ( this.bones.length > 64 )
			size = 32;
		else if ( this.bones.length > 16 )
			size = 16;
		else
			size = 8;

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
		this.boneTexture.minFilter = THREE.NearestFilter;
		this.boneTexture.magFilter = THREE.NearestFilter;
		this.boneTexture.generateMipmaps = false;
		this.boneTexture.flipY = false;

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new THREE.Matrix4() );

			}

		}

	}

};

THREE.Skeleton.prototype.calculateInverses = function () {

	this.boneInverses = [];

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		var inverse = new THREE.Matrix4();

		if ( this.bones[ b ] ) {

			inverse.getInverse( this.bones[ b ].matrixWorld );

		}

		this.boneInverses.push( inverse );

	}

};

THREE.Skeleton.prototype.pose = function () {

	var bone;

	// recover the bind-time world matrices

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			bone.matrixWorld.getInverse( this.boneInverses[ b ] );

		}

	}

	// compute the local matrices, positions, rotations and scales

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		bone = this.bones[ b ];

		if ( bone ) {

			if ( bone.parent ) {

				bone.matrix.getInverse( bone.parent.matrixWorld );
				bone.matrix.multiply( bone.matrixWorld );

			} else {

				bone.matrix.copy( bone.matrixWorld );

			}

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		}

	}

};

THREE.Skeleton.prototype.update = ( function () {

	var offsetMatrix = new THREE.Matrix4();
	
	return function () {

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform

			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}
		
	};

} )();


// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new THREE.Matrix4();
	this.bindMatrixInverse = new THREE.Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone, p, q, s;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = new THREE.Bone( this );
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
			bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

			if ( s !== undefined ) {

				bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 ) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

	this.skeleton = skeleton;

	if ( bindMatrix === undefined ) {

		this.updateMatrixWorld( true );

		bindMatrix = this.matrixWorld;

	}

	this.bindMatrix.copy( bindMatrix );
	this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

	this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

	if ( this.bindMode === "attached" ) {

		this.bindMatrixInverse.getInverse( this.matrixWorld );

	} else if ( this.bindMode === "detached" ) {

		this.bindMatrixInverse.getInverse( this.bindMatrix );

	} else {

		console.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

	}

};

THREE.SkinnedMesh.prototype.clone = function( object ) {

	if ( object === undefined ) {

		object = new THREE.SkinnedMesh( this.geometry, this.material, this.skeleton.useVertexTexture );

	}

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'MorphAnimMesh';

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

	this.startKeyframe = start;
	this.endKeyframe = end;

	this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

	this.direction = - 1;
	this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

	var geometry = this.geometry;

	if ( ! geometry.animations ) geometry.animations = {};

	var firstAnimation, animations = geometry.animations;

	var pattern = /([a-z]+)_?(\d+)/;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var parts = morph.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var label = parts[ 1 ];
			var num = parts[ 2 ];

			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

			var animation = animations[ label ];

			if ( i < animation.start ) animation.start = i;
			if ( i > animation.end ) animation.end = i;

			if ( ! firstAnimation ) firstAnimation = label;

		}

	}

	geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

	if ( ! this.geometry.animations ) this.geometry.animations = {};

	this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

	var animation = this.geometry.animations[ label ];

	if ( animation ) {

		this.setFrameRange( animation.start, animation.end );
		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
		this.time = 0;

	} else {

		console.warn( 'animation[' + label + '] undefined' );

	}

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / this.length;

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= - 1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

		if ( this.time < 0 ) this.time += this.duration;

	}

	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

	if ( keyframe !== this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

	var influences = this.morphTargetInfluences;

	for ( var i = 0, l = influences.length; i < l; i ++ ) {

		influences[ i ] = 0;

	}

	if ( a > -1 ) influences[ a ] = 1 - t;
	if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

	object.duration = this.duration;
	object.mirroredLoop = this.mirroredLoop;
	object.time = this.time;

	object.lastKeyframe = this.lastKeyframe;
	object.currentKeyframe = this.currentKeyframe;

	object.direction = this.direction;
	object.directionBackwards = this.directionBackwards;

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	for ( var l = 0; l < this.objects.length; l ++ ) {

		if ( distance < this.objects[ l ].distance ) {

			break;

		}

	}

	this.objects.splice( l, 0, { distance: distance, object: object } );
	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

		if ( distance < this.objects[ i ].distance ) {

			break;

		}

	}

	return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( matrixPosition );

		this.getObjectForDistance( distance ).raycast( raycaster, intersects );

	};

}() );

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( camera ) {

		if ( this.objects.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			this.objects[ 0 ].object.visible = true;

			for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

				if ( distance >= this.objects[ i ].distance ) {

					this.objects[ i - 1 ].object.visible = false;
					this.objects[ i     ].object.visible = true;

				} else {

					break;

				}

			}

			for ( ; i < l; i ++ ) {

				this.objects[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.LOD();

	THREE.Object3D.prototype.clone.call( this, object );

	for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
		var x = this.objects[ i ].object.clone();
		x.visible = i === 0;
		object.addLevel( x, this.objects[ i ].distance );
	}

	return object;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	return function ( material ) {

		THREE.Object3D.call( this );

		this.type = 'Sprite';

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	};

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

	var matrixPosition = new THREE.Vector3();

	return function ( raycaster, intersects ) {

		matrixPosition.setFromMatrixPosition( this.matrixWorld );

		var distance = raycaster.ray.distanceToPoint( matrixPosition );

		if ( distance > this.scale.x ) {

			return;

		}

		intersects.push( {

			distance: distance,
			point: this.position,
			face: null,
			object: this

		} );

	};

}() );

THREE.Sprite.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Sprite( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if ( size === undefined ) size = - 1;
	if ( distance === undefined ) distance = 0;
	if ( opacity === undefined ) opacity = 1;
	if ( color === undefined ) color = new THREE.Color( 0xffffff );
	if ( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( {
		texture: texture, 			// THREE.Texture
		size: size, 				// size in pixels (-1 = use texture.width)
		distance: distance, 		// distance (0-1) from light source (0=at light source)
		x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
		scale: 1, 					// scale
		rotation: 1, 				// rotation
		opacity: opacity,			// opacity
		color: color,				// color
		blending: blending			// blending
	} );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = - this.positionScreen.x * 2;
	var vecY = - this.positionScreen.y * 2;

	for( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};


// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.type = 'Scene';

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Scene();

	THREE.Object3D.prototype.clone.call( this, object );

	if ( this.fog !== null ) object.fog = this.fog.clone();
	if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

	object.autoUpdate = this.autoUpdate;
	object.matrixAutoUpdate = this.matrixAutoUpdate;

	return object;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n	if ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n	vec3 dirVector = normalize( lDirection.xyz );\n\n	float dotProduct = dot( transformedNormal, dirVector );\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n	#ifdef DOUBLE_SIDED\n\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n		#ifdef WRAP_AROUND\n\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n		#endif\n\n	#endif\n\n	#ifdef WRAP_AROUND\n\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n		#ifdef DOUBLE_SIDED\n\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n		#endif\n\n	#endif\n\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n	#ifdef DOUBLE_SIDED\n\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n	#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n		float dotProduct = dot( transformedNormal, lVector );\n\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n		#ifdef DOUBLE_SIDED\n\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n			#ifdef WRAP_AROUND\n\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n			#endif\n\n		#endif\n\n		#ifdef WRAP_AROUND\n\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n			#ifdef DOUBLE_SIDED\n\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n			#endif\n\n		#endif\n\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n		#endif\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n			float lDistance = 1.0;\n			if ( spotLightDistance[ i ] > 0.0 )\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n			lVector = normalize( lVector );\n\n			float dotProduct = dot( transformedNormal, lVector );\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n			#ifdef DOUBLE_SIDED\n\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n				#ifdef WRAP_AROUND\n\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n				#endif\n\n			#endif\n\n			#ifdef WRAP_AROUND\n\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n				#ifdef DOUBLE_SIDED\n\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n				#endif\n\n			#endif\n\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n			#ifdef DOUBLE_SIDED\n\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n			#endif\n\n		}\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		float dotProduct = dot( transformedNormal, lVector );\n\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n		#endif\n\n	}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

THREE.ShaderChunk[ 'default_vertex'] = "#ifdef USE_SKINNING\n\n	vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	#ifdef USE_MORPHNORMALS\n\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n	#else\n\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n\n	#endif\n\n	uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl

THREE.ShaderChunk[ 'lightmap_pars_vertex'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	vec3 pointDiffuse = vec3( 0.0 );\n	vec3 pointSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( pointLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n				// diffuse\n\n		float dotProduct = dot( normal, lVector );\n\n		#ifdef WRAP_AROUND\n\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n				// specular\n\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n	}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	vec3 spotDiffuse = vec3( 0.0 );\n	vec3 spotSpecular = vec3( 0.0 );\n\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n		float lDistance = 1.0;\n		if ( spotLightDistance[ i ] > 0.0 )\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n		lVector = normalize( lVector );\n\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n					// diffuse\n\n			float dotProduct = dot( normal, lVector );\n\n			#ifdef WRAP_AROUND\n\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n			#else\n\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\n\n			#endif\n\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n					// specular\n\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n		}\n\n	}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n	vec3 dirDiffuse = vec3( 0.0 );\n	vec3 dirSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n		vec3 dirVector = normalize( lDirection.xyz );\n\n				// diffuse\n\n		float dotProduct = dot( normal, dirVector );\n\n		#ifdef WRAP_AROUND\n\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n		#else\n\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\n\n		#endif\n\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n		// specular\n\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n		/*\n		// fresnel term from skin shader\n		const float F0 = 0.128;\n\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\n		float exponential = pow( base, 5.0 );\n\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\n		*/\n\n		/*\n		// fresnel term from fresnel shader\n		const float mFresnelBias = 0.08;\n		const float mFresnelScale = 0.3;\n		const float mFresnelPower = 5.0;\n\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n		*/\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n	}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	vec3 hemiDiffuse = vec3( 0.0 );\n	vec3 hemiSpecular = vec3( 0.0 );\n\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n		vec3 lVector = normalize( lDirection.xyz );\n\n		// diffuse\n\n		float dotProduct = dot( normal, lVector );\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n		hemiDiffuse += diffuse * hemiColor;\n\n		// specular (sky light)\n\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n		// specular (ground light)\n\n		vec3 lVectorGround = -lVector;\n\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n		float dotProductGround = dot( normal, lVectorGround );\n\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n	}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n	totalDiffuse += dirDiffuse;\n	totalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	totalDiffuse += hemiDiffuse;\n	totalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	totalDiffuse += pointDiffuse;\n	totalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	totalDiffuse += spotDiffuse;\n	totalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n	vec3 morphedNormal = vec3( 0.0 );\n\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n	morphedNormal += normal;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		uniform float refractionRatio;\n\n	#else\n\n		varying vec3 vReflect;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n			// Per-Pixel Tangent Space Normal Mapping\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n	varying vec2 vUv2;\n	uniform sampler2D lightMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n    // #if defined( USE_LOGDEPTHBUF )\n    //   vShadowCoord[ i ].z = log2(max(1e-6, vShadowCoord[ i ].w + 1.0)) * logDepthBufFC;\n    //   #ifdef USE_LOGDEPTHBUF_EXT\n    //     // vFragDepth = 1.0 + vShadowCoord[ i ].w;\n    //   #else\n    //     vShadowCoord[ i ].z = (vShadowCoord[ i ].z - 1.0);\n    //   #endif\n    // #endif\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	vWorldPosition = worldPosition.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	#ifdef GAMMA_INPUT\n\n		texelColor.xyz *= texelColor.xyz;\n\n	#endif\n\n	gl_FragColor = gl_FragColor * texelColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl

THREE.ShaderChunk[ 'lightmap_vertex'] = "#ifdef USE_LIGHTMAP\n\n	vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n	#ifdef GAMMA_INPUT\n\n		vColor = color * color;\n\n	#else\n\n		vColor = color;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n	#ifdef USE_MORPHTARGETS\n\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n	#endif\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	varying vec3 vReflect;\n\n	uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "#ifdef GAMMA_OUTPUT\n\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/hdr_encode_pars_fragment.glsl

THREE.ShaderChunk[ 'hdr_encode_pars_fragment'] = "#ifdef HDR_OUTPUT_LOGLUV\n  // logLuvMatrix matrix, for encoding\n  const mat3 logLuvMatrix = mat3(\n      0.2209, 0.3390, 0.4184,\n      0.1138, 0.6780, 0.7319,\n      0.0102, 0.1130, 0.2969);\n\n  vec4 HDREncode(in vec3 vRGB) \n  {\n    // Based on http://www.xnainfo.com/content.php?content=28\n    vec4 vResult; \n    vec3 Xp_Y_XYZp = logLuvMatrix * vRGB.xyz;\n    Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n    vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n    float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n    vResult.w = fract(Le);\n    vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n    return vResult;\n  }\n\n#elif defined( HDR_OUTPUT_RGBM )\n\n  vec4 HDREncode( in vec3 color ) {\n    vec4 rgbm;\n    color *= 1.0 / 9.0;\n    rgbm.a = clamp( max( max( color.r, color.g ), max( color.b, 1e-6 ) ) , 0.0, 1.0 );\n    rgbm.a = ceil( rgbm.a * 255.0 ) / 255.0;\n    rgbm.rgb = color.rgb / rgbm.a;\n    return rgbm;\n  }\n\n#elif defined( HDR_OUTPUT_RGBD )\n\n  vec4 HDREncode( in vec3 color ) {\n    //Based on http://vemberaudio.se/graphics/RGBdiv8.pdf\n    float maxRGB = max( max(1.0, color.r), max( color.g, color.b )); \n    return vec4(color.rgb, 1.0) / maxRGB;\n  }\n\n#elif defined( HDR_OUTPUT_RGBE )\n  vec4 HDREncode( in vec3 color ) {\n\n    //Based on http://www.graphics.cornell.edu/~bjw/rgbe/rgbe.c\n    float maxComp = max( max( color.r, color.g ), color.b );\n    float exponent = ceil( log2( maxComp ) );\n    float value = exp2( exponent );\n    vec3 mantissa = clamp( color / value, 0.0, 1.0 );\n    return vec4( mantissa, ( exponent + 128.0 ) / 255.0 );\n  }\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/hdr_decode_pars_fragment.glsl

THREE.ShaderChunk[ 'hdr_decode_pars_fragment'] = "#if defined( HDR_INPUT )\n\n  // Inverse logLuvMatrix matrix, for decoding\n  const mat3 InverseLogLuvMatrix = mat3(\n    6.0014, -2.7008, -1.7996,\n  -1.3320,  3.1029, -5.7721,\n  0.3008, -1.0882,  5.6268);\n\n  vec3 HDRDecodeLOGLUV(in vec4 vLogLuv)\n  {\n    // Based on http://www.xnainfo.com/content.php?content=28\n    float Le = vLogLuv.z * 255.0 + vLogLuv.w;\n    vec3 Xp_Y_XYZp;\n    Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n    Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;\n    Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;\n    vec3 vRGB = InverseLogLuvMatrix * Xp_Y_XYZp;\n    return vRGB;\n  }\n\n  vec3 HDRDecodeRGBM( vec4 rgbm ) {\n    //Based on http://vemberaudio.se/graphics/RGBdiv8.pdf\n    return 9.0 * rgbm.rgb * rgbm.a;\n  }\n\n  vec3 HDRDecodeRGBD( vec4 rgbd ) {\n    //Based on http://vemberaudio.se/graphics/RGBdiv8.pdf\n    return rgbd.rgb / max(rgbd.a, 0.003);\n  }\n\n  vec3 HDRDecodeRGBE( vec4 rgbe ) {\n    //Based on http://www.graphics.cornell.edu/~bjw/rgbe/rgbe.c\n    float f = exp2( rgbe.w * 255.0 - (128.0 + 0.0) );\n    return rgbe.rgb * f;\n  }\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/hdr_encode_fragment.glsl

THREE.ShaderChunk[ 'hdr_encode_fragment'] = "#if defined( HDR_OUTPUT_LOGLUV ) || defined( HDR_OUTPUT_RGBM ) || defined( HDR_OUTPUT_RGBD ) || defined( HDR_OUTPUT_RGBE )\n  gl_FragColor = HDREncode( gl_FragColor.xyz );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl

THREE.ShaderChunk[ 'map_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n		// Transforming Normal Vectors with the Inverse Transformation\n\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#else\n		float flipNormal = 1.0;\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = clamp( flipNormal * reflectVec.y * 0.5 + 0.5, 0.0, 1.0);\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * 0.15915494309189533576888376337251 + 0.5; // reciprocal( 2 PI ) + 0.5\n		vec4 envColor = texture2D( envMap, sampleUV );\n		\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n\n	#if defined( HDR_INPUT ) && defined( ENVMAP_HDR_INPUT )\n		#if ENVMAP_HDR_INPUT == HDR_TYPE_RGBM\n			envColor.xyz = HDRDecodeRGBM( envColor );\n		#elif ENVMAP_HDR_INPUT == HDR_TYPE_RGBD\n			envColor.xyz = HDRDecodeRGBD( envColor );\n		#elif ENVMAP_HDR_INPUT == HDR_TYPE_LOGLUV\n			envColor.xyz = HDRDecodeLOGLUV( envColor );\n		#elif ENVMAP_HDR_INPUT == HDR_TYPE_RGBE\n			envColor.xyz = HDRDecodeRGBE( envColor );\n		#endif\n	#endif\n\n	#ifdef GAMMA_INPUT\n\n		envColor.xyz *= envColor.xyz;\n\n	#endif\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		gl_FragColor.xyz += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	#ifndef USE_MORPHNORMALS\n\n	uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n	uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n	#else\n\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n	#endif\n\n	#ifdef FOG_EXP2\n\n		const float LOG2 = 1.442695;\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n	#endif\n	\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef USE_SKINNING\n\n	vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n	vec3 objectNormal = morphedNormal;\n\n#else\n\n	vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n	objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n	varying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n	uniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl

THREE.ShaderChunk[ 'map_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n  vec4 lightMapColor = texture2D( lightMap, vUv2 );\n  #ifdef LIGHTMAP_HDR_INPUT\n    #if LIGHTMAP_HDR_INPUT == HDR_TYPE_RGBM\n      lightMapColor.xyz = HDRDecodeRGBM( lightMapColor );\n    #elif LIGHTMAP_HDR_INPUT == HDR_TYPE_RGBD\n      lightMapColor.xyz = HDRDecodeRGBD( lightMapColor );\n    #elif LIGHTMAP_HDR_INPUT == HDR_TYPE_LOGLUV\n      lightMapColor.xyz = HDRDecodeLOGLUV( lightMapColor );\n    #elif LIGHTMAP_HDR_INPUT == HDR_TYPE_RGBE\n      lightMapColor.xyz = HDRDecodeRGBE( lightMapColor );\n    #endif\n  #endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * lightMapColor.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n	vec3 morphed = vec3( 0.0 );\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n	#endif\n\n	morphed += position;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n	worldNormal = normalize( worldNormal );\n\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n	#ifdef ENVMAP_MODE_REFLECTION\n\n		vReflect = reflect( cameraToVertex, worldNormal );\n\n	#else\n\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n	#ifdef SHADOWMAP_DEBUG\n\n		vec3 frustumColors[3];\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n	#endif\n\n	#ifdef SHADOWMAP_CASCADE\n\n		int inFrustumCount = 0;\n\n	#endif\n\n	float fDepth;\n	vec3 shadowColor = vec3( 1.0 );\n\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n				// if ( something && something ) breaks ATI OpenGL shader compiler\n				// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n				// don't shadow pixels outside of light frustum\n				// use just first frustum (for cascades)\n				// don't shadow pixels behind far plane of light frustum\n\n		#ifdef SHADOWMAP_CASCADE\n\n			inFrustumCount += int( inFrustum );\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n		#else\n\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		#endif\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n			shadowCoord.z += shadowBias[ i ];\n\n			#if defined( SHADOWMAP_TYPE_PCF )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n		/*\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n						// must enroll loop manually\n\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n						float fDepth = unpackDepth( rgbaDepth );\n\n						if ( fDepth < shadowCoord.z )\n							shadow += 1.0;\n\n				}\n\n				shadow /= 9.0;\n\n		*/\n\n				const float shadowDelta = 1.0 / 9.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.25 * xPixelOffset;\n				float dy0 = -1.25 * yPixelOffset;\n				float dx1 = 1.25 * xPixelOffset;\n				float dy1 = 1.25 * yPixelOffset;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n						// Percentage-close filtering\n						// (9 pixel kernel)\n						// http://fabiensanglard.net/shadowmappingPCF/\n\n				float shadow = 0.0;\n\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n				float dx0 = -1.0 * xPixelOffset;\n				float dy0 = -1.0 * yPixelOffset;\n				float dx1 = 1.0 * xPixelOffset;\n				float dy1 = 1.0 * yPixelOffset;\n\n				mat3 shadowKernel;\n				mat3 depthKernel;\n\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n				vec3 shadowZ = vec3( shadowCoord.z );\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n				shadowKernel[0] *= vec3(0.25);\n\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n				shadowKernel[1] *= vec3(0.25);\n\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n				shadowKernel[2] *= vec3(0.25);\n\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n				vec4 shadowValues;\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n				shadow = dot( shadowValues, vec4( 1.0 ) );\n\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n			#else\n\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n				float fDepth = unpackDepth( rgbaDepth );\n\n				if ( fDepth < shadowCoord.z )\n\n		// spot with multiple shadows is darker\n\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n		// spot with multiple shadows has the same color as single shadow spot\n\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n			#endif\n\n		}\n\n\n		#ifdef SHADOWMAP_DEBUG\n\n			#ifdef SHADOWMAP_CASCADE\n\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#else\n\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n			#endif\n\n		#endif\n\n	}\n\n	#ifdef GAMMA_OUTPUT\n\n		shadowColor *= shadowColor;\n\n	#endif\n\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n	#ifdef USE_SKINNING\n\n		vec4 worldPosition = modelMatrix * skinned;\n\n	#elif defined( USE_MORPHTARGETS )\n\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n	#else\n\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n	uniform float shadowDarkness[ MAX_SHADOWS ];\n	uniform float shadowBias[ MAX_SHADOWS ];\n\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n	float unpackDepth( const in vec4 rgba_depth ) {\n\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		float depth = dot( rgba_depth, bit_shift );\n		return depth;\n\n	}\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n	uniform float logDepthBufFC;\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		#extension GL_EXT_frag_depth : enable\n		varying float vFragDepth;\n\n	#endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"lightMap" : { type: "t", value: null },
		"specularMap" : { type: "t", value: null },
		"alphaMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: - 1 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	bump: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	},

	tonemap : {

		"middleGrey" : { type: "f", value: 0.6 },
		"maxLuminance" : { type: "f", value: 16.0 },
		"avgLuminance" : { type: "f", value: 2.0 },
		"luminanceMap" : { type: "t", value: null },
	},

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

			"	#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],
				THREE.ShaderChunk[ "hdr_encode_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

			"	varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

			"	#ifdef DOUBLE_SIDED",

					//"float isFront = float( gl_FrontFacing );",
					//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

			"		if ( gl_FrontFacing )",
			"			gl_FragColor.xyz *= vLightFront;",
			"		else",
			"			gl_FragColor.xyz *= vLightBack;",

			"	#else",

			"		gl_FragColor.xyz *= vLightFront;",

			"	#endif",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],
				THREE.ShaderChunk[ "hdr_encode_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bump" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"	vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"	vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"#define PHONG",

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "alphamap_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphamap_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],
				THREE.ShaderChunk[ "hdr_encode_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

			"	#ifdef USE_SIZEATTENUATION",
			"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
			"	#else",
			"		gl_PointSize = size;",
			"	#endif",

			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],
				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale"    : { type: "f", value: 1 },
				"dashSize" : { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

			"	vLineDistance = scale * lineDistance;",

			"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"	gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	if ( mod( vLineDistance, totalSize ) > dashSize ) {",

			"		discard;",

			"	}",

			"	gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

			"	#else",

			"		float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"	#endif",

			"	float color = 1.0 - smoothstep( mNear, mFar, depth );",
			"	gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"void main() {",

			"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
			"	vWorldPosition = worldPosition.xyz;",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],

			"void main() {",

				"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],
				"#if defined( HDR_INPUT ) && defined( ENVMAP_HDR_INPUT )",
					"#if ENVMAP_HDR_INPUT == HDR_TYPE_RGBM",
						"gl_FragColor = vec4( HDRDecodeRGBM( gl_FragColor ), 1.0 );",
					"#elif ENVMAP_HDR_INPUT == HDR_TYPE_RGBD",
						"gl_FragColor = vec4( HDRDecodeRGBD( gl_FragColor ), 1.0 );",
					"#elif ENVMAP_HDR_INPUT == HDR_TYPE_RGBE",
						"gl_FragColor = vec4( HDRDecodeRGBE( gl_FragColor ), 1.0 );",
					"#elif ENVMAP_HDR_INPUT == HDR_TYPE_LOGLUV",
						"gl_FragColor = vec4( HDRDecodeLOGLUV( gl_FragColor ), 1.0 );",
					"#endif",
				"#endif",
				"#if defined( GAMMA_INPUT ) && !defined( GAMMA_OUTPUT )",
					"gl_FragColor.xyz *= gl_FragColor.xyz;",
				"#elif !defined( GAMMA_INPUT ) && defined( GAMMA_OUTPUT )",
					"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",
				"#endif",
				THREE.ShaderChunk[ "hdr_encode_fragment" ],

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'equirect': {

		uniforms: { "tEquirect": { type: "t", value: null },
					"tFlip": { type: "f", value: - 1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

			"	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
			"	vWorldPosition = worldPosition.xyz;",

			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform sampler2D tEquirect;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],

			"void main() {",

				// "	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
				"vec3 direction = normalize( vWorldPosition );",
				"vec2 sampleUV;",
				"sampleUV.y = clamp( tFlip * direction.y * -0.5 + 0.5, 0.0, 1.0);",
				"sampleUV.x = atan( direction.z, direction.x ) * 0.15915494309189533576888376337251 + 0.5;", // reciprocal( 2 PI ) + 0.5
				"gl_FragColor = texture2D( tEquirect, sampleUV );",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

				"#if defined( HDR_INPUT ) && defined( ENVMAP_HDR_INPUT )",
					"#if ENVMAP_HDR_INPUT == HDR_TYPE_RGBM",
						"gl_FragColor = vec4( HDRDecodeRGBM( gl_FragColor ), 1.0 );",
					"#elif ENVMAP_HDR_INPUT == HDR_TYPE_RGBD",
						"gl_FragColor = vec4( HDRDecodeRGBD( gl_FragColor ), 1.0 );",
					"#elif ENVMAP_HDR_INPUT == HDR_TYPE_RGBE",
						"gl_FragColor = vec4( HDRDecodeRGBE( gl_FragColor ), 1.0 );",
					"#elif ENVMAP_HDR_INPUT == HDR_TYPE_LOGLUV",
						"gl_FragColor = vec4( HDRDecodeLOGLUV( gl_FragColor ), 1.0 );",
					"#endif",
				"#endif",
				"#if defined( GAMMA_INPUT ) && !defined( GAMMA_OUTPUT )",
					"gl_FragColor.xyz *= gl_FragColor.xyz;",
				"#elif !defined( GAMMA_INPUT ) && defined( GAMMA_OUTPUT )",
					"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",
				"#endif",
				THREE.ShaderChunk[ "hdr_encode_fragment" ],

			"}"

		].join("\n")

	},

	/* Depth encoding into RGBA texture
	 *
	 * based on SpiderGL shadow map example
	 * http://spidergl.org/example.php?id=6
	 *
	 * originally from
	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	 *
	 * see also
	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
	 */

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],
				THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

			"vec4 pack_depth( const in float depth ) {",

			"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
			"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
			"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "	vec4 res = fract( depth * bit_shift );",
			"	res -= res.xxyz * bit_mask;",
			"	return res;",

			"}",

			"void main() {",

				THREE.ShaderChunk[ "logdepthbuf_fragment" ],

			"	#ifdef USE_LOGDEPTHBUF_EXT",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

			"	#else",

			"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

			"	#endif",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	pixelRatio = 1,

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_depth = parameters.depth !== undefined ? parameters.depth : true,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
	_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	var lights = [];

	var _webglObjects = {};
	var _webglObjectsImmediate = [];

	var opaqueObjects = [];
	var transparentObjects = [];

	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;

	// hdr rendering
	
	this.hdrOutputEnabled = false;
	this.hdrOutputType = THREE.HDRFull;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;
	this.maxShadows = -1;

	// lights

	this.maxDirLights = -1;
	this.maxPointLights = -1;
	this.maxSpotLights = -1;
	this.maxHemiLights = -1;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = - 1,
	_currentGeometryProgram = '',
	_currentCamera = null,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = - 1,
	_oldFlipSided = - 1,

	_oldBlending = - 1,

	_oldBlendEquation = - 1,
	_oldBlendSrc = - 1,
	_oldBlendDst = - 1,

	_oldDepthTest = - 1,
	_oldDepthWrite = - 1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	_newAttributes = new Uint8Array( 16 ),
	_enabledAttributes = new Uint8Array( 16 ),

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenMatrixPS = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors:[], positions: [] },
		point: { length: 0, colors: [], positions: [], distances: [] },
		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [] },
		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

	};

	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl') !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		_canvas.addEventListener( 'webglcontextlost', function ( event ) {

			event.preventDefault();

			resetGLState();
			setDefaultGLState();

			_webglObjects = {};

		}, false);

	} catch ( error ) {

		console.error( error );

	}

	if ( _gl.getShaderPrecisionFormat === undefined ) {

		_gl.getShaderPrecisionFormat = function () {

			return {
				'rangeMin': 1,
				'rangeMax': 1,
				'precision': 1
			};

		}

	}

	var extensions = new THREE.WebGLExtensions( _gl );

	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_standard_derivatives' );

	if ( _logarithmicDepthBuffer ) {

		extensions.get( 'EXT_frag_depth' );

	}

	//

	var setDefaultGLState = function () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	var resetGLState = function () {

		_currentProgram = null;
		_currentCamera = null;

		_oldBlending = - 1;
		_oldDepthTest = - 1;
		_oldDepthWrite = - 1;
		_oldDoubleSided = - 1;
		_oldFlipSided = - 1;
		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		_lightsNeedUpdate = true;

		for ( var i = 0; i < _newAttributes.length; i ++ ) {

			_newAttributes[ i ] = 0;

		}

	};

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _supportsVertexTextures = _maxVertexTextures > 0;
	var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	var getCompressedTextureFormats = ( function () {

		var array;

		return function () {

			if ( array !== undefined ) {

				return array;

			}

			array = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

				var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ){

					array.push( formats[ i ] );

				}

			}

			return array;

		};

	} )();

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === 'highp' && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = 'mediump';
			console.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

		} else {

			_precision = 'lowp';
			console.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

		}

	}

	if ( _precision === 'mediump' && ! mediumpAvailable ) {

		_precision = 'lowp';
		console.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

	}

	// Plugins

	var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );

	var spritePlugin = new THREE.SpritePlugin( this, sprites );
	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.forceContextLoss = function () {

		extensions.get( 'WEBGL_lose_context' ).loseContext();

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return extensions.get( 'OES_texture_float' );

	};

	this.supportsStandardDerivatives = function () {

		return extensions.get( 'OES_standard_derivatives' );

	};

	this.supportsCompressedTextureS3TC = function () {

		return extensions.get( 'WEBGL_compressed_texture_s3tc' );

	};

	this.supportsCompressedTextureATC = function () {

		return extensions.get( 'WEBGL_compressed_texture_atc' );

	};

	this.supportsCompressedTexturePVRTC = function () {

		return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	};

	this.supportsBlendMinMax = function () {

		return extensions.get( 'EXT_blend_minmax' );

	};

	this.getMaxAnisotropy = ( function () {

		var value;

		return function () {

			if ( value !== undefined ) {

				return value;

			}

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

			return value;

		}

	} )();

	//START_VEROLD_MOD
	this.getMaxTextureSize  = function () {

		return _maxTextureSize;

	};

	this.getMaxCubemapSize  = function () {

		return _maxCubemapSize;

	};

	this.getMaxTextures  = function () {

		return _maxTextures;

	};

	this.getMaxVertexTextures  = function () {

		return _maxVertexTextures;

	};

	this.setPrecision = function( precision ) {
		_precision = precision !== undefined ? precision : 'highp';
	};

	this.getLights = function () {
		return _lights;
	};
	//END_VEROLD_MOD


	this.getPrecision = function () {

		return _precision;

	};

	this.dispose = function() {
		var i;
		for ( i in this.renderPluginsPre ) {
		   this.renderPluginsPre[i].dispose();
		}
		for ( i in this.renderPluginsPost ) {
		   this.renderPluginsPost[i].dispose();
		}
		this.renderPluginsPre = null;
		this.renderPluginsPost = null;
		opaqueObjects = null;
		transparentObjects = null;
		_canvas = null;
		_programs = null;
		_this = null;
	};
	
	this.getPixelRatio = function () {

		return pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		pixelRatio = value;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * pixelRatio;
		_canvas.height = height * pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * pixelRatio;
		_viewportY = y * pixelRatio;

		_viewportWidth = width * pixelRatio;
		_viewportHeight = height * pixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	//START_VEROLD_MOD
	this.getViewport = function () {
		var viewport = {
			x: _viewportX / pixelRatio,
			y: _viewportY / pixelRatio,
			width: _viewportWidth / pixelRatio,
			height: _viewportHeight / pixelRatio,
		}
		return viewport;
	};
	//END_VEROLD_MOD

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * pixelRatio,
			y * pixelRatio,
			width * pixelRatio,
			height * pixelRatio
		);

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.getClearColor = function () {

		return _clearColor;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.setClearAlpha = function ( alpha ) {

		_clearAlpha = alpha;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = resetGLState;

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var numMorphTargets = geometryGroup.numMorphTargets;

		if ( numMorphTargets ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		var numMorphNormals = geometryGroup.numMorphNormals;

		if ( numMorphNormals ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Events

	var onObjectRemoved = function ( event ) {

		var object = event.target;

		object.traverse( function ( child ) {

			child.removeEventListener( 'remove', onObjectRemoved );

			removeObject( child );

		} );

	};

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		if ( window.VAPI ) {
			window.VAPI.globalEvents.trigger("veroldEngine:textureDebugger:unregisterTexture", renderTarget );
		}

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {

		var buffers = [
			'__webglVertexBuffer',
			'__webglNormalBuffer',
			'__webglTangentBuffer',
			'__webglColorBuffer',
			'__webglUVBuffer',
			'__webglUV2Buffer',

			'__webglSkinIndicesBuffer',
			'__webglSkinWeightsBuffer',

			'__webglFaceBuffer',
			'__webglLineBuffer',

			'__webglLineDistanceBuffer'
		];

		for ( var i = 0, l = buffers.length; i < l; i ++ ) {

			var name = buffers[ i ];

			if ( geometry[ name ] !== undefined ) {

				_gl.deleteBuffer( geometry[ name ] );

				delete geometry[ name ];

			}

		}

		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var name in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );

			}

			delete geometry.__webglCustomAttributesList;

		}

		_this.info.memory.geometries --;

	};

	var deallocateGeometry = function ( geometry ) {

		delete geometry.__webglInit;

		if ( geometry instanceof THREE.BufferGeometry ) {

			for ( var name in geometry.attributes ) {

				var attribute = geometry.attributes[ name ];

				if ( attribute.buffer !== undefined ) {

					_gl.deleteBuffer( attribute.buffer );

					delete attribute.buffer;

				}

			}

			_this.info.memory.geometries --;

		} else {

			var geometryGroupsList = geometryGroups[ geometry.id ];

			if ( geometryGroupsList !== undefined ) {

				for ( var i = 0, l = geometryGroupsList.length; i < l; i ++ ) {

					var geometryGroup = geometryGroupsList[ i ];

					if ( geometryGroup.numMorphTargets !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphTargetsBuffers;

					}

					if ( geometryGroup.numMorphNormals !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

						}

						delete geometryGroup.__webglMorphNormalsBuffers;

					}

					deleteBuffers( geometryGroup );

				}

				delete geometryGroups[ geometry.id ];

			} else {

				deleteBuffers( geometry );

			}

		}

		// TOFIX: Workaround for deleted geometry being currently bound

		_currentGeometryProgram = '';

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

			delete texture.image.__webglTextureCube;

		} else {

			// 2D texture

			if ( texture.__webglInit === undefined ) return;

			_gl.deleteTexture( texture.__webglTexture );

			delete texture.__webglTexture;
			delete texture.__webglInit;

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		delete renderTarget.__webglTexture;

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

		delete renderTarget.__webglFramebuffer;
		delete renderTarget.__webglRenderbuffer;

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( object ) {

		var geometry = object.geometry;
		var material = object.material;

		var nvertices = geometry.vertices.length;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var name in material.attributes ) {

				var attribute = material.attributes[ name ];

				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;   // "f" and "i"

					if ( attribute.type === 'v2' ) size = 2;
					else if ( attribute.type === 'v3' ) size = 3;
					else if ( attribute.type === 'v4' ) size = 4;
					else if ( attribute.type === 'c'  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = name;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes( object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes( object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );
		geometryGroup.__normalArray = new Float32Array( nvertices * 3 );
		geometryGroup.__colorArray = new Float32Array( nvertices * 3 );
		geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

		if ( geometry.faceVertexUvs.length > 1 ) {

			geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

		geometryGroup.__typeArray = UintArray;
		geometryGroup.__faceArray = new UintArray( ntris * 3 );
		geometryGroup.__lineArray = new UintArray( nlines * 2 );

		var numMorphTargets = geometryGroup.numMorphTargets;

		if ( numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		var numMorphNormals = geometryGroup.numMorphNormals;

		if ( numMorphNormals ) {

			geometryGroup.__morphNormalsArrays = [];

			for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var name in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ name ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;   // "f" and "i"

					if ( attribute.type === 'v2' ) size = 2;
					else if ( attribute.type === 'v3' ) size = 3;
					else if ( attribute.type === 'v4' ) size = 4;
					else if ( attribute.type === 'c'  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = name;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			 ? object.material.materials[ geometryGroup.materialIndex ]
			 : object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined ||  customAttribute.boundTo === 'vertices' ) ) {

					cal = customAttribute.value.length;

					offset = 0;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]   = value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === 'c' ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				customAttribute.needsUpdate = false;

			}

		}

	}

	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]   = value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === 'c' ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]   = value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ]    = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

					customAttribute.needsUpdate = false;

				}

			}

		}

	}

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var needsSmoothNormals = materialNeedsSmoothNormals( material );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ]     = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ]     = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ]   = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ]     = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ]     = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ]     = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === 'c' ) {

						pp = [ 'r', 'g', 'b' ];

					} else {

						pp = [ 'x', 'y', 'z' ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === 'faceVertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === 'faces' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === 'faceVertices' ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ]   = v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		initAttributes();

		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( material.shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for ( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ]   = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.uv );
			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			enableAttribute( program.attributes.color );
			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.attributes;
		var programAttributesKeys = program.attributesKeys;

		for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {

			var key = programAttributesKeys[ i ];
			var programAttribute = programAttributes[ key ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ key ];

				if ( geometryAttribute !== undefined ) {

					var size = geometryAttribute.itemSize;

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );

					enableAttribute( programAttribute );

					_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

				} else if ( material.defaultAttributeValues !== undefined ) {

					if ( material.defaultAttributeValues[ key ].length === 2 ) {

						_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );

					} else if ( material.defaultAttributeValues[ key ].length === 3 ) {

						_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	// START_VEROLD_MOD - materialIndex in offsets
	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object, offsetIndices ) {
	// END_VEROLD_MOD - materialIndex in offsets

		if ( material.visible === false ) return;

		updateObject( object );

		var program = setProgram( camera, lights, fog, material, object );

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

			var index = geometry.attributes.index;
			
			if ( index ) {

				// indexed triangles

				var type, size;

				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}

				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					_gl.drawElements( mode, index.array.length, type, 0 );

					_this.info.render.calls ++;
					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
					_this.info.render.faces += index.array.length / 3;

				} else {

					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change

					updateBuffers = true;

					// START_VEROLD_MOD - materialIndex in offsets
					for ( var i = 0, il = offsetIndices.length; i < il; i ++ ) {

						var offset = offsets[ offsetIndices[ i ] ];

						// END_VEROLD_MOD - materialIndex in offsets

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, offset.index );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						// render indexed triangles
						_gl.drawElements( mode, offset.count, type, offset.start * size );

						_this.info.render.calls ++;
						_this.info.render.vertices += offset.count; // not really true, here vertices can be shared

						_this.info.render.faces += offset.count / 3;

					}

				}

			} else if ( !material.wireframe ) {

				// non-indexed triangles

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes[ 'position' ];

				// render non-indexed triangles

				_gl.drawArrays( mode, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.vertices += position.array.length / 3;
				_this.info.render.faces += position.array.length / 9;

			}

		} else if ( object instanceof THREE.PointCloud ) {

			// render particles

			var mode = _gl.POINTS;

			var index = geometry.attributes.index;

			if ( index ) {

				// indexed points

				var type, size;

				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}

				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					_gl.drawElements( mode, index.array.length, type, 0);

					_this.info.render.calls ++;
					_this.info.render.points += index.array.length;

				} else {

					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change

					if ( offsets.length > 1 ) updateBuffers = true;

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						var startIndex = offsets[ i ].index;

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, startIndex );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						// render indexed points

						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

						_this.info.render.calls ++;
						_this.info.render.points += offsets[ i ].count;

					}

				}

			} else {

				// non-indexed points

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes.position;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					_gl.drawArrays( mode, 0, position.array.length / 3 );

					_this.info.render.calls ++;
					_this.info.render.points += position.array.length / 3;

				} else {

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

						_this.info.render.calls ++;
						_this.info.render.points += offsets[ i ].count;

					}

				}

			}

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			var index = geometry.attributes.index;

			if ( index ) {

				// indexed lines

				var type, size;

				if ( index.array instanceof Uint32Array ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}

				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					if ( updateBuffers ) {

						setupVertexAttributes( material, program, geometry, 0 );
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

					_this.info.render.calls ++;
					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

				} else {

					// if there is more than 1 chunk
					// must set attribute pointers to use new offsets for each chunk
					// even if geometry and materials didn't change

					if ( offsets.length > 1 ) updateBuffers = true;

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						var startIndex = offsets[ i ].index;

						if ( updateBuffers ) {

							setupVertexAttributes( material, program, geometry, startIndex );
							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

						}

						// render indexed lines

						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

					}

				}

			} else {

				// non-indexed lines

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry, 0 );

				}

				var position = geometry.attributes.position;
				var offsets = geometry.offsets;

				if ( offsets.length === 0 ) {

					_gl.drawArrays( mode, 0, position.array.length / 3 );

					_this.info.render.calls ++;
					_this.info.render.vertices += position.array.length / 3;

				} else {

					for ( var i = 0, il = offsets.length; i < il; i ++ ) {

						_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

						_this.info.render.calls ++;
						_this.info.render.vertices += offsets[ i ].count;

					}

				}

			}

		}

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		updateObject( object );

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// vertices

		if ( ! material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					var attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[ 0 ] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[ 1 ] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues !== undefined ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			if ( material.skinning &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes.skinIndex );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes.skinWeight );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		disableUnusedAttributes();

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );
				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.PointCloud ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;
			_this.info.render.points += geometryGroup.__webglParticleCount;

		}

	};

	function initAttributes() {

		for ( var i = 0, l = _newAttributes.length; i < l; i ++ ) {

			_newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		_newAttributes[ attribute ] = 1;

		if ( _enabledAttributes[ attribute ] === 0 ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = 1;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = _enabledAttributes.length; i < l; i ++ ) {

			if ( _enabledAttributes[ i ] !== _newAttributes[ i ] ) {

				_gl.disableVertexAttribArray( i );
				_enabledAttributes[ i ] = 0;

			}

		}

	}

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			var attribute;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				attribute = attributes[ 'morphTarget' + m ];

				if ( attribute >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attribute );
					_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

				}

				attribute = attributes[ 'morphNormal' + m ];

				if ( attribute >= 0 && material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attribute );
					_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;

			}

		} else {

			// find the most influencing

			var activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;

			for ( var i = 0, il = influences.length; i < il; i ++ ) {

				var influence = influences[ i ];

				activeInfluenceIndices.push( [ influence, i ] );

			}

			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.push( [ 0, 0 ] );

			}

			var attribute;

			for ( var m = 0, ml = material.numSupportedMorphTargets; m < ml; m ++ ) {

				if ( activeInfluenceIndices[ m ] ) {

					var influenceIndex = activeInfluenceIndices[ m ][ 1 ];

					attribute = attributes[ 'morphTarget' + m ];

					if ( attribute >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
						enableAttribute( attribute );
						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );

					}

					attribute = attributes[ 'morphNormal' + m ];

					if ( attribute >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attribute );
						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );


					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					/*
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}
					*/

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	}

	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var fog = scene.fog;
		
		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		// update Skeleton objects

		scene.traverse( function ( object ) {

			if ( object instanceof THREE.SkinnedMesh ) {

				object.skeleton.update();

			}

		} );

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;
		opaqueObjects.length = 0;
		transparentObjects.length = 0;

		sprites.length = 0;
		lensFlares.length = 0;

		projectObject( scene );

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );
			
		}

		// custom render plugins (pre pass)

		shadowMapPlugin.render( scene, camera );

		//

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;
		_this.info.render.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for immediate objects

		for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {

			var webglObject = _webglObjectsImmediate[ i ];
			var object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( object, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;
			//START_VEROLD_MOD - override materials are objects with separate materials defined for different types of objects
			if ( material["static"] ) {
				this.setBlending( material["static"].blending, material["static"].blendEquation, material["static"].blendSrc, material["static"].blendDst );
				this.setDepthTest( material["static"].depthTest );
				this.setDepthWrite( material["static"].depthWrite );
				setPolygonOffset( material["static"].polygonOffset, material["static"].polygonOffsetFactor, material["static"].polygonOffsetUnits );
			}
			else {
				this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				this.setDepthTest( material.depthTest );
				this.setDepthWrite( material.depthWrite );
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
			}
			//END_VEROLD_MOD

			renderObjects( opaqueObjects, camera, lights, fog, true, material );
			renderObjects( transparentObjects, camera, lights, fog, true, material );
			renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( opaqueObjects, camera, lights, fog, false, material );
			renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, lights, fog, true, material );
			renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

	function projectObject( object ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

			// skip

		} else {

			initObject( object );

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				sprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else {

				var webglObjects = _webglObjects[ object.id ];

				if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

					for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

						var webglObject = webglObjects[i];

						unrollBufferMaterial( webglObject );

						webglObject.render = true;

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

							webglObject.z = _vector3.z;

						}

					}

				}

			}

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			projectObject( object.children[ i ] );

		}

	}

	function renderObjects( renderList, camera, lights, fog, useBlending, overrideMaterial ) {

		var material;

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var webglObject = renderList[ i ];

			var object = webglObject.object;
			var buffer = webglObject.buffer;

			setupMatrices( object, camera );

			//START_VEROLD_MOD
			if ( overrideMaterial && overrideMaterial[ "static" ] ) {
				if ( object instanceof THREE.SkinnedMesh ) {
					material = overrideMaterial[ "skinned" ];
				}
				else if ( object instanceof THREE.Mesh ) {
					material = overrideMaterial[ "static" ];
				}
				else {
					material = webglObject.material;
				}
			}
			else if ( overrideMaterial ) {
				material = overrideMaterial;

			} else {
			//END_VEROLD_MOD
				material = webglObject.material;

				if ( ! material ) continue;

				if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

				_this.setDepthTest( material.depthTest );
				_this.setDepthWrite( material.depthWrite );
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			}

			_this.setMaterialFaces( material );

			if ( buffer instanceof THREE.BufferGeometry ) {
				// START_VEROLD_MOD - materialIndex in offsets
				_this.renderBufferDirect( camera, lights, fog, material, buffer, object, webglObject.offsetIndices );
				// END_VEROLD_MOD - materialIndex in offsets

			} else {

				_this.renderBuffer( camera, lights, fog, material, buffer, object );

			}

		}

	}

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var material;

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var webglObject = renderList[ i ];
			var object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	}

	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryProgram = '';

		_this.setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	}

	function unrollBufferMaterial ( globject ) {

		var object = globject.object;
		var buffer = globject.buffer;

		var geometry = object.geometry;
		var material = object.material;
		
		// START_VEROLD_MOD - materialIndex in offsets
		var materialIndex, offset;
		// END_VEROLD_MOD - materialIndex in offsets

		if ( material instanceof THREE.MeshFaceMaterial ) {

			// START_VEROLD_MOD - materialIndex in offsets
			materialIndex = -1;

			if ( buffer instanceof THREE.BufferGeometry ) {

				if ( globject.offsetIndices ) {

					offset = buffer.offsets[ globject.offsetIndices[ 0 ] ];

					if ( offset.hasOwnProperty( 'materialIndex' ) ) {

						materialIndex = offset.materialIndex;

					}

				}

			} else {

				materialIndex = buffer.materialIndex;

			}

			if ( materialIndex >= 0 ) {

				material = material.materials[ materialIndex ];

			}
			// END_VEROLD_MOD - materialIndex in offsets

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		} else if ( material ) {

			globject.material = material;

			if ( material.transparent ) {

				transparentObjects.push( globject );

			} else {

				opaqueObjects.push( globject );

			}

		}

	}

	function initObject( object ) {

		// START_VEROLD_MOD - materialIndex in offsets
		var materialIndex, offsetIndices, offset;
		// END_VEROLD_MOD - materialIndex in offsets

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;
			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

			object.addEventListener( 'removed', onObjectRemoved );

		}

		var geometry = object.geometry;

		if ( geometry === undefined ) {

			// ImmediateRenderObject

		} else if ( geometry.__webglInit === undefined ) {

			geometry.__webglInit = true;
			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry instanceof THREE.BufferGeometry ) {

				_this.info.memory.geometries ++;

			} else if ( object instanceof THREE.Mesh ) {

				initGeometryGroups( object, geometry );

			} else if ( object instanceof THREE.Line ) {

				if ( geometry.__webglVertexBuffer === undefined ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object instanceof THREE.PointCloud ) {

				if ( geometry.__webglVertexBuffer === undefined ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined) {

			object.__webglActive = true;

			if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					// START_VEROLD_MOD - materialIndex in offsets
					if ( geometry.offsets ) {

						offsetIndices = {};

						for ( var i = 0; i < geometry.offsets.length; ++i ) {

							offset = geometry.offsets[ i ];

							materialIndex = offset.hasOwnProperty( 'materialIndex' ) ?
								offset.materialIndex : 0;

							if ( ! ( materialIndex in offsetIndices ) ) {

								offsetIndices[ materialIndex ] = new Array();

							}

							offsetIndices[ materialIndex ].push( i );

						}

						for ( materialIndex in offsetIndices ) {

							addBuffer( _webglObjects, geometry, object, offsetIndices[ materialIndex ] );

						}

					} else {

						addBuffer( _webglObjects, geometry, object );

					}
					// END_VEROLD_MOD - materialIndex in offsets

				} else if ( geometry instanceof THREE.Geometry ) {

					var geometryGroupsList = geometryGroups[ geometry.id ];

					for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {

						addBuffer( _webglObjects, geometryGroupsList[ i ], object );

					}

				}

			} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

				addBuffer( _webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( _webglObjectsImmediate, object );

			}

		}

	}

	// Geometry splitting

	var geometryGroups = {};
	var geometryGroupCounter = 0;

	function makeGroups( geometry, usesFaceMaterial ) {

		var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;

		var groupHash, hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		var group;
		var groups = {};
		var groupsList = [];

		for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

			var face = geometry.faces[ f ];
			var materialIndex = usesFaceMaterial ? face.materialIndex : 0;

			if ( ! ( materialIndex in hash_map ) ) {

				hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };

			}

			groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

			if ( ! ( groupHash in groups ) ) {

				group = {
					id: geometryGroupCounter ++,
					faces3: [],
					materialIndex: materialIndex,
					vertices: 0,
					numMorphTargets: numMorphTargets,
					numMorphNormals: numMorphNormals
				};

				groups[ groupHash ] = group;
				groupsList.push( group );

			}

			if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {

				hash_map[ materialIndex ].counter += 1;
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in groups ) ) {

					group = {
						id: geometryGroupCounter ++,
						faces3: [],
						materialIndex: materialIndex,
						vertices: 0,
						numMorphTargets: numMorphTargets,
						numMorphNormals: numMorphNormals
					};

					groups[ groupHash ] = group;
					groupsList.push( group );

				}

			}

			groups[ groupHash ].faces3.push( f );
			groups[ groupHash ].vertices += 3;

		}

		return groupsList;

	}

	function initGeometryGroups( object, geometry ) {

		var material = object.material, addBuffers = false;

		if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {

			delete _webglObjects[ object.id ];

			geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );

			geometry.groupsNeedUpdate = false;

		}

		var geometryGroupsList = geometryGroups[ geometry.id ];

		// create separate VBOs per geometry chunk

		for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

			var geometryGroup = geometryGroupsList[ i ];

			// initialise VBO on the first access

			if ( geometryGroup.__webglVertexBuffer === undefined ) {

				createMeshBuffers( geometryGroup );
				initMeshBuffers( geometryGroup, object );

				geometry.verticesNeedUpdate = true;
				geometry.morphTargetsNeedUpdate = true;
				geometry.elementsNeedUpdate = true;
				geometry.uvsNeedUpdate = true;
				geometry.normalsNeedUpdate = true;
				geometry.tangentsNeedUpdate = true;
				geometry.colorsNeedUpdate = true;

				addBuffers = true;

			} else {

				addBuffers = false;

			}

			if ( addBuffers || object.__webglActive === undefined ) {

				addBuffer( _webglObjects, geometryGroup, object );

			}

		}

		object.__webglActive = true;

	}

	// START_VEROLD_MOD - materialIndex in offsets
	function addBuffer( objlist, buffer, object, offsetIndices ) {
	// END_VEROLD_MOD - materialIndex in offsets

		var id = object.id;
		objlist[id] = objlist[id] || [];
		objlist[id].push(
			{
				id: id,
				buffer: buffer,
				object: object,
				material: null,
				z: 0,
				// START_VEROLD_MOD - materialIndex in offsets
				offsetIndices: offsetIndices
				// END_VEROLD_MOD - materialIndex in offsets
			}
		);

	};

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	// Objects updates

	function updateObject( object ) {

		var geometry = object.geometry;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;
			var attributesKeys = geometry.attributesKeys;

			for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {

				var key = attributesKeys[ i ];
				var attribute = attributes[ key ];

				if ( attribute.buffer === undefined ) {

					attribute.buffer = _gl.createBuffer();
					attribute.needsUpdate = true;

				}

				if ( attribute.needsUpdate === true ) {

					var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;

					_gl.bindBuffer( bufferType, attribute.buffer );
					_gl.bufferData( bufferType, attribute.array, _gl.STATIC_DRAW );

					attribute.needsUpdate = false;

				}

			}

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			if ( geometry.groupsNeedUpdate === true ) {

				initGeometryGroups( object, geometry );

			}

			var geometryGroupsList = geometryGroups[ geometry.id ];

			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {

				var geometryGroup = geometryGroupsList[ i ];
				var material = getBufferMaterial( object, geometryGroup );

				if ( geometry.groupsNeedUpdate === true ) {

					initMeshBuffers( geometryGroup, object );

				}

				var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			var material = getBufferMaterial( object, geometry );
			var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.PointCloud ) {

			var material = getBufferMaterial( object, geometry );
			var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty ) {

				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	}

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var name in material.attributes ) {

			if ( material.attributes[ name ].needsUpdate ) return true;

		}

		return false;

	}

	function clearCustomAttributes( material ) {

		for ( var name in material.attributes ) {

			material.attributes[ name ].needsUpdate = false;

		}

	}

	// Objects removal

	function removeObject( object ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.PointCloud ||
			 object instanceof THREE.Line ) {

			delete _webglObjects[ object.id ];

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( _webglObjectsImmediate, object );

		}

		delete object.__webglInit;
		delete object._modelViewMatrix;
		delete object._normalMatrix;

		delete object.__webglActive;

	}

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	}

	// Materials

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointCloudMaterial: 'particle_basic'
	};

	function initMaterial( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var shaderID = shaderIDs[ material.type ];

		if ( shaderID ) {

			var shader = THREE.ShaderLib[ shaderID ];

			material.__webglShader = {
				uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			}

		} else {

			material.__webglShader = {
				uniforms: material.uniforms,
				vertexShader: material.vertexShader,
				fragmentShader: material.fragmentShader
			}

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxLightCount = allocateLights( lights );
		var maxShadows = allocateShadows( lights );
		var maxBones = allocateBones( object );

		var parameters = {

			precision: _precision,
			supportsVertexTextures: _supportsVertexTextures,

			map: !! material.map,
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			lightMap: !! material.lightMap,
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: _logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: _this.maxMorphTargets,
			maxMorphNormals: _this.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
			shadowMapType: _this.shadowMapType,
			shadowMapDebug: _this.shadowMapDebug,
			shadowMapCascade: _this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		// Generate code

		var chunks = [];

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( material.fragmentShader );
			chunks.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				chunks.push( name );
				chunks.push( material.defines[ name ] );

			}

		}

		for ( var name in parameters ) {

			chunks.push( name );
			chunks.push( parameters[ name ] );

		}

		var code = chunks.join();

		var program;

		// Check if code has been already compiled

		for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				program.usedTimes ++;

				break;

			}

		}

		if ( program === undefined ) {

			program = new THREE.WebGLProgram( _this, code, material, parameters );
			_programs.push( program );

			_this.info.memory.programs = _programs.length;

		}

		material.program = program;

		var attributes = program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = 'morphTarget';

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = 'morphNormal';

			for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		for ( var u in material.__webglShader.uniforms ) {

			var location = material.program.uniforms[ u ];

			if ( location ) {
				material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
			}

		}

	}

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

			}

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			if ( _currentMaterialId === -1 ) refreshLights = true;
			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( _logarithmicDepthBuffer ) {

				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) _currentCamera = camera;

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

			}

			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

			}

			if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.skeleton.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

				}

			} else if ( object.skeleton && object.skeleton.boneMatrices ) {

				if ( p_uniforms.boneGlobalMatrices !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( _this.toneMappingEnabled ) {
				refreshUniformsToneMapping( m_uniforms );
			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					refreshLights = true;
					setupLights( lights );
					_lightsNeedUpdate = false;
				}

				if ( refreshLights ) {
					refreshUniformsLights( m_uniforms, _lights );
					markUniformsLightsNeedsUpdate( m_uniforms, true );
				} else {
					markUniformsLightsNeedsUpdate( m_uniforms, false );
				}

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.PointCloudMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( material.uniformsList );

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.value = material.map;
		if ( material.lightMap && material.lightMap.hdrPacking && material.hdrInputEnabled !== false ) {
			if ( !material.defines ) material.defines = {};
			if ( material.defines['LIGHTMAP_HDR_INPUT'] !== material.lightMap.hdrPacking ) {
				material.hdrInputEnabled = true;
				material.defines['LIGHTMAP_HDR_INPUT'] = material.lightMap.hdrPacking;
				material.needsUpdate = true;
			}
		}
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//  1. color map
		//  2. specular map
		//  3. normal map
		//  4. bump map
		//  5. alpha map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		if ( material.envMap && material.envMap.hdrPacking && material.hdrInputEnabled !== false ) {
			if ( !material.defines ) material.defines = {};
			if ( material.defines['ENVMAP_HDR_INPUT'] !== material.envMap.hdrPacking ) {
				material.hdrInputEnabled = true;
				material.defines['ENVMAP_HDR_INPUT'] = material.envMap.hdrPacking;
				material.needsUpdate = true;
			}
		}
		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsToneMapping ( uniforms ) {
		if ( uniforms.avgLuminance ) {
			uniforms.avgLuminance.value = _this.toneMapping_AvgLum;
			uniforms.maxLuminance.value = _this.toneMappingMaxLuminance;
			uniforms.middleGrey.value = _this.toneMappingMiddleGrey;
			uniforms.luminanceMap.value = _this.toneMappingLuminanceMap;
		}
	}

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	}

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	}

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, boolean ) {

		uniforms.ambientLightColor.needsUpdate = boolean;

		uniforms.directionalLightColor.needsUpdate = boolean;
		uniforms.directionalLightDirection.needsUpdate = boolean;

		uniforms.pointLightColor.needsUpdate = boolean;
		uniforms.pointLightPosition.needsUpdate = boolean;
		uniforms.pointLightDistance.needsUpdate = boolean;

		uniforms.spotLightColor.needsUpdate = boolean;
		uniforms.spotLightPosition.needsUpdate = boolean;
		uniforms.spotLightDistance.needsUpdate = boolean;
		uniforms.spotLightDirection.needsUpdate = boolean;
		uniforms.spotLightAngleCos.needsUpdate = boolean;
		uniforms.spotLightExponent.needsUpdate = boolean;

		uniforms.hemisphereLightSkyColor.needsUpdate = boolean;
		uniforms.hemisphereLightGroundColor.needsUpdate = boolean;
		uniforms.hemisphereLightDirection.needsUpdate = boolean;

	}

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	}

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	}

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	function loadUniformsGeneric ( uniforms ) {

		var texture, textureUnit, offset;

		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

			var uniform = uniforms[ j ][ 0 ];

			// needsUpdate property is not added to all uniforms.
			if ( uniform.needsUpdate === false ) continue;

			var type = uniform.type;
			var value = uniform.value;
			var location = uniforms[ j ][ 1 ];

			switch ( type ) {

				case '1i':
					_gl.uniform1i( location, value );
					break;

				case '1f':
					_gl.uniform1f( location, value );
					break;

				case '2f':
					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
					break;

				case '3f':
					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
					break;

				case '4f':
					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
					break;

				case '1iv':
					_gl.uniform1iv( location, value );
					break;

				case '3iv':
					_gl.uniform3iv( location, value );
					break;

				case '1fv':
					_gl.uniform1fv( location, value );
					break;

				case '2fv':
					_gl.uniform2fv( location, value );
					break;

				case '3fv':
					_gl.uniform3fv( location, value );
					break;

				case '4fv':
					_gl.uniform4fv( location, value );
					break;

				case 'Matrix3fv':
					_gl.uniformMatrix3fv( location, false, value );
					break;

				case 'Matrix4fv':
					_gl.uniformMatrix4fv( location, false, value );
					break;

				//

				case 'i':

					// single integer
					_gl.uniform1i( location, value );

					break;

				case 'f':

					// single float
					_gl.uniform1f( location, value );

					break;

				case 'v2':

					// single THREE.Vector2
					_gl.uniform2f( location, value.x, value.y );

					break;

				case 'v3':

					// single THREE.Vector3
					_gl.uniform3f( location, value.x, value.y, value.z );

					break;

				case 'v4':

					// single THREE.Vector4
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );

					break;

				case 'c':

					// single THREE.Color
					_gl.uniform3f( location, value.r, value.g, value.b );

					break;

				case 'iv1':

					// flat array of integers (JS or typed array)
					_gl.uniform1iv( location, value );

					break;

				case 'iv':

					// flat array of integers with 3 x N size (JS or typed array)
					_gl.uniform3iv( location, value );

					break;

				case 'fv1':

					// flat array of floats (JS or typed array)
					_gl.uniform1fv( location, value );

					break;

				case 'fv':

					// flat array of floats with 3 x N size (JS or typed array)
					_gl.uniform3fv( location, value );

					break;

				case 'v2v':

					// array of THREE.Vector2

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 2 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 2;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;

					}

					_gl.uniform2fv( location, uniform._array );

					break;

				case 'v3v':

					// array of THREE.Vector3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 3 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 3;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;

					}

					_gl.uniform3fv( location, uniform._array );

					break;

				case 'v4v':

					// array of THREE.Vector4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 4 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 4;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
						uniform._array[ offset + 3 ] = value[ i ].w;

					}

					_gl.uniform4fv( location, uniform._array );

					break;

				case 'm3':

					// single THREE.Matrix3
					_gl.uniformMatrix3fv( location, false, value.elements );

					break;

				case 'm3v':

					// array of THREE.Matrix3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 9 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

					}

					_gl.uniformMatrix3fv( location, false, uniform._array );

					break;

				case 'm4':

					// single THREE.Matrix4
					_gl.uniformMatrix4fv( location, false, value.elements );

					break;

				case 'm4v':

					// array of THREE.Matrix4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 16 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

					}

					_gl.uniformMatrix4fv( location, false, uniform._array );

					break;

				case 't':

					// single THREE.Texture (2d or cube)

					texture = value;
					textureUnit = getTextureUnit();

					_gl.uniform1i( location, textureUnit );

					if ( ! texture ) continue;

					if ( texture instanceof THREE.CubeTexture ||
					   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

						setCubeTexture( texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

						setCubeTextureDynamic( texture, textureUnit );

					} else {

						_this.setTexture( texture, textureUnit );

					}

					break;

				case 'tv':

					// array of THREE.Texture (2d)

					if ( uniform._array === undefined ) {

						uniform._array = [];

					}

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						uniform._array[ i ] = getTextureUnit();

					}

					_gl.uniform1iv( location, uniform._array );

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];

						if ( ! texture ) continue;

						_this.setTexture( texture, textureUnit );

					}

					break;

				default:

					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	}

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

	}

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	}

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	}

	function setupLights ( lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		//First, push all shadow-casting lights to the beginning of the light array
		var numShadowCasters = 0;
		for ( l = 0, ll = lights.length; l < ll; l ++ ) {
			light = lights[ l ];
			if ( light.onlyShadow ) continue;
			if ( light.castShadow ) {
				if ( l !== numShadowCasters ) {
					var tmpLight = lights[ numShadowCasters ];
					lights[ numShadowCasters ] = light;
					lights[ l ] = tmpLight;
				}
				numShadowCasters++;
			}
		}

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_direction.setFromMatrixPosition( light.matrixWorld );

				spotPositions[ spotOffset ]     = _direction.x;
				spotPositions[ spotOffset + 1 ] = _direction.y;
				spotPositions[ spotOffset + 2 ] = _direction.z;

				spotDistances[ spotLength ] = distance;

				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.normalize();

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		width *= pixelRatio;

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	}

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	}

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};

	// Textures

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		var extension;

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT is set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter is set to THREE.LinearFilter or THREE.NearestFilter. ( ' + texture.sourceFile + ' )' );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	}

	this.uploadTexture = function ( texture ) {

		if ( texture.__webglInit === undefined ) {

			texture.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			texture.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

		}

		_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		texture.image = clampToMaxSize( texture.image, _maxTextureSize );

		var image = texture.image,
		isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture instanceof THREE.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof THREE.CompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

					if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "Attempt to load unsupported compressed texture format" );

					}

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else { // regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

			}

		}

		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

		texture.needsUpdate = false;

		if ( texture.onUpdate ) texture.onUpdate();

	};

	this.setTexture = function ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );

		if ( texture.needsUpdate ) {

			_this.uploadTexture( texture );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElement( 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.log( 'THREE.WebGLRenderer:', image, 'is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height + '.' );

			return canvas;

		}

		return image;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

								if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

									_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "Attempt to load unsupported compressed texture format" );

								}

							} else {

								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	}

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	}

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	}

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	}

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_atc' );
		
		if ( extension !== undefined ) {

			if ( p === THREE.RGB_ATC_Format ) return extension.COMPRESSED_RGB_ATC_WEBGL;
			if ( p === THREE.RGBA_ATC_EXPLICIT_ALPHA_Format ) return extension.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL;
			if ( p === THREE.RGBA_ATC_INTERP_ALPHA_Format ) return extension.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === THREE.MinEquation ) return extension.MIN_EXT;
			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

	// Allocations

	function allocateBones ( object ) {

		if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow || light.visible === false ) continue;

			if ( light instanceof THREE.DirectionalLight && ( dirLights < _this.maxDirLights || _this.maxDirLights === -1 ) ) dirLights ++;
			if ( light instanceof THREE.PointLight && ( pointLights < _this.maxPointLights || _this.maxPointLights === -1 ) ) pointLights ++;
			if ( light instanceof THREE.SpotLight && ( spotLights < _this.maxSpotLights || _this.maxSpotLights === -1 ) ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight && ( hemiLights < _this.maxHemiLights || _this.maxHemiLights === -1 ) ) hemiLights ++;

		}

		return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

	}

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return _this.maxShadows === -1 ? maxShadows : Math.min( maxShadows, _this.maxShadows );

	}

	// DEPRECATED

	this.initMaterial = function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	};

	this.addPrePlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	};

	this.addPostPlugin = function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	};

	this.updateShadowMap = function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	};

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.uuid = THREE.Math.generateUUID();
	this.name = '';

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.generateMipmaps = true;

	this.shareDepthFrom = null;

	if ( window.VAPI ) {
		window.VAPI.globalEvents.trigger("veroldEngine:textureDebugger:registerTexture", this );
	}

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	setSize: function ( width, height ) {

		this.width = width;
		this.height = height;

	},

	clone: function () {

		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

		tmp.name = this.name;
		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.offset.copy( this.offset );
		tmp.repeat.copy( this.repeat );

		tmp.format = this.format;
		tmp.type = this.type;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		tmp.generateMipmaps = this.generateMipmaps;

		tmp.shareDepthFrom = this.shareDepthFrom;

		return tmp;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLExtensions = function ( gl ) {

	var extensions = {};

	this.get = function ( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		var extension;

		switch ( name ) {
		
			case 'OES_texture_float':
				extension = gl.getExtension( 'OES_texture_float' );
				break;

			case 'OES_texture_float_linear':
				extension = gl.getExtension( 'OES_texture_float_linear' );
				break;

			case 'OES_texture_half_float_linear':
				extension = gl.getExtension( 'OES_texture_half_float_linear' );
				break;

			case 'OES_standard_derivatives':
				extension = gl.getExtension( 'OES_standard_derivatives' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		if ( extension === null ) {

			console.log( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

		}

		extensions[ name ] = extension;

		return extension;

	};

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

	var programIdCount = 0;

	var generateDefines = function ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = '#define ' + d + ' ' + value;
			chunks.push( chunk );

		}

		return chunks.join( '\n' );

	};

	var cacheUniformLocations = function ( gl, program, identifiers ) {

		var uniforms = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			uniforms[ id ] = gl.getUniformLocation( program, id );

		}

		return uniforms;

	};

	var cacheAttributeLocations = function ( gl, program, identifiers ) {

		var attributes = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			attributes[ id ] = gl.getAttribLocation( program, id );

		}

		return attributes;

	};

	return function ( renderer, code, material, parameters ) {

		var _this = renderer;
		var _gl = _this.context;

		var defines = material.defines;
		var uniforms = material.__webglShader.uniforms;
		var attributes = material.attributes;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var index0AttributeName = material.index0AttributeName;

		if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0

			index0AttributeName = 'position';

		}

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var hdrOutputTypeDefine = null;
		if ( _this.hdrOutputEnabled ) {
			if ( parameters.hdrOutputEnabled !== false ) {
				var outputType = parameters.hdrOutputType ? parameters.hdrOutputType : _this.hdrOutputType;
				if ( outputType === THREE.HDRRGBM ) {
					hdrOutputTypeDefine = "HDR_OUTPUT_RGBM";
				}
				else if ( outputType === THREE.HDRRGBD ) {
					hdrOutputTypeDefine = "HDR_OUTPUT_RGBD";
				}
				else if ( outputType === THREE.HDRLOGLUV ) {
					hdrOutputTypeDefine = "HDR_OUTPUT_LOGLUV";
				}
				else if ( outputType === THREE.HDRRGBE ) {
					hdrOutputTypeDefine = "HDR_OUTPUT_RGBE";
				}
			}
		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case THREE.CubeReflectionMapping:
				case THREE.CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case THREE.EquirectangularReflectionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case THREE.SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case THREE.CubeRefractionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case THREE.MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case THREE.MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case THREE.AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		// console.log( 'building new program ' );

		//

		var customDefines = generateDefines( defines );

		//

		var program = _gl.createProgram();

		var prefix_vertex, prefix_fragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefix_vertex = '';
			prefix_fragment = '';

		} else {

			prefix_vertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				_this.gammaInput ? '#define GAMMA_INPUT' : '',
				_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',

				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

				'#define MAX_SHADOWS ' + parameters.maxShadows,

				'#define MAX_BONES ' + parameters.maxBones,

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals ? '#define USE_MORPHNORMALS' : '',
				parameters.wrapAround ? '#define WRAP_AROUND' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
				parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',


				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',
				'attribute vec2 uv2;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				''

			].join( '\n' );

			prefix_fragment = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				( parameters.bumpMap || parameters.normalMap ) ? '#extension GL_OES_standard_derivatives : enable' : '',

				customDefines,

				"#define HDR_TYPE_RGBM " + THREE.HDRRGBM,
				"#define HDR_TYPE_RGBD " + THREE.HDRRGBD,
				"#define HDR_TYPE_RGBE " + THREE.HDRRGBE,
				"#define HDR_TYPE_LOGLUV " + THREE.HDRLOGLUV,

				_this.hdrInputEnabled && parameters.hdrInputEnabled !== false ? "#define HDR_INPUT" : "",

				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

				'#define MAX_SHADOWS ' + parameters.maxShadows,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest: '',

				_this.gammaInput ? '#define GAMMA_INPUT' : '',
				_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',

				hdrOutputTypeDefine ? "#define " + hdrOutputTypeDefine : "",

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.metal ? '#define METAL' : '',
				parameters.wrapAround ? '#define WRAP_AROUND' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
				parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				''

			].join( '\n' );

		}

		var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
		var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		if ( index0AttributeName !== undefined ) {

			// Force a particular attribute to index 0.
			// because potentially expensive emulation is done by browser if attribute 0 is disabled.
			// And, color, for example is often automatically bound to index 0 so disabling it

			_gl.bindAttribLocation( program, 0, index0AttributeName );

		}

		_gl.linkProgram( program );

		if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

			console.error( 'THREE.WebGLProgram: Could not initialise shader.' );
			console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
			console.error( 'gl.getError()', _gl.getError() );

		}

		if ( _gl.getProgramInfoLog( program ) !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );
			// console.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		}

		// clean up

		_gl.deleteShader( glVertexShader );
		_gl.deleteShader( glFragmentShader );

		// cache uniform locations

		var identifiers = [

			'viewMatrix',
			'modelViewMatrix',
			'projectionMatrix',
			'normalMatrix',
			'modelMatrix',
			'cameraPosition',
			'morphTargetInfluences',
			'bindMatrix',
			'bindMatrixInverse'

		];

		if ( parameters.useVertexTexture ) {

			identifiers.push( 'boneTexture' );
			identifiers.push( 'boneTextureWidth' );
			identifiers.push( 'boneTextureHeight' );

		} else {

			identifiers.push( 'boneGlobalMatrices' );

		}

		if ( parameters.logarithmicDepthBuffer ) {

			identifiers.push('logDepthBufFC');

		}


		for ( var u in uniforms ) {

			identifiers.push( u );

		}

		this.uniforms = cacheUniformLocations( _gl, program, identifiers );

		// cache attributes locations

		identifiers = [

			'position',
			'normal',
			'uv',
			'uv2',
			'tangent',
			'color',
			'skinIndex',
			'skinWeight',
			'lineDistance'

		];

		for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( 'morphTarget' + i );

		}

		for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {

			identifiers.push( 'morphNormal' + i );

		}

		for ( var a in attributes ) {

			identifiers.push( a );

		}

		this.attributes = cacheAttributeLocations( _gl, program, identifiers );
		this.attributesKeys = Object.keys( this.attributes );

		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

	var addLineNumbers = function ( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	};

	return function ( gl, type, string ) {

		var shader = gl.createShader( type ); 

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ) );
			console.warn( addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	};

} )();

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

	var gl = renderer.context;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;
	var hasVertexTexture;

	var tempTexture, occlusionTexture;

	var init = function () {

		var vertices = new Float32Array( [
			-1, -1,  0, 0,
			 1, -1,  1, 0,
			 1,  1,  1, 1,
			-1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		gl.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

		var shader;

		if ( hasVertexTexture ) {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"uniform sampler2D occlusionMap;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if( renderType == 2 ) {",

							"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

							"vVisibility =        visibility.r / 9.0;",
							"vVisibility *= 1.0 - visibility.g / 9.0;",
							"vVisibility *=       visibility.b / 9.0;",
							"vVisibility *= 1.0 - visibility.a / 9.0;",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",
					"varying float vVisibility;",

					"void main() {",

						// pink square

						"if( renderType == 0 ) {",

							"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

						// restore

						"} else if( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * vVisibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		} else {

			shader = {

				vertexShader: [

					"uniform lowp int renderType;",

					"uniform vec3 screenPosition;",
					"uniform vec2 scale;",
					"uniform float rotation;",

					"attribute vec2 position;",
					"attribute vec2 uv;",

					"varying vec2 vUV;",

					"void main() {",

						"vUV = uv;",

						"vec2 pos = position;",

						"if( renderType == 2 ) {",

							"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
							"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

						"}",

						"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

					"}"

				].join( "\n" ),

				fragmentShader: [

					"precision mediump float;",

					"uniform lowp int renderType;",

					"uniform sampler2D map;",
					"uniform sampler2D occlusionMap;",
					"uniform float opacity;",
					"uniform vec3 color;",

					"varying vec2 vUV;",

					"void main() {",

						// pink square

						"if( renderType == 0 ) {",

							"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

						// restore

						"} else if( renderType == 1 ) {",

							"gl_FragColor = texture2D( map, vUV );",

						// flare

						"} else {",

							"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
							"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
							"visibility = ( 1.0 - visibility / 4.0 );",

							"vec4 texture = texture2D( map, vUV );",
							"texture.a *= opacity * visibility;",
							"gl_FragColor = texture;",
							"gl_FragColor.rgb *= color;",

						"}",

					"}"

				].join( "\n" )

			};

		}

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		}

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	};

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		gl.enableVertexAttribArray( attributes.vertex );
		gl.enableVertexAttribArray( attributes.uv );

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/unforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.disable( gl.CULL_FACE );
		gl.depthMask( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];
			
			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition )

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				gl.activeTexture( gl.TEXTURE1 );
				gl.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				gl.disable( gl.BLEND );
				gl.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				gl.activeTexture( gl.TEXTURE0 );
				gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				gl.disable( gl.DEPTH_TEST );

				gl.activeTexture( gl.TEXTURE1 );
				gl.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition )

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				gl.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		gl.enable( gl.CULL_FACE );
		gl.enable( gl.DEPTH_TEST );
		gl.depthMask( true );

		renderer.resetGLState();

	};

	function createProgram ( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

};

// File:src/renderers/webgl/plugins/ShadowMapPlugin.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {

	var _gl = _renderer.context;

	var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_matrixPosition = new THREE.Vector3(),
	
	_renderList = [];

	// init

	var depthShader = THREE.ShaderLib[ "depthRGBA" ];
	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

	_depthMaterial = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader
	 } );

	_depthMaterialMorph = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		morphTargets: true
	} );

	_depthMaterialSkin = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		skinning: true
	} );

	_depthMaterialMorphSkin = new THREE.ShaderMaterial( {
		uniforms: depthUniforms,
		vertexShader: depthShader.vertexShader,
		fragmentShader: depthShader.fragmentShader,
		morphTargets: true,
		skinning: true
	} );

	_depthMaterial._shadowPass = true;
	_depthMaterialMorph._shadowPass = true;
	_depthMaterialSkin._shadowPass = true;
	_depthMaterialMorphSkin._shadowPass = true;

	this.dispose = function() {
		_depthMaterial.dispose();
		_depthMaterial = null;
		_depthMaterialSkin.dispose();
		_depthMaterialSkin = null;
		_depthMaterialMorph.dispose();
		_depthMaterialMorph = null;
		_depthMaterialMorphSkin.dispose();
		_depthMaterialMorphSkin = null;
		_renderer = null;
		_renderList.splice(0, _renderList.length);
	}

	this.render = function ( scene, camera ) {

		if ( _renderer.shadowMapEnabled === false ) return;

		var i, il, j, jl, n,

		shadowMap, shadowMatrix, shadowCamera,
		program, buffer, material,
		webglObject, object, light,

		lights = [],
		k = 0,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_gl.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.FRONT );

		} else {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.setDepthTest( true );

		// preprocess lights
		// 	- skip lights that are not casting shadows
		//	- create virtual lights for cascaded shadow maps

		for ( i = 0, il = _lights.length; i < il; i ++ ) {

			light = _lights[ i ];

			if ( ! light.castShadow ) continue;

			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

					var virtualLight;

					if ( ! light.shadowCascadeArray[ n ] ) {

						virtualLight = createVirtualLight( light, n );
						virtualLight.originalCamera = camera;

						var gyro = new THREE.Gyroscope();
						gyro.position.copy( light.shadowCascadeOffset );

						gyro.add( virtualLight );
						gyro.add( virtualLight.target );

						camera.add( gyro );

						light.shadowCascadeArray[ n ] = virtualLight;

						console.log( "Created virtualLight", virtualLight );

					} else {

						virtualLight = light.shadowCascadeArray[ n ];

					}

					updateVirtualLight( light, n );

					lights[ k ] = virtualLight;
					k ++;

				}

			} else {

				lights[ k ] = light;
				k ++;

			}

		}

		// render depth map

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( ! light.shadowMap ) {

				var shadowFilter = THREE.LinearFilter;

				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

					shadowFilter = THREE.NearestFilter;

				}

				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
				light.shadowMap.name = (light.name !== '' ? light.name : "Light, " + light.id + "," ) + " shadow map";
				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

				light.shadowMatrix = new THREE.Matrix4();

			}

			if ( ! light.shadowCamera ) {

				if ( light instanceof THREE.SpotLight ) {

					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

				} else if ( light instanceof THREE.DirectionalLight ) {

					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

				} else {

					console.error( "Unsupported light type for shadow" );
					continue;

				}

				scene.add( light.shadowCamera );

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			}

			if ( light.shadowCameraVisible && ! light.cameraHelper ) {

				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
				scene.add( light.cameraHelper );

			}

			if ( light.isVirtual && light.originalCamera == camera ) {

				updateShadowCamera( camera, light );

			}

			shadowMap = light.shadowMap;
			shadowMatrix = light.shadowMatrix;
			shadowCamera = light.shadowCamera;

			//

			shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
			_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _matrixPosition );
			shadowCamera.updateMatrixWorld();

			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

			//

			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
			if ( light.shadowCameraVisible ) light.cameraHelper.update();

			// compute shadow matrix

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			// update camera matrices and frustum

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			// render shadow map

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// set object matrices & frustum culling

			_renderList.length = 0;

			projectObject( scene, scene, shadowCamera );


			// render regular objects

			var objectMaterial, useMorphing, useSkinning;

			for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

				webglObject = _renderList[ j ];

				object = webglObject.object;
				buffer = webglObject.buffer;

				// culling is overriden globally for all objects
				// while rendering depth map

				// need to deal with MeshFaceMaterial somehow
				// in that case just use the first of material.materials for now
				// (proper solution would require to break objects by materials
				//  similarly to regular rendering and then set corresponding
				//  depth materials per each chunk instead of just once per object)

				objectMaterial = getObjectMaterial( object );

				useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

				if ( object.customDepthMaterial ) {

					material = object.customDepthMaterial;

				} else if ( useSkinning ) {

					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

				} else if ( useMorphing ) {

					material = _depthMaterialMorph;

				} else {

					material = _depthMaterial;

				}

				_renderer.setMaterialFaces( objectMaterial );

				if ( buffer instanceof THREE.BufferGeometry ) {
					// START_VEROLD_MOD - materialIndex in offsets
					_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object, webglObject.offsetIndices );
					// END_VEROLD_MOD - materialIndex in offsets

				} else {

					_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );

				}

			}

			// set matrices and render immediate objects

			for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

				webglObject = _webglObjectsImmediate[ j ];
				object = webglObject.object;

				if ( object.visible && object.castShadow ) {

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

				}

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.resetGLState();

	};

	function projectObject( scene, object, shadowCamera ){

		if ( object.visible ) {

			var webglObjects = _webglObjects[ object.id ];

			if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {

				for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

					var webglObject = webglObjects[ i ];

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( webglObject );

				}

			}

			for ( var i = 0, l = object.children.length; i < l; i ++ ) {

				projectObject( scene, object.children[ i ], shadowCamera );

			}

		}

	}

	function createVirtualLight( light, cascade ) {

		var virtualLight = new THREE.DirectionalLight();

		virtualLight.isVirtual = true;

		virtualLight.onlyShadow = true;
		virtualLight.castShadow = true;

		virtualLight.shadowCameraNear = light.shadowCameraNear;
		virtualLight.shadowCameraFar = light.shadowCameraFar;

		virtualLight.shadowCameraLeft = light.shadowCameraLeft;
		virtualLight.shadowCameraRight = light.shadowCameraRight;
		virtualLight.shadowCameraBottom = light.shadowCameraBottom;
		virtualLight.shadowCameraTop = light.shadowCameraTop;

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;

		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

		virtualLight.pointsWorld = [];
		virtualLight.pointsFrustum = [];

		var pointsWorld = virtualLight.pointsWorld,
			pointsFrustum = virtualLight.pointsFrustum;

		for ( var i = 0; i < 8; i ++ ) {

			pointsWorld[ i ] = new THREE.Vector3();
			pointsFrustum[ i ] = new THREE.Vector3();

		}

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
		pointsFrustum[ 1 ].set(  1, - 1, nearZ );
		pointsFrustum[ 2 ].set( - 1,  1, nearZ );
		pointsFrustum[ 3 ].set(  1,  1, nearZ );

		pointsFrustum[ 4 ].set( - 1, - 1, farZ );
		pointsFrustum[ 5 ].set(  1, - 1, farZ );
		pointsFrustum[ 6 ].set( - 1,  1, farZ );
		pointsFrustum[ 7 ].set(  1,  1, farZ );

		return virtualLight;

	}

	// Synchronize virtual light with the original light

	function updateVirtualLight( light, cascade ) {

		var virtualLight = light.shadowCascadeArray[ cascade ];

		virtualLight.position.copy( light.position );
		virtualLight.target.position.copy( light.target.position );
		virtualLight.lookAt( virtualLight.target.position );

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;
		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		var pointsFrustum = virtualLight.pointsFrustum;

		pointsFrustum[ 0 ].z = nearZ;
		pointsFrustum[ 1 ].z = nearZ;
		pointsFrustum[ 2 ].z = nearZ;
		pointsFrustum[ 3 ].z = nearZ;

		pointsFrustum[ 4 ].z = farZ;
		pointsFrustum[ 5 ].z = farZ;
		pointsFrustum[ 6 ].z = farZ;
		pointsFrustum[ 7 ].z = farZ;

	}

	// Fit shadow camera's ortho frustum to camera frustum

	function updateShadowCamera( camera, light ) {

		var shadowCamera = light.shadowCamera,
			pointsFrustum = light.pointsFrustum,
			pointsWorld = light.pointsWorld;

		_min.set( Infinity, Infinity, Infinity );
		_max.set( - Infinity, - Infinity, - Infinity );

		for ( var i = 0; i < 8; i ++ ) {

			var p = pointsWorld[ i ];

			p.copy( pointsFrustum[ i ] );
			p.unproject( camera );

			p.applyMatrix4( shadowCamera.matrixWorldInverse );

			if ( p.x < _min.x ) _min.x = p.x;
			if ( p.x > _max.x ) _max.x = p.x;

			if ( p.y < _min.y ) _min.y = p.y;
			if ( p.y > _max.y ) _max.y = p.y;

			if ( p.z < _min.z ) _min.z = p.z;
			if ( p.z > _max.z ) _max.z = p.z;

		}

		shadowCamera.left = _min.x;
		shadowCamera.right = _max.x;
		shadowCamera.top = _max.y;
		shadowCamera.bottom = _min.y;

		// can't really fit near/far
		//shadowCamera.near = _min.z;
		//shadowCamera.far = _max.z;

		shadowCamera.updateProjectionMatrix();

	}

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use for shadow maps

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

	var gl = renderer.context;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;

	// decompose matrixWorld

	var spritePosition = new THREE.Vector3();
	var spriteRotation = new THREE.Quaternion();
	var spriteScale = new THREE.Vector3();

	var init = function () {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new THREE.Texture( canvas );
		texture.needsUpdate = true;

	};

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		gl.enableVertexAttribArray( attributes.position );
		gl.enableVertexAttribArray( attributes.uv );

		gl.disable( gl.CULL_FACE );
		gl.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		gl.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			renderer.setDepthTest( material.depthTest );
			renderer.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				renderer.setTexture( material.map, 0 );

			} else {

				renderer.setTexture( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		gl.enable( gl.CULL_FACE );

		renderer.resetGLState();

	};

	function createProgram () {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	};

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

		var matrix;

		if ( geometry2 instanceof THREE.Mesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.Texture( undefined, mapping );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		}, undefined, function ( event ) {

			if ( onError ) onError( event );

		} );

		texture.sourceFile = url;

		return texture;

	},

	loadTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.CubeTexture( images, mapping );

		// no flipping needed for cube textures

		texture.flipY = false;

		var loaded = 0;

		var loadTexture = function ( i ) {

			loader.load( array[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded += 1;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			} );

		}

		for ( var i = 0, il = array.length; i < il; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		depth = depth | 1;

		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 0; y < height; y ++ ) {

				var ly = y - 1 < 0 ? 0 : y - 1;
				var uy = y + 1 > height - 1 ? height - 1 : y + 1;
				var lx = x - 1 < 0 ? 0 : x - 1;
				var ux = x + 1 > width - 1 ? width - 1 : x + 1;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	},

	generateDataTexture: function ( width, height, color ) {

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			data[ i * 3 ] 	   = r;
			data[ i * 3 + 1 ] = g;
			data[ i * 3 + 2 ] = b;

		}

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true;

		return texture;

	}

};
// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Object3D();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

	faces: {},

	// Just for now. face[weight][style]

	face: 'helvetiker',
	weight: 'normal',
	style: 'normal',
	size: 150,
	divisions: 10,

	getFace: function () {

		try {

			return this.faces[ this.face ][ this.weight ][ this.style ];

		} catch (e) {

			throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

		};

	},

	loadFace: function ( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText: function ( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;

			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths: fontPaths, offset: width };

	},




	extractGlyphPoints: function ( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( ! glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch ( action ) {

				case 'm':

					// Move To

					x = outline[ i ++ ] * scaleX + offset;
					y = outline[ i ++ ] * scaleY;

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i ++ ] * scaleX + offset;
					y = outline[ i ++ ] * scaleY;
					path.lineTo( x,y );
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i ++ ] * scaleX + offset;
					cpy  = outline[ i ++ ] * scaleY;
					cpx1 = outline[ i ++ ] * scaleX + offset;
					cpy1 = outline[ i ++ ] * scaleY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i ++ ] *  scaleX + offset;
					cpy  = outline[ i ++ ] *  scaleY;
					cpx1 = outline[ i ++ ] *  scaleX + offset;
					cpy1 = outline[ i ++ ] *  scaleY;
					cpx2 = outline[ i ++ ] *  scaleX + offset;
					cpy2 = outline[ i ++ ] *  scaleY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha * scale, path:path };
	}

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

	// Parameters 

	parameters = parameters || {};

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

	var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
	var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
	var style = parameters.style !== undefined ? parameters.style : 'normal';

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function ( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function ( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v ++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for ( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count -- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				//throw ( "Warning, unable to triangulate polygon!" );
				//return null;
				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				console.log( 'Warning, unable to triangulate polygon!' );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for ( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv --;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

		var aX, aY, bX, bY, cX, cY;
		var apx, apy, bpx, bpy, cpx, cpy;
		var cCROSSap, bCROSScp, aCROSSbp;

		aX = cx - bx;  aY = cy - by;
		bX = ax - cx;  bY = ay - cy;
		cX = bx - ax;  cY = by - ay;

		for ( p = 0; p < n; p ++ ) {

			px = contour[ verts[ p ] ].x
			py = contour[ verts[ p ] ].y

			if ( ( ( px === ax ) && ( py === ay ) ) ||
				 ( ( px === bx ) && ( py === by ) ) ||
				 ( ( px === cx ) && ( py === cy ) ) )	continue;

			apx = px - ax;  apy = py - ay;
			bpx = px - bx;  bpy = py - by;
			cpx = px - cx;  cpy = py - cy;

			// see if p is inside triangle abc

			aCROSSbp = aX * bpy - aY * bpx;
			cCROSSap = cX * apy - cY * apx;
			bCROSScp = bX * cpy - bY * cpx;

			if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

		}

		return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
THREE.typeface_js = self._typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

	THREE.Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;
	this.source = this.context.createBufferSource();

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function ( file ) {

	var scope = this;

	var request = new XMLHttpRequest();
	request.open( 'GET', file, true );
	request.responseType = 'arraybuffer';
	request.onload = function ( e ) {

		scope.context.decodeAudioData( this.response, function ( buffer ) {

			scope.source.buffer = buffer;
			scope.source.connect( scope.panner );
			scope.source.start( 0 );

		} );

	};
	request.send();

	return this;

};

THREE.Audio.prototype.setLoop = function ( value ) {

	this.source.loop = value;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

	this.panner.refDistance = value;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

	this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();

	return function ( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		position.setFromMatrixPosition( this.matrixWorld );

		this.panner.setPosition( position.x, position.y, position.z );

	};

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

	THREE.Object3D.call( this );

	this.type = 'AudioListener';

	this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

	var position = new THREE.Vector3();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3();

	var orientation = new THREE.Vector3();
	var velocity = new THREE.Vector3();

	var positionPrev = new THREE.Vector3();

	return function ( force ) {

		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

		var listener = this.context.listener;
		var up = this.up;

		this.matrixWorld.decompose( position, quaternion, scale );

		orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );
		velocity.subVectors( position, positionPrev );

		listener.setPosition( position.x, position.y, position.z );
		listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
		listener.setVelocity( velocity.x, velocity.y, velocity.z );

		positionPrev.copy( position );

	};

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	console.log( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( ! divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	}

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( ! divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	}

	return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

	if ( this.cacheArcLengths
		&& ( this.cacheArcLengths.length == divisions + 1 )
		&& ! this.needsUpdate) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	this.needsUpdate = false;

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
	this.needsUpdate = true;
	this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

		comparison = arcLengths[ i ] - targetArcLength;

		if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );

	var vec = pt2.clone().sub(pt1);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return - 3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3  t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.constructor = constructor;
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];
	
	this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[0].getPoint(0);
	var endPoint = this.curves[this.curves.length-1].getPoint(1);
	
	if (! startPoint.equals(endPoint)) {
		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
	}
	
};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY, maxZ;
	var minX, minY, minZ;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	var v3 = points[0] instanceof THREE.Vector3;

	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < minY ) minY = p.y;

		if ( v3 ) {

			if ( p.z > maxZ ) maxZ = p.z;
			else if ( p.z < minZ ) minZ = p.z;

		}

		sum.add( p );

	}

	var ret = {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY

	};

	if ( v3 ) {

		ret.maxZ = maxZ;
		ret.minZ = minZ;

	}

	return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < points.length; i ++ ) {

		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

	}

	return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( ! bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( ! bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		xNorm = oldX / bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getTangent( xNorm );
		normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};


// File:src/extras/core/Gyroscope.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

	THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );
THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;

THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

	var translationObject = new THREE.Vector3();
	var quaternionObject = new THREE.Quaternion();
	var scaleObject = new THREE.Vector3();

	var translationWorld = new THREE.Vector3();
	var quaternionWorld = new THREE.Quaternion();
	var scaleWorld = new THREE.Vector3();

	return function ( force ) {

		this.matrixAutoUpdate && this.updateMatrix();

		// update matrixWorld

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent ) {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
				this.matrix.decompose( translationObject, quaternionObject, scaleObject );

				this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


			} else {

				this.matrixWorld.copy( this.matrix );

			}


			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	};
	
}() );

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc',								// Circle
	ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
											   aCP2x, aCP2y,
											   aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc(aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {
	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
		aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );
	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	var lastPoint = curve.getPoint(1);
	args.push(lastPoint.x);
	args.push(lastPoint.y);

	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	if (this.useSpacedPoints) {
		console.log('tata');
		return this.getSpacedPoints( divisions, closedPath );
	}

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !! args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;
		  
		case THREE.PathActions.ELLIPSE:

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !! args[ 6 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1];
	var EPSILON = 0.0000000001;
	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
			 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
		points.splice( points.length - 1, 1);
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

//
// Breaks path into shapes
//
//	Assumptions (if parameter isCCW==true the opposite holds):
//	- solid shapes are defined clockwise (CW)
//	- holes are defined counterclockwise (CCW)
//
//	If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

	function extractSubpaths( inActions ) {

		var i, il, item, action, args;

		var subPaths = [], lastPath = new THREE.Path();

		for ( i = 0, il = inActions.length; i < il; i ++ ) {

			item = inActions[ i ];

			args = item.args;
			action = item.action;

			if ( action == THREE.PathActions.MOVE_TO ) {

				if ( lastPath.actions.length != 0 ) {

					subPaths.push( lastPath );
					lastPath = new THREE.Path();

				}

			}

			lastPath[ action ].apply( lastPath, args );

		}

		if ( lastPath.actions.length != 0 ) {

			subPaths.push( lastPath );

		}

		// console.log(subPaths);

		return	subPaths;
	}

	function toShapesNoHoles( inSubpaths ) {

		var shapes = [];

		for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

			var tmpPath = inSubpaths[ i ];

			var tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;

			shapes.push( tmpShape );
		}

		//console.log("shape", shapes);

		return shapes;
	};

	function isPointInsidePolygon( inPt, inPolygon ) {
		var EPSILON = 0.0000000001;

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
				if ( edgeDy < 0 ) {
					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y == edgeLowPt.y ) {
					if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!
				} else {
					var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
					if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = ! inside;		// true intersection left of inPt
				}
			} else {		// parallel or colinear
				if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
				// egde lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;
			}
		}

		return	inside;
	}


	var subPaths = extractSubpaths( this.actions );
	if ( subPaths.length == 0 ) return [];

	if ( noHoles === true )	return	toShapesNoHoles( subPaths );


	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length == 1) {

		tmpPath = subPaths[0];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? ! holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);
	
	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[mainIdx] = undefined;
	newShapeHoles[mainIdx] = [];

	var i, il;

	for ( i = 0, il = subPaths.length; i < il; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = THREE.Shape.Utils.isClockWise( tmpPoints );
		solid = isCCW ? ! solid : solid;

		if ( solid ) {

			if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx ++;

			newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
			newShapes[mainIdx].s.actions = tmpPath.actions;
			newShapes[mainIdx].s.curves = tmpPath.curves;
			
			if ( holesFirst )	mainIdx ++;
			newShapeHoles[mainIdx] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

			//console.log('ccw', i);

		}

	}

	// only Holes? -> probably all Shapes with wrong orientation
	if ( ! newShapes[0] )	return	toShapesNoHoles( subPaths );


	if ( newShapes.length > 1 ) {
		var ambigious = false;
		var toChange = [];

		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
			betterShapeHoles[sIdx] = [];
		}
		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
			var sh = newShapes[sIdx];
			var sho = newShapeHoles[sIdx];
			for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
				var ho = sho[hIdx];
				var hole_unassigned = true;
				for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
					if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
						if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {
							hole_unassigned = false;
							betterShapeHoles[s2Idx].push( ho );
						} else {
							ambigious = true;
						}
					}
				}
				if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
			}
		}
		// console.log("ambigious: ", ambigious);
		if ( toChange.length > 0 ) {
			// console.log("to change: ", toChange);
			if (! ambigious)	newShapeHoles = betterShapeHoles;
		}
	}

	var tmpHoles, j, jl;
	for ( i = 0, il = newShapes.length; i < il; i ++ ) {
		tmpShape = newShapes[i].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[i];
		for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
			tmpShape.holes.push( tmpHoles[j].h );
		}
	}

	//console.log("shape", shapes);

	return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	var geometry = new THREE.ShapeGeometry( this, options );
	return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	if (this.useSpacedPoints) {
		return this.extractAllSpacedPoints(divisions);
	}

	return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
			// inOtherPt needs to be colinear to the inSegment
			if ( inSegPt1.x != inSegPt2.x ) {
				if ( inSegPt1.x < inSegPt2.x ) {
					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
				} else {
					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
				}
			} else {
				if ( inSegPt1.y < inSegPt2.y ) {
					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
				} else {
					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
				}
			}
		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
			var EPSILON = 0.0000000001;

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs(limit) > EPSILON ) {			// not parallel

				var perpSeg2;
				if ( limit > 0 ) {
					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
				} else {
					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 == 0 ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt1 ];
				}
				if ( perpSeg2 == limit ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt2 ];
				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 == 0 )		return  [ inSeg2Pt1 ];
				if ( perpSeg1 == limit )	return  [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {		// parallel or colinear
				if ( ( perpSeg1 != 0 ) ||
					 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
				var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {
					if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
						 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
					return  [ inSeg1Pt1 ];                 					// they are the same point
				}
				// segment#1  is a single point
				if ( seg1Pt ) {
					if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return  [ inSeg1Pt1 ];
				}
				// segment#2  is a single point
				if ( seg2Pt ) {
					if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return  [ inSeg2Pt1 ];
				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if (seg1dx != 0) {		// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
					}
				} else {				// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
					}
				}
				if ( seg1minVal <= seg2minVal ) {
					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal == seg2minVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];
				} else {
					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal == seg2maxVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];
				}
			}
		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
			// The order of legs is important

			var EPSILON = 0.0000000001;

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {				// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
				} else {								// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
				}
			} else {										// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );
			}
		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;
				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;
				}

				return	true;
			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {
				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
					nextIdx = sIdx+1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
					if ( intersection.length > 0 )		return	true;
				}

				return	false;
			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {
				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
					chkHole = holes[indepHoles[ihIdx]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
						nextIdx = hIdx+1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}
				}
				return	false;
			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {
				counter --;
				if ( counter < 0 ) {
					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;
				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {
						holeIdx = indepHoles[h];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[cutKey] !== undefined )			continue;

						hole = holes[holeIdx];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
							holePt = hole[ h2 ];
							if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice(h,1);

							tmpShape1 = shape.slice( 0, shapeIndex+1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex+1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[cutKey] = true;			// remember failure
					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found
				}
			}

			return shape; 			/* shape with no holes */
		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[h] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};


// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub(this.v1);
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var vector = new THREE.Vector2();

	vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var vector = new THREE.Vector2();

	vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]
	var point1 = points[ intPoint ]
	var point2 = points[ intPoint > points.length - 2 ? points.length -1 : intPoint + 1 ]
	var point3 = points[ intPoint > points.length - 3 ? points.length -1 : intPoint + 2 ]

	var vector = new THREE.Vector2();

	vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
	vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

	return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	var angle;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}
	
	var vector = new THREE.Vector2();

	vector.x = this.aX + this.xRadius * Math.cos( angle );
	vector.y = this.aY + this.yRadius * Math.sin( angle );

	return vector;

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return vector;

	}

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return vector;

	}

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var vector = new THREE.Vector3();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

		return vector;

	}

);

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

		var point0 = points[ ( intPoint - 1 ) % points.length ];
		var point1 = points[ ( intPoint     ) % points.length ];
		var point2 = points[ ( intPoint + 1 ) % points.length ];
		var point3 = points[ ( intPoint + 2 ) % points.length ];

		var vector = new THREE.Vector3();

		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

		return vector;

	}

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

	LINEAR: 0,
	CATMULLROM: 1,
	CATMULLROM_FORWARD: 2,

	//

	add: function () { console.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
	get: function () { console.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
	remove: function () { console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

	//

	animations: [],

	init: function ( data ) {

		if ( data.initialized === true ) return data;

		// loop through all keys

		for ( var h = 0; h < data.hierarchy.length; h ++ ) {

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

					 data.hierarchy[ h ].keys[ k ].time = 0;

				}

				// create quaternions

				if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

				}

			}

			// prepare morph target keys

			if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = - 1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for ( var morphTargetName in usedMorphTargets ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}

		data.initialized = true;

		return data;

	},

	parse: function ( root ) {

		var parseRecurseHierarchy = function ( root, hierarchy ) {

			hierarchy.push( root );

			for ( var c = 0; c < root.children.length; c ++ )
				parseRecurseHierarchy( root.children[ c ], hierarchy );

		};

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

				hierarchy.push( root.skeleton.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	},

	play: function ( animation ) {

		if ( this.animations.indexOf( animation ) === - 1 ) {

			this.animations.push( animation );

		}

	},

	stop: function ( animation ) {

		var index = this.animations.indexOf( animation );

		if ( index !== - 1 ) {

			this.animations.splice( index, 1 );

		}

	},

	update: function ( deltaTimeMS ) {

		for ( var i = 0; i < this.animations.length; i ++ ) {

			this.animations[ i ].resetBlendWeights( );

		}

		for ( var i = 0; i < this.animations.length; i ++ ) {

			this.animations[ i ].update( deltaTimeMS );

		}

	}

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, data ) {

	this.root = root;
	this.data = THREE.AnimationHandler.init( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );

	this.currentTime = 0;
	this.timeScale = 1;

	this.isPlaying = false;
	this.loop = true;
	this.weight = 0;

	this.interpolationType = THREE.AnimationHandler.LINEAR;

};


THREE.Animation.prototype.keyTypes = [ "pos", "rot", "scl" ];


THREE.Animation.prototype.play = function ( startTime, weight ) {

	this.currentTime = startTime !== undefined ? startTime : 0;
	this.weight = weight !== undefined ? weight: 1;

	this.isPlaying = true;

	this.reset();

	THREE.AnimationHandler.play( this );

};


THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;

	THREE.AnimationHandler.stop( this );

};

THREE.Animation.prototype.reset = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		if ( object.animationCache === undefined ) {

			object.animationCache = {
				animations: {},
				blending: {
					positionWeight: 0.0,
					quaternionWeight: 0.0,
					scaleWeight: 0.0
				}
			};
		}

		if ( object.animationCache.animations[this.data.name] === undefined ) {

			object.animationCache.animations[this.data.name] = {};
			object.animationCache.animations[this.data.name].prevKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.animations[this.data.name].nextKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.animations[this.data.name].originalMatrix = object.matrix;

		}

		var animationCache = object.animationCache.animations[this.data.name];

		// Get keys to match our current time

		for ( var t = 0; t < 3; t ++ ) {

			var type = this.keyTypes[ t ];

			var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
			var nextKey = this.getNextKeyWith( type, h, 1 );

			// START_VEROLD_MOD - robust keyframes
			if ( !prevKey || !prevKey[ type ] || !nextKey || !nextKey[ type ] ) {
				continue;
			}
			// END_VEROLD_MOD - robust keyframes

			while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

				prevKey = nextKey;
				nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

			}

			animationCache.prevKey[ type ] = prevKey;
			animationCache.nextKey[ type ] = nextKey;

		}

	}

};

THREE.Animation.prototype.resetBlendWeights = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		if ( object.animationCache !== undefined ) {

			object.animationCache.blending.positionWeight = 0.0;
			object.animationCache.blending.quaternionWeight = 0.0;
			object.animationCache.blending.scaleWeight = 0.0;

		}

	}

};

THREE.Animation.prototype.update = (function(){

	var points = [];
	var target = new THREE.Vector3();
	var newVector = new THREE.Vector3();
	var newQuat = new THREE.Quaternion();

	// Catmull-Rom spline

	var interpolateCatmullRom = function ( points, scale ) {

		var c = [], v3 = [],
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;

		point = ( points.length - 1 ) * scale;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

		pa = points[ c[ 0 ] ];
		pb = points[ c[ 1 ] ];
		pc = points[ c[ 2 ] ];
		pd = points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
		v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
		v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

		return v3;

	};

	var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

	return function ( delta ) {

		if ( this.isPlaying === false ) return;

		this.currentTime += delta * this.timeScale;

		if ( this.weight === 0 )
			return;

		//

		var duration = this.data.length;

		if ( this.currentTime > duration || this.currentTime < 0 ) {

			if ( this.loop ) {

				this.currentTime %= duration;

				if ( this.currentTime < 0 )
					this.currentTime += duration;

				this.reset();

			} else {

				this.stop();

			}

		}

		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

			var object = this.hierarchy[ h ];
			var animationCache = object.animationCache.animations[this.data.name];
			var blending = object.animationCache.blending;

			// loop through pos/rot/scl

			for ( var t = 0; t < 3; t ++ ) {

				// get keys

				var type    = this.keyTypes[ t ];
				var prevKey = animationCache.prevKey[ type ];
				var nextKey = animationCache.nextKey[ type ];

				// START_VEROLD_MOD - robust keyframes
				if ( !prevKey || !prevKey[ type ] || !nextKey || !nextKey[ type ] ) {

					continue;

				}
				// END_VEROLD_MOD - robust keyframes
				if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
					( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

					prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					nextKey = this.getNextKeyWith( type, h, 1 );

					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					}

					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;

				}

				var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

				var prevXYZ = prevKey[ type ];
				var nextXYZ = nextKey[ type ];

				if ( scale < 0 ) scale = 0;
				if ( scale > 1 ) scale = 1;

				// interpolate

				if ( type === "pos" ) {

					if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

						newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

						// blend
						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
						object.position.lerp( newVector, proportionalWeight );
						blending.positionWeight += this.weight;

					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
								this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

						points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
						points[ 1 ] = prevXYZ;
						points[ 2 ] = nextXYZ;
						points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

						scale = scale * 0.33 + 0.33;

						var currentPoint = interpolateCatmullRom( points, scale );
						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
						blending.positionWeight += this.weight;

						// blend

						var vector = object.position;
						
						vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
						vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
						vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

						if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

							var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

							target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
							target.sub( vector );
							target.y = 0;
							target.normalize();

							var angle = Math.atan2( target.x, target.z );
							object.rotation.set( 0, angle, 0 );

						}

					}

				} else if ( type === "rot" ) {

					THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

					// Avoid paying the cost of an additional slerp if we don't have to
					if ( blending.quaternionWeight === 0 ) {

						object.quaternion.copy(newQuat);
						blending.quaternionWeight = this.weight;

					} else {

						var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
						THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
						blending.quaternionWeight += this.weight;

					}

				} else if ( type === "scl" ) {

					newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

					var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
					object.scale.lerp( newVector, proportionalWeight );
					blending.scaleWeight += this.weight;

				}

			}

		}

		return true;

	};

})();





// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	// START_VEROLD_MOD - robust keyframes
	if ( keys !== undefined && keys.length > 0 ) {
	// END_VEROLD_MOD - robust keyframes
		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
			 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

			key = key < keys.length - 1 ? key : keys.length - 1;

		} else {

			key = key % keys.length;

		}

		for ( ; key < keys.length; key ++ ) {

			if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
				 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				key = key < keys.length - 1 ? key : keys.length - 1;

			} else {
		
				key = key % keys.length;
		
			}
		
			// for ( ; key < keys.length; key++ ) {
		
				if ( keys[ key ][ type ] !== undefined ) {
		
					return keys[ key ];
		
				}
		
			// }
		}
		return this.data.hierarchy[ h ].keys[ 0 ];

	// START_VEROLD_MOD - robust keyframes
	}

	return null;
	// END_VEROLD_MOD - robust keyframes
};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	// START_VEROLD_MOD - robust keyframes
	if ( keys !== undefined && keys.length > 0 ) {
	// END_VEROLD_MOD - robust keyframes

		if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
			this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
			key = key > 0 ? key : 0;
	
		} else {
	
			key = key >= 0 ? key : key + keys.length;
	
		}
	
	
		for ( ; key >= 0; key -- ) {
	
			if ( keys[ key ][ type ] !== undefined ) {
	
				return keys[ key ];
	
			}
	
		}
	
		return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

	// START_VEROLD_MOD - robust keyframes
	}

	return null;
	// END_VEROLD_MOD - robust keyframes
};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( data ) {

	this.root = data.node;
	this.data = THREE.AnimationHandler.init( data );
	this.hierarchy = THREE.AnimationHandler.parse( this.root );
	this.currentTime = 0;
	this.timeScale = 0.001;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	// initialize to first keyframes

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var keys = this.data.hierarchy[h].keys,
			sids = this.data.hierarchy[h].sids,
			obj = this.hierarchy[h];

		if ( keys.length && sids ) {

			for ( var s = 0; s < sids.length; s ++ ) {

				var sid = sids[ s ],
					next = this.getNextKeyWith( sid, h, 0 );

				if ( next ) {

					next.apply( sid );

				}

			}

			obj.matrixAutoUpdate = false;
			this.data.hierarchy[h].node.updateMatrix();
			obj.matrixWorldNeedsUpdate = true;

		}

	}

};


THREE.KeyFrameAnimation.prototype.play = function ( startTime ) {

	this.currentTime = startTime !== undefined ? startTime : 0;

	if ( this.isPlaying === false ) {

		this.isPlaying = true;

		// reset key cache

		var h, hl = this.hierarchy.length,
			object,
			node;

		for ( h = 0; h < hl; h ++ ) {

			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];

			if ( node.animationCache === undefined ) {

				node.animationCache = {};
				node.animationCache.prevKey = null;
				node.animationCache.nextKey = null;
				node.animationCache.originalMatrix = object.matrix;

			}

			var keys = this.data.hierarchy[h].keys;

			if (keys.length) {

				node.animationCache.prevKey = keys[ 0 ];
				node.animationCache.nextKey = keys[ 1 ];

				this.startTime = Math.min( keys[0].time, this.startTime );
				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

			}

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.play( this );

};


THREE.KeyFrameAnimation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;

	THREE.AnimationHandler.stop( this );

	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {
		
		var obj = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		if ( node.animationCache !== undefined ) {

			var original = node.animationCache.originalMatrix;

			original.copy( obj.matrix );
			obj.matrix = original;

			delete node.animationCache;

		}

	}

};


// Update

THREE.KeyFrameAnimation.prototype.update = function ( delta ) {

	if ( this.isPlaying === false ) return;

	this.currentTime += delta * this.timeScale;

	//

	var duration = this.data.length;

	if ( this.loop === true && this.currentTime > duration ) {

		this.currentTime %= duration;

	}

	this.currentTime = Math.min( this.currentTime, duration );

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		var keys = node.keys,
			animationCache = node.animationCache;


		if ( keys.length ) {

			var prevKey = animationCache.prevKey;
			var nextKey = animationCache.nextKey;

			if ( nextKey.time <= this.currentTime ) {

				while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

					prevKey = nextKey;
					nextKey = keys[ prevKey.index + 1 ];

				}

				animationCache.prevKey = prevKey;
				animationCache.nextKey = nextKey;

			}

			if ( nextKey.time >= this.currentTime ) {

				prevKey.interpolate( nextKey, this.currentTime );

			} else {

				prevKey.interpolate( nextKey, nextKey.time );

			}

			this.data.hierarchy[ h ].node.updateMatrix();
			object.matrixWorldNeedsUpdate = true;

		}

	}

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key % keys.length;

	for ( ; key < keys.length; key ++ ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key >= 0 ? key : key + keys.length;

	for ( ; key >= 0; key -- ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ keys.length - 1 ];

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 * @author willy-vvu / http://willy-vvu.github.io
 */

THREE.MorphAnimation = function ( mesh ) {

	this.mesh = mesh;
	this.frames = mesh.morphTargetInfluences.length;
	this.currentTime = 0;
	this.duration = 1000;
	this.loop = true;
	this.lastFrame = 0;
	this.currentFrame = 0;

	this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

	constructor: THREE.MorphAnimation,

	play: function () {

		this.isPlaying = true;

	},

	pause: function () {

		this.isPlaying = false;

	},

	update: function ( delta ) {

		if ( this.isPlaying === false ) return;

		this.currentTime += delta;

		if ( this.loop === true && this.currentTime > this.duration ) {

			this.currentTime %= this.duration;

		}

		this.currentTime = Math.min( this.currentTime, this.duration );

		var interpolation = this.duration / this.frames;
		var frame = Math.floor( this.currentTime / interpolation );

		if ( frame != this.currentFrame ) {

			this.mesh.morphTargetInfluences[ this.lastFrame ] = 0;
			this.mesh.morphTargetInfluences[ this.currentFrame ] = 1;
			this.mesh.morphTargetInfluences[ frame ] = 0;

			this.lastFrame = this.currentFrame;
			this.currentFrame = frame;

		}

		this.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
		this.mesh.morphTargetInfluences[ this.lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];

	}

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var scope = this;

	var width_half = width / 2;
	var height_half = height / 2;
	var depth_half = depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

  radius = radius || 50;
  segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var i, uvs = [],
	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

	this.vertices.push(center);
	uvs.push( centerUV );

	for ( i = 0; i <= segments; i ++ ) {

		var vertex = new THREE.Vector3();
		var segment = thetaStart + i / segments * thetaLength;

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		this.vertices.push( vertex );
		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 1; i <= segments; i ++ ) {

		this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

  }

	this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

// File:src/extras/geometries/CubeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	console.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );
	return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );

 };

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = radialSegments || 8;
	heightSegments = heightSegments || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ heightSegments ][ x + 1 ];
			var v2 = vertices[ heightSegments ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
			var uv2 = uvs[ heightSegments ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {
		shapes = [];
		return;
	}

	THREE.Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( ! vec ) console.log( "die" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	// Find directions for point movement

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( inPt, inPrev, inNext ) {

		var EPSILON = 0.0000000001;
		
		// computes for inPt the corresponding point inPt' on a new contour
		//   shiftet by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.
		
		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
		
		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
		
		// check for colinear edges
		var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
		if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
			
			// length of vectors for normalizing
	
			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
			
			// shift adjacent points by unit vectors to the left
	
			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
			
			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
			// scaling factor for v_prev to intersection point
	
			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			// vector from inPt to intersection point
	
			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
			if ( v_trans_lensq <= 2 ) {
				return	new THREE.Vector2( v_trans_x, v_trans_y );
			} else {
				shrink_by = Math.sqrt( v_trans_lensq / 2 );
			}
			
		} else {		// handle special case of colinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > EPSILON ) {
				if ( v_next_x > EPSILON ) { direction_eq = true; }
			} else {
				if ( v_prev_x < - EPSILON ) {
					if ( v_next_x < - EPSILON ) { direction_eq = true; }
				} else {
					if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }
				}
			}

			if ( direction_eq ) {
				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );
			} else {
				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );
			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

			position2.copy( extrudePts[0] ).add(normal).add(binormal);

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[s] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0 ; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}
		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( --i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}
		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		// normal, color, material
		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

 		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new THREE.Vector2( a.x, a.y ),
			new THREE.Vector2( b.x, b.y ),
			new THREE.Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {
			return [
				new THREE.Vector2( a.x, 1 - a.z ),
				new THREE.Vector2( b.x, 1 - b.z ),
				new THREE.Vector2( c.x, 1 - c.z ),
				new THREE.Vector2( d.x, 1 - d.z )
			];
		} else {
			return [
				new THREE.Vector2( a.y, 1 - a.z ),
				new THREE.Vector2( b.y, 1 - b.z ),
				new THREE.Vector2( c.y, 1 - c.z ),
				new THREE.Vector2( d.y, 1 - d.z )
			];
		}
	}
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( shapes instanceof Array === false ) shapes = [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	//

	var i, l, hole, s;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];

			if ( THREE.Shape.Utils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

	// Vertices

	var contour = vertices;

	for ( i = 0, l = holes.length; i < l; i ++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	var cont, clen = contour.length;

	for ( i = 0; i < vlen; i ++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i ++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

	}

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

	THREE.Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments, uvMult, uvOffset ) {

	THREE.BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = widthSegments || 1;
	var gridY = heightSegments || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	
	var uvy = uvOffset ? Math.floor(gridY1 * -uvOffset ) : gridY;
	uvMult = uvMult ? uvMult : 1.0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;
		var uvx = uvOffset ? Math.floor(gridX1 * uvOffset ) : 0;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset     ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2     ] = (uvx * uvMult / gridX );
			uvs[ offset2 + 1 ] = (uvy * uvMult / gridY );

			offset += 3;
			offset2 += 2;
			uvx++;
		}
		uvy--;
	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset     ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

		for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

		var thetaSegment = i * (thetaSegments + 1);

		for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment;
			var v2 = segment + thetaSegments + 1;
			var v3 = segment + thetaSegments + 2;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			v1 = segment;
			v2 = segment + thetaSegments + 2;
			v3 = segment + 1;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

		}
	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;


// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength 
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;
			var v = y / heightSegments;

			var vertex = new THREE.Vector3();
			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < heightSegments; y ++ ) {

		for ( x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].clone().normalize();
			var n2 = this.vertices[ v2 ].clone().normalize();
			var n3 = this.vertices[ v3 ].clone().normalize();
			var n4 = this.vertices[ v4 ].clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

				uv1.x = ( uv1.x + uv2.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

				uv3.x = ( uv3.x + uv4.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

	}

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

	parameters = parameters || {};

	var textShapes = THREE.FontUtils.generateShapes( text, parameters );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

	this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 8;
	tubularSegments = tubularSegments || 6;
	arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= radialSegments; j ++ ) {

		for ( var i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}

	for ( var j = 1; j <= radialSegments; j ++ ) {

		for ( var i = 1; i <= tubularSegments; i ++ ) {

			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		p: p,
		q: q,
		heightScale: heightScale
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = radialSegments || 64;
	tubularSegments = tubularSegments || 8;
	p = p || 2;
	q = q || 3;
	heightScale = heightScale || 1;
	
	var grid = new Array( radialSegments );
	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < radialSegments; ++ i ) {

		grid[ i ] = new Array( tubularSegments );
		var u = i / radialSegments * 2 * p * Math.PI;
		var p1 = getPos( u, q, p, radius, heightScale );
		var p2 = getPos( u + 0.01, q, p, radius, heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var v = j / tubularSegments * 2 * Math.PI;
			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			grid[ i ][ j ] = this.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < radialSegments; ++ i ) {

		for ( var j = 0; j < tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % radialSegments;
			var jp = ( j + 1 ) % tubularSegments;

			var a = grid[ i ][ j ];
			var b = grid[ ip ][ j ];
			var c = grid[ ip ][ jp ];
			var d = grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

	THREE.Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		segments: segments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	segments = segments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;
	taper = taper || THREE.TubeGeometry.NoTaper;

	var grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = segments + 1,

		x, y, z,
		tx, ty, tz,
		u, v, r,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}

	// consruct the grid

	for ( i = 0; i < numpoints; i ++ ) {

		grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		r = radius * taper( u );

		for ( j = 0; j < radialSegments; j ++ ) {

			v = j / radialSegments * 2 * Math.PI;

			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = r * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}
	}


	// construct the mesh

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < radialSegments; j ++ ) {

			ip = ( closed ) ? (i + 1) % segments : i + 1;
			jp = (j + 1) % radialSegments;

			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = grid[ ip ][ j ];
			c = grid[ ip ][ jp ];
			d = grid[ i ][ jp ];

			uva = new THREE.Vector2( i / segments, j / radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function ( u ) {

	return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

	return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

	var	tangent = new THREE.Vector3(),
		normal = new THREE.Vector3(),
		binormal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		epsilon = 0.0001,
		smallest,

		tx, ty, tz,
		i, u, v;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i ++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	/*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

	function initialNormal3() {
		// select an initial normal vector perpenicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {
			smallest = tx;
			normal.set( 1, 0, 0 );
		}

		if ( ty <= smallest ) {
			smallest = ty;
			normal.set( 0, 1, 0 );
		}

		if ( tz <= smallest ) {
			normal.set( 0, 0, 1 );
		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i ++ ) {

		normals[ i ] = normals[ i-1 ].clone();

		binormals[ i ] = binormals[ i-1 ].clone();

		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

		if ( vec.length() > epsilon ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), - 1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i < numpoints; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}
};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

	THREE.Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

	}

	var midpoints = [], p = this.vertices;

	var faces = [];

	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

		var v1 = p[ indices[ i     ] ];
		var v2 = p[ indices[ i + 1 ] ];
		var v3 = p[ indices[ i + 2 ] ];

		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

	}

	var centroid = new THREE.Vector3();

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		subdivide( faces[ i ], detail );

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, Math.max( x1, x2 ) );
		var min = Math.min( x0, Math.min( x1, x2 ) );

		if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3 ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
		that.faces.push( face );

		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

		var azi = azimuth( centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide( face, detail ) {

		var cols = Math.pow(2, detail);
		var cells = Math.pow(4, detail);
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++) {

				if ( j == 0 && i == cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 == 0 ) {

					make(
						v[ i ][ k + 1],
						v[ i + 1 ][ k ],
						v[ i ][ k ]
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1][ k + 1],
						v[ i + 1 ][ k ]
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

	this.parameters = {
		radius: radius,
		detail: detail
	};

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (1, 1, 1)
		-1, -1, -1,    -1, -1,  1,
		-1,  1, -1,    -1,  1,  1,
		 1, -1, -1,     1, -1,  1,
		 1,  1, -1,     1,  1,  1,

		// (0, 1/, )
		 0, -r, -t,     0, -r,  t,
		 0,  r, -t,     0,  r,  t,

		// (1/, , 0)
		-r, -t,  0,    -r,  t,  0,
		 r, -t,  0,     r,  t,  0,

		// (, 0, 1/)
		-t,  0, -r,     t,  0, -r,
		-t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};
};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	this.parameters = {
		radius: radius,
		detail: detail
	};

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, il, j, p;
	var u, v;

	var stackCount = stacks + 1;
	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}
	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = (i + 1) * sliceCount + j + 1;
			d = (i + 1) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var vertices = new Float32Array( [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	] );

	var colors = new Float32Array( [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

	return function ( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		THREE.Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.position.copy( origin );

		this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

	var axis = new THREE.Vector3();
	var radians;

	return function ( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, length - headLength, 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.set( color );
	this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = function ( object ) {

	var geometry = object.geometry;

	if ( geometry.boundingBox === null ) {

		geometry.computeBoundingBox();

	}

	var min = geometry.boundingBox.min;
	var max = geometry.boundingBox.max;

	/*
	  5____4
	1/___0/|
	| 6__|_7
	2/___3/

	0: max.x, max.y, max.z
	1: min.x, max.y, max.z
	2: min.x, min.y, max.z
	3: max.x, min.y, max.z
	4: max.x, max.y, min.z
	5: min.x, max.y, min.z
	6: min.x, min.y, min.z
	7: max.x, min.y, min.z
	*/

	var vertices = this.geometry.attributes.position.array;

	vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
	vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

	vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
	vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

	vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
	vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

	vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
	vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

	//

	vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
	vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

	vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
	vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

	vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
	vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

	vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
	vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

	//

	vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
	vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

	vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
	vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

	vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
	vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

	vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
	vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

	this.geometry.attributes.position.needsUpdate = true;

	this.geometry.computeBoundingSphere();

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.camera = camera;
	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.dispose = function () {
	
	this.geometry.dispose();
	this.material.dispose();
};

THREE.CameraHelper.prototype.update = function () {

	var geometry, pointMap;
	
	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();

	var setPoint = function ( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				geometry.vertices[ points[ i ] ].copy( vector );

			}

		}

	};

	return function () {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1.00001 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1.00001 );
		setPoint( "n2",   w, - h, - 1.00001 );
		setPoint( "n3", - w,   h, - 1.00001 );
		setPoint( "n4",   w,   h, - 1.00001 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1.00001 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1.00001 );
		setPoint( "u3",         0, h * 2,   - 1.00001 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1.00001 );
		setPoint( "cn2",   w,   0, - 1.00001 );
		setPoint( "cn3",   0, - h, - 1.00001 );
		setPoint( "cn4",   0,   h, - 1.00001 );

		geometry.verticesNeedUpdate = true;

	};

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3( - size,   size, 0 ),
		new THREE.Vector3(   size,   size, 0 ),
		new THREE.Vector3(   size, - size, 0 ),
		new THREE.Vector3( - size, - size, 0 ),
		new THREE.Vector3( - size,   size, 0 )
	);

	var material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Line( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push(
		new THREE.Vector3(),
		new THREE.Vector3()
	);

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	};

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	var geometry2 = object.geometry.clone();

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;
	var numEdges = 0;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
				numEdges ++;

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = new Float32Array( numEdges * 2 * 3 );

	var index = 0;

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

			var vertex = vertices[ h.vert1 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

			vertex = vertices[ h.vert2 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

		}

	}

	geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var faces = this.object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = function () {

	var vertices = this.geometry.vertices;

	var object = this.object;
	var objectVertices = object.geometry.vertices;
	var objectFaces = object.geometry.faces;
	var objectWorldMatrix = object.matrixWorld;

	object.updateMatrixWorld( true );

	this.normalMatrix.getNormalMatrix( objectWorldMatrix );

	for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

		var face = objectFaces[ i ];

		vertices[ i2 ].copy( objectVertices[ face.a ] )
			.add( objectVertices[ face.b ] )
			.add( objectVertices[ face.c ] )
			.divideScalar( 3 )
			.applyMatrix4( objectWorldMatrix );

		vertices[ i2 + 1 ].copy( face.normal )
			.applyMatrix3( this.normalMatrix )
			.normalize()
			.multiplyScalar( this.size )
			.add( vertices[ i2 ] );

	}

	this.geometry.verticesNeedUpdate = true;

	return this;

};


// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

}

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {
	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 12, 8 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

		}

	}

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object instanceof THREE.Bone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

	var geometry = this.geometry;

	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

	var boneMatrix = new THREE.Matrix4();

	var j = 0;

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

			j += 2;

		}

	}

	geometry.verticesNeedUpdate = true;

	geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose();
	this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var normal = face.vertexNormals[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

// File:src/extras/helpers/VertexTangentsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0x0000ff;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );
THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var tangent = face.vertexTangents[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();
	var skinning = false;

	if ( object.geometry instanceof THREE.Geometry ) {

		var vertices = object.geometry.vertices;
		var faces = object.geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	} else if ( object.geometry instanceof THREE.BufferGeometry ) {

		if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry
			var vertices = object.geometry.attributes.position.array;
			var indices = object.geometry.attributes.index.array;
			var drawcalls = object.geometry.drawcalls;
			var numEdges = 0;
			
			if ( drawcalls.length === 0 ) {
				drawcalls = [ { count : indices.length, index : 0, start : 0 } ];
			}

			// allocate maximal size
			var wireframeIndices = new Uint16Array( 2 * indices.length );

			for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

				var start = drawcalls[ o ].start;
				var count = drawcalls[ o ].count;
				var index = drawcalls[ o ].index;

				geometry.drawcalls.push({ count : count * 2, index : index, start : start * 2 });

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						wireframeIndices[ 2 * (i + j) ] = indices[ i + j ];
						wireframeIndices[ 2 * (i + j) + 1 ] = indices[ i + ( j + 1 ) % 3 ];
					}
				}
			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'index', new THREE.BufferAttribute( wireframeIndices, 1 ) );

			if ( object.geometry.attributes.skinIndex && object.geometry.attributes.skinWeight ) {
				var skinIndices = object.geometry.attributes.skinIndex.array;
				var skinWeights = object.geometry.attributes.skinWeight.array;
				geometry.addAttribute( 'skinWeight', new THREE.BufferAttribute( skinWeights, 4 ) );
				geometry.addAttribute( 'skinIndex', new THREE.BufferAttribute( skinIndices, 4 ) );
				skinning = true;
			}
		} else { // non-indexed BufferGeometry

			var vertices = object.geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		}

	}

	if ( skinning && object.skeleton ) {
		this.skeleton = object.skeleton;
		this.bindMatrix = object.bindMatrix;
		this.bindMatrixInverse = object.bindMatrixInverse;
	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, skinning: skinning } ), THREE.LinePieces );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

	THREE.Object3D.call( this );

	this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		startFrame: start,
		endFrame: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];
			var num = chunks[ 2 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "animation[" + name + "] undefined" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

	}

};

window.THREE = THREE;

return THREE;

});
define('VeroldEngine/Materials/EngineMaterials',[ 'underscore' , 'three']
, function(_, THREE ){

  var EngineMaterials = {

    'wireframe': {

      wireframe: true,
      transparent: true,
      blending: THREE.MultiplyBlending,
      polygonOffset: true,
      polygonOffsetFactor: 1.0,
      polygonOffsetUnits: 1.0,

      uniforms: {

        //tDiffuse: { type: "t", value: 0, texture: null },
        wireColor: { type: "c", value: new THREE.Color( 0xaaaaaa )},

      },

      vertexShader: [

      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'],

        "void main() {",

          THREE.ShaderChunk[ "skinbase_vertex" ],
          THREE.ShaderChunk[ "skinning_vertex" ],
          THREE.ShaderChunk[ "default_vertex" ],
          THREE.ShaderChunk[ 'logdepthbuf_vertex'],
          "#if !defined( USE_LOGDEPTHBUF )",
            "gl_Position.z = ( (gl_Position.z / gl_Position.w) - 0.00003 ) * gl_Position.w;",
          "#endif",

        "}"

      ].join("\n"),

      fragmentShader: [

      "uniform vec3 wireColor;",
      THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'],

        "void main() {",

          THREE.ShaderChunk[ 'logdepthbuf_fragment'],
          "gl_FragColor = vec4( wireColor, 1.0 );",

        "}"

      ].join("\n")

    },
    
    'skybox': {

      //depthTest: false,
      //depthWrite: true,
      side : THREE.BackSide,
      useFog : true,
      fog : true,
      vertexColors: THREE.NoColors,
      //transparent: true,

      uniforms: THREE.UniformsUtils.merge( [

        THREE.UniformsLib[ "fog" ],
        { color: { type: "c", value: new THREE.Color(0xff0000) } },
        { skyboxFogPower: { type: "f", value: 0.0 } },
        { skyboxFogScale: { type: "f", value: 0.0 } },
        { environmentTexture: { type: "t", value: null } },
      ]),
        //{
        //color: { type: "c", value: new THREE.Color(0xff0000) },
        //environmentTexture: { type: "t", value: null },
        //}
      //},

      vertexShader: [

       "varying vec3 vCameraVector;",

        "void main() {",

          "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
          
          "vCameraVector = worldPosition.xyz - cameraPosition;",

          "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
          "gl_Position.z = 1.0;",

        "}"

      ].join("\n"),

      fragmentShader: [

        THREE.ShaderChunk["fog_pars_fragment"],

        "uniform vec3 color;",
        "uniform float skyboxFogPower;",
        "uniform float skyboxFogScale;",
        "uniform samplerCube environmentTexture;",
        
        "varying vec3 vCameraVector;",

        "void main() {",
          //"float power = clamp( 0.1 + 0.9 * (1.0 - vNormal.z * vNormal.z ), 0.0, 1.0);",
          "vec3 cameraVectorN = normalize( vCameraVector );",
          "vec4 environmentColor = textureCube( environmentTexture, vec3( -vCameraVector.x, vCameraVector.yz )  );",
          
          "gl_FragColor = vec4( environmentColor.xyz, 1.0 );",

          "#ifdef USE_FOG",
            "float fogFactor = clamp( pow( (1.0 - cameraVectorN.y), skyboxFogPower * 12.0 ), 0.0, 1.0) + (skyboxFogScale * 2.0 - 1.0);",

            "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

          "#endif",

        "}"

      ].join("\n")

    },
    

    'picking': {

      depthTest: true,
      depthWrite: true,
      transparent: false,
      side: THREE.DoubleSide,

      uniforms: {

        color: { type: "c", value: 0xff0000 },

      },

      vertexShader: [
        THREE.ShaderChunk[ "skinning_pars_vertex" ],

        "void main() {",
          
          THREE.ShaderChunk[ "skinbase_vertex" ],
          THREE.ShaderChunk[ "skinnormal_vertex" ],
          THREE.ShaderChunk[ "defaultnormal_vertex" ],
          THREE.ShaderChunk[ "skinning_vertex" ],
          THREE.ShaderChunk[ "default_vertex" ],
          

        "}"

      ].join("\n"),

      fragmentShader: [

        "uniform vec3 color;",

        "void main() {",
         
          "gl_FragColor = vec4( color, 1.0 );",

        "}"

      ].join("\n")

    },
  }
    
  return EngineMaterials;
});

/**
 * @module VAPI
 */
define('VeroldEngine/Components/VeroldComponent',[ 'underscore', 'backbone' ], function(_, Backbone) {
  /**
   * Verold component base class
   * @class VeroldComponent
   * @mixin Backbone.Events
   * @constructor
   */
  function VeroldComponent() {
  }

  _.extend(VeroldComponent.prototype, {
    /**
     * Get the unique key of this component
     * @method getId
     * @return {String} the key for this component
     */
    getId: function() {
      return this.__verold__.id;
    },

    /**
     * Get the script name of this component
     * @method getScriptName
     * @return {String} the script name
     */
    getScriptName: function() {
      var script = this.getAssetRegistry().getAssetById( this.getScriptId() );
      return script.getName();
    },

    /**
     * Get the script id of this component
     * @method getScriptId
     * @return {String} the script id
     */
    getScriptId: function() {
      return this.__verold__.scriptId;
    },

    // getComponentData: function() {
    //   var components = this.getEntity().getProperty("components");
    //   var component = components[ this.getId() ];
    //   if ( component ) {
    //     return component.componentData;
    //   }
    //   else {
    //     return null;
    //   }
    // },

    componentDataChanged: function( changedComponentData, previousComponentData ) {
      var scriptAsset = this.getAssetRegistry().getAssetById( this.getScriptId() );
      var compData = this.veroldEntity.getComponentData( this.getId() );
      this.getComponentManager()._buildAttributes( scriptAsset, compData, this );

      if ( this.attributesChanged && this.veroldEntity.state_base !== "pending") {
        this.attributesChanged( changedComponentData, previousComponentData );
      }
      this.trigger('attributesChanged', changedComponentData, previousComponentData );
    },

    getDefaultAttributes: function() {
      var scriptAsset = this.getAssetRegistry().getAssetById( this.getScriptId() );
      var scriptAttributes = scriptAsset.getProperty('attributes') || {};
      var returnVal = {};
      _.each( scriptAttributes, function(attr, name ) {
        returnVal[ name ] = attr.default;
      }, this );
      return returnVal;
    },

    /**
     * Set the specified attribute to the specified value. This works across engine instances.
     * @param  {String} attrib  The attribute name
     * @param {Mixed} value   The new value of the attribute.
     * @param {Object} options The standard options object (supports 'save' boolean and 'success' and 'failure' callbacks )
     */
    setAttribute: function( attrib, value, options ) {
      if ( this.veroldEntity && _.isString( attrib ) ) {
        var params = {};
        params[ "components." + this.getId() + ".componentData." + attrib ] = value;
        this.veroldEntity.set( params, options );
      }
    },

    /**
     * Get the value of the specified attribute. Note that if the attribute has been
     * directly changed on this instance of the component, the returned value will give
     * you the saved value (i.e. the same value that a 'resetAttribute' call would yield)
     * @param  {String} attrib  The attribute name
     * @return {Mixed}        The saved attribute value.
     */
    getAttribute: function( attrib ) {
      if ( this.veroldEntity && _.isString( attrib ) ) {
        var compData = this.veroldEntity.getComponentData( this.getId() );
        return compData[ attrib ];
      }
    },

    getProperty: function( prop ) {
      if ( this.veroldEntity && _.isString( prop ) ) {
        var comp = this.veroldEntity.entityModel.get('components.' + this.getId() );
        return comp[ prop ];
      }
    },

    /**
     * Reset the specified attribute to the saved value.
     * @param  {String} attrib  The attribute name
     */
    resetAttribute: function( attrib ) {
      if ( this.veroldEntity && _.isString( attrib ) ) {
        var value = this.getAttribute( attrib );
        this.setAttribute( attrib, value );
      }
    },

    /**
     * Returns the VeroldEntity that the component is attached to
     * @method getEntity
     * @return {VAPI.VeroldEntity} the VeroldEntity which this component is attached to
     */
    getEntity: function() {
      return this.veroldEntity;
    },

    getObject: function() {
      console.warn("VeroldComponent.getObject() is deprecated. Please use VeroldComponent.getEntity().");
      return this.veroldEntity;
    },

    /**
     * Get the component manager for this VeroldEntity
     * @method getComponentManager
     * @return {VAPI.ComponentManager} This VeroldEntity's component manager
     */
    getComponentManager: function() {
      return this.veroldEntity.componentManager;
    },

    /**
     * Removes this component from the attached VeroldEntity
     * @method remove
     */
    remove: function() {
      this.getEntity().removeComponent(this);
    },

    /**
     * Returns the VeroldEngine that thecomponent is running in
     * @method getEngine
     * @return {VAPI.Engine} the Engine object
     */
    getEngine: function() {
      return this.veroldEntity.veroldEngine;
    },

    /**
     * Enables the component
     * @method enable
     */
    enable: function() {
      this.__verold__.enabled = true;
      this.trigger('enable');
    },

    /**
     * Disables the component
     * @method disable
     */
    disable: function() {
      this.__verold__.enabled = false;
      this.trigger('disable');
    },

    /**
     * Check whether the component is enabled or not
     * @method isEnabled
     * @return {Boolean}
     */
    isEnabled: function() {
      return this.__verold__.enabled;
    },

    /**
     * Check if threeData exists
     * @method hasThreeData
     * @return {Boolean} Whether or not the threeData object exists
     */
    hasThreeData: function() {
      return !!( this.veroldEntity && this.veroldEntity.threeData);
    },

    /**
     * Returns the three.js data attached to the object
     * @method getThreeData
     * @return {mixed}
     */
    getThreeData: function() {
      return this.veroldEntity.threeData;
    },

    /**
     * Returns the Three.js object (THREE.Object3D) associated with this component
     * @method getThreeObject
     * @return {mixed}
     */
    getThreeObject: function() {
      return this.veroldEntity.threeData;
    },

    /**
     * Returns the global event system
     * @method getEvents
     * @return {Backbone.Events} the global Backbone.Events instance
     */
    getEvents: function() {
      return this.events;
    },

    getRenderer: function() {
      return this.getEngine().getBaseRenderer();
    },

    /**
     * Returns the WebGLRenderer currently being used by the Verold engine
     * @method getThreeRenderer
     * @return {THREE.WebGLRenderer} the THREE.WebGLRenderer object
     */
    getThreeRenderer: function() {
      var threeRenderer = this.getEngine().getBaseRenderer().threeRenderer;
      
      return threeRenderer;
    },

    /**
     * Returns the THREE.EffectComposer currently being used by the Verold engine
     * @method getThreeComposer
     * @return {THREE.WebGLRenderer} the THREE.WebGLRenderer object
     */
    getThreeComposer: function() {
      var threeComposer = this.getEngine().getBaseRenderer().threeComposer;
      
      return threeComposer;
    },

    /**
     * Returns the Input handler being used by the object's engine
     * @method getInput
     * @return {VAPI.Input} [description]
     */
    getInput: function() {
      return this.veroldEntity.veroldEngine.Input;
    },

    /**
     * Returns the scene that this component is a part of
     * @method getScene
     * @return {VAPI.SceneAsset} the SceneAsset object
     */
    getScene: function() {
      return this.veroldEntity.getParentAsset();
    },

    /**
     * Returns the THREE.Scene object that this entity is a part of.
     * @method getThreeScene
     * @return {THREE.Scene} the THREE.Scene object
     */
    getThreeScene: function() {
      return this.veroldEntity.getParentAsset().threeData;
    },

    /**
     * Returns the global asset registry
     * @return {VAPI.AssetRegistry} the global asset registry
     */
    getAssetRegistry: function() {
      return this.getEngine().assetRegistry;
    },

    /***
     * Forces the component to remove and readd itself
     */
    reload: function() {
      var params = [this.getScriptId(), this.veroldEntity.getComponentData(this.getId()), this.getId()],
          object = this.getEntity();
      object.removeComponent( params[2] );
      object.addComponent( params[0], params[1], params[2] );
    },

    preInit: function() {
    },

    /**
     * Called after the component is created
     * @method init
     */
    init: function() {
    },

     /**
      * Called on component or object destroy
      * @method shutdown
      */
    shutdown: undefined,

    /**
     * Earlier version of update
     * @param {float} delta the amount of time since the last call
     * @method preUpdate
     */
    preUpdate: undefined,

    /**
     * Main update
     * @param {float} delta the amount of time since the last call
     * @method update
     */
    update: undefined,

    /**
     * Later version of update
     * @param {float} delta the amount of time since the last call
     * @method postUpdate
     */
    postUpdate: undefined,

    /**
     * @method  render
     * @param {float} delta the amount of time since the last call
     */
    render: undefined,

    /**
     * Called when the application loses focus
     * @method supsend
     */
    suspend: undefined,

    /**
     * Called when the application regains focus
     * @method resume
     */
    resume: undefined,

    /**
     * Called when a component's attribute values change
     * in the editor.
     * @method attributesChanged
     * @param  {Object} attributes An object containing all of the attributes whose values have changed.
     */
    attributesChanged: undefined,

    /**
     * Called when the Three.JS object data is available
     * @method  objectCreated
     */
    objectCreated: undefined,

    /**
     * Called when the Three.JS object is completely loaded, including all of it's children
     * @method  objectLoaded
     */
    objectLoaded: undefined,

    /**
     * Called when the scene is fully loaded
     * @method sceneLoaded
     */
    sceneLoaded: undefined
  }, Backbone.Events);

  window.VAPI = window.VAPI || {};
  window.VAPI.VeroldComponent = VeroldComponent;

  return VeroldComponent;
});

define('VeroldEngine/libs/three/postprocessing/EffectComposer',['three'], function(THREE) {
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.EffectComposer = function ( renderer, renderTarget ) {

		this.renderer = renderer;

		if ( renderTarget === undefined ) {

			var pixelRatio = renderer.getPixelRatio();

			var width  = Math.floor( renderer.context.canvas.width  / pixelRatio ) || 1;
			var height = Math.floor( renderer.context.canvas.height / pixelRatio ) || 1;
			var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

			renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );
			renderTarget.name = "EffectComposer Render Target";
		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		this.passes = [];
		this.enabled = true;

		if ( THREE.CopyShader === undefined )
			console.error( "THREE.EffectComposer relies on THREE.CopyShader" );

		this.copyPass = new THREE.ShaderPass( THREE.CopyShader );

	};

	THREE.EffectComposer.prototype = {

		swapBuffers: function() {

			var tmp = this.readBuffer;
			this.readBuffer = this.writeBuffer;
			this.writeBuffer = tmp;

		},

		addPass: function ( pass ) {

			this.passes.push( pass );

		},

		insertPass: function ( pass, index ) {

			this.passes.splice( index, 0, pass );

		},

		render: function ( delta ) {

			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;

			var maskActive = false;

			var pass, i, il = this.passes.length;

			for ( i = 0; i < il; i ++ ) {

				pass = this.passes[ i ];

				if ( !pass.enabled ) continue;

				pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

				if ( pass.needsSwap ) {

					if ( maskActive ) {

						var context = this.renderer.context;

						context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

						this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

						context.stencilFunc( context.EQUAL, 1, 0xffffffff );

					}

					this.swapBuffers();

				}

				if ( pass instanceof THREE.MaskPass ) {

					maskActive = true;

				} else if ( pass instanceof THREE.ClearMaskPass ) {

					maskActive = false;

				}

			}

		},

		reset: function ( renderTarget ) {

			if ( renderTarget === undefined ) {

				renderTarget = this.renderTarget1.clone();

				var pixelRatio = this.renderer.getPixelRatio();

				renderTarget.width  = Math.floor( this.renderer.context.canvas.width  / pixelRatio );
				renderTarget.height = Math.floor( this.renderer.context.canvas.height / pixelRatio );
			}
			var oldRenderTarget1 = this.renderTarget1;
			var oldRenderTarget2 = this.renderTarget2;
			if ( oldRenderTarget1 ) {
				oldRenderTarget1.dispose();
			}
			if ( oldRenderTarget2 ) {
				oldRenderTarget2.dispose();
			}

			this.renderTarget1 = renderTarget;
			this.renderTarget2 = renderTarget.clone();

			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;

		},

		setSize: function ( width, height ) {

			var renderTarget = this.renderTarget1.clone();

			renderTarget.width = width;
			renderTarget.height = height;

			this.reset( renderTarget );

		},

		dispose: function() {
			this.renderTarget1.dispose();
			this.renderTarget2.dispose();
			this.copyPass.dispose();
			// for ( var p in this.passes ) {
			// 	this.passes[p].dispose();
			// }
			this.passes = undefined;
			this.renderer = undefined;
		}

	};
});

define('VeroldEngine/libs/three/postprocessing/BloomPass',['three'], function(THREE) {
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.BloomPass = function ( strength, kernelSize, sigma, resolutionX, resolutionY ) {

		strength = ( strength !== undefined ) ? strength : 1;
		kernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;
		sigma = ( sigma !== undefined ) ? sigma : 4.0;
				
		// render targets
		this.setSize( resolutionX, resolutionY );

		// copy material

		if ( THREE.CopyShader === undefined )
			console.error( "THREE.BloomPass relies on THREE.CopyShader" );

		var copyShader = THREE.CopyShader;

		this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );

		this.copyUniforms[ "opacity" ].value = strength;

		this.materialCopy = new THREE.ShaderMaterial( {

			uniforms: this.copyUniforms,
			vertexShader: copyShader.vertexShader,
			fragmentShader: copyShader.fragmentShader,
			blending: THREE.AdditiveBlending,
			transparent: true

		} );

		// convolution material

		if ( THREE.ConvolutionShader === undefined )
			console.error( "THREE.BloomPass relies on THREE.ConvolutionShader" );

		var convolutionShader = THREE.ConvolutionShader;

		this.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );

		this.convolutionUniforms[ "uImageIncrement" ].value = THREE.BloomPass.blurx;
		this.convolutionUniforms[ "cKernel" ].value = THREE.ConvolutionShader.buildKernel( sigma );

		this.materialConvolution = new THREE.ShaderMaterial( {

			uniforms: this.convolutionUniforms,
			vertexShader:  convolutionShader.vertexShader,
			fragmentShader: convolutionShader.fragmentShader,
			defines: {
				"KERNEL_SIZE_FLOAT": kernelSize.toFixed( 1 ),
				"KERNEL_SIZE_INT": kernelSize.toFixed( 0 )
			}

		} );

		if ( THREE.ClampShader === undefined )
			console.error( "THREE.BloomPass relies on THREE.ClampShader" );
		var clampShader = THREE.ClampShader;

		this.clampUniforms = THREE.UniformsUtils.clone( clampShader.uniforms );

		// this.convolutionUniforms[ "uImageIncrement" ].value = THREE.BloomPass.blurx;
		// this.convolutionUniforms[ "cKernel" ].value = THREE.ConvolutionShader.buildKernel( sigma );

		this.materialClamp = new THREE.ShaderMaterial( {

			uniforms: this.clampUniforms,
			vertexShader:  clampShader.vertexShader,
			fragmentShader: clampShader.fragmentShader,
		} );

		this.enabled = true;
		this.needsSwap = false;
		this.clear = false;


		this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
		this.scene  = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
		this.scene.add( this.quad );

	};

	THREE.BloomPass.prototype = {

		render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

			if ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );

			//Clamp to threshold
			this.quad.material = this.materialClamp;

			this.clampUniforms[ "tDiffuse" ].value = readBuffer;
			renderer.render( this.scene, this.camera, writeBuffer, true );

			// Render quad with blured scene into texture (convolution pass 1)

			this.quad.material = this.materialConvolution;

			this.convolutionUniforms[ "tDiffuse" ].value = writeBuffer;
			this.convolutionUniforms[ "uImageIncrement" ].value = THREE.BloomPass.blurX;

			renderer.render( this.scene, this.camera, this.renderTargetX, true );


			// Render quad with blured scene into texture (convolution pass 2)

			this.convolutionUniforms[ "tDiffuse" ].value = this.renderTargetX;
			this.convolutionUniforms[ "uImageIncrement" ].value = THREE.BloomPass.blurY;

			renderer.render( this.scene, this.camera, this.renderTargetY, true );

			// Render original scene with superimposed blur to texture

			this.quad.material = this.materialCopy;

			this.copyUniforms[ "tDiffuse" ].value = this.renderTargetY;

			if ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );

			renderer.render( this.scene, this.camera, readBuffer, this.clear );

		},

		setSigma: function( sigma ) {
			if ( sigma ) {
				var kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;
	      // var kernelSize = this.bloom.kernelSize !== undefined ? this.bloom.kernelSize : 25;
	      this.materialConvolution.defines = {
	        "KERNEL_SIZE_FLOAT": kernelSize.toFixed( 1 ),
	        "KERNEL_SIZE_INT": kernelSize.toFixed( 0 )
	      }
	      this.materialConvolution.needsUpdate = true;
	      this.convolutionUniforms[ "cKernel" ].value = THREE.ConvolutionShader.buildKernel( sigma );
	    }
		},

		setSize: function( resolutionX, resolutionY ) {
			this.resolutionX = ( resolutionX !== undefined ) ? resolutionX : 256;
			this.resolutionY = ( resolutionY !== undefined ) ? resolutionY : 256;
			var pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };
			if ( this.renderTargetX ) {
				this.renderTargetX.dispose();
			}
			if ( this.renderTargetY ) {
				this.renderTargetY.dispose();
			}
			this.renderTargetX = new THREE.WebGLRenderTarget( this.resolutionX, this.resolutionY, pars );
			this.renderTargetX.name = "Bloom Convolution X";
			this.renderTargetY = new THREE.WebGLRenderTarget( this.resolutionX, this.resolutionY, pars );
			this.renderTargetY.name = "Bloom Convolution Y";
		},

		dispose: function() {
			this.renderTargetX.dispose();
			this.renderTargetY.dispose();
			this.copyUniforms = undefined;
			this.convolutionUniforms = undefined;
			this.materialCopy.dispose();
			this.materialConvolution.dispose();
			this.quad.geometry.dispose();
			this.quad = undefined;
			this.scene = undefined;
			this.camera = undefined;
		}

	};

	THREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );
	THREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );
});

define('VeroldEngine/libs/three/postprocessing/BokehPass',['three'], function(THREE) {
/**
 * Depth-of-field post-process with bokeh shader
 */


THREE.BokehPass = function ( scene, camera, params ) {

	this.scene = scene;
	this.camera = camera;

	var focus = ( params.focus !== undefined ) ? params.focus : 1.0;
	var aspect = ( params.aspect !== undefined ) ? params.aspect : camera.aspect;
	var aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;
	var maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;

	// render targets

	var width = params.width || window.innerWidth || 1;
	var height = params.height || window.innerHeight || 1;

	this.renderTargetColor = new THREE.WebGLRenderTarget( width, height, {
		minFilter: THREE.LinearFilter,
		magFilter: THREE.LinearFilter,
		format: THREE.RGBFormat
	} );

	this.renderTargetDepth = this.renderTargetColor.clone();

	// depth material

	this.materialDepth = new THREE.MeshDepthMaterial();

	// bokeh material

	if ( THREE.BokehShader === undefined ) {
		console.error( "THREE.BokehPass relies on THREE.BokehShader" );
	}
	
	var bokehShader = THREE.BokehShader;
	var bokehUniforms = THREE.UniformsUtils.clone( bokehShader.uniforms );

	bokehUniforms[ "tDepth" ].value = this.renderTargetDepth;

	bokehUniforms[ "focus" ].value = focus;
	bokehUniforms[ "aspect" ].value = aspect;
	bokehUniforms[ "aperture" ].value = aperture;
	bokehUniforms[ "maxblur" ].value = maxblur;

	this.materialBokeh = new THREE.ShaderMaterial({
		uniforms: bokehUniforms,
		vertexShader: bokehShader.vertexShader,
		fragmentShader: bokehShader.fragmentShader
	});

	this.uniforms = bokehUniforms;
	this.enabled = true;
	this.needsSwap = false;
	this.renderToScreen = false;
	this.clear = false;

	this.camera2 = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
	this.scene2  = new THREE.Scene();

	this.quad2 = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
	this.scene2.add( this.quad2 );

};

THREE.BokehPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		this.quad2.material = this.materialBokeh;

		// Render depth into texture

		this.scene.overrideMaterial = this.materialDepth;

		renderer.render( this.scene, this.camera, this.renderTargetDepth, true );

		// Render bokeh composite

		this.uniforms[ "tColor" ].value = readBuffer;

		if ( this.renderToScreen ) {

			renderer.render( this.scene2, this.camera2 );

		} else {

			renderer.render( this.scene2, this.camera2, writeBuffer, this.clear );

		}

		this.scene.overrideMaterial = null;

	}

};
});

define('VeroldEngine/libs/three/postprocessing/DotScreenPass',['three'], function(THREE) {
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.DotScreenPass = function ( center, angle, scale ) {

		if ( THREE.DotScreenShader === undefined )
			console.error( "THREE.DotScreenPass relies on THREE.DotScreenShader" );

		var shader = THREE.DotScreenShader;

		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		if ( center !== undefined ) this.uniforms[ "center" ].value.copy( center );
		if ( angle !== undefined ) this.uniforms[ "angle"].value = angle;
		if ( scale !== undefined ) this.uniforms[ "scale"].value = scale;

		this.material = new THREE.ShaderMaterial( {

			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

		this.enabled = true;
		this.renderToScreen = false;
		this.needsSwap = true;


		this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
		this.scene  = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
		this.scene.add( this.quad );

	};

	THREE.DotScreenPass.prototype = {

		render: function ( renderer, writeBuffer, readBuffer, delta ) {

			this.uniforms[ "tDiffuse" ].value = readBuffer;
			this.uniforms[ "tSize" ].value.set( readBuffer.width, readBuffer.height );

			this.quad.material = this.material;

			if ( this.renderToScreen ) {

				renderer.render( this.scene, this.camera );

			} else {

				renderer.render( this.scene, this.camera, writeBuffer, false );

			}

		}

	};
});

define('VeroldEngine/libs/three/postprocessing/FilmPass',['three'], function(THREE) {
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {

		if ( THREE.FilmShader === undefined )
			console.error( "THREE.FilmPass relies on THREE.FilmShader" );

		var shader = THREE.FilmShader;

		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		this.material = new THREE.ShaderMaterial( {

			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

		if ( grayscale !== undefined )	this.uniforms.grayscale.value = grayscale;
		if ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;
		if ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;
		if ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;

		this.enabled = true;
		this.renderToScreen = false;
		this.needsSwap = true;


		this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
		this.scene  = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
		this.scene.add( this.quad );

	};

	THREE.FilmPass.prototype = {

		render: function ( renderer, writeBuffer, readBuffer, delta ) {

			this.uniforms[ "tDiffuse" ].value = readBuffer;
			this.uniforms[ "time" ].value = (this.uniforms[ "time" ].value + delta) % 10.0 + 0.1;

			this.quad.material = this.material;

			if ( this.renderToScreen ) {

				renderer.render( this.scene, this.camera );

			} else {

				renderer.render( this.scene, this.camera, writeBuffer, false );

			}

		},

		dispose: function() {
			this.quad.geometry.dispose();
			this.quad = undefined;
			this.material.dispose();
			this.material = undefined;
			this.uniforms = undefined;
			this.scene = undefined;
			this.camera = undefined;
		}

	};
});

define('VeroldEngine/libs/three/postprocessing/MaskPass',['three'], function(THREE) {
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.MaskPass = function ( scene, camera ) {

		this.scene = scene;
		this.camera = camera;

		this.enabled = true;
		this.clear = true;
		this.needsSwap = false;

		this.inverse = false;

	};

	THREE.MaskPass.prototype = {

		render: function ( renderer, writeBuffer, readBuffer, delta ) {

			var context = renderer.context;

			// don't update color or depth

			context.colorMask( false, false, false, false );
			context.depthMask( false );

			// set up stencil

			var writeValue, clearValue;

			if ( this.inverse ) {

				writeValue = 0;
				clearValue = 1;

			} else {

				writeValue = 1;
				clearValue = 0;

			}

			context.enable( context.STENCIL_TEST );
			context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
			context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
			context.clearStencil( clearValue );

			// draw into the stencil buffer

			renderer.render( this.scene, this.camera, readBuffer, this.clear );
			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

			// re-enable update of color and depth

			context.colorMask( true, true, true, true );
			context.depthMask( true );

			// only render where stencil is set to 1

			context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
			context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

		}

	};


	THREE.ClearMaskPass = function () {

		this.enabled = true;

	};

	THREE.ClearMaskPass.prototype = {

		render: function ( renderer, writeBuffer, readBuffer, delta ) {

			var context = renderer.context;

			context.disable( context.STENCIL_TEST );

		}

	};
});

define('VeroldEngine/libs/three/postprocessing/RenderPass',['three'], function(THREE) {
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

		this.scene = scene;
		this.camera = camera;

		this.overrideMaterial = overrideMaterial;

		this.clearColor = clearColor;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

		this.oldClearColor = new THREE.Color();
		this.oldClearAlpha = 1;

		this.enabled = true;
		this.clear = true;
		this.needsSwap = false;

	};

	THREE.RenderPass.prototype = {

		render: function ( renderer, writeBuffer, readBuffer, delta ) {

			// renderer.setViewport( 0, 0, renderer.domElement.width, renderer.domElement.height );

			this.scene.overrideMaterial = this.overrideMaterial !== undefined ? this.overrideMaterial : this.scene.overrideMaterial;

			if ( this.clearColor ) {

				this.oldClearColor.copy( renderer.getClearColor() );
				this.oldClearAlpha = renderer.getClearAlpha();

				renderer.setClearColor( this.clearColor, this.clearAlpha );

			}

			renderer.render( this.scene, this.camera, readBuffer, this.clear );

			if ( this.clearColor ) {

				renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

			}

			this.scene.overrideMaterial = null;

		},

		dispose: function() {
			this.scene = undefined;
			this.camera = undefined;
		}

	};
});

define('VeroldEngine/libs/three/postprocessing/SavePass',['three'], function(THREE) {
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.SavePass = function ( renderTarget ) {

		if ( THREE.CopyShader === undefined )
			console.error( "THREE.SavePass relies on THREE.CopyShader" );

		var shader = THREE.CopyShader;

		this.textureID = "tDiffuse";

		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		this.material = new THREE.ShaderMaterial( {

			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

		this.renderTarget = renderTarget;

		if ( this.renderTarget === undefined ) {

			this.renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };
			this.renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, this.renderTargetParameters );

		}

		this.enabled = true;
		this.needsSwap = false;
		this.clear = false;


		this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
		this.scene  = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
		this.scene.add( this.quad );

	};

	THREE.SavePass.prototype = {

		render: function ( renderer, writeBuffer, readBuffer, delta ) {

			if ( this.uniforms[ this.textureID ] ) {

				this.uniforms[ this.textureID ].value = readBuffer;

			}

			this.quad.material = this.material;

			renderer.render( this.scene, this.camera, this.renderTarget, this.clear );

		}

	};
});

define('VeroldEngine/libs/three/shaders/BasicShader',['three'], function(THREE) {
/**
 * @author mrdoob / http://www.mrdoob.com
 *
 * Simple test shader
 */

THREE.BasicShader = {

	uniforms: {},

	vertexShader: [

		"void main() {",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"void main() {",

			"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/BilinearMipmapShader',['three'], function(THREE) {
/**
 * @author miibond
 *
 * Down-sample a given texture to a target exactly half the size. Useful for texture packings where automatic
 * bilinear filtering is inappropriate (e.g. depthRGBA, RGBE, etc.)
 */

THREE.BilinearDownSampleShader = {

	uniforms: {
		"tDiffuse": { type: "t", value: null },
		"resolution": { type: "v2", value: new THREE.Vector2() },
	},
	vertexShader: [
		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"
	].join('\n'),
	fragmentShader: [
		"varying vec2 vUv;",
		"uniform sampler2D tDiffuse;",
		"uniform vec2 resolution;",
		THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],
		THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],
		
		"void main() {",
			"vec2 offset = 0.5 / resolution;",
			"vec4 colour;",
			"vec4 samples[ 4 ];",

      "samples[0] = texture2D( tDiffuse, vUv + vec2( -offset.x, -offset.x ) );",
      "samples[1] = texture2D( tDiffuse, vUv + vec2( offset.x, -offset.x ) );",
      "samples[2] = texture2D( tDiffuse, vUv + vec2( offset.x, offset.y ) );",
      "samples[3] = texture2D( tDiffuse, vUv + vec2( -offset.x, offset.y ) );",

			"for ( int i = 0; i < 4; i++ ) {",
				"#if defined( HDR_INPUT ) && defined( HDR_INPUT_TYPE )",
					"#if ( HDR_INPUT_TYPE == HDR_TYPE_LOGLUV )",
						"colour += vec4( HDRDecodeLOGLUV( samples[i] ), 1.0 );",
					"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBM )",
						"colour += vec4( HDRDecodeRGBM( samples[i] ), 1.0 );",
					"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBD )",
						"colour += vec4( HDRDecodeRGBD( samples[i] ), 1.0 );",
					"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBE )",
						"colour += vec4( HDRDecodeRGBE( samples[i] ), 1.0 );",
					"#else",
						"colour += samples[i];",
					"#endif",
				"#else",
						"colour += samples[i];",
				"#endif",
			"}",

			"gl_FragColor = colour * 0.25;",
			
			THREE.ShaderChunk[ "hdr_encode_fragment" ],
			
		"}",
	].join('\n')

};
});
define('VeroldEngine/libs/three/shaders/BleachBypassShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]
 * - based on Nvidia example
 * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass
 */

THREE.BleachBypassShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 base = texture2D( tDiffuse, vUv );",

			"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );",
			"float lum = dot( lumCoeff, base.rgb );",
			"vec3 blend = vec3( lum );",

			"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );",

			"vec3 result1 = 2.0 * base.rgb * blend;",
			"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );",

			"vec3 newColor = mix( result1, result2, L );",

			"float A2 = opacity * base.a;",
			"vec3 mixRGB = A2 * newColor.rgb;",
			"mixRGB += ( ( 1.0 - A2 ) * base.rgb );",

			"gl_FragColor = vec4( mixRGB, base.a );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/BlendShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Blend two textures
 */

THREE.BlendShader = {

	uniforms: {

		"tDiffuse1": { type: "t", value: null },
		"tDiffuse2": { type: "t", value: null },
		"mixRatio":  { type: "f", value: 0.5 },
		"opacity":   { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",
		"uniform float mixRatio;",

		"uniform sampler2D tDiffuse1;",
		"uniform sampler2D tDiffuse2;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel1 = texture2D( tDiffuse1, vUv );",
			"vec4 texel2 = texture2D( tDiffuse2, vUv );",
			"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/BokehShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */

THREE.BokehShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"tDepth":   { type: "t", value: null },
		"focus":    { type: "f", value: 1.0 },
		"aspect":   { type: "f", value: 1.0 },
		"aperture": { type: "f", value: 0.025 },
		"maxblur":  { type: "f", value: 1.0 },
		"opacity": { type: "f", value: 1.0 }
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"varying vec2 vUv;",

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDepth;",

		"uniform float maxblur;",  // max blur amount
		"uniform float aperture;", // aperture - bigger values for shallower depth of field

		"uniform float focus;",
		"uniform float aspect;",
		"uniform float opacity;",

		"float unpackDepth( const in vec4 rgba_depth ) {",

			"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"float depth = dot( rgba_depth, bit_shift );",
			"return depth;",

		"}",

		"void main() {",

			"vec2 aspectcorrect = vec2( 1.0, aspect );",

			"float depth1 = unpackDepth( texture2D( tDepth, vUv ) );",

			"float factor = max( depth1 - focus, 0.0);",

			"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );",

			"vec2 dofblur9 = dofblur * 0.9;",
			"vec2 dofblur7 = dofblur * 0.7;",
			"vec2 dofblur4 = dofblur * 0.4;",

			"vec4 col = vec4( 0.0 );",

			"col += texture2D( tDiffuse, vUv.xy );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );",

			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );",

			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );",

			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );",
			"col += texture2D( tDiffuse, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );",

			"gl_FragColor = col / 41.0;",
			"gl_FragColor.a = opacity;",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/BokehShader2',['three'], function(THREE) {
/**
 * @author zz85 / https://github.com/zz85 | twitter.com/blurspline
 *
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)
 *
 * Requires #define RINGS and SAMPLES integers
 */



THREE.BokehShader2 = {

	uniforms: {

		"textureWidth":  { type: "f", value: 1.0 },
		"textureHeight":  { type: "f", value: 1.0 },

		"focalDepth":   { type: "f", value: 1.0 },
		"focalLength":   { type: "f", value: 24.0 },
		"fstop": { type: "f", value: 0.9 },

		"tColor":   { type: "t", value: null },
		"tDepth":   { type: "t", value: null },

		"maxblur":  { type: "f", value: 1.0 },

		"showFocus":   { type: "i", value: 0 },
		"manualdof":   { type: "i", value: 0 },
		"vignetting":   { type: "i", value: 0 },
		"depthblur":   { type: "i", value: 0 },

		"threshold":  { type: "f", value: 0.5 },
		"gain":  { type: "f", value: 2.0 },
		"bias":  { type: "f", value: 0.5 },
		"fringe":  { type: "f", value: 0.7 },

		"znear":  { type: "f", value: 0.1 },
		"zfar":  { type: "f", value: 100 },

		"noise":  { type: "i", value: 1 },
		"dithering":  { type: "f", value: 0.0001 },
		"pentagon": { type: "i", value: 0 },

		"shaderFocus":  { type: "i", value: 1 },
		"focusCoords":  { type: "v2", value: new THREE.Vector2()},


	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"varying vec2 vUv;",

		"uniform sampler2D tColor;",
		"uniform sampler2D tDepth;",
		"uniform float textureWidth;",
		"uniform float textureHeight;",

		"const float PI = 3.14159265;",

		"float width = textureWidth; //texture width",
		"float height = textureHeight; //texture height",

		"vec2 texel = vec2(1.0/width,1.0/height);",

		"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below",
		"uniform float focalLength; //focal length in mm",
		"uniform float fstop; //f-stop value",
		"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)",

		"/*",
		"make sure that these two values are the same for your camera, otherwise distances will be wrong.",
		"*/",

		"uniform float znear; // camera clipping start",
		"uniform float zfar; // camera clipping end",

		"//------------------------------------------",
		"//user variables",

		"const int samples = SAMPLES; //samples on the first ring",
		"const int rings = RINGS; //ring count",

		"const int maxringsamples = rings * samples;",

		"uniform bool manualdof; // manual dof calculation",
		"float ndofstart = 1.0; // near dof blur start",
		"float ndofdist = 2.0; // near dof blur falloff distance",
		"float fdofstart = 1.0; // far dof blur start",
		"float fdofdist = 3.0; // far dof blur falloff distance",

		"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)",

		"uniform bool vignetting; // use optical lens vignetting",

		"float vignout = 1.3; // vignetting outer border",
		"float vignin = 0.0; // vignetting inner border",
		"float vignfade = 22.0; // f-stops till vignete fades",

		"uniform bool shaderFocus;",

		"bool autofocus = shaderFocus;",
		"//use autofocus in shader - use with focusCoords",
		"// disable if you use external focalDepth value",

		"uniform vec2 focusCoords;",
		"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)",
		"// if center of screen use vec2(0.5, 0.5);",

		"uniform float maxblur;",
		"//clamp value of max blur (0.0 = no blur, 1.0 default)",

		"uniform float threshold; // highlight threshold;",
		"uniform float gain; // highlight gain;",

		"uniform float bias; // bokeh edge bias",
		"uniform float fringe; // bokeh chromatic aberration / fringing",

		"uniform bool noise; //use noise instead of pattern for sample dithering",

		"uniform float dithering;",
		"float namount = dithering; //dither amount",

		"uniform bool depthblur; // blur the depth buffer",
		"float dbsize = 1.25; // depth blur size",

		"/*",
		"next part is experimental",
		"not looking good with small sample and ring count",
		"looks okay starting from samples = 4, rings = 4",
		"*/",

		"uniform bool pentagon; //use pentagon as bokeh shape?",
		"float feather = 0.4; //pentagon shape feather",

		"//------------------------------------------",

		"float penta(vec2 coords) {",
			"//pentagonal shape",
			"float scale = float(rings) - 1.3;",
			"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);",
			"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);",
			"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);",
			"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);",
			"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);",
			"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);",

			"vec4  one = vec4( 1.0 );",

			"vec4 P = vec4((coords),vec2(scale, scale));",

			"vec4 dist = vec4(0.0);",
			"float inorout = -4.0;",

			"dist.x = dot( P, HS0 );",
			"dist.y = dot( P, HS1 );",
			"dist.z = dot( P, HS2 );",
			"dist.w = dot( P, HS3 );",

			"dist = smoothstep( -feather, feather, dist );",

			"inorout += dot( dist, one );",

			"dist.x = dot( P, HS4 );",
			"dist.y = HS5.w - abs( P.z );",

			"dist = smoothstep( -feather, feather, dist );",
			"inorout += dist.x;",

			"return clamp( inorout, 0.0, 1.0 );",
		"}",

		"float bdepth(vec2 coords) {",
			"// Depth buffer blur",
			"float d = 0.0;",
			"float kernel[9];",
			"vec2 offset[9];",

			"vec2 wh = vec2(texel.x, texel.y) * dbsize;",

			"offset[0] = vec2(-wh.x,-wh.y);",
			"offset[1] = vec2( 0.0, -wh.y);",
			"offset[2] = vec2( wh.x -wh.y);",

			"offset[3] = vec2(-wh.x,  0.0);",
			"offset[4] = vec2( 0.0,   0.0);",
			"offset[5] = vec2( wh.x,  0.0);",

			"offset[6] = vec2(-wh.x, wh.y);",
			"offset[7] = vec2( 0.0,  wh.y);",
			"offset[8] = vec2( wh.x, wh.y);",

			"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;",
			"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;",
			"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;",


			"for( int i=0; i<9; i++ ) {",
				"float tmp = texture2D(tDepth, coords + offset[i]).r;",
				"d += tmp * kernel[i];",
			"}",

			"return d;",
		"}",


		"vec3 color(vec2 coords,float blur) {",
			"//processing the sample",

			"vec3 col = vec3(0.0);",

			"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;",
			"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;",
			"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;",

			"vec3 lumcoeff = vec3(0.299,0.587,0.114);",
			"float lum = dot(col.rgb, lumcoeff);",
			"float thresh = max((lum-threshold)*gain, 0.0);",
			"return col+mix(vec3(0.0),col,thresh*blur);",
		"}",

		"vec2 rand(vec2 coord) {",
			"// generating noise / pattern texture for dithering",

			"float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;",
			"float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;",

			"if (noise) {",
				"noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;",
				"noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;",
			"}",

			"return vec2(noiseX,noiseY);",
		"}",

		"vec3 debugFocus(vec3 col, float blur, float depth) {",
			"float edge = 0.002*depth; //distance based edge smoothing",
			"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);",
			"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);",

			"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);",
			"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);",

			"return col;",
		"}",

		"float linearize(float depth) {",
			"return -zfar * znear / (depth * (zfar - znear) - zfar);",
		"}",


		"float vignette() {",
			"float dist = distance(vUv.xy, vec2(0.5,0.5));",
			"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);",
			"return clamp(dist,0.0,1.0);",
		"}",

		"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {",
			"float rings2 = float(rings);",
			"float step = PI*2.0 / float(ringsamples);",
			"float pw = cos(j*step)*i;",
			"float ph = sin(j*step)*i;",
			"float p = 1.0;",
			"if (pentagon) {",
				"p = penta(vec2(pw,ph));",
			"}",
			"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;",
			"return 1.0 * mix(1.0, i /rings2, bias) * p;",
		"}",

		"void main() {",
			"//scene depth calculation",

			"float depth = linearize(texture2D(tDepth,vUv.xy).x);",

			"// Blur depth?",
			"if (depthblur) {",
				"depth = linearize(bdepth(vUv.xy));",
			"}",

			"//focal plane calculation",

			"float fDepth = focalDepth;",

			"if (autofocus) {",

				"fDepth = linearize(texture2D(tDepth,focusCoords).x);",

			"}",

			"// dof blur factor calculation",

			"float blur = 0.0;",

			"if (manualdof) {",
				"float a = depth-fDepth; // Focal plane",
				"float b = (a-fdofstart)/fdofdist; // Far DoF",
				"float c = (-a-ndofstart)/ndofdist; // Near Dof",
				"blur = (a>0.0) ? b : c;",
			"} else {",
				"float f = focalLength; // focal length in mm",
				"float d = fDepth*1000.0; // focal plane in mm",
				"float o = depth*1000.0; // depth in mm",

				"float a = (o*f)/(o-f);",
				"float b = (d*f)/(d-f);",
				"float c = (d-f)/(d*fstop*CoC);",

				"blur = abs(a-b)*c;",
			"}",

			"blur = clamp(blur,0.0,1.0);",

			"// calculation of pattern for dithering",

			"vec2 noise = rand(vUv.xy)*namount*blur;",

			"// getting blur x and y step factor",

			"float w = (1.0/width)*blur*maxblur+noise.x;",
			"float h = (1.0/height)*blur*maxblur+noise.y;",

			"// calculation of final color",

			"vec3 col = vec3(0.0);",

			"if(blur < 0.05) {",
				"//some optimization thingy",
				"col = texture2D(tColor, vUv.xy).rgb;",
			"} else {",
				"col = texture2D(tColor, vUv.xy).rgb;",
				"float s = 1.0;",
				"int ringsamples;",

				"for (int i = 1; i <= rings; i++) {",
					"/*unboxstart*/",
					"ringsamples = i * samples;",

					"for (int j = 0 ; j < maxringsamples ; j++) {",
						"if (j >= ringsamples) break;",
						"s += gather(float(i), float(j), ringsamples, col, w, h, blur);",
					"}",
					"/*unboxend*/",
				"}",

				"col /= s; //divide by sample count",
			"}",

			"if (showFocus) {",
				"col = debugFocus(col, blur, depth);",
			"}",

			"if (vignetting) {",
				"col *= vignette();",
			"}",

			"gl_FragColor.rgb = col;",
			"gl_FragColor.a = 1.0;",
		"} "

	].join("\n")

};
});

define('VeroldEngine/libs/three/shaders/BrightnessContrastShader',['three'], function(THREE) {
/**
 * @author tapio / http://tapio.github.com/
 *
 * Brightness and contrast adjustment
 * https://github.com/evanw/glfx.js
 * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)
 * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */

THREE.BrightnessContrastShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"brightness": { type: "f", value: 0 },
		"contrast":   { type: "f", value: 0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float brightness;",
		"uniform float contrast;",

		"varying vec2 vUv;",

		"void main() {",

			"gl_FragColor = texture2D( tDiffuse, vUv );",

			"gl_FragColor.rgb += brightness;",

			"if (contrast > 0.0) {",
				"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;",
			"} else {",
				"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;",
			"}",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/ColorCorrectionShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Color correction
 */

THREE.ColorCorrectionShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"powRGB":   { type: "v3", value: new THREE.Vector3( 2, 2, 2 ) },
		"mulRGB":   { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec3 powRGB;",
		"uniform vec3 mulRGB;",

		"varying vec2 vUv;",

		"void main() {",

			"gl_FragColor = texture2D( tDiffuse, vUv );",
			"gl_FragColor.rgb = mulRGB * pow( gl_FragColor.rgb, powRGB );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/ColorifyShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Colorify shader
 */

THREE.ColorifyShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"color":    { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform vec3 color;",
		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",

			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",
			"float v = dot( texel.xyz, luma );",

			"gl_FragColor = vec4( v * color, texel.w );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/ConvolutionShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */

THREE.ConvolutionShader = {

	defines: {

		"KERNEL_SIZE_FLOAT": "25.0",
		"KERNEL_SIZE_INT": "25",

	},

	uniforms: {

		"tDiffuse":        { type: "t", value: null },
		"uImageIncrement": { type: "v2", value: new THREE.Vector2( 0.001953125, 0.0 ) },
		"cKernel":         { type: "fv1", value: [] }

	},

	vertexShader: [

		"uniform vec2 uImageIncrement;",

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float cKernel[ KERNEL_SIZE_INT ];",

		"uniform sampler2D tDiffuse;",
		"uniform vec2 uImageIncrement;",

		"varying vec2 vUv;",

		"void main() {",

			"vec2 imageCoord = vUv;",
			"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );",

			"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {",

				"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];",
				"imageCoord += uImageIncrement;",

			"}",

			"gl_FragColor = sum;",

		"}"


	].join("\n"),

	buildKernel: function ( sigma ) {

		// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.

		function gauss( x, sigma ) {

			return Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );

		}

		var i, values, sum, halfWidth, kMaxKernelSize = 49, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;

		if ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;
		halfWidth = ( kernelSize - 1 ) * 0.5;

		values = new Array( kernelSize );
		sum = 0.0;
		for ( i = 0; i < kernelSize; ++i ) {

			values[ i ] = gauss( i - halfWidth, sigma );
			sum += values[ i ];

		}

		// normalize the kernel

		for ( i = 0; i < kernelSize; ++i ) values[ i ] /= sum;

		return values;

	}

};
});
define('VeroldEngine/libs/three/shaders/CopyShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

THREE.CopyShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/ClampShader',['three'], function(THREE) {

THREE.ClampShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"threshold":   { type: "f", value: 0.8 },
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float threshold;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",

			// "vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			// "float v = dot( texel.xyz, luma );",
			// "vec3 normTex = normalize(texel.xyz);",

			"gl_FragColor.xyz = max( texel.xyz - threshold, 0.0 ) * 5.0;",
			"gl_FragColor.w = 1.0;",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/DOFMipMapShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Depth-of-field shader using mipmaps
 * - from Matt Handley @applmak
 * - requires power-of-2 sized render target with enabled mipmaps
 */

THREE.DOFMipMapShader = {

	uniforms: {

		"tColor":   { type: "t", value: null },
		"tDepth":   { type: "t", value: null },
		"focus":    { type: "f", value: 1.0 },
		"maxblur":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float focus;",
		"uniform float maxblur;",

		"uniform sampler2D tColor;",
		"uniform sampler2D tDepth;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 depth = texture2D( tDepth, vUv );",

			"float factor = depth.x - focus;",

			"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );",

			"gl_FragColor = col;",
			"gl_FragColor.a = 1.0;",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/DotScreenShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Dot screen shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

THREE.DotScreenShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"tSize":    { type: "v2", value: new THREE.Vector2( 256, 256 ) },
		"center":   { type: "v2", value: new THREE.Vector2( 0.5, 0.5 ) },
		"angle":    { type: "f", value: 1.57 },
		"scale":    { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform vec2 center;",
		"uniform float angle;",
		"uniform float scale;",
		"uniform vec2 tSize;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"float pattern() {",

			"float s = sin( angle ), c = cos( angle );",

			"vec2 tex = vUv * tSize - center;",
			"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;",

			"return ( sin( point.x ) * sin( point.y ) ) * 4.0;",

		"}",

		"void main() {",

			"vec4 color = texture2D( tDiffuse, vUv );",

			"float average = ( color.r + color.g + color.b ) / 3.0;",

			"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/EdgeShader',['three'], function(THREE) {
/**
 * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog
 *
 * Edge Detection Shader using Frei-Chen filter
 * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector
 *
 * aspect: vec2 of (1/width, 1/height)
 */

THREE.EdgeShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"aspect":    { type: "v2", value: new THREE.Vector2( 512, 512 ) },
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",

		"uniform vec2 aspect;",

		"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",


		"mat3 G[9];",

		// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45

		"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );",
		"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );",
		"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );",
		"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );",
		"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );",
		"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );",
		"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );",
		"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );",
		"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );",

		"void main(void)",
		"{",

			"G[0] = g0,",
			"G[1] = g1,",
			"G[2] = g2,",
			"G[3] = g3,",
			"G[4] = g4,",
			"G[5] = g5,",
			"G[6] = g6,",
			"G[7] = g7,",
			"G[8] = g8;",

			"mat3 I;",
			"float cnv[9];",
			"vec3 sample;",

			/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
			"for (float i=0.0; i<3.0; i++) {",
				"for (float j=0.0; j<3.0; j++) {",
					"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
					"I[int(i)][int(j)] = length(sample);",
				"}",
			"}",

			/* calculate the convolution values for all the masks */
			"for (int i=0; i<9; i++) {",
				"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
				"cnv[i] = dp3 * dp3;",
			"}",

			"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);",
			"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);",

			"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);",
		"}",

	].join("\n")
};
});

define('VeroldEngine/libs/three/shaders/EdgeShader2',['three'], function(THREE) {
/**
 * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog
 *
 * Edge Detection Shader using Sobel filter
 * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector
 *
 * aspect: vec2 of (1/width, 1/height)
 */

THREE.EdgeShader2 = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"aspect":    { type: "v2", value: new THREE.Vector2( 512, 512 ) },
		"colour":    { type: "c", value: new THREE.Color( 0xffffff ) },
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",
		"uniform vec2 aspect;",
		"uniform vec3 colour;",


		"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",

		"mat3 G[2];",

		"const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );",
		"const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );",


		"void main(void)",
		"{",
			"mat3 I;",
			"float cnv[2];",
			"vec3 sample;",

			"G[0] = g0;",
			"G[1] = g1;",

			/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
			// "for (float i=0.0; i<3.0; i++) {",
			// 	"for (float j=0.0; j<3.0; j++) {",
			// 		"sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
			// 		"I[int(i)][int(j)] = length(sample);",
			// 	"}",
			// "}",

			//OSX Yosemite with AMD cards seems to have trouble with the above loop. Unrolling...
			"I[0][0] = length(texture2D( tDiffuse, vUv + texel * vec2(-1.0,-1.0) ).rgb);",
			"I[0][1] = length(texture2D( tDiffuse, vUv + texel * vec2(-1.0,0.0) ).rgb);",
			"I[0][2] = length(texture2D( tDiffuse, vUv + texel * vec2(-1.0,1.0) ).rgb);",
			"I[1][0] = length(texture2D( tDiffuse, vUv + texel * vec2(0.0,-1.0) ).rgb);",
			"I[1][1] = length(texture2D( tDiffuse, vUv + texel * vec2(0.0,0.0) ).rgb);",
			"I[1][2] = length(texture2D( tDiffuse, vUv + texel * vec2(0.0,1.0) ).rgb);",
			"I[2][0] = length(texture2D( tDiffuse, vUv + texel * vec2(1.0,-1.0) ).rgb);",
			"I[2][1] = length(texture2D( tDiffuse, vUv + texel * vec2(1.0,0.0) ).rgb);",
			"I[2][2] = length(texture2D( tDiffuse, vUv + texel * vec2(1.0,1.0) ).rgb);",


			/* calculate the convolution values for all the masks */
			"for (int i=0; i<2; i++) {",
				"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
				"cnv[i] = dp3 * dp3; ",
			"}",

			"gl_FragColor = vec4(colour, sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));",
		"} ",

	].join("\n")

};
});

define('VeroldEngine/libs/three/shaders/FilmShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Film grain & scanlines shader
 *
 * - ported from HLSL to WebGL / GLSL
 * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html
 *
 * Screen Space Static Postprocessor
 *
 * Produces an analogue noise overlay similar to a film grain / TV static
 *
 * Original implementation and noise algorithm
 * Pat 'Hawthorne' Shearon
 *
 * Optimized scanlines + noise version with intensity scaling
 * Georg 'Leviathan' Steinrohder
 *
 * This version is provided under a Creative Commons Attribution 3.0 License
 * http://creativecommons.org/licenses/by/3.0/
 */

THREE.FilmShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"time":       { type: "f", value: 0.0 },
		"nIntensity": { type: "f", value: 0.5 },
		"sIntensity": { type: "f", value: 0.05 },
		"sCount":     { type: "f", value: 4096 },
		"grayscale":  { type: "i", value: 1 },

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		// control parameter
		"uniform float time;",

		"uniform bool grayscale;",

		// noise effect intensity value (0 = no effect, 1 = full effect)
		"uniform float nIntensity;",

		// scanlines effect intensity value (0 = no effect, 1 = full effect)
		"uniform float sIntensity;",

		// scanlines effect count value (0 = no effect, 4096 = full effect)
		"uniform float sCount;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			// sample the source
			"vec4 cTextureScreen = texture2D( tDiffuse, vUv );",

			// make some noise
			"float x = vUv.x * vUv.y * time *  1000.0;",
			"x = mod( x, 13.0 ) * mod( x, 123.0 );",
			"float dx = mod( x, 0.01 );",

			// add noise
			"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );",

			// get us a sine and cosine
			"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );",

			// add scanlines
			"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;",

			// interpolate between source and result by intensity
			"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );",

			// convert to grayscale if desired
			"if( grayscale ) {",

				"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );",

			"}",

			"gl_FragColor =  vec4( cResult, cTextureScreen.a );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/FocusShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Focus shader
 * based on PaintEffect postprocess from ro.me
 * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

THREE.FocusShader = {

	uniforms : {

		"tDiffuse":       { type: "t", value: null },
		"screenWidth":    { type: "f", value: 1024 },
		"screenHeight":   { type: "f", value: 1024 },
		"sampleDistance": { type: "f", value: 0.94 },
		"waveFactor":     { type: "f", value: 0.00125 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float screenWidth;",
		"uniform float screenHeight;",
		"uniform float sampleDistance;",
		"uniform float waveFactor;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 color, org, tmp, add;",
			"float sample_dist, f;",
			"vec2 vin;",
			"vec2 uv = vUv;",

			"add = color = org = texture2D( tDiffuse, uv );",

			"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );",
			"sample_dist = dot( vin, vin ) * 2.0;",

			"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;",

			"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );",
			"if( tmp.b < color.b ) color = tmp;",

			"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );",
			"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );",

			"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );",

		"}"


	].join("\n")
};
});
define('VeroldEngine/libs/three/shaders/FresnelShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Based on Nvidia Cg tutorial
 */

THREE.FresnelShader = {

	uniforms: {

		"mRefractionRatio": { type: "f", value: 1.02 },
		"mFresnelBias": { type: "f", value: 0.1 },
		"mFresnelPower": { type: "f", value: 2.0 },
		"mFresnelScale": { type: "f", value: 1.0 },
		"tCube": { type: "t", value: null }

	},

	vertexShader: [

		"uniform float mRefractionRatio;",
		"uniform float mFresnelBias;",
		"uniform float mFresnelScale;",
		"uniform float mFresnelPower;",

		"varying vec3 vReflect;",
		"varying vec3 vRefract[3];",
		"varying float vReflectionFactor;",

		"void main() {",

			"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
			"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

			"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );",

			"vec3 I = worldPosition.xyz - cameraPosition;",

			"vReflect = reflect( I, worldNormal );",
			"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );",
			"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );",
			"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );",
			"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );",

			"gl_Position = projectionMatrix * mvPosition;",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform samplerCube tCube;",

		"varying vec3 vReflect;",
		"varying vec3 vRefract[3];",
		"varying float vReflectionFactor;",

		"void main() {",

			"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",
			"vec4 refractedColor = vec4( 1.0 );",

			"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;",
			"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;",
			"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;",

			"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );",

		"}"

	].join("\n")

};
});

define('VeroldEngine/libs/three/shaders/FXAAShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 * @author davidedc / http://www.sketchpatch.net/
 *
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

THREE.FXAAShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec2 resolution;",

		"varying vec2 vUv;",

		"#define FXAA_REDUCE_MIN   (1.0/128.0)",
		"#define FXAA_REDUCE_MUL   (1.0/8.0)",
		"#define FXAA_SPAN_MAX     8.0",

		"void main() {",

			"vec3 rgbNW = clamp( texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz, 0.0, 1.0);",
			"vec3 rgbNE = clamp( texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz, 0.0, 1.0);",
			"vec3 rgbSW = clamp( texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz, 0.0, 1.0);",
			"vec3 rgbSE = clamp( texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz, 0.0, 1.0);",
			"vec4 rgbaM  = clamp( texture2D( tDiffuse,  gl_FragCoord.xy  * resolution ), 0.0, 1.0);",
			"vec3 rgbM  = rgbaM.xyz;",
			"float opacity  = rgbaM.w;",

			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float lumaNW = dot( rgbNW, luma );",
			"float lumaNE = dot( rgbNE, luma );",
			"float lumaSW = dot( rgbSW, luma );",
			"float lumaSE = dot( rgbSE, luma );",
			"float lumaM  = dot( rgbM,  luma );",
			"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
			"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",

			"vec2 dir;",
			"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
			"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",

			"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",

			"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
			"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
				  "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
						"dir * rcpDirMin)) * resolution;",

			"vec3 rgbA = 0.5 * (",
				"clamp( texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz, 0.0, 1.0) +",
				"clamp( texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz, 0.0, 1.0) );",

			"vec3 rgbB = rgbA * 0.5 + 0.25 * (",
				"clamp( texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz, 0.0, 1.0) +",
				"clamp( texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz, 0.0, 1.0) );",

			"float lumaB = dot( rgbB, luma );",

			"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",

				"gl_FragColor = vec4( rgbA, opacity );",

			"} else {",

				"gl_FragColor = vec4( rgbB, opacity );",

			"}",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/GammaShader',['three'], function(THREE) {
/**
 * @author miibond
 *
 * Full-screen gamma-correction
 */

THREE.GammaShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
	},

	defines: {
		"GAMMA_VALUE" : 2.0,
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"#if !defined(GAMMA_VALUE)",
			"#define GAMMA_VALUE 0.5",
		"#endif",

		"uniform sampler2D tDiffuse;",
		
		"varying vec2 vUv;",

		THREE.ShaderChunk['hdr_decode_pars_fragment'],
		THREE.ShaderChunk['hdr_encode_pars_fragment'],

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			
			"#if defined( HDR_INPUT ) && defined( HDR_INPUT_TYPE )",
				"#if ( HDR_INPUT_TYPE == HDR_TYPE_LOGLUV )",
					"gl_FragColor = vec4( HDRDecodeLOGLUV( texel ), 1.0 );",
				"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBM )",
					"gl_FragColor = vec4( HDRDecodeRGBM( texel ), 1.0 );",
				"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBD )",
					"gl_FragColor = vec4( HDRDecodeRGBD( texel ), 1.0 );",
				"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBE )",
					"gl_FragColor = vec4( HDRDecodeRGBE( texel ), 1.0 );",
				"#else",
					"gl_FragColor = texel;",
				"#endif",
			"#else",
				"gl_FragColor = texel;",
			"#endif",

			//Gamma 2.0
			// "#if ( GAMMA_VALUE == 2 )",
			// 	"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",
			// "#elif ( GAMMA_VALUE == 0.5 )",
				"gl_FragColor.xyz = gl_FragColor.xyz * gl_FragColor.xyz;",
			// "#else",
			// 	"gl_FragColor.xyz = pow( gl_FragColor.xyz, 1.0 / GAMMA_VALUE );",
			// "#endif",

		"}"

	].join("\n")

};

});
define('VeroldEngine/libs/three/shaders/HorizontalBlurShader',['three'], function(THREE) {
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

THREE.HorizontalBlurShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"h":        { type: "f", value: 1.0 / 512.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float h;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/HorizontalTiltShiftShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 * - "r" parameter control where "focused" horizontal line lies
 */

THREE.HorizontalTiltShiftShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"h":        { type: "f", value: 1.0 / 512.0 },
		"r":        { type: "f", value: 0.35 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float h;",
		"uniform float r;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"float hh = h * abs( r - vUv.y );",

			"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/HueSaturationShader',['three'], function(THREE) {
/**
 * @author tapio / http://tapio.github.com/
 *
 * Hue and saturation adjustment
 * https://github.com/evanw/glfx.js
 * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.
 * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)
 */

THREE.HueSaturationShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"hue":        { type: "f", value: 0 },
		"saturation": { type: "f", value: 0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float hue;",
		"uniform float saturation;",

		"varying vec2 vUv;",

		"void main() {",

			"gl_FragColor = texture2D( tDiffuse, vUv );",

			// hue
			"float angle = hue * 3.14159265;",
			"float s = sin(angle), c = cos(angle);",
			"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;",
			"float len = length(gl_FragColor.rgb);",
			"gl_FragColor.rgb = vec3(",
				"dot(gl_FragColor.rgb, weights.xyz),",
				"dot(gl_FragColor.rgb, weights.zxy),",
				"dot(gl_FragColor.rgb, weights.yzx)",
			");",

			// saturation
			"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;",
			"if (saturation > 0.0) {",
				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));",
			"} else {",
				"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);",
			"}",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/KaleidoShader',['three'], function(THREE) {
/**
 * @author felixturner / http://airtight.cc/
 *
 * Kaleidoscope Shader
 * Radial reflection around center point
 * Ported from: http://pixelshaders.com/editor/
 * by Toby Schachman / http://tobyschachman.com/
 *
 * sides: number of reflections
 * angle: initial angle in radians
 */

THREE.KaleidoShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"sides":    { type: "f", value: 6.0 },
		"angle":    { type: "f", value: 0.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float sides;",
		"uniform float angle;",
		
		"varying vec2 vUv;",

		"void main() {",

			"vec2 p = vUv - 0.5;",
			"float r = length(p);",
			"float a = atan(p.y, p.x) + angle;",
			"float tau = 2. * 3.1416 ;",
			"a = mod(a, tau/sides);",
			"a = abs(a - tau/sides/2.) ;",
			"p = r * vec2(cos(a), sin(a));",
			"vec4 color = texture2D(tDiffuse, p + 0.5);",
			"gl_FragColor = color;",

		"}"

	].join("\n")

};
});

define('VeroldEngine/libs/three/shaders/LuminosityShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Luminosity
 * http://en.wikipedia.org/wiki/Luminosity
 */

THREE.LuminosityShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"maxLuminance": { type: "f", value: 100.0 }
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"#ifdef MAX_LUMINANCE",
			"uniform float maxLuminance;",
		"#endif",

		"varying vec2 vUv;",

		THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],
		THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			
			"#if defined( HDR_INPUT ) && defined( HDR_INPUT_TYPE )",
				"#if ( HDR_INPUT_TYPE == HDR_TYPE_LOGLUV )",
					"texel.xyz = HDRDecodeLOGLUV( texel );",
				"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBM )",
					"texel.xyz = HDRDecodeRGBM( texel );",
				"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBD )",
					"texel.xyz = HDRDecodeRGBD( texel );",
				"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBE )",
					"texel.xyz = HDRDecodeRGBE( texel );",
				"#endif",
			"#endif",

			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float v = dot( texel.xyz, luma );",

			"#ifdef MAX_LUMINANCE",
				"v = clamp( v, 0.0, maxLuminance );",
			"#endif",
			"gl_FragColor = vec4( v, v, v, texel.w );",

			THREE.ShaderChunk[ "hdr_encode_fragment" ],

		"}"

	].join("\n")

};

});
define('VeroldEngine/libs/three/shaders/MirrorShader',['three'], function(THREE) {
/**
 * @author felixturner / http://airtight.cc/
 *
 * Mirror Shader
 * Copies half the input to the other half
 *
 * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)
 */

THREE.MirrorShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"side":     { type: "i", value: 1 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform int side;",
		
		"varying vec2 vUv;",

		"void main() {",

			"vec2 p = vUv;",
			"if (side == 0){",
				"if (p.x > 0.5) p.x = 1.0 - p.x;",
			"}else if (side == 1){",
				"if (p.x < 0.5) p.x = 1.0 - p.x;",
			"}else if (side == 2){",
				"if (p.y < 0.5) p.y = 1.0 - p.y;",
			"}else if (side == 3){",
				"if (p.y > 0.5) p.y = 1.0 - p.y;",
			"} ",
			"vec4 color = texture2D(tDiffuse, p);",
			"gl_FragColor = color;",

		"}"

	].join("\n")

};
});

define('VeroldEngine/libs/three/shaders/NormalMapShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Normal map shader
 * - compute normals from heightmap
 */

THREE.NormalMapShader = {

	uniforms: {

		"heightMap":  { type: "t", value: null },
		"resolution": { type: "v2", value: new THREE.Vector2( 512, 512 ) },
		"scale":      { type: "v2", value: new THREE.Vector2( 1, 1 ) },
		"height":     { type: "f", value: 0.05 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float height;",
		"uniform vec2 resolution;",
		"uniform sampler2D heightMap;",

		"varying vec2 vUv;",

		"void main() {",

			"float val = texture2D( heightMap, vUv ).x;",

			"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;",
			"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;",

			"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/RGBShiftShader',['three'], function(THREE) {
/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

THREE.RGBShiftShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"amount":   { type: "f", value: 0.005 },
		"angle":    { type: "f", value: 0.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float amount;",
		"uniform float angle;",

		"varying vec2 vUv;",

		"void main() {",

			"vec2 offset = amount * vec2( cos(angle), sin(angle));",
			"vec4 cr = texture2D(tDiffuse, vUv + offset);",
			"vec4 cga = texture2D(tDiffuse, vUv);",
			"vec4 cb = texture2D(tDiffuse, vUv - offset);",
			"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",

		"}"

	].join("\n")

};
});

define('VeroldEngine/libs/three/shaders/SepiaShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Sepia tone shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

THREE.SepiaShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"amount":   { type: "f", value: 1.0 },
		"opacity": { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float amount;",
		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 color = texture2D( tDiffuse, vUv );",
			"vec3 c = color.rgb;",

			"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );",
			"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );",
			"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );",

			"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), opacity * color.a );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/SSAOShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Screen-space ambient occlusion shader
 * - ported from
 *   SSAO GLSL shader v1.2
 *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)
 *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)
 * - modifications
 * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)
 * - refactoring and optimizations
 */

THREE.SSAOShader = {

	uniforms: //THREE.UniformsUtils.merge( [
		// THREE.UniformsLib[ "fog" ],
		{

		"tDiffuse":     { type: "t", value: null },
		"tDepth":       { type: "t", value: null },
		"size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
		"cameraNear":   { type: "f", value: 1 },
		"cameraFar":    { type: "f", value: 100 },
		"onlyAO":       { type: "i", value: 0 },
		"aoClamp":      { type: "f", value: 0.5 },
		"lumInfluence": { type: "f", value: 0.5 },
		"noiseAmount": { type: "f", value: 0.0003 },
		"radius": { type: "f", value: 5.0 },
		"diffArea": { type: "f", value: 0.4 },
		"gDisplace": { type: "f", value: 0.4 },
		"fogEnabled": { type: "i", value: 1 },
		"fogDensity": { type: "f", value: 0.0025 },
		"depthScale": { type: "f", value: 1000.0 },
		"opacity": { type: "f", value: 1.0 }
	},
		// ] ),
	

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		//THREE.ShaderChunk['fog_pars_fragment'],
		"uniform int fogEnabled;",
		"uniform float fogDensity;",
		"uniform float depthScale;",
		// "uniform float fogFar;",
		"uniform float cameraNear;",
		"uniform float cameraFar;",

		"uniform bool onlyAO;",      // use only ambient occlusion pass?

		"uniform vec2 size;",        // texture width, height
		"uniform float aoClamp;",    // depth clamp - reduces haloing at screen edges

		"uniform float lumInfluence;",  // how much luminance affects occlusion

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDepth;",

		"varying vec2 vUv;",

		// "#define PI 3.14159265",
		"#define DL 2.399963229728653",  // PI * ( 3.0 - sqrt( 5.0 ) )
		"#define EULER 2.718281828459045",

		// helpers

		"float width = size.x;",   // texture width
		"float height = size.y;",  // texture height

		"float cameraFarPlusNear = cameraFar + cameraNear;",
		"float cameraFarMinusNear = cameraFar - cameraNear;",
		"float cameraCoef = 2.0 * cameraNear;",

		// user variables

		"const int samples = 16;",     // ao sample count
		"uniform float radius;",  // ao radius

		"const bool useNoise = true;",      // use noise instead of pattern for sample dithering
		"uniform float noiseAmount;", // dithering amount

		"uniform float diffArea;",   // self-shadowing reduction
		"uniform float gDisplace;",  // gauss bell center
		"uniform float opacity;",


		// RGBA depth

		"float unpackDepth( const in vec4 rgba_depth ) {",

			"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"float depth = dot( rgba_depth, bit_shift );",
			"return depth;",

		"}",

		// generating noise / pattern texture for dithering

		"vec2 rand( const vec2 coord ) {",

			"vec2 noise;",

			"if ( useNoise ) {",

				"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
				"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );",

				"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",

			"} else {",

				"float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );",
				"float gg = fract( coord.t * ( height / 2.0 ) );",

				"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",

			"}",

			"return ( noise * 2.0  - 1.0 ) * noiseAmount;",

		"}",

		// "#ifdef USE_FOG",
		"float doFog() {",
			"float zdepth = unpackDepth( texture2D( tDepth, vUv ) );",
			"float depth = -cameraFar * cameraNear / ( zdepth * cameraFarMinusNear - cameraFar );",
			// "return smoothstep( fogNear, fogFar, depth );",


		// "	#ifdef USE_LOGDEPTHBUF_EXT",

		// "		float depth = gl_FragDepthEXT / gl_FragCoord.w;",

		// "	#else",

		// "		float depth = gl_FragCoord.z / gl_FragCoord.w;",

		// "	#endif",

		// "	#ifdef FOG_EXP2",
		"float depthShift = depth * 0.001;",
			  "float densityShift = fogDensity * 1000.0;",
					//const float LOG2 = 1.442695;
					"float fogFactor = 1.0 - clamp( 1.0 / exp( densityShift * densityShift * depthShift * depthShift ), 0.0, 1.0);",

		// "		const float LOG2 = 1.442695;",
		// "		float fogFactor = exp2( - fogDensity * fogDensity * zdepth * zdepth * LOG2 );",
		// "		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",

		// "	#else",

		// "		float fogFactor = smoothstep( fogNear, fogFar, depth );",

		// "	#endif",

		//"	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",
		"	return fogFactor;",

		"}",
		// "#endif",

		"float readDepth( const in vec2 coord ) {",

			// "return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );",
			"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );",


		"}",

		"float compareDepths( const in float depth1, const in float depth2, inout int far ) {",

			"float garea = 2.0;",                         // gauss bell width
			"float diff = ( depth1 - depth2 ) * depthScale;",  // depth difference (0-100)

			// reduce left bell width to avoid self-shadowing

			"if ( diff < gDisplace ) {",

				"garea = diffArea;",

			"} else {",

				"far = 1;",

			"}",

			"float dd = diff - gDisplace;",
			"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );",
			"return gauss;",

		"}",

		"float calcAO( float depth, float dw, float dh ) {",

			"float dd = radius - depth * radius;",
			"vec2 vv = vec2( dw, dh );",

			"vec2 coord1 = vUv + dd * vv;",
			"vec2 coord2 = vUv - dd * vv;",

			"float temp1 = 0.0;",
			"float temp2 = 0.0;",

			"int far = 0;",
			"temp1 = compareDepths( depth, readDepth( coord1 ), far );",

			// DEPTH EXTRAPOLATION

			"if ( far > 0 ) {",

				"temp2 = compareDepths( readDepth( coord2 ), depth, far );",
				"temp1 += ( 1.0 - temp1 ) * temp2;",

			"}",

			"return temp1;",

		"}",

		"void main() {",

			"vec2 noise = rand( vUv );",
			"float depth = readDepth( vUv );",

			"float tt = clamp( depth, aoClamp, 1.0 );",

			"float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );",
			"float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );",

			"float ao = 0.0;",

			"float dz = 1.0 / float( samples );",
			"float z = 1.0 - dz / 2.0;",
			"float l = 0.0;",

			"for ( int i = 0; i <= samples; i ++ ) {",

				"float r = sqrt( 1.0 - z );",

				"float pw = cos( l ) * r;",
				"float ph = sin( l ) * r;",
				"ao += calcAO( depth, pw * w, ph * h );",
				"z = z - dz;",
				"l = l + DL;",

			"}",

			"ao /= float( samples );",
			"ao = 1.0 - ao;",
			"if ( fogEnabled == 1 ) {",
				"ao = mix( ao, 1.0, doFog() );",
			"}",

			"vec3 color = texture2D( tDiffuse, vUv ).rgb;",

			"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );",
			"float lum = dot( color.rgb, lumcoeff );",
			"vec3 luminance = vec3( lum );",

			"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // mix( color * ao, white, luminance )

			"if ( onlyAO ) {",

				"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // ambient occlusion only

			"}",

			"gl_FragColor = vec4( final, opacity );",

		"}"

	].join("\n")

};
});

define('VeroldEngine/libs/three/shaders/TriangleBlurShader',['three'], function(THREE) {
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Triangle blur shader
 * based on glfx.js triangle blur shader
 * https://github.com/evanw/glfx.js
 *
 * A basic blur filter, which convolves the image with a
 * pyramid filter. The pyramid filter is separable and is applied as two
 * perpendicular triangle filters.
 */

THREE.TriangleBlurShader = {

	uniforms : {

		"texture": { type: "t", value: null },
		"delta":   { type: "v2", value:new THREE.Vector2( 1, 1 )  }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"#define ITERATIONS 10.0",

		"uniform sampler2D texture;",
		"uniform vec2 delta;",

		"varying vec2 vUv;",

		"float random( vec3 scale, float seed ) {",

			// use the fragment position for a different seed per-pixel

			"return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed );",

		"}",

		"void main() {",

			"vec4 color = vec4( 0.0 );",

			"float total = 0.0;",

			// randomize the lookup values to hide the fixed number of samples

			"float offset = random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );",

			"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {",

				"float percent = ( t + offset - 0.5 ) / ITERATIONS;",
				"float weight = 1.0 - abs( percent );",

				"color += texture2D( texture, vUv + delta * percent ) * weight;",
				"total += weight;",

			"}",

			"gl_FragColor = color / total;",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/ToneMapShader',['three'], function(THREE) {
/**
 * @author miibond
 *
 * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf
 */

THREE.ToneMapShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"averageLuminance":  { type: "f", value: 1.0 },
		"luminanceMap":  { type: "t", value: null },
		"maxLuminance":  { type: "f", value: 16.0 },
		"exposureBias":  { type: "f", value: 0.6 },
		"maxLuminanceRT":  { type: "t", value: null },
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"#ifdef ADAPT_WHITE_BALANCE",
			"uniform sampler2D maxLuminanceRT;",
		"#else",
			"uniform float maxLuminance;",
		"#endif",

		"varying vec2 vUv;",

		"uniform float exposureBias;",
		
		"#ifdef SAMPLE_LUMINANCE",
			"uniform sampler2D luminanceMap;",
		"#else",
			"uniform float averageLuminance;",
		"#endif",

		THREE.ShaderChunk['hdr_decode_pars_fragment'],
		THREE.ShaderChunk['hdr_encode_pars_fragment'],

		// #ifdef FILMIC_UC2
		// From Uncharted 2 - http://www.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting
			"uniform float whiteScale;",
			"const float A = 0.15;",// A = Shoulder Strength
	    "const float B = 0.50;",// B = Linear Strength
	    "const float C = 0.10;",// C = Linear Angle
	    "const float D = 0.20;",// D = Toe Strength
	    "const float E = 0.02;",// E = Toe Numerator
	    "const float F = 0.30;",// F = Toe Denominator

	    "vec3 UC2Tonemap( vec3 x ) {",
	      "return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;",
	    "}",
	  // #endif
		
		"const vec3 LUM_CONVERT = vec3(0.299, 0.587, 0.114);",

		"vec3 ToneMap( vec3 vColor ) {",
			"#ifdef SAMPLE_LUMINANCE",
				// Get the calculated average luminance 
				"vec4 lumAvg = texture2D(luminanceMap, vUv);",
				"float fLumAvg = lumAvg.r;",
				"#if defined( HDR_INPUT ) && defined( HDR_INPUT_TYPE )",
					"#if ( HDR_INPUT_TYPE == HDR_TYPE_LOGLUV )",
						"fLumAvg = HDRDecodeLOGLUV( lumAvg ).r;",
					"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBM )",
						"fLumAvg = HDRDecodeRGBM( lumAvg ).r;",
					"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBD )",
						"fLumAvg = HDRDecodeRGBD( lumAvg ).r;",
					"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBE )",
						"fLumAvg = HDRDecodeRGBE( lumAvg ).r;",
					"#endif",
				"#endif",
			"#else",
				"float fLumAvg = averageLuminance;",
			"#endif",
			
			// "#if defined( FILMIC_UC2 )",
			"#ifdef ADAPT_WHITE_BALANCE",
				"vec3 maxLum = texture2D( maxLuminanceRT, vUv ).rgb;",
				"vec3 white = 1.0 / UC2Tonemap( maxLum );",
			"#else",
				"vec3 white = vec3(maxLuminance);",
			"#endif",
      // "maxLum = log2( maxLum * 1.5 + 3.5 );",
      // "vColor *= vec3( 16.0 );",
			"vec3 curr = UC2Tonemap( (exposureBias / (fLumAvg + 0.025)) * vColor );",
			// "vec3 curr = UC2Tonemap( exposureBias * vColor );",
			// "vec3 whiteScale = 1.0 / UC2Tonemap(white);",
			
			"return curr * white;",
            
			// "#else",//Reinhard Tonemapping
			// 	// Calculate the luminance of the current pixel
			// 	"float fLumPixel = dot(vColor, LUM_CONVERT);",

			// 	// Apply the modified operator (Eq. 4)
			// 	"float fLumScaled = (fLumPixel * exposureBias) / fLumAvg;",

			// 	"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);",
			// 	"return fLumCompressed * vColor;",
			// "#endif",
		"}",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			
			"#if defined( HDR_INPUT ) && defined( HDR_INPUT_TYPE )",
				"#if ( HDR_INPUT_TYPE == HDR_TYPE_LOGLUV )",
					"gl_FragColor = vec4( ToneMap( HDRDecodeLOGLUV( texel ) ), 1.0 );",
				"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBM )",
					"gl_FragColor = vec4( ToneMap( HDRDecodeRGBM( texel ) ), 1.0 );",
				"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBD )",
					"gl_FragColor = vec4( ToneMap( HDRDecodeRGBD( texel ) ), 1.0 );",
				"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBE )",
					"gl_FragColor = vec4( ToneMap( HDRDecodeRGBE( texel ) ), 1.0 );",
				"#else",
					"gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );",
				"#endif",
			"#else",
				"gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );",
			"#endif",

			//Gamma 2.0
			"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",

		"}"

	].join("\n")

};

});
define('VeroldEngine/libs/three/shaders/UnpackDepthRGBAShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Unpack RGBA depth shader
 * - show RGBA encoded depth as monochrome color
 */

THREE.UnpackDepthRGBAShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		// RGBA depth

		"float unpackDepth( const in vec4 rgba_depth ) {",

			"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"float depth = dot( rgba_depth, bit_shift );",
			"return depth;",

		"}",

		"void main() {",

			"float depth = 1.0 - unpackDepth( texture2D( tDiffuse, vUv ) );",
			"gl_FragColor = opacity * vec4( vec3( depth ), 1.0 );",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/VerticalBlurShader',['three'], function(THREE) {
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
 * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/
 *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 */

THREE.VerticalBlurShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"v":        { type: "f", value: 1.0 / 512.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float v;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/VerticalTiltShiftShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position
 *
 * - 9 samples per pass
 * - standard deviation 2.7
 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
 * - "r" parameter control where "focused" horizontal line lies
 */

THREE.VerticalTiltShiftShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"v":        { type: "f", value: 1.0 / 512.0 },
		"r":        { type: "f", value: 0.35 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float v;",
		"uniform float r;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 sum = vec4( 0.0 );",

			"float vv = v * abs( r - vUv.y );",

			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;",
			"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;",

			"gl_FragColor = sum;",

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/shaders/VignetteShader',['three'], function(THREE) {
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Vignette shader
 * based on PaintEffect postprocess from ro.me
 * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js
 */

THREE.VignetteShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"offset":   { type: "f", value: 1.0 },
		"darkness": { type: "f", value: 1.0 },
		"opacity": { type: "f", value: 1.0 }
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float offset;",
		"uniform float darkness;",
		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			// Eskil's vignette

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );",
			"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a * opacity );",

			/*
			// alternative version from glfx.js
			// this one makes more "dusty" look (as opposed to "burned")

			"vec4 color = texture2D( tDiffuse, vUv );",
			"float dist = distance( vUv, vec2( 0.5 ) );",
			"color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );",
			"gl_FragColor = color;",
			*/

		"}"

	].join("\n")

};
});
define('VeroldEngine/libs/three/postprocessing/ShaderPass',['three'
	, 'VeroldEngine/libs/three/shaders/BasicShader'
	, 'VeroldEngine/libs/three/shaders/BilinearMipmapShader'
	, 'VeroldEngine/libs/three/shaders/BleachBypassShader'
	, 'VeroldEngine/libs/three/shaders/BlendShader'
	, 'VeroldEngine/libs/three/shaders/BokehShader'
	, 'VeroldEngine/libs/three/shaders/BokehShader2'
	, 'VeroldEngine/libs/three/shaders/BrightnessContrastShader'
	, 'VeroldEngine/libs/three/shaders/ColorCorrectionShader'
	, 'VeroldEngine/libs/three/shaders/ColorifyShader'
	, 'VeroldEngine/libs/three/shaders/ConvolutionShader'
	, 'VeroldEngine/libs/three/shaders/CopyShader'
	, 'VeroldEngine/libs/three/shaders/ClampShader'
	, 'VeroldEngine/libs/three/shaders/DOFMipMapShader'
	, 'VeroldEngine/libs/three/shaders/DotScreenShader'
	, 'VeroldEngine/libs/three/shaders/EdgeShader'
	, 'VeroldEngine/libs/three/shaders/EdgeShader2'
	, 'VeroldEngine/libs/three/shaders/FilmShader'
	, 'VeroldEngine/libs/three/shaders/FocusShader'
	, 'VeroldEngine/libs/three/shaders/FresnelShader'
	, 'VeroldEngine/libs/three/shaders/FXAAShader'
	, 'VeroldEngine/libs/three/shaders/GammaShader'
	, 'VeroldEngine/libs/three/shaders/HorizontalBlurShader'
	, 'VeroldEngine/libs/three/shaders/HorizontalTiltShiftShader'
	, 'VeroldEngine/libs/three/shaders/HueSaturationShader'
	, 'VeroldEngine/libs/three/shaders/KaleidoShader'
	, 'VeroldEngine/libs/three/shaders/LuminosityShader'
	, 'VeroldEngine/libs/three/shaders/MirrorShader'
	, 'VeroldEngine/libs/three/shaders/NormalMapShader'
	, 'VeroldEngine/libs/three/shaders/RGBShiftShader'
	, 'VeroldEngine/libs/three/shaders/SepiaShader'
	, 'VeroldEngine/libs/three/shaders/SSAOShader'
	, 'VeroldEngine/libs/three/shaders/TriangleBlurShader'
	, 'VeroldEngine/libs/three/shaders/ToneMapShader'
	, 'VeroldEngine/libs/three/shaders/UnpackDepthRGBAShader'
	, 'VeroldEngine/libs/three/shaders/VerticalBlurShader'
	, 'VeroldEngine/libs/three/shaders/VerticalTiltShiftShader'
	, 'VeroldEngine/libs/three/shaders/VignetteShader'], function(THREE) {
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.ShaderPass = function ( shader, textureID ) {

		this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		this.material = new THREE.ShaderMaterial( {
			blending: THREE.NormalBlending,
	transparent: true,
			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

		this.renderToScreen = false;

		this.enabled = true;
		this.needsSwap = true;
		this.clear = false;


		this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
		this.scene  = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
		this.scene.add( this.quad );

	};

	THREE.ShaderPass.prototype = {

		render: function ( renderer, writeBuffer, readBuffer, delta ) {

			if ( this.uniforms[ this.textureID ] ) {

				this.uniforms[ this.textureID ].value = readBuffer;

			}

			this.quad.material = this.material;

			if ( this.renderToScreen ) {
				var prevViewPort = renderer.getViewport();
				if ( this.viewPort ) {
					renderer.setViewport( this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height );
				}
				if ( this.clearColor || this.clearDepth ) {
					renderer.clear( !!this.clearColor, !!this.clearDepth, false );
				}
				renderer.render( this.scene, this.camera );
				if ( this.viewPort ) {
					renderer.setViewport( prevViewPort.x, prevViewPort.y, prevViewPort.width, prevViewPort.height );
				}

			} else if ( this.renderToTexture ) {
				// var prevViewPort = renderer.getViewport();
				// if ( this.viewPort ) {
				// 	renderer.setViewport( this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height );
				// }
				if ( this.clearColor || this.clearDepth ) {
					renderer.clear( this.clearColor, this.clearDepth, false );
				}
				renderer.render( this.scene, this.camera, this.renderToTexture );
				// if ( this.viewPort ) {
				// 	renderer.setViewport( prevViewPort.x, prevViewPort.y, prevViewPort.width, prevViewPort.height );
				// }

			} else {

				renderer.render( this.scene, this.camera, writeBuffer, this.clear );

			}

		},

		dispose: function() {
			this.quad.geometry.dispose();
			this.quad = undefined;
			this.camera = undefined;
			this.scene = undefined;
			this.material.dispose();
			this.material = undefined;
			this.uniforms = undefined;
		}

	};
});

define('VeroldEngine/libs/three/postprocessing/TexturePass',['three'], function(THREE) {
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	THREE.TexturePass = function ( texture, opacity ) {

		if ( THREE.CopyShader === undefined )
			console.error( "THREE.TexturePass relies on THREE.CopyShader" );

		var shader = THREE.CopyShader;

		this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

		this.uniforms[ "opacity" ].value = ( opacity !== undefined ) ? opacity : 1.0;
		this.uniforms[ "tDiffuse" ].value = texture;

		this.material = new THREE.ShaderMaterial( {

			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

		this.enabled = true;
		this.needsSwap = false;


		this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
		this.scene  = new THREE.Scene();

		this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
		this.scene.add( this.quad );

	};

	THREE.TexturePass.prototype = {

		render: function ( renderer, writeBuffer, readBuffer, delta ) {

			this.quad.material = this.material;

			renderer.render( this.scene, this.camera, readBuffer );

		}

	};
});

define('VeroldEngine/libs/three/postprocessing/AdaptiveToneMappingPass',['three'], function(THREE) {
/**
 * @author miibond
 * Generate a texture that represents the luminosity of the current scene, adapted over time
 * to simulate the optic nerve responding to the amount of light it is receiving.
 * Based on a GDC2007 presentation by Wolfgang Engel titled "Post-Processing Pipeline"
 *
 * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf
 */

THREE.AdaptiveToneMappingPass = function ( adaptive, resolution ) {

	this.resolution = ( resolution !== undefined ) ? resolution : 256;
	this.needsUpdate = true;
	this.adaptive = adaptive !== undefined? !!adaptive : true;
	this.needsManualDownSample = false;

	this.luminanceRT = null;
	this.previousLuminanceRT = null;
	this.currentLuminanceRT = null;
	this.currentLuminanceRTDownSampled = [];

	this.maxLuminanceRT = null;
	this.previousMaxLuminanceRT = null;
	this.currentMaxLuminanceRT = [];
		
	if ( THREE.CopyShader === undefined )
		console.error( "THREE.AdaptiveToneMappingPass relies on THREE.CopyShader" );

	var copyShader = THREE.CopyShader;

	this.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );

	this.materialCopy = new THREE.ShaderMaterial( {

		uniforms: this.copyUniforms,
		vertexShader: copyShader.vertexShader,
		fragmentShader: copyShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false,
		depthWrite: false,
	} );

	if ( THREE.LuminosityShader === undefined )
		console.error( "THREE.AdaptiveToneMappingPass relies on THREE.LuminosityShader" );

	this.materialLuminance = new THREE.ShaderMaterial( {

		uniforms: THREE.UniformsUtils.clone( THREE.LuminosityShader.uniforms ),
		vertexShader: THREE.LuminosityShader.vertexShader,
		fragmentShader: THREE.LuminosityShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false,
		depthWrite: false,
		name: "Luminance",
		defines: {"MAX_LUMINANCE": ""}
	} );

	this.adaptLuminanceShader = {
		defines: {
			"MIP_LEVEL_1X1" : Math.log2( this.resolution ).toFixed(1),
		},
		uniforms: {
			"lastLum": { type: "t", value: null },
			"currentLum": { type: "t", value: null },
			"delta": { type: 'f', value: 0.016 },
			"tau": { type: 'f', value: 1.0 }
		},
		vertexShader: [
			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"
		].join('\n'),
		fragmentShader: [
			"varying vec2 vUv;",

			"uniform sampler2D lastLum;",
			"uniform sampler2D currentLum;",
			"uniform float delta;",
			"uniform float tau;",
			THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],
			
			"void main() {",
			
				"vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );",
				"vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );",
				
				"#if defined( HDR_INPUT ) && defined( HDR_INPUT_TYPE )",
					"#if ( HDR_INPUT_TYPE == HDR_TYPE_LOGLUV )",
						"float fLastLum = HDRDecodeLOGLUV( lastLum ).r;",
						"float fCurrentLum = HDRDecodeLOGLUV( currentLum ).r;",
					"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBM )",
						"float fLastLum = HDRDecodeRGBM( lastLum ).r;",
						"float fCurrentLum = HDRDecodeRGBM( currentLum ).r;",
					"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBD )",
						"float fLastLum = HDRDecodeRGBD( lastLum ).r;",
						"float fCurrentLum = HDRDecodeRGBD( currentLum ).r;",
					"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBE )",
						"float fLastLum = HDRDecodeRGBE( lastLum ).r;",
						"float fCurrentLum = HDRDecodeRGBE( currentLum ).r;",
					"#else",
						"float fLastLum = lastLum.r;",
						"float fCurrentLum = currentLum.r;",
					"#endif",
				"#else",
						"float fLastLum = lastLum.r;",
						"float fCurrentLum = currentLum.r;",
				"#endif",
				
				//The adaption seems to work better in extreme lighting differences
				//if the input luminance is squared.
				// "fCurrentLum = pow( fCurrentLum, 2.0 );",

				// Adapt the luminance using Pattanaik's technique
				"float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));",
				// "fAdaptedLum = sqrt(fAdaptedLum);",
				"gl_FragColor = vec4( vec3( fAdaptedLum ), 1.0 );",
				THREE.ShaderChunk[ "hdr_encode_fragment" ],
			"}",
		].join('\n')
	};

	this.materialAdaptiveLum = new THREE.ShaderMaterial( {

		uniforms: this.adaptLuminanceShader.uniforms,
		vertexShader: this.adaptLuminanceShader.vertexShader,
		fragmentShader: this.adaptLuminanceShader.fragmentShader,
		defines: this.adaptLuminanceShader.defines,
		blending: THREE.NoBlending,
		depthTest: false,
		depthWrite: false,
		name: "Adaptive Luminance"
	} );

	if ( THREE.ToneMapShader === undefined )
		console.error( "THREE.AdaptiveToneMappingPass relies on THREE.ToneMapShader" );

	this.materialToneMap = new THREE.ShaderMaterial( {

		uniforms: THREE.UniformsUtils.clone( THREE.ToneMapShader.uniforms ),
		vertexShader: THREE.ToneMapShader.vertexShader,
		fragmentShader: THREE.ToneMapShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false,
		depthWrite: false,
		name: "Tone Map"
	} );

	this.downSampleShader = {
		// defines: {
		// 	"RESOLUTION" : this.resolution.toFixed(1),
		// },
		uniforms: {
			"tDiffuse": { type: "t", value: null },
			"resolution": { type: "v2", value: new THREE.Vector2() },
			"encode": { type: 'i', value: 1 },
			// "tau": { type: 'f', value: 1.0 }
		},
		vertexShader: [
			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"
		].join('\n'),
		fragmentShader: [
			"varying vec2 vUv;",
			"uniform sampler2D tDiffuse;",
			"uniform vec2 resolution;",
			THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],
			
			"void main() {",
				"vec2 offset = 0.5 / resolution;",
				"vec4 luminosity;",
				"vec4 samples[ 4 ];",

        "samples[0] = texture2D( tDiffuse, vUv + vec2( -offset.x, -offset.x ) );",
        "samples[1] = texture2D( tDiffuse, vUv + vec2( offset.x, -offset.x ) );",
        "samples[2] = texture2D( tDiffuse, vUv + vec2( offset.x, offset.y ) );",
        "samples[3] = texture2D( tDiffuse, vUv + vec2( -offset.x, offset.y ) );",

				"for ( int i = 0; i < 4; i++ ) {",
					"#if defined( HDR_INPUT ) && defined( HDR_INPUT_TYPE )",
						"#if ( HDR_INPUT_TYPE == HDR_TYPE_LOGLUV )",
							"luminosity[ i ] = HDRDecodeLOGLUV( samples[i] ).r;",
						"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBM )",
							"luminosity[ i ] = HDRDecodeRGBM( samples[i] ).r;",
						"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBD )",
							"luminosity[ i ] = HDRDecodeRGBD( samples[i] ).r;",
						"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBE )",
							"luminosity[ i ] = HDRDecodeRGBE( samples[i] ).r;",
						"#else",
							"luminosity[ i ] = samples[i].r;",
						"#endif",
					"#else",
							"luminosity[ i ] = samples[i].r;",
					"#endif",
				"}",

				"float newLum = dot(luminosity, vec4(0.25));",
				
				"gl_FragColor = vec4( vec3( newLum ), 1.0 );",
				THREE.ShaderChunk[ "hdr_encode_fragment" ],
				
			"}",
		].join('\n')
	};
	this.materialDownSample = new THREE.ShaderMaterial( {
		uniforms: this.downSampleShader.uniforms,
		vertexShader: this.downSampleShader.vertexShader,
		fragmentShader: this.downSampleShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false,
		depthWrite: false,
		name: "down-sample"
	});

	this.maxLuminanceShader = {
		// defines: {
		// 	"RESOLUTION" : this.resolution.toFixed(1),
		// },
		uniforms: {
			"tDiffuse": { type: "t", value: null },
			"resolution": { type: "v2", value: new THREE.Vector2() },
		},
		vertexShader: [
			"varying vec2 vUv;",

			"void main() {",

				"vUv = uv;",
				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"
		].join('\n'),
		fragmentShader: [
			"varying vec2 vUv;",
			"uniform sampler2D tDiffuse;",
			"uniform vec2 resolution;",
			THREE.ShaderChunk[ "hdr_decode_pars_fragment" ],
			THREE.ShaderChunk[ "hdr_encode_pars_fragment" ],
			
			"void main() {",
				"vec2 offset = 0.5 / resolution;",
				"vec4 luminosity;",
				"vec4 samples[ 4 ];",

        "samples[0] = texture2D( tDiffuse, vUv + vec2( -offset.x, -offset.x ) );",
        "samples[1] = texture2D( tDiffuse, vUv + vec2( offset.x, -offset.x ) );",
        "samples[2] = texture2D( tDiffuse, vUv + vec2( offset.x, offset.y ) );",
        "samples[3] = texture2D( tDiffuse, vUv + vec2( -offset.x, offset.y ) );",

				"for ( int i = 0; i < 4; i++ ) {",
					"#if defined( HDR_INPUT ) && defined( HDR_INPUT_TYPE )",
						"#if ( HDR_INPUT_TYPE == HDR_TYPE_LOGLUV )",
							"luminosity[ i ] = HDRDecodeLOGLUV( samples[i] ).r;",
						"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBM )",
							"luminosity[ i ] = HDRDecodeRGBM( samples[i] ).r;",
						"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBD )",
							"luminosity[ i ] = HDRDecodeRGBD( samples[i] ).r;",
						"#elif ( HDR_INPUT_TYPE == HDR_TYPE_RGBE )",
							"luminosity[ i ] = HDRDecodeRGBE( samples[i] ).r;",
						"#else",
							"luminosity[ i ] = samples[i].r;",
						"#endif",
					"#else",
							"luminosity[ i ] = samples[i].r;",
					"#endif",
				"}",

				"float maxLum = max( max(luminosity.r, luminosity.g), max( luminosity.b, luminosity.a ));",
				
				"gl_FragColor = vec4( vec3( maxLum ), 1.0 );",
				THREE.ShaderChunk[ "hdr_encode_fragment" ],
				
			"}",
		].join('\n')
	};
	this.materialMaxLuminance = new THREE.ShaderMaterial( {
		uniforms: this.maxLuminanceShader.uniforms,
		vertexShader: this.maxLuminanceShader.vertexShader,
		fragmentShader: this.maxLuminanceShader.fragmentShader,
		blending: THREE.NoBlending,
		depthTest: false,
		depthWrite: false,
		name: "max-luminance"
	});

	this.enabled = true;
	this.needsSwap = true;
	this.clear = false;

	this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
	this.scene  = new THREE.Scene();

	this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );
	this.scene.add( this.quad );

};

THREE.AdaptiveToneMappingPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {

		if ( this.needsUpdate ) {
			this.resetRenderTargets( renderer, readBuffer );
			
			this.needsUpdate = false;
		}

		if ( this.adaptive ) {
			//Render the luminance of the current scene into a render target with mipmapping enabled
			this.quad.material = this.materialLuminance;
			this.materialLuminance.uniforms.tDiffuse.value = readBuffer;
			renderer.render( this.scene, this.camera, this.currentLuminanceRT );
			this.materialAdaptiveLum.uniforms.delta.value = delta;

			if ( this.adaptiveWhiteLevel ) {
				this.determineMaxLuminance( renderer );
				//Adapt the max luminance value over time
				this.quad.material = this.materialAdaptiveLum;
				this.materialAdaptiveLum.uniforms.lastLum.value = this.previousMaxLuminanceRT;
				this.materialAdaptiveLum.uniforms.currentLum.value = this.currentMaxLuminanceRT[ this.currentMaxLuminanceRT.length - 1 ];
				renderer.render( this.scene, this.camera, this.maxLuminanceRT );
				this.materialToneMap.uniforms.maxLuminanceRT.value = this.maxLuminanceRT;
			}

			//If we need to generate a 1x1 texture for sampling luminosity (because filtering isn't supported)
			if ( this.needsManualDownSample ) {
				this.downSampleLuminance( renderer );
				this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRTDownSampled[ this.currentLuminanceRTDownSampled.length - 1 ];
			}
			else {
				this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT;
			}

			//Use the new luminance values, the previous luminance and the frame delta to
			//adapt the luminance over time.
			this.quad.material = this.materialAdaptiveLum;
			// this.materialAdaptiveLum.uniforms.delta.value = delta;
			this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT;
			
			renderer.render( this.scene, this.camera, this.luminanceRT );

			//Copy the new adapted luminance value so that it can be used by the next frame.
			this.quad.material = this.materialCopy;
			this.copyUniforms.tDiffuse.value = this.luminanceRT;
			renderer.render( this.scene, this.camera, this.previousLuminanceRT );

			this.copyUniforms.tDiffuse.value = this.maxLuminanceRT;
			renderer.render( this.scene, this.camera, this.previousMaxLuminanceRT );
		}

		//Now tonemap the scene, using the luminance
		this.quad.material = this.materialToneMap;
		this.materialToneMap.uniforms.tDiffuse.value = readBuffer;
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );
		
	},

	downSampleLuminance: function( renderer ) {
		this.quad.material = this.materialDownSample;
		this.materialDownSample.uniforms.tDiffuse.value = this.currentLuminanceRT;
		for ( var i = 0; i < this.currentLuminanceRTDownSampled.length; i++ ) {
			this.materialDownSample.uniforms.resolution.value.x = Math.pow( 2.0, this.currentLuminanceRTDownSampled.length - i );
			this.materialDownSample.uniforms.resolution.value.y = Math.pow( 2.0, this.currentLuminanceRTDownSampled.length - i );
			renderer.render( this.scene, this.camera, this.currentLuminanceRTDownSampled[ i ], true );
			this.materialDownSample.uniforms.tDiffuse.value = this.currentLuminanceRTDownSampled[ i ];
		}

	},

	determineMaxLuminance: function( renderer ) {
		this.quad.material = this.materialMaxLuminance;
		this.materialMaxLuminance.uniforms.tDiffuse.value = this.currentLuminanceRT;
		for ( var i = 0; i < this.currentMaxLuminanceRT.length; i++ ) {
			this.materialMaxLuminance.uniforms.resolution.value.x = Math.pow( 2.0, this.currentMaxLuminanceRT.length - i );
			this.materialMaxLuminance.uniforms.resolution.value.y = Math.pow( 2.0, this.currentMaxLuminanceRT.length - i );
			renderer.render( this.scene, this.camera, this.currentMaxLuminanceRT[ i ], true );
			this.materialMaxLuminance.uniforms.tDiffuse.value = this.currentMaxLuminanceRT[ i ];
		}

	},

	resetRenderTargets: function( renderer, renderTarget ) {
		var i, res, pars, extensions;
		// render targets
		if ( this.luminanceRT ) {
			this.luminanceRT.dispose();
		}
		if ( this.currentLuminanceRT ) {
			this.currentLuminanceRT.dispose();
		}
		if ( this.previousLuminanceRT ) {
			this.previousLuminanceRT.dispose();
		}
		if ( this.currentLuminanceRTDownSampled ) {
			for ( i = 0; i < this.currentLuminanceRTDownSampled.length; i++ ) {
				this.currentLuminanceRTDownSampled[ i ].dispose();
			}
			this.currentLuminanceRTDownSampled = [];
		}
		if ( this.maxLuminanceRT ) {
			this.maxLuminanceRT.dispose();
		}
		if ( this.previousMaxLuminanceRT ) {
			this.previousMaxLuminanceRT.dispose();
		}
		if ( this.currentMaxLuminanceRT ) {
			for ( i = 0; i < this.currentMaxLuminanceRT.length; i++ ) {
				this.currentMaxLuminanceRT[ i ].dispose();
			}
			this.currentMaxLuminanceRT = [];
		}
		pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: renderTarget.format, type: renderTarget.type };

		//Determine if we will let the mipmaps for currentLuminanceRT to be auto-generated or not.
		//For any compressed HDR formats, we'll have to manually down-sample the RT.
		if ( renderTarget.type === THREE.FloatType ) {
			//If we're using a floating point render target, check if the 
			extensions = new THREE.WebGLExtensions( renderer.getContext() );
			if ( extensions.get('OES_texture_half_float_linear') || extensions.get('OES_texture_float_linear') ) {
				//We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader
				this.needsManualDownSample = false;
			}
			else {
				this.needsManualDownSample = true;
			}
		}
		else if ( renderer.hdrOutputEnabled && renderer.hdrOutputType ) {
			this.needsManualDownSample = true;
		}
		else {
			this.needsManualDownSample = false;
			
		}
		if ( this.needsManualDownSample ) {
			pars.minFilter = THREE.NearestFilter;
			pars.magFilter = THREE.NearestFilter;
		}
		else {
			pars.minFilter = THREE.LinearFilter;
			pars.magFilter = THREE.LinearFilter;
		}
		this.luminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );
		this.luminanceRT.generateMipmaps = false;
		this.luminanceRT.name = "Average Luminance";
		this.previousLuminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );
		this.previousLuminanceRT.generateMipmaps = false;
		this.previousLuminanceRT.name = "Previous Luminance";

		if ( !this.needsManualDownSample ) {
			pars.minFilter = THREE.LinearMipMapLinearFilter;
		}
		this.currentLuminanceRT = new THREE.WebGLRenderTarget( this.resolution, this.resolution, pars );
		this.currentLuminanceRT.name = "Current Luminance";
		
		if ( this.adaptive ) {
			this.materialToneMap.defines["SAMPLE_LUMINANCE"] = "";
			this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT;
		}
		
		this.materialLuminance.needsUpdate = true;
		this.materialAdaptiveLum.needsUpdate = true;
		this.materialToneMap.needsUpdate = true;
		this.materialDownSample.needsUpdate = true;

		if ( renderer.hdrOutputEnabled ) {
			this.materialLuminance.hdrOutputType = renderer.hdrOutputType;
			this.materialAdaptiveLum.hdrOutputType = renderer.hdrOutputType;
			this.materialDownSample.hdrOutputType = renderer.hdrOutputType;
			this.materialToneMap.hdrOutputEnabled = false;

			this.materialLuminance.hdrInputEnabled = true;
			this.materialLuminance.defines['HDR_INPUT_TYPE'] = renderer.hdrOutputType;
			this.materialAdaptiveLum.hdrInputEnabled = true;
			this.materialAdaptiveLum.defines['HDR_INPUT_TYPE'] = renderer.hdrOutputType;
			this.materialToneMap.hdrInputEnabled = true;
			this.materialToneMap.defines['HDR_INPUT_TYPE'] = renderer.hdrOutputType;	
			this.materialDownSample.hdrInputEnabled = true;
			this.materialDownSample.defines['HDR_INPUT_TYPE'] = renderer.hdrOutputType;	
		}

		pars.minFilter = THREE.NearestFilter;
		pars.magFilter = THREE.NearestFilter;
		if ( this.needsManualDownSample ) {
			this.currentLuminanceRT.generateMipmaps = false;
			this.currentLuminanceRTDownSampled = new Array( parseInt( Math.log2( this.resolution ) ) );
			for ( i = 1; i <= this.currentLuminanceRTDownSampled.length; i++ ) {
				res = parseInt( this.resolution / Math.pow( 2, i ) );
				this.currentLuminanceRTDownSampled[ i - 1 ] = new THREE.WebGLRenderTarget( res, res, pars );
				this.currentLuminanceRTDownSampled[ i - 1 ].name = "Current Luminance RT" + (i - 1);
			}
			this.materialAdaptiveLum.defines['MIP_LEVEL_1X1'] = "0.0";
		}
		else {
			this.materialAdaptiveLum.defines['MIP_LEVEL_1X1'] = Math.log2( this.resolution ).toFixed(1);
		}

		this.currentMaxLuminanceRT = new Array( parseInt( Math.log2( this.resolution ) ) );
		for ( i = 1; i <= this.currentMaxLuminanceRT.length; i++ ) {
			res = parseInt( this.resolution / Math.pow( 2, i ) );
			this.currentMaxLuminanceRT[ i - 1 ] = new THREE.WebGLRenderTarget( res, res, pars );
			this.currentMaxLuminanceRT[ i - 1 ].name = "Current Max Luminance RT" + (i - 1);
		}
		this.previousMaxLuminanceRT = new THREE.WebGLRenderTarget( 1, 1, pars );
		this.previousMaxLuminanceRT.name = "Previous Max Luminance";
		this.maxLuminanceRT = new THREE.WebGLRenderTarget( 1, 1, pars );
		this.maxLuminanceRT.name = "Current Max Luminance";

		this.seedTargets( renderer );
		
	},

	seedTargets: function( renderer ) {
		//Put something in the adaptive luminance texture so that the scene can render initially
		this.quad.material = new THREE.MeshBasicMaterial( {color: 0x777777, opacity: 0.5 });
		renderer.render( this.scene, this.camera, this.luminanceRT );
		renderer.render( this.scene, this.camera, this.previousLuminanceRT );
		renderer.render( this.scene, this.camera, this.currentLuminanceRT );

		renderer.render( this.scene, this.camera, this.previousMaxLuminanceRT );
	},

	setAdaptive: function( adaptive ) {
		if ( adaptive ) {
			this.adaptive = true;
			this.materialToneMap.defines["SAMPLE_LUMINANCE"] = "";
			this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT;
		}
		else {
			this.adaptive = false;
			delete this.materialToneMap.defines["SAMPLE_LUMINANCE"];
			this.materialToneMap.uniforms.luminanceMap.value = undefined;
		}
		this.materialToneMap.needsUpdate = true;
	},

	setAdaptiveWhiteLevel: function( autoWhite ) {
		if ( autoWhite && this.adaptive ) {
			this.adaptiveWhiteLevel = true;
			this.materialToneMap.defines["ADAPT_WHITE_BALANCE"] = "";
			this.materialToneMap.uniforms.maxLuminanceRT.value = this.maxLuminanceRT;
		}
		else {
			this.adaptiveWhiteLevel = false;
			delete this.materialToneMap.defines["ADAPT_WHITE_BALANCE"];
			this.materialToneMap.uniforms.maxLuminanceRT.value = undefined;
		}
		this.materialToneMap.needsUpdate = true;
	},

	setAdaptionRate: function( rate ) {
		if ( rate ) {
			this.materialAdaptiveLum.uniforms.tau.value = Math.abs( rate );
		}
	},

	setMaxLuminance: function( maxLum ) {
		if ( maxLum ) {
			var A = 0.15;
			var B = 0.50;
			var C = 0.10;
			var D = 0.20;
			var E = 0.02;
			var F = 0.30;
			this.materialToneMap.uniforms.maxLuminance.value = 1.0 / ( ( maxLum * ( A * maxLum + C * B ) + D * E ) / ( maxLum * ( A * maxLum + B ) + D * F ) ) - E / F;
			this.materialLuminance.uniforms.maxLuminance.value = maxLum;
			if ( !this.materialLuminance.defines || !this.materialLuminance.defines["MAX_LUMINANCE"] ) {
				this.materialLuminance.defines["MAX_LUMINANCE"] = "";
				this.materialLuminance.needsUpdate = true;
			}
		}
	},

	setAverageLuminance: function( avgLum ) {
		if ( avgLum ) {
			this.materialToneMap.uniforms.averageLuminance.value = avgLum;
		}
	},

	setExposure: function( exposure ) {
		if ( exposure ) {
			this.materialToneMap.uniforms.exposureBias.value = exposure;
		}
	},

	dispose: function() {
		if ( this.luminanceRT ) {
			this.luminanceRT.dispose();
		}
		if ( this.previousLuminanceRT ) {
			this.previousLuminanceRT.dispose();
		}
		if ( this.currentLuminanceRT ) {
			this.currentLuminanceRT.dispose();
		}
		if ( this.materialLuminance ) {
			this.materialLuminance.dispose();
		}
		if ( this.materialAdaptiveLum ) {
			this.materialAdaptiveLum.dispose();
		}
		if ( this.materialCopy ) {
			this.materialCopy.dispose();
		}
		if ( this.materialToneMap ) {
			this.materialToneMap.dispose();
		}
	}

};
});
/**
 * @module VAPI
 */
define('VeroldEngine/Components/ComponentManager',[ 'underscore', 'backbone', 'async', 'three', 'VeroldEngine/libs/uuid', 'VeroldEngine/Components/VeroldComponent'
  , 'VeroldEngine/libs/three/postprocessing/EffectComposer'
  , 'VeroldEngine/libs/three/postprocessing/BloomPass'
  , 'VeroldEngine/libs/three/postprocessing/BokehPass'
  , 'VeroldEngine/libs/three/postprocessing/DotScreenPass'
  , 'VeroldEngine/libs/three/postprocessing/FilmPass'
  , 'VeroldEngine/libs/three/postprocessing/MaskPass'
  , 'VeroldEngine/libs/three/postprocessing/RenderPass'
  , 'VeroldEngine/libs/three/postprocessing/SavePass'
  , 'VeroldEngine/libs/three/postprocessing/ShaderPass'
  , 'VeroldEngine/libs/three/postprocessing/TexturePass'
  , 'VeroldEngine/libs/three/postprocessing/AdaptiveToneMappingPass'
  // , 'VeroldEngine/libs/three/effects/OculusRiftEffect'
  // , 'VeroldEngine/libs/three/Projector' 
  ],
      function(_, Backbone, async, THREE, uuid, VeroldComponent) {
  

  // event -> function name
  var veroldObjectEventMap = {
    /*
    'load': 'load',
    'load_base': 'loadBase',
    'load_base_and_dependencies': 'loadBaseAndDependencies',
    'load_hierarchy': 'loadHierarchy',
    'load_hierarchy_and_dependencies': 'loadHierarchyAndDependencies',
    'load_dependencies': 'loadDependencies',
    'load_progress': 'loadProgress',
    'load_base_failure': 'loadBaseFailure',
    'load_hierarchy_failure': 'loadHierarchyFailure',
    'load_dependencies_failure': 'loadDependenciesFailure'
    */
  };

  var engineEventMap = {
    'preUpdate': 'preUpdate',
    'update': 'update',
    'postUpdate': 'postUpdate',
    'preRender': 'preRender',
    'render': 'render',
    'postRender': 'postRender',
    'preRenderView': 'preRenderView',
    'postRenderView': 'postRenderView',
    'blur': 'suspend',
    'focus': 'resume'
  };

  /**
   * @class  ComponentManager
   * @param  {Object} opts Options hash `eg: { veroldEntity: veroldEntity }`
   * @constructor
   */
  function ComponentManager(opts) {
    this.components = {};
    this.veroldEntity = opts.veroldEntity;
  }

  _.extend(ComponentManager.prototype, Backbone.Events, {

    initialize: function() {
      var componentJson = this.veroldEntity.entityModel.get("components");
      
      var keys = this._sortComponentKeys( componentJson );
      var that = this;
      async.forEach( keys, function( componentId, next ) {
        var component = componentJson[componentId],
            componentData = that.veroldEntity.getComponentData(componentId);
        if ( !that.components[ componentId ] ) {
          that._createComponent( component.scriptId, componentData, componentId, !!component.enabled, function() {
            next();
          } );
        }
        else {
          next();
        }
      }, function() {
        //Don't trigger load_components here. The components aren't 'loaded' until they're all initialized.
         // that.veroldEntity.trigger("load_components", that.veroldEntity );
      } );
    },

    _sortComponentKeys: function( componentsJson ) {
      var componentsOrder = this.veroldEntity.entityModel.get("componentsOrder");
      var components = _.clone( componentsJson );
      if ( componentsOrder && componentsOrder.length ) {
        var keys = [];
        for (var i = 0; i < componentsOrder.length; i++ ) {
          if ( components[ componentsOrder[ i ] ]) {
            keys.push( componentsOrder[ i ] );
            delete components[ componentsOrder[ i ] ];
          }
        }
        //Add remaining components that weren't in the order structure.
        for ( var j in components ) {
          keys.push( j );
        }
        return keys;
      }
      else {
        return _.keys( componentsJson );
      }
    },

    onEntityComponentsChanges: function( model ) {
      var that = this;

      function setBuiltIn( componentId ) {
        //Set the 'isBuiltIn' flag on the component so that it won't get removed by saves.
        var componentJson = that.veroldEntity.entityModel.get('components.' + componentId );
        var scriptAsset = that.veroldEntity.veroldEngine.assetRegistry.getAssetById( componentJson.scriptId );
        if ( scriptAsset && scriptAsset.entityModel.isBuiltIn ) {
          componentJson.isBuiltIn = true;
        }
      }

      if ( !this.veroldEntity.veroldEngine.componentSettings.enabled ) {
        return;
      }
      var componentChanges = model.changed.components;
      var componentPreviousValues = model._previousAttributes.components;

      _.each( componentChanges, function(component, componentId) {
        var existingComponent, fullComponentDescriptor;

        if (_.isUndefined(component)) {
          this.unloadComponent(componentId);
          this._removeComponent(componentId);
        } else {

          existingComponent = this.components[ componentId ];

          if (!existingComponent) {
            setBuiltIn( componentId );
            var thisComponentDescriptor = this.veroldEntity.entityModel.get('components.' + componentId );
            fullComponentDescriptor = { scriptId : thisComponentDescriptor.scriptId, componentData: {}, enabled: component.enabled };
            var prefabObj = this.veroldEntity.getPrefabObject();
            if ( prefabObj ) {
              var prefabComponentDescriptor = prefabObj.entityModel.get('components.' + componentId );
              if ( prefabComponentDescriptor ) {
                _.extend( fullComponentDescriptor.componentData, thisComponentDescriptor.componentData, prefabComponentDescriptor.componentData );
              }
            }
            if ( _.isEmpty( fullComponentDescriptor.componentData ) ) {
              fullComponentDescriptor.componentData = thisComponentDescriptor.componentData;
            }
            if ( fullComponentDescriptor.scriptId ) {
              this._createComponent( fullComponentDescriptor.scriptId, fullComponentDescriptor.componentData, componentId, !!fullComponentDescriptor.enabled );
            }
          }
          else {
            var previousData = componentPreviousValues[ componentId ].componentData;
            if ( component.enabled ) {
              existingComponent.enable();
            }
            else if ( component.enabled === false ) {
              existingComponent.disable();
            }
            setBuiltIn( componentId );
            if ( component.componentData ) {
              existingComponent.componentDataChanged( component.componentData, previousData );
            }
          }
        }
      }, this);
      //}
    },

    _assignAttribute: function( attributeName, attributeDef, finalComponentData ) {
      if (attributeDef.type === 'asset' && finalComponentData[ attributeName ]) {
        var assetId = finalComponentData[ attributeName ];
        if (!_.isObject( assetId )) {
          var asset = this.veroldEntity.veroldEngine.assetRegistry.getAssetById( assetId );
          finalComponentData[ attributeName ] = asset;
          if ( asset ) {
            this.veroldEntity.registerDependency( asset.id );
          }
        }
      } else if (attributeDef.type === 'object') {
        if (!_.isObject( finalComponentData[ attributeName ])) {
          finalComponentData[ attributeName ] = this.veroldEntity.veroldEngine.getEntityById( finalComponentData[ attributeName ]);
        }
      } else if (attributeDef.type === 'c') {
        finalComponentData[ attributeName ] = new THREE.Color( finalComponentData[ attributeName ] );
      } else if ( attributeDef.type === 'a') {
        //Handle arrays of different types
        if (attributeDef.subType.type === 'asset') {
          _.each( finalComponentData[ attributeName ], function(id, idx) {
            finalComponentData[ attributeName ][ idx ] = this.veroldEntity.veroldEngine.assetRegistry.getAssetById( id );
          }, this);
        } else if (attributeDef.subType.type === 'object') {
          _.each( finalComponentData[ attributeName ], function(id, idx) {
            finalComponentData[ attributeName ][ idx ] = this.veroldEntity.veroldEngine.getEntityById( id );
          }, this);
        }
        else if ( attributeDef.subType.type === 'custom') {
          _.each( finalComponentData[ attributeName ], function( custAttr, idx) {
            _.each( attributeDef.subType.attributes, function( attr, name ) {
              this._assignAttribute( name, attr, custAttr );
            }, this );
          }, this );
        }
      } else if ( attributeDef.type === 'custom') {
        if ( !finalComponentData[ attributeName ] ) {
          finalComponentData[ attributeName ] = {};
        }
        _.each( attributeDef.attributes, function( attr, name ) {
          this._assignAttribute( name, attr, finalComponentData[ attributeName ]);
        }, this );
      }
    },

    //Link up entities to component data and assign the final attribute values to the component.
    _buildAttributes: function( scriptAsset, finalComponentData, component ) {

      var scriptAttributes = scriptAsset.entityModel.get('payload.attributes') || {};
      _.each(scriptAttributes, function(attr, name) {
        this._assignAttribute( name, attr, finalComponentData );
      }, this);
      _.extend(component, finalComponentData);
    },

    _buildEvents: function(scriptAsset) {
      var eventList = scriptAsset.entityModel.get('payload.events') || {};
      _.each(eventList, function(params, name) {
        this.veroldEntity.registerComponentEvent(name, params.parameters, params.scope, params.action, params.category, params.filter);
      }, this);
    },

    _offloadEvents: function(scriptAsset) {
      var eventList = scriptAsset.entityModel.get('payload.events') || {};
      _.each(eventList, function(params, name) {
        this.veroldEntity.removeComponentEvent(name, params.scope);
      }, this);
    },

    _createComponent: function(scriptId, componentData, componentId, enabled, fn ) {
      var ScriptAsset = require('VeroldEngine/AssetRegistry/ScriptAsset'),
          klass,
          scriptName,
          scriptAsset,
          component;

      if (scriptId instanceof ScriptAsset) {
        scriptId = scriptId.id;
      }

      if (!componentId) {
        componentId = uuid();
      }

      if (this.components[componentId]) {
        return console.error('Component with id: ' + componentId + ' already exists!');
      }

      scriptAsset = scriptId && this.veroldEntity.veroldEngine.assetRegistry.getAssetById(scriptId);

      if (!scriptAsset) {
        scriptAsset = _.first(this.veroldEntity.veroldEngine.assetRegistry.Scripts.find({ name: scriptId }));
      }


      if (!scriptAsset) {
        console.warn('Unable to find script asset for ' + scriptId);
        return;
      }

      if (!scriptAsset.isRunnable()) {
        console.info('Skipping component: ' + componentId + " using script " + scriptAsset.getName() );
        this.trigger('add', componentId);
        return null;
      }

      scriptAsset.load({ load: _.bind(function() {
        klass = scriptAsset.scriptData.klass;
        scriptName = scriptAsset.entityModel.get('name');

        // console.log( this.veroldEntity.veroldEngine.engineName +  ': Creating component: ' + componentId + " using script " + scriptAsset.getName() );
        try {
          component = new klass();

          this.components[componentId] = component;

          component.__verold__ = {};
          component.__verold__.id = componentId;
          component.__verold__.scriptName = scriptName;
          component.__verold__.componentData = _.deepClone(componentData);
          component.__verold__.scriptId = scriptId;
          component.__verold__.enabled = enabled;

          component.veroldEntity = this.veroldEntity;
          component.events = this.veroldEntity.veroldEngine.globalEvents;

          if ( !this.veroldEntity.getParentAsset().loadComponents ) {
            this.trigger('add', componentId);
            if (_.isFunction(fn)) {
              return fn(component);
            }
            return;
          }

          if (this.veroldEntity.veroldEngine.componentSettings.runtime) {
            if (typeof component.preInit === 'function') {
              component.preInit();
            }
          }
          else if (this.veroldEntity.veroldEngine.componentSettings.editor) {
            if (typeof component.preInitEditor === 'function') {
              component.preInitEditor();
            }
          }

          this._buildEvents(scriptAsset);

          //If the object is already loaded when the component is created, explicitly load the component
          if ( this.veroldEntity.state_base !== 'pending') {
            this.loadComponent( componentId );
          }

          this.trigger('add', componentId);

          if (_.isFunction(fn)) {
            return fn(component);
          }

        } catch(e) {
          console.error('Error while creating component: ' + scriptName);
          console.error(e.stack);
        }
      }, this)});
    },

    loadComponent: function(componentId) {

      var component = this.components[componentId];
      if ( !component ) {
        console.warn("Trying to load component, " + componentId + ", that doesn't exist for entity, " + this.veroldEntity.id );
        return;
      }

      var scriptAsset = this.veroldEntity.veroldEngine.assetRegistry.getAssetById( component.__verold__.scriptId );
      var defaultComponentData = scriptAsset.getDefaultComponentData();
      var finalComponentData = _.extend(defaultComponentData || {}, _.deepClone( component.__verold__.componentData ));
      var that = this;

      if (this.veroldEntity.veroldEngine.componentSettings.runtime) {

        // If the object is already loading or loaded, trigger the init call.
        if (typeof component.init === 'function') {
          this._buildAttributes( scriptAsset, finalComponentData, component );
          component.init();
        }

        _.each(engineEventMap, function(fnName, eventName) {
          if (typeof component[fnName] === 'function') {
            this.veroldEntity.veroldEngine.on(eventName, component[fnName], component);
          }
        }, this);

        _.each(veroldObjectEventMap, function(fnName, eventName) {
          if (typeof component[fnName] === 'function') {
            this.veroldEntity.on(eventName, component[fnName], component);
          }
        }, this);

        if (typeof component.objectCreated === 'function') {
          if (this.veroldEntity.state_base === 'loaded') {
            component.objectCreated();
          } else {
            this.veroldEntity.once('load_base', component.objectCreated, component);
          }
        }

        if (typeof component.componentsLoaded === 'function') {
          if (this.veroldEntity.state_components === 'loaded') {
            component.componentsLoaded();
          } else {
            this.veroldEntity.once('load_components', component.componentsLoaded, component);
          }
        }

        if (typeof component.objectLoaded === 'function') {
          if (this.veroldEntity.state_base === 'loaded' && this.veroldEntity.state_hierarchy === 'loaded') {
            component.objectLoaded();
          } else {
            this.veroldEntity.once('load_base_and_hierarchy', component.objectLoaded, component);
          }
        }

        if (typeof component.sceneLoaded === 'function') {
          var scene = this.veroldEntity.getParentAsset();
          if ( scene.isLoaded()) {
            component.sceneLoaded();
          } else {
            scene.once( 'load', component.sceneLoaded, component);
          }
        }

        if (typeof component.enabled === 'function') {
          component.listenTo(component, 'enable', component.enabled);
        }

        if (typeof component.disabled === 'function') {
          component.listenTo(component, 'disable', component.disabled);
        }
      } else if (this.veroldEntity.veroldEngine.componentSettings.editor) {
        // Editor components
        if (typeof component.editorInit === 'function') {

            try {
              that._buildAttributes( scriptAsset, finalComponentData, component );
              component.editorInit();
            } catch(e) {
              console.error('Failed to start editor component, error caught: ', e.message);
            }
        }

        if (scriptAsset && typeof component.reload === 'function') {
          scriptAsset.on('script_changed', component.reload, component);
        }
      }


    },

    unloadComponent: function(componentId) {
      var component, scriptAsset;

      if (this.components) {
        if (_.isObject(componentId)) {
          _.each(this.components, function(c, id) {
            if (!component && c === componentId) {
              component = c;
              componentId = id;
            }
          }, this);
        } else {
          component = this.components[componentId];
        }

        if (!_.isObject(component)) {
          //console.error('Could not find component to remove', componentId);
          return;
        }

        scriptAsset = this.veroldEntity.veroldEngine.assetRegistry.Scripts.assets[component.__verold__.scriptId];

        //setTimeout(_.bind(function() {
        try {
          if (!this.veroldEntity || !this.veroldEntity.veroldEngine) {
            return;
          }

          if (this.veroldEntity.veroldEngine.componentSettings.runtime) {
            // Play mode components
            _.each(engineEventMap, function(fnName, eventName) {
              if (typeof component[fnName] === 'function') {
                this.veroldEntity.veroldEngine.off(eventName, component[fnName], component);
              }
            }, this);

            _.each(veroldObjectEventMap, function(fnName, eventName) {
              if (typeof component[fnName] === 'function') {
                this.veroldEntity.off(eventName, component[fnName], component);
              }
            }, this);

            if ( this.veroldEntity.state_base !== "pending" && typeof component.shutdown === 'function') {
              component.shutdown();
            }
          } else if (this.veroldEntity.veroldEngine.componentSettings.editor) {
            // Editor components

            this._offloadEvents(scriptAsset);

            if ( this.veroldEntity.state_base !== "pending" && typeof component.editorShutdown === 'function') {
              component.editorShutdown();
            }

            if (scriptAsset && typeof component.reload === 'function') {
              scriptAsset.off('script_changed', component.reload, component);
            }
          }

          if (typeof component.stopListening === 'function') {
            component.stopListening();
          }
          if (typeof component.objectCreated === 'function') {
            this.veroldEntity.off('load_base', component.objectCreated, component);
          }
          if (typeof component.componentsLoaded === 'function') {
            this.veroldEntity.off('load_components', component.componentsLoaded, component);
          }
          if (typeof component.objectLoaded === 'function') {
            this.veroldEntity.off('load_base_and_hierarchy', component.objectLoaded, component);
          }
          if (typeof component.sceneLoaded === 'function') {
            var scene = this.veroldEntity.getParentAsset();
            scene.off( 'load_base_and_hierarchy', component.sceneLoaded, component);
          }
          if (typeof component.init === 'function') {
            this.veroldEntity.off( 'load_started', component.init, component);
          }

          //
          // this.trigger('remove', componentId);
        } catch(e) {
          console.error('Error while destroying component: ' + component.__verold__.scriptName);
          console.error(e.stack);
        }
        //}, this), 0);
      }
    },

    _removeComponent: function( componentId ) {
      if ( this.components[componentId] ) {
        var component = this.components[componentId];
        this.components[componentId] = undefined;
        delete this.components[componentId];
        component.veroldEntity = undefined;
        component.events = undefined;
        component.__verold__ = undefined;

        this.trigger('remove', componentId);

      }
    },

    unloadComponents: function() {
      if ( this.veroldEntity.getParentAsset().loadComponents ) {
        _.each( this.components, function( comp, id ) {
          this.unloadComponent( id );
        }, this );
      }
    },

    loadComponents: function() {
      if ( this.veroldEntity.getParentAsset().loadComponents ) {
        _.each( this.components, function( comp, id ) {
          this.loadComponent( id );
        }, this );
      }
      this.veroldEntity.trigger("load_components");
    },

    /**
     * Get components matching query
     * @method get
     * @param  {mixed} query Either a query object such as { scriptName: 'Your Script Name' } or a
     *                       string. If this is a string, then multiple searches will be performed
     *                       until a match is found in this order 'id', 'scriptName', 'scriptId'
     * @return {VAPI.VeroldComponent} an array of components matching the query
     */
    get: function(query) {
      var found = [];


      if (_.isString(query)) {
        var val = query;

        // if this matches a script id, just return it
        if (this.components[val]) {
          return [this.components[val]];
        }

        // these can have multiple components
        _.each([ 'scriptName', 'scriptId' ], function(prop) {
          if (found.length < 1) {
            var query = {};
            query[prop] = val;

            found = this.get(query);
          }
        }, this);

        return found;
      }

      if (!_.isObject(query) || !_.size(query)) {
        return [];
      }

      if (this.components) {
        _.each(this.components, function(component) {
          var match = true;
          if ( component ) {
            _.each(query, function(val, prop) {
              if (component.__verold__[prop] !== val) {
                match = false;
              }
            });

            if (match) {
              found.push(component);
            }
          }
        });
      }

      return found;
    },

    /**
     * Returns an array of all attached components
     * @method all
     * @return {Array} an array of components
     */
    all: function() {
      return _.toArray(this.components);
    },

    /**
     * Get a component. This is a convenience method that wraps Components.get, this will just
     * return the first entity. If query is not specified then it will return the first of all
     * components.
     * @method first
     * @param  {mixed} [query] Either a query object such as { scriptName: 'Your Script Name' } or a
     *                       string. If this is a string, then multiple searches will be performed
     *                       until a match is found in this order 'id', 'scriptName', 'scriptId'
     * @return {VAPI.VeroldComponent} this first component matching the query
     */
    first: function(query) {
      if (!query) {
        return _.first(this.all());
      }
      return _.first(this.get(query));
    },

    /**
     * Remove all components
     * @method empty
     */
    // empty: function() {
    //   _.each(this.components, this.unloadComponent, this);
    // },

    /**
     * Iterate over all of the components and call `fn` for each
     * @method  each
     * @param  {Function} fn      the function to call on each component
     * @param  {Mixed}   context  the value of `this` for each function call
     */
    each: function(fn, context) {
      return _.each(this.components, fn, context);
    }
  });

  window.VAPI = window.VAPI || {};
  window.VAPI.ComponentManager = ComponentManager;

  return ComponentManager;
});

/**
 * @module VAPI
 */
define('VeroldEngine/VeroldEntity',[ 'underscore'
       , 'backbone'
       , 'three'
       , 'async'
       , 'VeroldEngine/libs/uuid'
       , 'VeroldEngine/models/entity'
       , 'VeroldEngine/Materials/EngineMaterials'
       , 'VeroldEngine/Components/ComponentManager'
  ],
  function(_, Backbone, THREE, async, uuid, EntityModel, EngineMaterials, ComponentManager) {
    // global VAPI

    /**
    * The base class for all objects and assets in the engine.
    *
    * @class VeroldEntity
    * @mixin Backbone.Events
    * @constructor
    */
    var VeroldEntity = function( ) {
      this.veroldEngine = undefined;
      this.id = undefined;
      this.type = undefined;
      this.componentManager = undefined;
      this.state_base = "pending";
      this.state_hierarchy = "pending";
      this.state_components = "pending";
      this.state_dependencies = "pending";
      //this.state_hierarchy_dependencies = "pending";
      this.threeData = null;
      this.entityModel = undefined;
      this.loadingProgress = {
      
      };
      this.threeData = undefined;
      this.events = {};
    };

    VeroldEntity.prototype = {

      events: {
        load: {'params': [], 'action': false, 'category': 'Loading'},
        load_base: {'params': [], 'action': false, 'category': 'Loading'},
        load_hierarchy: {'params': [], 'action': false, 'category': 'Loading'},
        startTimer: {'params': [{'name': "time", "description": "The time (in seconds) that will elapse before the 'endTimer' event is fired.", "type": "f", "default" : 5.0 }], 'action': true, 'category': 'General'},
        endTimer: {'params': [], 'action': false, 'category': 'General'}
      },

      initialize: function( properties ) {
        if ( !properties.veroldEngine || !properties.entityModel ) {
          console.error( "Can't create an asset/object without an engine reference or a backbone model.");
          return false;
        }

        this.veroldEngine = properties.veroldEngine;
        this.isVeroldEntity = true;

        this.state_base = "pending";
        this.state_hierarchy = "pending";
        this.state_dependencies = "pending";
        //this.state_hierarchy_dependencies = "pending";

        this.id = properties.entityModel.get("id");
        this.type = properties.entityModel.get("type");
        this.entityModel = properties.entityModel;

        var payload = this.entityModel.get("payload");
        if ( !payload ) {
          payload = {};
          this.entityModel.set( {"payload" : payload }, {silent: true} );
        }
        if ( payload.visible === undefined ) {
          payload.visible = true;
        }
        var components = this.entityModel.get("components");
        if ( !components ) {
          this.entityModel.set( {"components" : { } }, {silent: true} );
        }

        this.entityModel.on( "change:name", this.onEntityNameChanged, this );
        // this.entityModel.on( "change:description", this.onEntityDescriptionChanged, this );
        this.entityModel.on( "change:payload.*", this.onEntityPayloadChanged, this );
        this.entityModel.on( "change:children.*", this.onEntityChildrenChanged, this );

        if ( this.entityModel.isPersistent !== false ) {
          this.entityModel.isPersistent = true;
        }

        this.on("startTimer", this.startTimer, this );

        this.on("load_base", this.onLoadBase, this );
        this.on("load_hierarchy", this.onLoadHierarchy, this );
        this.on("load_dependencies", this.onLoadDependencies, this );
        //this.on("load_progress", this.onLoadProgress, this );
        this.on("load_hierarchy_failure", this.onLoadHierarchyFailure, this );
        this.on("load_base_failure", this.onLoadBaseFailure, this );
        this.on("load_components", this.onLoadComponents, this);

        this.veroldEngine.on("scriptDeleted", this.onScriptDeleted, this );

      },

      uninitialize: function() {
        // Stop listening to events bound with this.listenToOnce, this.listenTo, etc.
        this.stopListening();

        this.off("startTimer", this.startTimer, this );

        this.off("load_base", this.onLoadBase, this );
        this.off("load_hierarchy", this.onLoadHierarchy, this );
        this.off("load_dependencies", this.onLoadDependencies, this );
        //this.off("load_progress", this.onLoadProgress, this );
        this.off("load_hierarchy_failure", this.onLoadHierarchyFailure, this );
        this.off("load_base_failure", this.onLoadBaseFailure, this );
        this.off("load_components", this.onLoadComponents, this);

        this.veroldEngine.off("scriptDeleted", this.onScriptDeleted, this );

        this.entityModel.off( "change:name", this.onEntityNameChanged, this );
        // this.entityModel.off( "change:description", this.onEntityDescriptionChanged, this );
        this.entityModel.off( "change:payload.*", this.onEntityPayloadChanged, this );
        this.entityModel.off( "change:children.*", this.onEntityChildrenChanged, this );

        if ( this.componentManager ) {
          this.entityModel.off( "change:components.*", this.componentManager.onEntityComponentsChanges, this.componentManager);
          this.componentManager.unloadComponents();
          this.componentManager = null;
        }

        this._uninitPrefabBindings();


        this.unload();

        this.entityModel.veroldEngine = undefined;
        this.entityModel = undefined;
        this.loadingProgress = undefined;
        this.id = undefined;
        this.type = undefined;
        this.state_base = "pending";
        this.state_hierarchy = "pending";
        this.state_dependencies = "pending";
        //this.state_hierarchy_dependencies = "pending";

        this.threeData = undefined;

        this.veroldEngine = undefined;

      },

      initializeComponents: function() {
        if ( !this.componentManager ) {
          this.componentManager = new ComponentManager({ veroldEntity: this });
          this.entityModel.on( "change:components.*", this.componentManager.onEntityComponentsChanges, this.componentManager);
          this.componentManager.initialize();
        }
      },

      startTimer: function( time ) {
        function updateTimer( delta ) {
          elapsedTime += delta;
          if ( elapsedTime >= time ) {
            that.veroldEngine.off( 'update', updateTimer, that );
            that.trigger('endTimer');
          }
        }
        var that = this;
        var elapsedTime = 0.0;
        this.veroldEngine.on( 'update', updateTimer, this );
      },

      onScriptDeleted: function( scriptId ) {
        if ( this.componentManager ) {
          var comps = this.getComponentsByScriptId( scriptId );
          _.each( comps, function( component, id ) {
            console.log("Removing component from " + this.type + ", " + this.id + ", because the script asset has been deleted.");
            this.removeComponent( id, { save: true } );
          }, this );
        }
      },

      registerDependency: function( assetId ) {
        var parentAsset = this.getParentAsset();
        parentAsset.registerDependency( assetId );
      },

      /**
       * Traverse this entity's hierarchy and call the given function for each of them.
       * @method traverse
       * @param  {Function} fn The function to call for each object. The function will be passed two parameters. The first is the object
       * and the second is the parent. If the function returns a non-zero value, the traverse will immediately stop.
       */
      traverse: function( fn ) {
        var parentAsset = this.getParentAsset();
        var children = this.entityModel.get("children");
        for ( var x in children ) {
          if ( children[x] ) {
            var object = parentAsset.getObjectById( x );
            if ( object ) {
              var returnVal = fn( object, this );
              if ( !returnVal ) {
                object.traverse( fn );
              }
              else {
                break;
              }
            }
          }
        }
      },

      /**
       * Return true if this entity matches the provided filters.
       * @param  {Object}  filters [description]
       * @return {Boolean}         True iff this entity matches the provided filters.
       */
      isMatch: function( filters ) {
        if ( _.isObject( filters ) ) {
          for ( var key in filters ) {
            var value = filters[ key ];
            if ( value !== undefined ) {
              if ( _.isArray( value ) ) {
                for ( var i in value ) {
                  if ( this.entityModel.get(key) === value[i] || this.entityModel[key] === value[i] ) {
                    return true;
                  }
                }
              }
              else if ( this.entityModel.get(key) === value || this.entityModel[key] === value ) {
                return true;
              }
            }
          }
        }
        else {
          return true;
        }
        return false;
      },

      /**
       * get the three data associated with this entity
       * @method getThreeData
       * @param  {Object} [options]
       * @return {Three Object} The Three.JS data attached to this VeroldEntity. Can be things like THREE.Material, THREE.Object3D, THREE.PointLight, etc. See threejs.org/docs/
       */
      getThreeData: function( options ) {
        if ( !this.threeData ) {
          this.load( options );
        }
        return this.threeData;
      },

      //Returns the backbone model for the asset.
      getEntityModel : function() {
        return this.entityModel;
      },

      /**
       * Search this entity's hierarchy and return the first object that matches any of the provided filters.
       * @method getObject
       * @param  {Object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {Object}        The first object that matches the querry
       */
      getObject: function( filters ) {
        var result = null;
        this.traverse( function( obj ) {
          if ( obj.isMatch( filters ) ) {
            result = obj;
            return 1;
          }
        });
        return result;
      },

      /**
       * Returns the object with the provided Id, if it exists in this entity's hierarchy.
       * @method getObjectById
       * @param  {String} objectID The ID of the object
       * @return {Object} The object or null if not found.
       */
      getObjectById: function( objectID ) {
        console.warn("VeroldEntity.getObjectById(id) must be implemented by derrived class.");
      },

      /**
       * Returns the first object with the provided name that is found in this object's hierarchy.
       * Note: Care should be taken when calling this function often (such as every frame)
       * because it is not build for high performance.
       * @method getObjectByName
       * @param  {String} objectName The name of the object
       * @return {Object} The object, if found, or null if not found.
       */
      getObjectByName: function( objectName ) {
        var results = this.getObjects( { name: objectName } );
        if ( results && results.length ) {
          return results[0];
        }
        else {
          return null;
        }
      },

      /**
       * Returns all objects with the provided name that are in this entity's hierarchy.
       * Note: Care should be taken when calling this function often (such as every frame)
       * because it is not build for high performance.
       * @method getObjectsByName
       * @param  {String} objectName The name of the object
       * @return {Array} An array of all objects with the given name.
       */
      getObjectsByName: function( objectName ) {
        var results = this.getObjects( { name: objectName } );
        return results;
      },

      /**
       * Search this entity's hierarchy and returns an array of objects that match any of the provided filters.
       * @method getObjects
       * @param  {Object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array}        Array of objects that match the querry
       */
      getObjects: function( filter ) {
        var results = [];
        this.traverse( function( obj ) {
          if ( obj.isMatch( filter ) ) {
            results.push( obj );
          }
        });
        return results;
      },

      /**
       * Returns the object if it is a direct child of this object.
       * @method getChildById
       * @param  {String} objectID The ID of the child to get
       * @return {VeroldEntity}  The child object, if it exists
       */
      getChildById: function( objectID ) {
        if ( this.entityModel.get("children")[ objectID ] ) {
          return this.getParentAsset().getObjectById( objectID );
        }
        else {
          return null;
        }
      },

      getDescendants: function( filters ) {
        console.log("getDescendants is deprecated. Please use getObjects instead.");
        return this.getObjects( filters );
      },

      getDecendants: function( filters ) {
        return this.getDescendants( filters );
      },

      /**
       * Returns the first descendant in the hierarchy that has the given name.
       * @method getDescendantByName
       * @param  {String} name The name of the object to look for.
       * @return {array}  Array of objects that match the querry
       */
      getDescendantByName: function( name ) {

        return this.getDescendants( { name: "name" })[0];
      },

      /**
       * Return all direct children of this object.
       * @method getChildren
       * @param  {Object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {Object} An object containing all the matching objects, keyed by id.
       */
      getChildren: function( filters ) {
        var results = {};
        var children = this.entityModel.get("children");

        if ( !filters ) {
          _.each( children, function( included, id ) {
            if ( included ) {
              var obj = this.getChildById( id );
              results[ obj.id ] = obj;
            }
          }, this );
        }
        else {
          _.each( children, function( included, id ) {
            if ( included ) {
              var obj = this.getChildById( id );
              if ( obj.isMatch( filters )) {
                results[ obj.id ] = obj;
              }
            }
          }, this );
        }
        return results;
      },

      /**
       * Returns the top-level asset that this object is part of.
       * If this object is an asset, the returned object will be the object.
       * @method getParentAsset
       * @return {VeroldEntity} The parent asset of this object.
       */
      getParentAsset: function() {
        var parentAssetId = this.entityModel.get("parentAssetId");
        if ( this.entityModel.isAsset() ) {
          return this;
        }
        else if ( parentAssetId ) {
          return this.veroldEngine.assetRegistry.getAssetById( parentAssetId );
        }
        else {
          return null;
        }
      },

      /**
       * Returns the object that is the immediate parent of this one.
       * Returns null if this object doesn't have a parent. This will be
       * the case if the object is an asset or is orphaned.
       * @method getParentObject
       * @return {VeroldEntity} The parent object of this object.
       */
      getParentObject: function() {

        var parentAsset = this.getParentAsset();
        var parentObj = parentAsset.getObjectById( this.entityModel.get("parentId") );

        return parentObj;
      },

      /**
       * If this object is a prefab instance, return the top-level of the instance.
       * @method getPrefabInstanceTop
       * @return {VeroldEntity} The top-level of the prefab instance.
       */
      getPrefabInstanceTop: function() {

        if ( this.isPrefabInstanceTop() ) {
          return this;
        }
        else {
          var prefabInstanceId = this.entityModel.get("prefabInstanceId");
          if ( prefabInstanceId ) {
            return this.getParentAsset().getObjectById( prefabInstanceId );
          }
          else {
            return null;
          }
        }
      },

      /**
       * Returns the asset that this object is an instance of. i.e. this will give you
       * the Prefab Asset that this object is inherrited from.
       * @method getPrefabAsset
       * @return {VAPI.VeroldAsset} The asset that this object is an instance of.
       */
      getPrefabAsset: function() {
        var prefabAssetId = this.entityModel.get("prefabAssetId");
        if ( prefabAssetId ) {
          return this.veroldEngine.assetRegistry.getAssetById( prefabAssetId );
        }
        return null;
      },

      /**
       * Returns the top-level asset where the source data for this object is stored.
       * i.e. this will give you the asset that contains the link to the original asset
       * data on the server (e.g. mesh data, animation data, etc.)
       * @method getPrefabObject
       * @return {VAPI.VeroldAsset} the asset where the source data for this object is stored.
       */
      getPrefabObject: function() {
        var prefabObjectId = this.entityModel.get("prefabObjectId");
        if ( prefabObjectId ) {
          var prefabAsset = this.getPrefabAsset();
          if ( prefabAsset) {

            if ( prefabObjectId === prefabAsset.id ) {
              return prefabAsset;
            }
            else {

              var obj = prefabAsset.getObjectById( prefabObjectId );
              if ( !obj ) {
                console.warn("VeroldEntity.getPrefabObject(): The prefab object being requested doesn't exist in its parent asset. Either the ID is invalid or the asset hasn't been loaded yet.");
              }
              return obj;
            }
          }
          else {
            console.error( this.veroldEngine.engineName + " - VeroldEntity.getPrefabObject() - The instance object doesn't have a valid prefab defined or isn't tied to a prefab.");
          }
        }
        return null;
      },

      /**
       * Returns the ID of the source asset of this object.
       * @method getSourceAssetId
       * @return {String} The ID of the source asset of this object
       */
      getSourceAssetId: function() {
        return this.entityModel.get("sourceAssetId");
      },

      /**
       * Returns the top-level asset where the source data for this object is stored.
       * i.e. this will give you the asset that contains the link to the original asset
       * data on the server (e.g. mesh data, animation data, etc.)
       * @method getSourceAsset
       * @return {VAPI.VeroldAsset} the asset where the source data for this object is stored.
       */
      getSourceAsset: function() {
        var sourceAssetId = this.entityModel.get("sourceAssetId");
        if ( sourceAssetId ) {
          return this.veroldEngine.assetRegistry.getAssetById( sourceAssetId );
        }
        return null;
      },

      /**
       * Returns the ID of the source object of this object.
       * @method getSourceObjectId
       * @return {String} The ID of the source object of this object
       */
      getSourceObjectId: function() {
        return this.entityModel.get("sourceObjectId");
      },

      /**
       * Returns the object from which the source data for this object is loaded.
       * i.e. this will give you the object that contains the link to the original
       * data on the server (e.g. mesh data )
       * @method getSourceObject
       * @return {VAPI.VeroldObject} the object where the source data for this object is stored.
       */
      getSourceObject: function() {
        var sourceObjectId = this.entityModel.get("sourceObjectId");
        if ( sourceObjectId ) {
          var sourceAsset = this.getSourceAsset();
          if ( sourceAsset) {

            if ( sourceObjectId === sourceAsset.id ) {
              return sourceAsset;
            }
            else {

              var obj = sourceAsset.getObjectById( sourceObjectId );
              if ( !obj ) {
                console.warn("VeroldEntity.getSourceObject(): The source object being requested doesn't exist in its parent asset. Either the ID is invalid or the asset hasn't been loaded yet.");
              }
              return obj;
            }
          }
          else {
            console.warn( this.veroldEngine.engineName + " - VeroldEntity.getSourceObject() - The instance object doesn't have a valid source asset defined.");
          }
        }
        return null;
      },

      /**
       * Returns true if the object is an instance of an asset.
       * @method isInstance
       * @return {boolean} true if the object is an instance of a prefab or if it
       * is not a source object. false otherwise.
       */
      isInstance: function() {
        var sourceAssetId = this.entityModel.get("sourceAssetId");
        if ( sourceAssetId ) {
          return true;
        }
        else {
          return false;
        }
      },

      /**
       * Returns true if the object is an instance of a prefab asset.
       * @method isPrefabInstance
       * @return {boolean} true if the object is an instance of a prefab object
       */
      isPrefabInstance: function() {
        var prefabAssetId = this.entityModel.get("prefabAssetId");
        if ( prefabAssetId ) {
          return true;
        }
        else {
          return false;
        }
      },

      /**
       * Returns true if the object is the top-level of a prefab instance tree.
       * @method isPrefabInstanceTop
       * @return {Boolean} True if and only if the object is the top level of a prefab instance.
       */
      isPrefabInstanceTop: function() {
        return this.entityModel.get("prefabObjectId") && this.entityModel.get("prefabObjectId") === this.entityModel.get("prefabAssetId") ? true : false;
      },

      isComponentsLoaded: function() {
        return !this.veroldEngine.componentSettings.enabled ||
               this.state_components === 'loaded';
      },

      /**
       * If the condition for specified event is met, immediately calls the callback. Otherwise, listens for
       * the event to be fired and then calls it. Useful for more concise code.
       * @method when
       * @param {String} eventName The name of the event to listen for
       * @param {Function} callback The callback function to call when the event occurs
       * @param {Object} context The context that the callback will be called in
       */
      when: function( eventName, callback, context ) {
        if ( _.isFunction( callback ) ) {
          if ( eventName === 'load' && this.isLoaded() ||
            eventName === 'load_base' && this.isBaseLoaded() ||
            eventName === 'load_hierarchy' && this.isHierarchyLoaded() ||
            eventName === 'load_dependencies' && this.isDependenciesLoaded() ||
            eventName === 'load_components' && this.isComponentsLoaded() ) {
            callback.call( context, this );
          }
          else {
            this.once( eventName, callback, context );
          }
        }
      },

      onLoadBase: function() {
        this.state_base = "loaded";
        if ( this.state_hierarchy === "loaded") {
          this.trigger( "load_base_and_hierarchy", this );
        }
        if ( this.state_dependencies === "loaded" || this.state_dependencies === "failed" ) {
          this.trigger("load_base_and_dependencies", this );
          if ( this.state_hierarchy === "loaded" && this.isComponentsLoaded() ) {
            //Ensures that all load_base events have fired before load fires
            var that = this;
            setTimeout( function() {
              if ( that.entityModel ) {
                that.trigger("load", that);
              }
            }, 0);
          }
        }
      },

      onLoadHierarchy: function() {
        this.state_hierarchy = "loaded";
        if ( this.state_base === "loaded") {
          this.trigger( "load_base_and_hierarchy", this );
        }
        if ( this.state_dependencies === "loaded" || this.state_dependencies === "failed" ) {
          this.trigger("load_hierarchy_and_dependencies", this );
          if ( this.state_base === "loaded" && this.isComponentsLoaded() ) {
            //Ensures that all load_base events have fired before load fires
            var that = this;
            setTimeout( function() {
              if ( that.entityModel ) {
                that.trigger("load", that);
              }
            }, 0);
          }
        }
      },

      onLoadDependencies: function() {
        //console.log("dependencies loaded for " + this.type + " " + this.id );
        this.state_dependencies = "loaded";
        if ( this.state_base === "loaded" ) {
          this.trigger("load_base_and_dependencies", this );
          if ( this.state_hierarchy === "loaded" ) {
            this.trigger("load_hierarchy_and_dependencies", this );
            if (this.isComponentsLoaded()) {
              //Ensures that all load_base events have fired before load fires
              var that = this;
              setTimeout( function() {
                if ( that.entityModel ) {
                  that.trigger("load", that);
                }
              }, 0);
            }
          }
        }
      },

      onLoadComponents: function() {
        this.state_components = "loaded";
        if ( this.state_base === "loaded" && this.state_hierarchy === "loaded" && this.state_dependencies === "loaded" ) {
          //Ensures that all load_base events have fired before load fires
          var that = this;
          setTimeout( function() {
            if ( that.entityModel ) {
              that.trigger("load", that);
            }
          }, 0);
        }
      },

      //onLoadProgress: function() {
        //With the progress info from the child, figure out this object's
        //loading progress.
        // this.updateLoadingProgress();
        //this.updateDependencyLoadingProgress();
      //},

      onLoadBaseFailure: function() {
        this.state_base = "failed";
      },

      onLoadHierarchyFailure: function() {
        this.state_hierarchy = "failed";
      },

      onLoadDependenciesFailure: function() {
        //Even if the dependencies for this object failed to load, we'll still trigger the
        //'load' event if all of the hierarchy loaded.
        this.state_dependencies = "failed";
        if ( this.state_base === "loaded" ) {
          this.trigger("load_base_and_dependencies", this );
          if ( this.state_hierarchy === "loaded" ) {
            this.trigger("load_hierarchy_and_dependencies", this );
            if (this.isComponentsLoaded()) {
              this.trigger("load", this);
            }
          }
        }
      },

      /**
       * Loads the Three.JS data for this object and all of its children. The following events will be fired
       * during this process:
       * "load" - fired when all objects in the hierarchy are loaded and all dependencies are either loaded or have encountered an error.
       * "load_base" - fired when the data for just object is loaded, not including any children or asset dependencies (materials, textures, etc.).
       * "load_base_and_hierarchy" - fired when the Three.JS data for the object is loaded as well as for the entire heirarchy below this object.
       * "load_base_and_dependencies" - fired when the data for the top-level object is loaded as well as any asset dependencies (materials, textures, etc.) used by the entire hierarchy.
       * "load_hierarchy" - fired when the hierarchy of Three.JS objects have been loaded. This does not include asset dependencies like materials and textures.
       * "load_hierarchy_and_dependencies" - fired when the hierarchy of Three.JS objects have been loaded as well as all asset dependencies like materials and textures.
       * "load_dependencies" - fired when all the asset dependencies (animations, textures, etc.) for an object (and its children) have been loaded. This does not necessarily mean that the Three.JS objects for the hierarchy are loaded.
       * "load_progress" - fired whenever the loading of the object, its children, or any of its asset dependencies makes progress. Check the "loadingProgress" member of the object for progress information.
       * "load_base_failure" - fired iff this object fails to be created for any reason. Sets state_base = "failed"
       * "load_hierarchy_failure" - fired iff an object in the hierarchy failed to be created for some reason. Sets state_hierarchy = "failed"
       * "load_dependencies_failure" - fired when one or more dependencies failed to load. Sets state_dependencies = "failed"
       * @method load
       * @param  {Object} callbacks This object contains callbacks for various loading events:
       * "load"
       * "load_base"
       * "load_base_and_dependencies"
       * "load_base_and_hierarchy"
       * "load_hierarchy"
       * "load_hierarchy_and_dependencies"
       * "load_dependencies"
       * "load_progress"
       * "load_base_failure"
       * "load_hierarchy_failure"
       * "load_dependencies_failure"
       *
       */
      load: function( callbacks ) {

        if ( !callbacks ) { callbacks = {}; }

        if ( callbacks.success || callbacks.success_base || callbacks.success_hierarchy || callbacks.failure ) {
          console.error("Passing in deprecated callback names to 'load' method!!!");
        }

        //Bind any passed-in callbacks to the appropriate events.
        if ( callbacks.load ) {
          this.listenToOnce( this, "load", function( ) {
            callbacks.load( this );
          } );
        }
        if ( callbacks.load_base ) {
          this.listenToOnce( this, "load_base", function( ) {
            callbacks.load_base( this );
          } );
        }
        if ( callbacks.load_base_and_hierarchy ) {
          this.listenToOnce( this, "load_base_and_hierarchy", function( ) {
            callbacks.load_base_and_hierarchy( this );
          } );
        }
        if ( callbacks.load_base_and_dependencies ) {
          this.listenToOnce( this, "load_base_and_dependencies", function( ) {
            callbacks.load_base_and_dependencies( this );
          } );
        }
        if ( callbacks.load_hierarchy ) {
          this.listenToOnce( this, "load_hierarchy", function( ) {
            callbacks.load_hierarchy( this );
          } );
        }
        if ( callbacks.load_hierarchy_and_dependencies ) {
          this.listenToOnce( this, "load_hierarchy_and_dependencies", function( ) {
            callbacks.load_hierarchy_and_dependencies( this );
          } );
        }
        if ( callbacks.load_dependencies ) {
          this.listenToOnce( this, "load_dependencies", function( ) {
            callbacks.load_dependencies( this );
          } );
        }
        if ( callbacks.load_components ) {
          this.listenToOnce( this, "load_components", function( ) {
            callbacks.load_components( this );
          } );
        }
        // if ( callbacks.load_progress ) {
        //   this.on( "load_progress", function onProgress( ) {
        //     callbacks.load_progress( this );
        //     if ( this.getLoadingProgress() >= 1.0 ) {
        //       this.off( "load_progress", onProgress, this );
        //     }
        //   }, this );
        // }
        if ( callbacks.load_base_failure ) {
          this.listenToOnce( this, "load_base_failure", function( ) {
            callbacks.load_base_failure( this );
          } );
        }
        if ( callbacks.load_hierarchy_failure ) {
          this.listenToOnce( this, "load_hierarchy_failure", function( ) {
            callbacks.load_hierarchy_failure( this );
          } );
        }
        if ( callbacks.load_dependencies_failure ) {
          this.listenToOnce( this, "load_dependencies_failure", function( ) {
            callbacks.load_dependencies_failure( this );
          } );
        }

        var that = this;
        this.once("load", function() {
          var parentAsset = that.getParentAsset();
          parentAsset.trigger( "objectLoaded", that );
        }, this );

        //Load this object
        this.load_base( );

        //Now handle loading the object's children
        this.load_hierarchy( );

        this.load_dependencies();
      },

      reset: function() {},

      getDataSizeTotalDownload: undefined,
      getDataSizeTotalInMemory: undefined,
      getDataSizeGeometryDownload: undefined,
      getDataSizeGeometryInMemory: undefined,
      getDataSizeTextureDownload: undefined,
      getDataSizeTextureInMemory: undefined,
      getDataSizeAnimationDownload: undefined,
      getDataSizeAnimationInMemory: undefined,

      getListOfReferencedGeometries: function() {
        var list = {};
        var children = this.entityModel.get("children");
        _.each( children, function( included, id ) {
          if ( included ) {
            var obj = this.getChildById( id );
            if ( obj ) {
              var childsList = obj.getListOfReferencedGeometries();
              _.each( childsList, function( x, id ) {
                list[ id ] = childsList[ id ];
              }, this );
            }
          }
        }, this );
        return list;
      },

      getListOfReferencedTextures: function() {
        var list = {};
        var children = this.entityModel.get("children");
        _.each( children, function( included, id ) {
          if ( included ) {
            var obj = this.getChildById( id );
            if ( obj ) {
              var childsList = obj.getListOfReferencedTextures();
              _.each( childsList, function( x, id ) {
                list[ id ] = childsList[ id ];
              }, this );
            }
          }
        }, this );
        return list;
      },

      //Hmm, since animations aren't connected to an entity, we can't generally get a list...
      // getListOfReferencedAnimations: function() {
      //   var list = {};
      //   var children = this.entityModel.get("children");
      //   _.each( children, function( included, id ) {
      //     if ( included ) {
      //       var obj = this.getChildById( id );
      //       if ( obj ) {
      //         var childsList = obj.getListOfReferencedAnimations();
      //         _.each( childsList, function( x, id ) {
      //           list[ id ] = childsList[ id ];
      //         }, this );
      //       }
      //     }
      //   }, this );
      //   return list;
      // },


      load_base: function( options ) {

        if ( this.state_base === "loaded" ) {
          this.trigger( "load_base", this );
        }
        else if ( this.state_base === "pending" ) {
          this.state_base = "loading";
          this.trigger('load_started', this );
          this.componentManager.loadComponents();
          
          var json = this.entityModel.toJSON();
          if ( this.isInstance() ) {

            var srcObj = this.getSourceObject();
            if ( !srcObj ) {
              this.trigger("load_base_failure", this );
              return;
            }

          }
          this._loadThreeData( json );
        }
      },

      load_dependencies: function() {
        this.trigger("load_dependencies", this );
      },

      /**
       * Erase this entity's components.
       * @method clearComponents
       * @param  {Object} options Standard options structure to support 'success' callback, 'save' boolean, etc.
       */
      clearComponents: function( options ) {
        this.set({"components" : {}}, options );
      },

      //This method checks for references to other veroldObjects in its
      //components. If references to other objects in the hierarchy are found,
      //those references are replaced with references to the corresponding cloned
      //object. Otherwise, references are left unchanged.
      _linkupComponentReferences: function( componentData ) {
        var prefabParent = this.getPrefabInstanceTop();
        if ( prefabParent ) {
          var prefabIdMapping = prefabParent.getPrefabIdMapping();

        // _.each( components, function( comp, id ) {
        //   if ( !comp.componentData ) {
        //     comp.componentData = {};
        //   }
          _.each( componentData, function( value, key ) {
            if ( _.isArray( value ) ) {
              _.each( value, function( refId, refKey ) {
                if ( prefabIdMapping[ refId ] ) {
                  componentData[ key ][ refKey ] = prefabIdMapping[ refId ];
                }
              });
            }
            else if ( _.isString( value )) {
              if ( prefabIdMapping[value] ) {
                componentData[ key ] = prefabIdMapping[ value ];
              }
            }
          });
        }
      },

      /**
       * Reset this entity's components to match its prefab (if it's an instance).
       * If the entity isn't an instance of a prefab, this will not affect its components.
       * @method revertComponentsToPrefab
       * @param  {Object} options Standard options structure to support 'success' callback, 'save' boolean, etc.
       */
      revertComponentsToPrefab: function( options ) {
        var prefabObject = this.getPrefabObject();
        if ( prefabObject ) {
          var newComponents = {};
          var components = this.entityModel.get("components");
          var prefabComponents = prefabObject.entityModel.get("components");

          this.clearComponents();
          //For each component that we have, reset it to match the prefab.
          _.each( components, function( component, id ) {
            if ( prefabComponents[ id ] ) {
              newComponents[ id ] = { scriptId: prefabComponents[ id ].scriptId, componentData: {} };
            }
          }, this );

          //For each component that is in the prefab and not in this object, add it
          _.each( prefabComponents, function( component, id ) {
            if ( !newComponents[ id ] ) {
              newComponents[ id ] = { scriptId: component.scriptId, componentData: {} };
            }
          }, this );

          this.set( {"components": newComponents }, options );
        }
      },

      /**
       * If this object is a prefab instance, revert its settings
       * back to that of the prefab. By default, this call is recursive
       * and will revert changes for this object's hierachy as well.
       * Pass in "nonRecursive" key with a value of true to change this.
       * @method revertToPrefab
       * @param  {Object} options Options object
       */
      revertToPrefab: function( options ) {
        var that = this;
        var prefabObject = this.getPrefabObject();
        if ( prefabObject ) {
          var changeMade = false;
          var isTopLevel = this.isPrefabInstanceTop();
          var payload = this.entityModel.get("payload");
          var prefabPayload = prefabObject.entityModel.get("payload");

          var newPayload = {};
          _.each( payload, function( value, key ) {
            if ( !isTopLevel || !(key === "position" || key === "orientation" ) ) {
              changeMade = true;
              newPayload[ key ] = undefined;
            }
          }, this );
          if ( isTopLevel ) {
            newPayload.position = payload.position;
            newPayload.orientation = payload.orientation;
          }

          this.revertComponentsToPrefab( );

          //Apply the payload changes and then, once that's
          //finished, revert all children recursively. After that, add or remove any children
          //that don't match the prefab.
          this.set({"payload" : newPayload }, { save: options ? options.save && changeMade : false,
            success: function( ) {
              if ( options && !options.nonRecursive ) {
                var children = that.entityModel.get("children");
                var ids = _.keys( children );
                async.forEach( ids, function( id, next ) {

                  if ( children[ id ] ) {
                    var obj = that.getParentAsset().getObjectById( id );
                    if ( obj ) {
                      obj.revertToPrefab( {
                        save: options.save,
                        success: function() {
                          next();
                        },
                        failure: function() {
                          next();
                        }
                      } );
                    }
                    else {
                      next();
                    }
                  }
                  else {
                    next();
                  }
                }, function() {
                  that._revertChildrenToPrefab( options );
                } );
              }
              else {
                //that._revertChildrenToPrefab( options );
                if ( options && options.success ) {
                  options.success( that );
                }
              }
            }
          });

        }
        else if ( options && options.failure ) {
          options.failure();
        }
      },

      /**
       * Revert the enitre prefab instance associated with this object to
       * match the source prefab.
       * @method revertAllToPrefab
       * @param  {Object} options [description]
       */
      revertAllToPrefab: function( options ){
        var topLevelObject = this.getPrefabInstanceTop();
        if ( topLevelObject ) {
          if ( options && options.nonRecursive ) {
            delete options.nonRecursive;
          }
          topLevelObject.revertToPrefab( options );
        }
      },

      //Reset children of this object to only the ones also specified in the prefab
      _revertChildrenToPrefab: function( options ) {
        var that = this;
        var changes = {};
        var prefabObject = this.getPrefabObject();
        var prefabAsset = this.getPrefabAsset();
        if ( prefabObject ) {
          var differences = this._determineChildDifferences( prefabObject );
          var ids = _.keys( differences );
          async.forEach( ids, function( id, next ) {
            if ( differences[ id ] ) {
              changes[ "children." + id ] = false;
              next();
            }
            else {
              var parentAsset = that.getParentAsset();
              var prefab = prefabAsset.getObjectById( id );
              prefab.copyTo( parentAsset.id, {
                persistent: that.entityModel.isPersistent,
                save: options.save,
                success: function( copy ) {
                  //Linkup new objects to prefab
                  prefabAsset.linkupPrefab( copy, prefab, { save : options.save, prefabInstanceId: that.entityModel.get("prefabInstanceId") } );
                  //this.addChild( copy, { save : save } );
                  changes[ "children." + copy.id ] = true;
                  next();
                }
              });
            }
          }, function() {
            if ( !_.isEmpty(changes) ) {
              that.set( changes, options );
            }
            else if ( options && options.success ) {
              options.success();
            }
          } );
        }
        else if ( options && options.success ) {
          options.success();
        }
      },

      //Compare the children of this object with the children of the given prefab object.
      //Return an object with a list of children as keys and a boolean as value.
      //If the boolean is true, it means that the child is from this object and doesn't have a corresponding child in the prefab.
      //If the boolean is false, the child is from the prefab and doesn't have a corresponding child in this object
      _determineChildDifferences: function( prefabObject ) {
        var prefabAssetId = this.entityModel.get("prefabAssetId");
        var prefabChildren = prefabObject.entityModel.get("children");
        var myChildren = this.entityModel.get("children");
        var differences = {};
        var prefabObjectMap = {};

        //Construct a map of children of this object that have corresponding children
        //in the prefab.
        //At the same time, find children in this object that don't have associated
        //prefab objects in the given prefab.
        _.each( myChildren, function( included, id ) {
          if ( included ) {
            var child = this.getParentAsset().getObjectById( id );
            if ( child ) {
              var childPrefabId = child.entityModel.get("prefabObjectId");
              var childPrefabAssetId = child.entityModel.get("prefabAssetId");

              if ( childPrefabId && childPrefabAssetId === prefabAssetId && prefabChildren[ childPrefabId ]) {
                prefabObjectMap[ childPrefabId ] = child;
              }
              else {
                differences[ id ] = true;
              }
            }
          }
        }, this );

        //Find children in prefab that don't have a corresponding child in this object.
        _.each( prefabChildren, function( included, id ) {
          if ( included ) {
            var child = prefabObject.getParentAsset().getObjectById( id );

            if ( child && !prefabObjectMap[ id ] ) {
              differences[ id ] = false;
            }
          }

        }, this );

        return differences;
      },


      /**
       * If this object is a prefab instance, save the current changes to the
       * prefab object and propagate the changes to all other instances of the
       * prefab. By default, this call is recursive and will push changes for this
       * object's hierachy as well.
       * @method pushToPrefab
       * @param  {Object} options The standard options object.
       */
      pushToPrefab: function( options ) {
        this.dontAcceptPrefabUpdates = true;
        var that = this;
        var prefabObj = this.getPrefabObject();
        if ( prefabObj ) {

          //Copy children
          that._pushChildrenToPrefab( prefabObj, {
            save : options ? options.save : false,
            success: function() {
              //Copy payload values and components
              prefabObj.copyProperties( that, {
                success: function() {
                  prefabObj.copyComponents( that, { //save: options ? options.save : false,
                    success: function() {
                      //Remove components that aren't in this object
                      var componentRemoval = [];
                      var prefabComponents = prefabObj.entityModel.get("components");
                      var myComponents = that.entityModel.get("components");
                      _.each( prefabComponents, function( component, id ) {
                        if ( !myComponents[ id ] ) {
                          componentRemoval.push( "components." + id );
                        }
                      }, that );

                      for ( var i = 0; i < componentRemoval.length; i++ ) {
                        prefabObj.unset( componentRemoval[i], { save: false } );
                      }

                      if ( options && options.save ) {
                        prefabObj.save( {
                          success: function() {
                            that.revertToPrefab( {
                              save : options ? options.save : false,
                              nonRecursive: true,
                              success: function() {
                                var children = that.entityModel.get("children");
                                var ids = _.keys( children );
                                if ( options && options.nonRecursive ) {
                                  ids = {};
                                }
                                async.forEach( ids, function( id, next ) {
                                  if ( children[ id ] ) {
                                    var obj = that.getParentAsset().getObjectById( id );
                                    if ( obj ) {
                                      obj.pushToPrefab( {
                                        save : options ? options.save : false,
                                        nonRecursive: false,
                                        success: function() {
                                          next();
                                        }
                                      } );
                                    }
                                    else {
                                      next();
                                    }
                                  }
                                  else {
                                    next();
                                  }
                                }, function() {
                                  if ( options && options.success ) {
                                    that.dontAcceptPrefabUpdates = false;
                                    options.success();
                                  }
                                });
                              }
                            } );
                          }
                        });
                      }

                    }
                  });
                }
              });
            }
          } );


        }
      },

      pushAllToPrefab: function( options ){
        var topLevelObject = this.getPrefabInstanceTop();
        if ( topLevelObject ) {
          if ( options && options.nonRecursive ) {
            delete options.nonRecursive;
          }
          topLevelObject.pushToPrefab( options );
        }
      },

      _pushChildrenToPrefab: function( prefabObject, options ) {

        var removeChildren = {};
        var prefabAsset = prefabObject.getParentAsset();
        var that = this;
        var differences = this._determineChildDifferences( prefabObject );
        var ids = _.keys( differences );
        async.forEach( ids, function( id, next ) {
          //If there is a child that isn't in the prefab, copy it to the prefab.
          if ( differences[ id ] ) {
            var child = that.getParentAsset().getObjectById( id );
            if ( child ) {

              child.copyTo( prefabAsset.id, {
                persistent: prefabAsset.entityModel.isPersistent,
                save: options.save,
                success: function( copy ) {
                  //child.set( { "prefabObjectId" : copy.id, "prefabAssetId" : prefabAsset.id }, { save: options.save });

                  copy.traverse( function( obj ) {
                    obj.unset( "prefabObjectId", { silent: true } );
                    obj.unset( "prefabAssetId", { silent: true } );
                    obj.unset( "prefabInstanceId", { silent: true } );
                  });
                  copy.unset( "prefabObjectId", { silent: true } );
                  copy.unset( "prefabAssetId", { silent: true } );
                  copy.unset( "prefabInstanceId", { silent: true } );
                  //Linkup new objects to prefab
                  prefabAsset.linkupPrefab( child, copy, { save : options.save, prefabInstanceId: that.entityModel.get("prefabInstanceId"),
                    success: function() {
                      prefabObject.addChild( copy, { save : options.save, keepPrefabLinks: true,
                        success: function() {
                          next();
                        }
                      } );
                    }
                  } );

                }
              });
            }
            else {
              next();
            }
          }
          else {
            removeChildren[ "children." + id ] = false;
            next();
          }
        }, function() {
          //save
          if ( _.isEmpty( removeChildren )) {
            if ( options && options.success ) {
              options.success();
            }
          }
          else {
            prefabObject.set( removeChildren, options );
          }
        });

      },

      /**
       * Copy the properties of the given object to this object, overwriting
       * any of the same name.
       * @method copyProperties
       * @param  {VeroldEntity} object  The object to copy properties from.
       * @param  {Object} options The standard options object
       */
      copyProperties: function( object, options ) {
        var changes = { payload: {}};
        var payload = object.entityModel.get("payload");
        var myPayload = this.entityModel.get("payload");

        _.extend( changes.payload, myPayload, payload );

        this.set( changes, options );
      },

      /**
       * Copy the components attached to the given object to this object.
       * This will add components that don't exist as well as copy attribute
       * values for components that do exist, overwriting the existing values.
       * @method copyComponents
       * @param  {VAPI.VeroldEntity} object  The source object
       * @param  {Object} options The standard options object
       */
      copyComponents: function( object, options ) {
        var changes = { components: {} };
        var objComponents = object.entityModel.get("components");
        var myComponents = this.entityModel.get("components");

        _.extend( changes.components, myComponents, objComponents );

        _.each( objComponents, function( component, id ) {

          if ( myComponents[ id ] ) {
            _.extend( changes.components[ id ].componentData, myComponents[ id ].componentData, component.componentData );
          }

        }, this );

        this.set( changes, options );
      },

      /**
       * Copy the properties of the given object to this object, leaving
       * any of the same name unmodified.
       * @method mergeProperties
       * @param  {VeroldEntity} object  The object to copy properties from.
       * @param  {Object} options The standard options object
       */
      mergeProperties: function( object, options ) {
        var changes = { payload: {}};
        var payload = object.entityModel.get("payload");
        var myPayload = this.entityModel.get("payload");

        _.extend( changes.payload, payload, myPayload );

        this.set( changes, options );
      },

      /**
       * Copy the components attached to the given object to this object.
       * This will add components that don't exist and leave existing components
       * unmodified.
       * @method mergeComponents
       * @param  {VAPI.VeroldEntity} object  The source object
       * @param  {Object} options The standard options object
       */
      mergeComponents: function( object, options ) {
        var changes = { components: {} };
        var objComponents = object.entityModel.get("components");
        var myComponents = this.entityModel.get("components");

        _.extend( changes.components, objComponents, myComponents );

        _.each( objComponents, function( component, id ) {

          if ( myComponents[ id ] ) {
            _.extend( changes.components[ id ].componentData, component.componentData, myComponents[ id ].componentData );
          }

        }, this );

        this.set( changes, options );
      },

      _loadThreeData: function(  json  ) {

        function onSourceLoaded( srcObj ) {
          srcObj.off( "load_base", onSourceLoaded, that );
          that.threeData = srcObj.cloneThreeData();
          that.threeData.veroldEntityId = that.id;
          that.threeData.name = that.entityModel.get("name");
          //that.loadingProgress = srcObj.loadingProgress;

          that.applyPayloadSettings_loaded( json.payload );

          that.trigger("load_base", that);
          var parentAsset = that.getParentAsset();
          parentAsset.trigger( "objectLoaded", that );
        }

        var that = this;

        //If this is an instance, load the source and clone it.
        if ( this.isInstance() ) {

          this._initPrefabBindings();
          var srcObject = that.getSourceObject();
          srcObject.on( "load_base", onSourceLoaded, this );
          srcObject.load();
        }
        //Otherwise, we need to create a new object.
        else {
          this.threeData = new THREE.Object3D();
          this.threeData.veroldEntityId = this.id;
          this.threeData.name = this.entityModel.get("name");
          this.applyPayloadSettings_loaded( json.payload );

          this.trigger("load_base", this);
          var parentAsset = this.getParentAsset();
          parentAsset.trigger( "objectLoaded", this );
        }
      },

      //If this object is an instance of another, we'll hook up the backbone events
      //so that we can listen to changes to the source asset.
      _initPrefabBindings: function( ) {
        var prefabObject = this.getPrefabObject();
        if ( prefabObject ) {
          //prefabObject.entityModel.on( "change:name", this.onPrefabEntityNameChanged, this );
          prefabObject.entityModel.on( "change:payload.*", this.onPrefabEntityPayloadChanged, this );
          prefabObject.entityModel.on( "change:components.*", this.onPrefabEntityComponentsChanged, this );
          prefabObject.entityModel.on( "change:children.*", this.onPrefabEntityChildrenChanged, this );
        }
        var srcObject = this.getSourceObject();
        if ( srcObject ) {
          srcObject.on( "load_progress_source", this.onSourceLoadProgress, this );
        }
        else {
          console.error("Source object can't be found for instance " + this.type + ", " + this.id );
        }
      },

      _uninitPrefabBindings: function( ) {
        var prefabObject = this.getPrefabObject();
        if ( prefabObject ) {
          //prefabObject.entityModel.on( "change:name", this.onPrefabEntityNameChanged, this );
          prefabObject.entityModel.off( "change:payload.*", this.onPrefabEntityPayloadChanged, this );
          prefabObject.entityModel.off( "change:components.*", this.onPrefabEntityComponentsChanged, this );
          prefabObject.entityModel.off( "change:children.*", this.onPrefabEntityChildrenChanged, this );
        }
        var srcObject = this.getSourceObject();
        if ( srcObject ) {
          srcObject.off( "load_progress_source", this.onSourceLoadProgress, this );
        }

      },

      isHierarchyFinished: function() {
        return ( this.state_hierarchy === "loaded" || this.state_hierarchy === "failure" );
      },

      isBaseFinished: function() {
        return ( this.state_base === "loaded" || this.state_base === "failure" );
      },

      isHierarchyFailed: function() {
        return ( this.state_hierarchy === "failure" );
      },

      isBaseFailed: function() {
        return ( this.state_base === "failure" );
      },

      onChildLoadProgress: function( child ) {
        //With the progress info from the child, figure out this object's
        //loading progress.
        //this.updateLoadingProgress();
        this.trigger( "load_progress", this );

      },

      /**
       * Loads the entire hierarchy of objects below this one.
       * @method load_hierarchy
       */
      load_hierarchy: function( ) {

        if ( this.state_hierarchy === "loaded" ) {
          this.trigger( "load_hierarchy", this );
        }
        else if ( this.state_hierarchy === "pending" ) {
          var that = this;
          this.state_hierarchy = "loading";

          //Record a list of the child hierarchies to load so that we can know
          //when all the children are complete.
          var parentAsset = this.getParentAsset();
          var children = this.entityModel.get( "children");
          var childIds = _.keys( children );

          //Go through the children and load them if they're set to true.
          //Then add them as a child, when they're loaded.
          async.forEach( childIds, function( id, next ) {
            var included = children[ id ];
            if ( included ) {
              var child = parentAsset.getObjectById( id );
              if ( child ) {
                //Setting the parent id because this might not exist yet (especially for non-persistent objects that are
                //put together manually by code.)
                child.set({"parentId": that.id }, {silent: true});
                var nextCalledAlready = false;
                // child.on( "load_hierarchy", that.onChildHierarchyLoaded, that );
                //child.on( "load_base", that.onChildTopLevelLoaded, that );
                //child.on( "load_progress", that.onChildLoadProgress, that );
                // child.on( "load_hierarchy_failure", that.onChildHierarchyFailed, that );
                // child.on( "load_base_failure", that.onChildTopLevelFailed, that );
                //When the child's base is loaded, add it to this object
                that.listenToOnce( child, "load_base", function onChildLoaded( childObj ) {
                  function thisLoaded() {

                    that.threeData.add( childObj.threeData );
                    that.veroldEngine.needsRender = true;

                    if ( childObj.type === "light") {
                      console.log("A light was added to object " + that.id + " so we'll rebuild all shaders.");
                      that.veroldEngine.trigger('rebuildMaterials');
                    }
                    if ( child.state_hierarchy === "loaded" && !nextCalledAlready ) {
                      nextCalledAlready = true;
                      next();
                    }
                  }

                  if ( that.state_base === "loaded") {
                    thisLoaded();
                  }
                  else {
                    that.listenToOnce( that, "load_base", thisLoaded );
                    that.load_base();
                  }

                } );

                that.listenToOnce( child, "load_hierarchy", function onChildHierarchyLoaded( childObj ) {
                  if ( child.state_base === "loaded" && child.threeData.parent && !nextCalledAlready ) {
                    nextCalledAlready = true;
                    next();
                  }
                });

                child.load();
              }
              else {
                console.warn("The " + that.type + ", " + that.id + ", has a child, " + id + ", that can't be found.");
                var propertyString = "children." + id;
                var removeJSON = {};
                removeJSON[ propertyString ] = false;
                that.set( removeJSON, { silent: true } );
                next();
              }
            }
            else {
              next();
            }
          }, function() {
            that.trigger("load_hierarchy", that);
          } );
        }
      },

      /**
       * Unload the object and its hierarchy.
       * @method unload
       * @param  {Object} options [Supported callbacks: { success, failure }]
       */
      unload: function( options ) {
        if (!options) { options = {}; }

        if ( this.componentManager ) {
          this.componentManager.unloadComponents();
        }

        if ( this.state_base !== 'pending' ) {

          if ( this.threeData ) {
            if ( this.threeData.parent ) {
              this.threeData.parent.remove(this.threeData);
            }
          }
        }

        //Unregister any dependencies that we're listening to.
        // for ( x in this.dependencies ) {
        //   if ( this.dependencies.hasOwnProperty( x ) ) {
        //     this.unregisterDependency(x, true, true );
        //   }
        // }
        var that = this;
        //Only unload children that are legit verold objects. Everything else should be
        //handled by whatever created it.
        var parentAsset = this.getParentAsset();
        var children = this.entityModel.get("children");
        var childObjectIds = _.keys( children );
        async.forEach( childObjectIds, function( id, next ) {

          if ( children[ id ] ) {
            var childObj = parentAsset.getObjectById( id );
            if ( childObj ) {
              //childObj.off( "sizeNeedsUpdate", that.onChildSizeNeedsUpdate, that );
              // childObj.off( "load_hierarchy", that.onChildHierarchyLoaded, that );
              //childObj.off( "load_base", that.onChildTopLevelLoaded, that );
              //childObj.off( "load_progress", that.onChildLoadProgress, that );
              // childObj.off( "load_hierarchy_failure", that.onChildHierarchyFailed, that );
              // childObj.off( "load_base_failure", that.onChildTopLevelFailed, that );

              if ( !options.nonRecursive ) {
                childObj.unload( {
                  success: function() {
                    next();
                  },
                  failure: function() {
                    console.warning("There was a problem unloading, ", childObj );
                    next();
                  }
                });
              }
              else {
                next();
              }
            }
            else {
              next();
            }
          }
          else {
            next();
          }
        }, function() {
          that.state_base = 'pending';
          that.state_hierarchy = 'pending';
          //that.state_hierarchy_dependencies = 'pending';
          that.state_dependencies = 'pending';
          that.threeData = null;
          // that.dataSize = {
          //   "base" : 0,
          //   "base_in_memory" : 0,
          //   "hierarchy" : 0,
          //   "dependencies" : 0,
          //   "dependencies_in_memory" : 0,
          // };
          that.loadingProgress = {
            "base" : 0,
            "hierarchy" : 0,
            "dependencies" : 0,
          };
          if ( options && options.success ) {
            options.success( that );
          }
        });
      },

      /**
       * Returns true if the three.js data is fully loaded, including all dependencies
       * and children in this entity's hierarchy.
       * @method isLoaded
       * @return {Boolean} True, if loaded
       */
      isLoaded: function() {
        return (this.state_base === "loaded" && this.state_hierarchy === "loaded" && this.state_dependencies === "loaded" ) ? true : false;
      },

      /**
       * Returns true if the three.js data for this entity is loaded. This does not include
       * any dependencies (like materials, textures, etc.) or any children in this entity's hierarchy.
       * @method isBaseLoaded
       * @return {Boolean} True, if the base three.js object is loaded
       */
      isBaseLoaded: function() {
        return (this.state_base === "loaded" ) ? true : false;
      },

      /**
       * Returns true if the three.js data for this entity's entire hierarchy is loaded. This does not include
       * any dependencies (like materials, textures, etc.).
       * @method isHierarchyLoaded
       * @return {Boolean} True, if the three.js hierarchy is loaded
       */
      isHierarchyLoaded: function() {
        return (this.state_hierarchy === "loaded" ) ? true : false;
      },

      /**
       * Returns true if the three.js data for all assets referenced by this entity are loaded.
       * i.e. materials, textures, animations, etc.
       * @method isDependenciesLoaded
       * @return {Boolean} True, if the dependencies are all loaded
       */
      isDependenciesLoaded: function() {
        return (this.state_dependencies === "loaded" ) ? true : false;
      },

      isPersistent: function() {
        return this.entityModel.isPersistent ? true : false;
      },

      _generateUuid: function() {
        var uuid = "", i, random;
        for (i = 0; i < 32; i++) {
          random = Math.random() * 16 | 0;

          if (i === 8 || i === 12 || i === 16 || i === 20) {
            uuid += "-";
          }
          uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);
        }
        return uuid;
      },

      //If the Three.JS data is available, update the settings for the object.
      //This method is called after loading an object and whenever there is a backbone
      //change event fired.
      applyPayloadSettings_loaded: function( changes, options ) {
        if ( this.state_base !== "pending" && changes ) {

          var position, orientation;
          if ( changes ) {
            var newVal;
            var isStatic = this.getProperty("static");

            this.threeData.matrixAutoUpdate = !(isStatic && !this.veroldEngine.isEditor);
            this.threeData.rotationAutoUpdate = !(isStatic && !this.veroldEngine.isEditor);

            //Transform updates
            if ( this.threeData.position !== undefined ) {
              position = this.getPosition();
              this.threeData.position.set( position.x, position.y, position.z );
            }
            if ( this.threeData.quaternion !== undefined ) {
              orientation = this.getQuaternion();
              this.threeData.quaternion.set( orientation.x, orientation.y, orientation.z, orientation.w );
            }
            if ( this.threeData.scale !== undefined ) {
              var scale = this.getScale();
              this.threeData.scale.set( scale.x, scale.y, scale.z );
            }

            if ( changes.hasOwnProperty("center") ) {
              var center = this.getCenter();
              if ( center ) {
                if ( this.threeData.center ) {
                  this.threeData.center.set( center.x, center.y, center.z );
                }
                else {
                  this.threeData.center = new THREE.Vector3( center.x, center.y, center.z );
                }
              }
            }

            if ( this.getProperty("editorOnly") && !this.veroldEngine.isEditor ) {
              this.threeData.visible = false;
            }
            if ( this.threeData.visible !== undefined ) {
              if ( this.getProperty("editorOnly") ) {
                if ( this.veroldEngine.isEditor ) {
                  newVal = this.getProperty("visible");
                  if ( newVal !== undefined ) {
                    this.threeData.visible = newVal;
                  }
                }
              }
              else {
                newVal = this.getProperty("visible");
                if ( newVal !== undefined ) {
                  this.threeData.visible = newVal;
                }
              }
            }

            if ( this.threeData.castShadow !== undefined ) {
              newVal = this.getProperty("castShadow");
              if ( newVal !== undefined ) {
                this.threeData.castShadow = newVal;
              }
            }
            if ( this.threeData.receiveShadow !== undefined ) {
              newVal = this.getProperty("receiveShadow");
              if ( newVal !== undefined ) {
                this.threeData.receiveShadow = newVal;
              }
            }
            if ( this.threeData.frustumCulled !== undefined ) {
              newVal = this.getProperty("frustumCulled");
              if ( newVal !== undefined ) {
                this.threeData.frustumCulled = newVal;
              }
            }

            if ( isStatic ) {
              this.threeData.matrixWorldNeedsUpdate = true;
              this.threeData.updateMatrix();
            }

          }
        }
      },

      //Update the settings for the object that don't require the Three.JS data to exist.
      //This method is called after loading an object and whenever there is a backbone
      //change event fired.
      applyPayloadSettings_unloaded: function( changes, options ) {

      },

      set : function( json, options ) {
        if ( json.id && this.id !== json.id ) {
          console.warn(this.veroldEngine.engineName + ":VeroldEntity - ID specified in JSON when calling 'set' doesn't match the ID of the object. Was this intended?");
        }

        this.entityModel.set( json, options );
        if ( !options || ( !options.remote && !options.silent && !options.undo ) ) {
          this.veroldEngine.globalEvents.trigger( "entityPayloadChange", this.entityModel, json );
        }
        if ( options ) {

          if ( options.save && this.entityModel.isPersistent && this.veroldEngine.isWritable) {
            this.save( options );
          }
          else if ( options.success ) {
            options.success( this );
          }
        }
      },

      hardSet : function( json, options ) {
        // var current = this.entityModel.toJSON();
        // _.each( current, function( value, name ) {
        //   if ( json[ name ] === undefined ) {
        //     json[ name ] = undefined;
        //   }
        //   if ( _.isObject( json[ name ] ) ) {
        //     _.each( current[ name ], function( subValue, subName ) {
        //       if ( json[name][subName] === undefined ) {
        //         json[name][subName] = undefined;
        //       }
        //     }, this );
        //   }
        // }, this );
        var children = this.entityModel.get("children");
        this.entityModel.clearData();
        _.each( children, function( included, id ) {
          if ( included && !json.children[id] && this.entityModel.isValidEntityId( id ) ) {
            json.children[id] = false;
          }
          else if ( included ) {
            json.children[id] = true;
          }
        }, this );

        this.set( json, options );
      },

      hardSubSet : function( attrib, json, options ) {
        var current = this.entityModel.toJSON();
        if ( _.isObject( current[ attrib ] ) ) {
          _.each( current[ attrib ], function( value, name ) {
            if ( json[name] === undefined ) {
              json[name] = undefined;
            }
          }, this );
        }

        var change = {};
        change[attrib] = json;
        this.set( change, options );
      },

      save : function( options ) {
        if ( !options ) {
          options = {};
        }
        if ( this.entityModel.isPersistent && window.socket) {
          var that = this;
          var saveJSON = {};
          if ( window.socket ) {
            saveJSON.connectionId = window.socket.io.engine.id;
          } else {
            saveJSON.connectionId = null;
          }
          saveJSON.parentAssetId = this.getParentAsset().id;

          this.entityModel.save( saveJSON, { silent: true,
            success: function( ) { //model, response ) {
              if ( options.success ) { options.success( that ); }
              //console.log( that.veroldEngine.engineName + ":VeroldEntity - Object: ", that, " saved." );
            },
            error: function( model, response ) {
              if ( options.failure ) { options.failure( that ); }
              console.log( that.veroldEngine ? that.veroldEngine.engineName : "Verold Engine" + ":VeroldEntity - Object failed to save: ", model, response);
            }
          });
        }
      },

      //Deep unset of backbone data.
      //
      unset : function( json, options ) {
        if ( json.id && this.id !== json.id ) {
          console.warn(this.veroldEngine.engineName + ":VeroldEntity - ID specified in JSON when calling 'unset' doesn't match the ID of the object. Was this intended?");
        }

        //delete json.id;
        if ( !options ) { options = {}; }

        this.entityModel.unset( json, options );

        var that = this;

        if ( options.save && this.entityModel.isPersistent && window.socket && this.veroldEngine.isWritable) {
          // var saveJSON = {};
          // if ( window.socket ) {
          //   saveJSON.connectionId = window.socket.io.engine.id;
          // } else {
          //   saveJSON.connectionId = null;
          // }
          // saveJSON.parentAssetId = this.getParentAsset().id;

          this.save( options );
          // this.entityModel.save( saveJSON, { silent: true,
          //   success: function( model, response ) {
          //     if ( options.success ) { options.success(); }
          //     console.log( that.veroldEngine.engineName + ":VeroldEntity - Object saved: ", that );
          //   },
          //   error: function( model, response) {
          //     if ( options.failure ) {
          //       options.failure();
          //     }
          //     console.log( that.veroldEngine.engineName + ":VeroldEntity - Object failed to save: ", that, response);
          //   }
          // });
        }
        else {

          if ( options.success ) {
            options.success( this );
          }
        }

      },

      destroy: function( options ) {
        var parentAsset = this.getParentAsset();

        parentAsset.destroyObject( this.id, options );
      },


      /**
       * Clones the object in the database as well as the threeJS data, if loaded.
       * @method clone
       * @param  {Object} options The standard options object
       */
      clone: function( options ) {

        var newCloneID;
        var parentAsset = this.getParentAsset();
        var that = this;

        if ( !options ) { options = {}; }

        if ( options.persistent && !options.nonRecursive ) {

          var cloneJSON = {};

          if ( window.socket ) {
            cloneJSON.connectionId = window.socket.io.engine.id;
          } else {
            cloneJSON.connectionId = null;
          }
          cloneJSON.parentAssetId = parentAsset.id;

          this.entityModel.getClone( cloneJSON, function( newEntity ) {

            newCloneID = newEntity.id;
            newEntity.veroldEngine = that.veroldEngine;
            that.veroldEngine.globalEvents.trigger( "entityAddedChange", newEntity );
            parentAsset.whenObjectRegistered( newCloneID, function() {
              var object = parentAsset.getObjectById( newCloneID );
              object.traverse( function( obj ) {
                that.veroldEngine.globalEvents.trigger( "entityAddedChange", obj.entityModel );
              });
              if ( options.success ) {
                options.success( object );
              }
            });
          });

        }
        else {

          var newObjectJSON = {};

          newObjectJSON.id = options.id ? parentAsset.generateUniqueObjectID( options.id ) : parentAsset.generateUniqueObjectID( this.entityModel.id );
          newObjectJSON.name = options.name !== undefined ? options.name : this.entityModel.get("name");

          //Only copy the prefab links if the top-level of the instance is being copied
          //If the top-level is copied, set the flag so that recursive calls will copy links.
          if ( options.keepPrefabLinks && this.isPrefabInstance() || this.isPrefabInstanceTop() ) {
            options.keepPrefabLinks = true;
            newObjectJSON.prefabObjectId = this.entityModel.get("prefabObjectId");
            newObjectJSON.prefabAssetId = this.entityModel.get("prefabAssetId");

            if ( this.isPrefabInstanceTop() ) {
              options.prefabInstanceId = newObjectJSON.id;

            }
            newObjectJSON.prefabInstanceId = options.prefabInstanceId ? options.prefabInstanceId : this.entityModel.get("prefabInstanceId");
          }
          //If the object isn't a prefab instance, turn off the flag so that children don't keep their links.
          else if ( !this.isPrefabInstance() ) {
            options.keepPrefabLinks = false;
          }

          newObjectJSON.type = this.entityModel.get("type");
          newObjectJSON.sourceObjectId = this.entityModel.get("sourceObjectId");
          newObjectJSON.sourceAssetId = this.entityModel.get("sourceAssetId");
          newObjectJSON.payload = this.entityModel.clonePayload();
          newObjectJSON.components = this.entityModel.cloneComponents();

          parentAsset.createObject( newObjectJSON, { persistent: false,
            success: function( newObject ) {

              var children = that.entityModel.get("children");
              if ( children && !options.nonRecursive ) {
                var ids = _.keys( children );
                async.forEach( ids, function( id, next ) {
                  if ( children[ id ]) {
                    var child = parentAsset.getObjectById( id );
                    child.clone( { persistent: false,
                      prefabInstanceId: options.prefabInstanceId,
                      keepPrefabLinks: options.keepPrefabLinks,
                      success: function( newChild ) {
                        newObject.addChild( newChild, {
                          keepPrefabLinks: options.keepPrefabLinks,
                          success: function() {
                            next();
                          }
                        } );
                      }
                    });
                  }
                }, function() {
                  if ( options.success ) {
                    options.success( newObject );
                  }
                });
              }
              else {
                if ( options.success)  {
                  options.success( newObject );
                }
              }
            }
          });
        }
      },

      //Only copies and returns the Three.JS data for the asset. i.e. it doesn't create another
      //Verold asset but only the underlying Three.JS data.
      //Each object type may need to override this function to provide this functionality.
      //Should options be specified to allow for cloning whole tree, etc.?
      cloneThreeData: function( ) {
        if ( this.threeData ) {
          var children = this.threeData.children;
          this.threeData.children = [];
          var newObject = this.threeData.clone();
          this.threeData.children = children;
          return newObject;
        }
      },

      //Copies and returns the Three.JS data for the asset while keeping transformations linked.
      //Each object type may need to override this function to provide this functionality.
      //Should options be specified to allow for cloning whole tree, etc.?
      mirrorThreeData: function( options ) {
        var that = this;
        function mirrorThreeObject( object, recursive ) {
          var children = object.children;
          object.children = [];
          var newObject = object.clone();
          object.children = children;
          newObject.position = object.position;
          newObject.quaternion = object.quaternion;
          newObject.scale = object.scale;

          if ( recursive ) {
            _.each( children, function( value, x ) {
              var newChild = mirrorThreeObject( children[x], true );
              newObject.add( newChild );
              that.veroldEngine.needsRender = true;
            }, this);
          }
          return newObject;
        }

        if ( this.threeData ) {
          var newObject = mirrorThreeObject( this.threeData, options.recursive );

          return newObject;
        }
      },

      /**
       * Copy this object and all of its children to the given asset.
       * @method copyTo
       * @param  {assetId} assetID The destination asset for the copied objects.
       * @param  {Object} options Options for the copy. 'success' is a callback that
       * is called when the copy is complete. It's parameter is the newly created object.
       */
      copyTo: function( assetID, options ) {
        var newParent = this.veroldEngine.assetRegistry.getAssetById( assetID );
        if ( newParent ) {
          this.clone( {
            persistent: options.persistent,
            save: options.save,
            success : function( newObj ) {

              newObj.moveTo( assetID, options );
            }
          });
        }
        else {
          console.warn("Non-existent asset specified in copyTo()");
        }
      },

      /**
       * Move this object and all of its children to the given asset.
       * @method moveTo
       * @param  {assetId} assetID The destination asset for the moved objects.
       * @param  {Object} options Options for the move. 'success' is a callback that
       * is called when the move is complete. It's parameter is the newly created object.
       */
      moveTo: function( assetID, options ) {

        var that = this;
        var newParent = this.veroldEngine.assetRegistry.getAssetById( assetID );
        if ( newParent ) {
          if ( this.id === assetID ) {
            return;
          }
          var parentAsset = this.getParentAsset();
          var parent = this.getParentObject();
          if ( parent ) {
            parent.removeChildById( this.id );
          }
          var objects = [ this.id ];
          this.traverse( function( obj ) {
            objects.push( obj.id );
          });

          //This object will be part of a new asset and won't have a parent yet.
          this.entityModel.set({"parentId" : null}, {silent: true});

          async.forEach( objects, function( id, next ) {
            var obj = parentAsset.getObjectById( id );
            parentAsset.entityModel.subEntities.remove( obj.entityModel );
            newParent.entityModel.subEntities.add( obj.entityModel );

            //The moving of the object has caused a new one to be registered. Replace
            //this new object with the old one. This won't update references in other
            //concurrent engines...
            newParent.objects[ obj.id ].uninitialize();
            obj.entityModel.veroldEngine = that.veroldEngine;
            newParent.objects[ obj.id ] = obj;
            if ( options && options.persistent && obj.entityModel.isPersistent ) {
              obj.save( {
                success: function() {
                  console.log("Moved " + obj.type + ", " + obj.id + ", to new asset.");
                  next();
                },
                failure: function() {
                  console.error("Failed to moved " + obj.type + ", " + obj.id + ", to new asset.");
                  next();
                }
              });
            }
            else {
              next();
            }
          }, function() {
            if ( options.success ) {
              options.success( that );
            }
          } );

        }
        else {
          console.warn("Non-existent asset specified in moveTo()");
        }
      },

      /**
       * Adds the specified object as a direct child of this object.
       * The object must already be registered as part of the parent asset.
       * (i.e. it was created with createObject() or moved to this asset with moveTo())
       * @method addChildById
       * @param  {String} objectId The ID of the object to add as a direct child of this object.
       * @param  {Object} options  Standard options structure. Can contain the following key-value pairs:
       * 'save' : true or false
       * 'success' : callback function when finished
       * 'failure' : callback function when failed
       * 'retainTransform' : true if you want the child's transform automatically adjusted to keep its
       *  position, orientation and size relative to the parent the same as before.
       */
      addChildById: function( objectId, options ) {

        function _retainWorldTransform ( oldParent, object, options ) {
          var childJSON = {};
          //If the object is loaded, we'll use the three.js matrix data to
          //compute the new transform information for the child (so that the
          //child's relative world transform doesn't change)
          if ( options.retainTransform && that.threeData ) {

            var newParentMat = new THREE.Matrix4();
            newParentMat.getInverse( that.threeData.matrixWorld );

            if ( oldParent && oldParent.threeData ) {

              var parentMat = new THREE.Matrix4();
              parentMat.copy( oldParent.threeData.matrixWorld );

              if ( object.threeData ) {
                object.threeData.applyMatrix( parentMat );
              }
            }

            var position = new THREE.Vector3();
            var scale = new THREE.Vector3();
            var quaternion = new THREE.Quaternion();
            if ( object.threeData ) {
              object.threeData.applyMatrix( newParentMat );
              position.copy( object.threeData.position );
              scale.copy( object.threeData.scale );
              quaternion.copy( object.threeData.quaternion );
            }
            else {
              var mat = new THREE.Matrix4();
              position.copy( object.getPosition() );
              quaternion.copy( object.getQuaternion() );
              scale.copy( object.getScale() );
              mat.compose( position, quaternion, scale );
              mat.multiply( newParentMat );
              mat.decompose( position, quaternion, scale );
            }

            childJSON["payload.position"] = { x: position.x, y: position.y, z: position.z };
            childJSON["payload.orientation"] = { x: quaternion.x, y: quaternion.y, z: quaternion.z, w: quaternion.w };
            childJSON["payload.scale"] = { x: scale.x, y: scale.y, z: scale.z };
            childJSON.parentId = that.id;
            object.set( childJSON, { save: options.save, success: options.success } );
          }
          else {
            object.set({ "parentId" : that.id }, options);
          }
        }

        function _removeFromOldParent( oldParent, object, options ) {
          //If the object has a parent already, remove it from that parent.
          if ( oldParent && oldParent.id !== that.id ) {
            //remove the object from previous parent
            var removeJSON = {};
            removeJSON[ propertyString ] = false;
            oldParent.set( removeJSON, options );
          }
          else {
            if ( options && options.success ) {
              options.success( that );
            }
          }
        }

        var that = this;
        var object = this.getParentAsset().getObjectById( objectId );
        if ( object ) {

          if ( objectId === this.id ) { return; }
          if (!options) { options = {}; }

          //These calls to 'set' will trigger the backbone events that will handle the changes.
          var propertyString = "children." + objectId;
          var oldParent = object.getParentObject();
          _removeFromOldParent( oldParent, object, {
            save: options.save,
            failure: function() {
              console.error("addChildById: Failed to remove new child from old parent. Aborting.");
              if ( options && options.failure ) {
                options.failure( that );
              }
            },
            success: function() {
              _retainWorldTransform( oldParent, object, {
                save: options.retainTransform && options.save, //Save only if retainTransform is being done
                retainTransform: options.retainTransform,
                failure: function() {
                  console.error("addChildById: Failed to set the transform of the new child. Reverting.");
                  if ( oldParent ) {
                    var addJSON = {};
                    addJSON[ propertyString ] = true;
                    oldParent.set( addJSON, { save: options.save });
                  }
                  if ( options && options.failure ) {
                    options.failure( that );
                  }
                },
                success: function() {

                  if ( !options.keepPrefabLinks ) {
                    if ( object.isPrefabInstance() && !object.isPrefabInstanceTop() ) {
                      object.breakPrefabLink( { save: options.save });
                    }
                  }

                  //Add the object as a direct child of this object
                  var addJSON = {};
                  addJSON[ propertyString ] = true;

                  that.set( addJSON, { save: options.save,
                    failure: function() {
                      console.error("addChildById: Failed to add the new child. Reverting.");
                      if ( oldParent ) {
                        var addJSON = {};
                        addJSON[ propertyString ] = true;
                        oldParent.set( addJSON, { save: options.save });
                      }
                      if ( options && options.failure ) {
                        options.failure( that );
                      }
                    },
                    success: function() {
                      if ( options && options.success ) {
                        options.success( that );
                      }
                    }
                  });
                }
              } );
            }
          } );


        }
        else {
          console.error( this.veroldEngine.engineName + " - VeroldEntity.addChildById - the object being added is not part of this asset. If it is an object from a different asset (e.g. scene, model, etc.), it must first be moved to this asset using moveTo()");
        }
      },

      /**
       * Adds the specified object as a direct child of this object.
       * The object must already be registered as part of the parent asset.
       * (i.e. it was created with createObject() or moved to this asset with moveTo())
       * @method addChild
       * @param  {VAPI.VeroldObject} object  The object to add as a direct child of this object.
       * @param  {Object} options Options structure. Can contain the following key-value pairs:
       * 'save' : true or false
       * 'success' : callback function when finished
       * 'failure' : callback function when failed
       */
      addChild: function( object, options ) {

        this.addChildById( object.id, options );
      },

      /**
       * Removes the specified object as a direct child of this asset.
       * This does not delete (destroy) the object or unload it.
       * @method removeChildById
       * @param  {String} objectId The ID of the object to add as a direct child of this object.
       * @param  {Object} options  Options structure. Can contain the following key-value pairs:
       * 'save' : true or false
       * 'success' : callback function when finished
       * 'failure' : callback function when failed
       */
      removeChildById: function( objectId, options ) {
        var object = this.getParentAsset().getObjectById( objectId );
        if ( object ) {
          if (!options) { options = {}; }
          //If the current parent of the object is this asset, remove it.
          if ( this.entityModel.get("children")[ object.id ] ) {

            //These calls to 'set' will trigger the backbone events that will handle the changes.
            var propertyString = "children." + object.id;
            //remove the object from previous parent
            var removeJSON = {};
            removeJSON[ propertyString ] = false;
            this.set( removeJSON, options );
          }
          else {
            console.warn( this.veroldEngine.engineName + " - VeroldEntity.removeChildById - the object is not a direct child of this object. If you're trying to delete the object, call destroyObject()");
          }
        }
        else {
          console.warn( this.veroldEngine.engineName + " - VeroldEntity.removeChildById - the object being removed is not part of this asset.");
        }
      },

      /**
       * Removes the specified object as a direct child of this asset.
       * This does not delete (destroy) the object or unload it.
       * @method removeChild
       * @param  {VAPI.VeroldObject} object  The object to add as a direct child of this object.
       * @param  {Object} options Standard options structure. Can contain the following key-value pairs:
       * 'save' : true or false
       * 'success' : callback function when finished
       * 'failure' : callback function when failed
       */
      removeChild: function( object, options ) {
        this.removeChildById( object.id, options );
      },

      onEntityNameChanged: function( model, value ) {
        var changeList = model.changed;

        if ( changeList.name ) {
          if ( this.threeData && this.threeData.name !== undefined ) {
            this.threeData.name = value;
          }
        }

      },

      //Called when the backbone model changes and the scene object needs to be
      //updated to reflect the changes.
      onEntityPayloadChanged: function( model, changes ) {//, value) {
        var changeList = model.changed;

        if ( this.state_base === "loaded" ) {
          if (!changeList.payload) { changeList.payload = {}; }
          this.applyPayloadSettings_loaded( changeList.payload );
        }
        this.applyPayloadSettings_unloaded( changeList.payload );
      },

      //Called when the backbone model's children list changes.
      //We'll make sure the child object's parentId is updated appropriately
      //and, if the object is loaded, we'll update the Three.JS data as well.
      onEntityChildrenChanged: function( model, value ) {
        var changeList = model.changed;

        var that = this;
        var parentAsset = this.getParentAsset();

        var children = _.keys( changeList.children );
        async.forEach( children, function( id, next ) {

          var child = parentAsset.getObjectById( id );
          if ( changeList.children[ id ] && child ) {
            //console.log( this.veroldEngine.engineName + " - Adding child " + child.type + ", " + x + ", to " + this.type + ", " + this.id );
            if ( that.veroldEngine.isPrimaryEngine() ) {
              child.registerInitialDependencies();
            }

            //child.on( "sizeNeedsUpdate", that.onChildSizeNeedsUpdate, that );
            //child.on( "load_progress", that.onChildLoadProgress, that );
            // child.on( "load_hierarchy", that.onChildHierarchyLoaded, that );
            //child.on( "load_base", that.onChildTopLevelLoaded, that );
            // child.on( "load_base_failure", that.onChildTopLevelFailed, that );
            // child.on( "load_hierarchy_failure", that.onChildHierarchyFailed, that );

            if ( that.state_base !== "pending" ) {
              var nextCalledAlready = false;
              //that.state_hierarchy = "loading";
              child.load( {
                load_base: function( newChild ) {
                  if ( that.state_base !== "loaded" ) {
                    newChild.listenToOnce( that, "load_base", function() {
                      that.threeData.add( newChild.threeData );
                      that.veroldEngine.needsRender = true;
                    });
                  }
                  else {
                    that.threeData.add( newChild.threeData );
                    that.veroldEngine.needsRender = true;
                  }
                  if ( newChild.type === "light") {
                    console.log("A light was added to object, " + that.id + ", so we'll rebuild all shaders.");
                    that.veroldEngine.trigger('rebuildMaterials');
                  }
                  if ( child.state_hierarchy === "loaded" && !nextCalledAlready ) {
                    nextCalledAlready = true;
                    next();
                  }
                },
                load_hierarchy: function() {
                  if ( child.state_base === "loaded" && child.threeData.parent && !nextCalledAlready ) {
                    nextCalledAlready = true;
                    next();
                  }
                }
              });
            }
          }
          else {

            // console.log(that.veroldEngine.engineName +  " - Removing child, " + id + ", from " + that.type + ", " + that.id );
            if ( child ) {

              if ( that.veroldEngine.isPrimaryEngine() ) {
                child.unregisterInitialDependencies();
              }

              //child.off( "sizeNeedsUpdate", that.onChildSizeNeedsUpdate, that );
              //child.off( "load_progress", that.onChildLoadProgress, that );
              // child.off( "load_hierarchy", that.onChildHierarchyLoaded, that );
              //child.off( "load_base", that.onChildTopLevelLoaded, that );
              // child.off( "load_base_failure", that.onChildTopLevelFailed, that );
              // child.off( "load_hierarchy_failure", that.onChildHierarchyFailed, that );

              if ( that.state_base !== "pending" ) {
                that.threeData.remove( parentAsset.objects[ id ].threeData );
                if ( child.type === "light") {
                  console.log("A light was removed from object, " + that.id + ", so we'll rebuild all shaders.");
                  that.veroldEngine.trigger('rebuildMaterials');
                }
              }
            }
            next();
            //this.trigger("child_removed", child);
          }
        }, function() {
          that.trigger("load_hierarchy");
          //If the parent's hierarchy has previously been loaded, it's not listening anymore so
          //tell it that it's hierarchy has been loaded again.
          var parent = that.getParentObject();
          if ( parent && parent.state_hierarchy === "loaded" ) {
            parent.trigger("load_hierarchy");
          }
        });

        parentAsset.trigger( "sizeNeedsUpdate", this );
      },

      onSourceLoadProgress: function() {
        this.trigger("load_progress", this);
      },

      //Called when the source/prefab asset changes and the instance object needs to be
      //updated to reflect the changes.
      onPrefabEntityPayloadChanged: function( model ) {
        if ( this.dontAcceptPrefabUpdates ) {
          return;
        }
        var changeList = model.changed;
        var payload = this.entityModel.get("payload");
        var payloadChanges = {};
        var topLevel = this.isPrefabInstanceTop();
        //Only update the property if the instance hasn't overridden it.
        _.each( changeList.payload, function( payloadVal, valueName ) {

          if ( topLevel && ( valueName === "position" || valueName === "orientation" || valueName === "scale" ) ) {
            return;
          }
          if ( payload[ valueName ] === undefined || payload[ valueName ] === null ) {
            payloadChanges[ valueName ] = payloadVal;
          }
        }, this );

        if ( this.state_base === "loaded" ) {
          this.applyPayloadSettings_loaded( payloadChanges );
        }
        this.applyPayloadSettings_unloaded( payloadChanges );

      },

      onPrefabEntityComponentsChanged: function( model ) {
        if ( this.dontAcceptPrefabUpdates ) {
          return;
        }
        if (!this.componentManager) {
          return;
        }
        var changedPrefabComponents = model.changed.components;
        var prefabObject = this.getPrefabObject();
        var prefabComponents = prefabObject.entityModel.get("components");
        var myComponents = this.entityModel.get("components");
        if ( !myComponents ) {
          myComponents = {};
        }
        var changes = { components: {}};
        var removals = [];
        //For new components coming from the prefab, add them to our payload.
        //For deleted components coming from the prefab, handle deleting them.
        _.each( changedPrefabComponents, function( comp, id ) {
          if ( !comp ) {
            if ( myComponents[ id ] ) {
              //Only remove the component if it doesn't have any overridden parameters.
              if ( _.isEmpty( myComponents[ id ].componentData ) ) {
                removals.push( "components." + id );
              }
            }
            return;
          }
          if ( !myComponents[ id ] ) {
            changes.components[ id ] = { scriptId: prefabComponents[ id ].scriptId, componentData: {} };
          }
        }, this );
        if ( removals.length ) {
          _.each( removals, function( toRemove ) {
            this.unset( toRemove );
          }, this );
          if ( _.isEmpty( changes.components ) ) {
            this.save();
          }
        }
        if ( !_.isEmpty( changes.components ) ) {
          this.set( changes, {save: true});
        }
      },

      //Called when the source/prefab asset changes and the instance object needs to be
      //updated to reflect the changes.
      onPrefabEntityChildrenChanged: function( model ) {
        if ( this.dontAcceptPrefabUpdates ) {
          return;
        }
        var that = this;
        // var changeList = model.changed;
        // var children = this.entityModel.get("children");
        // var childrenChanges = {};
        var prefabAsset = this.getPrefabAsset();
        var save = this.veroldEngine.isWritable && this.entityModel.isPersistent ? true : false;

        var prefabObject = this.getPrefabObject();

        var differences = this._determineChildDifferences( prefabObject );

        _.each( differences, function( notInPrefab, id ) {

          //Look at this object's children to find one that is an instance of the prefabObjId
          //If it doesn't exist, create a clone
          if ( !notInPrefab ) {
            var parentAsset = this.getParentAsset();
            var prefab = prefabAsset.getObjectById( id );
            prefab.copyTo( parentAsset.id, {
              persistent: this.entityModel.isPersistent,
              save: save,
              success: function( copy ) {
                //Linkup new objects to prefab
                prefabAsset.linkupPrefab( copy, prefab, {
                  save : save,
                  prefabInstanceId: that.entityModel.get("prefabInstanceId"),
                  success: function() {
                    that.addChild( copy, { save : save, keepPrefabLinks: true } );
                  }
                } );
              }
            });
          }
          //If it does exist and it has been deleted, delete it from this object.
          else { // if ( !included ) {
            //prefabObjectMap[ prefabObjId ].destroy();
            var child = this.getParentAsset().getObjectById( id );
            if ( child ) {
              child.destroy();
            }
          }

        }, this );

      },

      generateUniqueObjectName: function( assetName ) {
        var parentAsset = this.getParentAsset();
        return parentAsset.generateUniqueObjectName( assetName );
      },

      generateUniqueObjectID: function( objectID ) {
        var parentAsset = this.getParentAsset();
        return parentAsset.generateUniqueObjectID( objectID );
      },

      /**
       * Align an object relative to a position. This uses the object's bounding box.
       * @method alignToPosition
       * @param  {vector3} newPosition The position to work relative to.
       * @param  {vector3} alignment   An object of the form { "x": x, "y": y, "z": z} where the values for x, y and z
       * are between -1 and +1 and specify how the object is aligned to the edges of the model. e.g. { x: 0, y: -1, z: 0 }
       * will align the bottom, centre of the object to the specified position.
       * @param  {Object} options     Options object. You can pass in 'success' and 'failure' callbacks that will be
       * called when the action finishes.
       */
      alignToPosition: function( newPosition, alignment, options ) {

        var orientation = this.getQuaternion();
        var scale = this.getScale();
        var center = this.getCenter();
        var rotation = new THREE.Quaternion();
        rotation.set( orientation.x, orientation.y, orientation.z, orientation.w );

        var boundingbox = this.getProperty("boundingbox");
        if (!boundingbox) {
          console.warn("No bounding box specified for " + this.type + " " + this.id + " so we can't align it.");
          return;
        }
        var aabb = {};
        aabb.min = new THREE.Vector3( boundingbox.min.x, boundingbox.min.y, boundingbox.min.z);
        aabb.max = new THREE.Vector3( boundingbox.max.x, boundingbox.max.y, boundingbox.max.z);
        aabb.min.applyQuaternion( rotation );
        aabb.max.applyQuaternion( rotation );

        var offset = new THREE.Vector3( center.x, center.y, center.z );
        offset.applyQuaternion( rotation );

        aabb.min.multiply(  scale  );
        aabb.max.multiply(  scale  );
        offset.multiply(  scale  );

        if ( alignment ) {
          _.each( alignment, function( value, x ) {
            var newMin  =  Math.min(  aabb.min[x],  aabb.max[x]  );
            var newMax  =  Math.max(  aabb.min[x],  aabb.max[x]  );
            var align = alignment[x] * 0.5 + 0.5;
            newPosition[x] -= ((1.0 - align) * newMin + align * newMax);
          }, this );
        }

        var modelChanges = { "payload.position": { "x": newPosition.x, "y": newPosition.y, "z": newPosition.z }};

        this.set( modelChanges, options );

      },

      /**
       * get the current scale of the object
       * @method getScale
       * @return {Vector3} the axis scales
       */
      getScale: function() {
        var scale = this.getProperty("scale");
        if ( scale ) {
          return new THREE.Vector3( scale.x, scale.y, scale.z );
        }
        else {
          return new THREE.Vector3( 1, 1, 1);
        }
      },

      /**
       * set the scale of each axis
       * @method setScale
       * @param {float} x :     value to scale the x axis
       * @param {float} y :     value to scale the y axis
       * @param {float} z :     value to scale the z axis
       * @param {Object} options :    Options object. You can pass in 'success' and 'failure' callbacks that will be
       * called when the action finishes.
       */
      setScale: function( x, y, z, options ) {
        if ( z === undefined ) { console.warn("Calling setScale with invalid arguments. Expected setScale( x, y, z, options )."); }

        this.set( { "payload.scale" : { x: x, y: y, z : z }}, options );
      },

      /**
       * Get the name of the entity
       * @method getName
       * @return {String} The entity's name
       */
      getName: function() {
        return this.entityModel.get("name");
      },

      /**
       * Set the name of the entity
       * @method setName
       * @param {String} newName       : The entity's new name
       * @param {Object} options :    Options object. You can pass in 'success' and 'failure' callbacks that will be
       * called when the action finishes.
       */
      setName: function( newName, options ) {
        return this.set( {"name" : newName }, options );
      },

      /**
       * Get the description of the entity
       * @method getDescription
       * @return {String} The entity's description
       */
      getDescription: function() {
        return this.entityModel.get("description");
      },

      /**
       * Set the description of the entity
       * @method setDescription
       * @param {String} newName       : The entity's new description
       * @param {Object} options :    Options object. You can pass in 'success' and 'failure' callbacks that will be
       * called when the action finishes.
       */
      setDescription: function( newDescription, options ) {
        return this.set( {"description" : newDescription }, options );
      },

      /**
       * Get the position of the object
       * @method getPosition
       * @param  {Vector3} outVector Optional vector to write the result to. Passing this in will avoid another
       * THREE.Vector3 from being created.
       * @return {Vector3} position of the object
       */
      getPosition: function( outVector ) {
        var returnVector = outVector;
        if ( !outVector ) {
          returnVector = new THREE.Vector3();
        }
        var position = this.getProperty("position");
        if ( position ) {
          returnVector.copy( position );
        }
        return returnVector;
      },

      /**
       * set the position of the object
       * @method setPosition
       * @param {float} x       : x axis position
       * @param {float} y       : y axis position
       * @param {float} z       : z axis position
       * @param {Object} options :    Options object. You can pass in 'success' and 'failure' callbacks that will be
       * called when the action finishes.
       */
      setPosition: function( x, y, z, options ) {
        if ( z === undefined ) { console.warn("Calling setPosition with invalid arguments. Expected setPosition( x, y, z, options )."); }

        this.set( { "payload.position" : { x: x, y: y, z : z }}, options );
      },

      /**
       * get the quaternion for the object
       * @method getQuaternion
       * @return {Quaternion} object's quaternion
       */
      getQuaternion: function() {
        var orientation = this.getProperty("orientation");
        if ( orientation ) {
          return new THREE.Quaternion( orientation.x, orientation.y, orientation.z, orientation.w );
        }
        else {
          return new THREE.Quaternion();
        }
      },

      /**
       * set the quaternion for the object
       * @method setQuaternion
       * @param {float} x       : x axis rotation
       * @param {float} y       : y axis rotation
       * @param {float} z       : z axis rotation
       * @param {float} w       : magnitude of rotation
       * @param {Object} options    Options object. You can pass in 'success' and 'failure' callbacks that will be
       * called when the action finishes.
       */
      setQuaternion: function( x, y, z, w, options ) {
        if ( w === undefined ) {
          console.warn("Calling setQuaternion with invalid arguments. Expected setQuaternion( x, y, z, w, options ).");
        }

        this.set( { "payload.orientation" : { x: x, y: y, z : z, w: w }}, options );
      },

      /**
       * Get the center point of the object
       * @method getCenter
       * @param  {Vector3} outVector Optional vector to write the result to. Passing this in will avoid another
       * THREE.Vector3 from being created.
       * @return {Vector3} the center point of the object. if the object has no center, it uses the center of the bounding box
       */
      getCenter: function( outVector ) {
        var returnVector = outVector;
        if ( !outVector ) {
          returnVector = new THREE.Vector3();
        }

        var bb = this.getProperty("boundingbox");
        if ( bb ) {
          returnVector.copy( bb.min );
          returnVector.add( bb.max );
          returnVector.multiplyScalar( 0.5 );
        }
        else {
          returnVector.set(0.0, 0.0, 0.0);
        }

        return returnVector;
      },

      /**
       * get the center point relative to the parent's position
       * @return {Vector3} the center point in the parent's space
       */
      getCenterInParentSpace: function() {
        var center = this.getCenter();
        var quaternion = this.getQuaternion();
        var scale = this.getScale();
        var position = this.getPosition();
        center.multiply( scale );
        center.applyQuaternion( quaternion );
        center.add( position );
        return center;
      },

      /**
       * Set a new or existing property for this object.
       * @method setProperty
       * @param  {String} propertyName Name of the property to set.
       * @param  {Mixed} value        Value of the property.
       * @param  {Object} options      Standard options object to specify callbacks, saving, etc.
       */
      setProperty: function( propertyName, value, options ) {
        var changes = {};
        changes[ "payload." + propertyName ] = value;
        this.set( changes, options );
      },

      /**
       * Set a new or existing property for this object and for all objects under it in the hierarchy
       * @method setPropertyRecursive
       * @param  {String} propertyName Name of the property to set.
       * @param  {Mixed} value        Value of the property.
       * @param  {Object} options      Standard options object to specify callbacks, saving, etc.
       */
      setPropertyRecursive: function( propertyName, value, options ) {
        var that = this;
        if ( !options ) {
          options = {};
        }
        // Code for saveRecursive
        if ( this.entityModel.isPersistent && options.save ) {
          var payload = {};
          payload[propertyName] = value;
          this.entityModel.setPayloadRecursive( payload, function() {
            if ( options.success ) {
              //TODO - this callback doesn't actually represent the end of the transaction
              //since we don't know that the changes have come back over the TMU yet.
              options.success( this );
            }
          });
        }
        else {
          this.setProperty( propertyName, value, { success: function() {
            var children = _.keys( that.entityModel.get('children') );
            async.forEach( children, function( id, next ) {
              var child = that.getObjectById(id);
              if ( child ) {
                child.setPropertyRecursive( propertyName, value, { success: next } );
              }
              else {
                next();
              }
            }, function() {
              if ( options.success ) {
                options.success( that );
              }
            });
          }});
          
        }
      },

      /**
       * Returns the property of the object given by 'propertyName'
       * If the property doesn't exist in the object, the prefab object
       * is checked. If the prefab doesn't contain the property, the
       * source object is checked.
       * @method getProperty
       * @param  {String} propertyName The name of the property.
       * @return {Mixed}              The property value
       */
      getProperty: function( propertyName ) {
        var payload = this.entityModel.get("payload");
        if ( payload && payload[ propertyName ] !== undefined ) {
          return payload[ propertyName ];
        }
        else {
          var prefabObj = this.getPrefabObject();
          if ( prefabObj ) {
            return prefabObj.getProperty( propertyName );
          }
          else {
            var sourceObj = this.getSourceObject();
            if ( sourceObj ) {
              return sourceObj.getProperty( propertyName );
            }
            else {
              return undefined;
            }
          }
        }
        return undefined;
      },

      /**
       * Returns the previous value of the property of the object given by 'propertyName'
       * If the property doesn't exist in the object, the prefab object
       * is checked. If the prefab doesn't contain the property, the
       * source object is checked.
       * @method getPreviousProperty
       * @param  {String} propertyName The name of the property.
       * @return {Mixed}              The property's previous value
       */
      getPreviousProperty: function( propertyName ) {
        var payload = this.entityModel.previous("payload");
        if ( payload && payload[ propertyName ] !== undefined ) {
          return payload[ propertyName ];
        }
        else {
          var prefabObj = this.getPrefabObject();
          if ( prefabObj ) {
            return prefabObj.getPreviousProperty( propertyName );
          }
          else {
            var sourceObj = this.getSourceObject();
            if ( sourceObj ) {
              return sourceObj.getPreviousProperty( propertyName );
            }
            else {
              return undefined;
            }
          }
        }
        return undefined;
      },

      /**
       * Set the specified material on every object in the hierarchy.
       * @method setMaterialRecursive
       * @param {String} materialId The Id of the material to use.
       */
      setMaterialRecursive: function( materialId ) {
        if ( this.setMaterial ) {
          this.setMaterial( materialId );
        }
        var children = this.getChildren();
        _.each( children, function( child, id ) {
          child.setMaterialRecursive( materialId );
        }, this );
      },

      /**
       * Unlink this entity from its prefab. This will prevent it from receiving prefab
       * updates. By default, the entity's hierarchy is also unlinked. Passing in options.nonRecursive
       * as 'true' will prevent this.
       * @method breakPrefabLink
       * @param  {Object} options Standard options structure supporting success callback, save boolean, etc.
       */
      breakPrefabLink: function( options ) {
        if ( !this.isPrefabInstance() ) {
          console.warn("breakPrefabLink: Can't call this on an entity that isn't an instance.");
          if ( options && options.success ) {
            options.success();
          }
          return;
        }
        var that = this;
        options = options ? options : {};

        var children = this.entityModel.get("children");
        var ids = _.keys( children );
        async.forEach( ids, function( id, next ) {
          if ( children[ id ] && !options.nonRecursive ) {
            var child = that.getParentAsset().getObjectById( id );
            if ( child ) {
              child.breakPrefabLink( { silent: options.silent, save: options.save, nonRecursive: options.nonRecursive,
                success: function() {
                  next();
                },
                failure: function() {
                  next();
                }
              } );
            }
            else {
              next();
            }
          }
          else {
            next();
          }
        }, function() {

          that._uninitPrefabBindings();
          that.mergeProperties( that.getPrefabObject(), { silent: options.silent } );
          that.mergeComponents( that.getPrefabObject() );
          var changes = {};
          
          changes.prefabInstanceId = undefined;
          changes.prefabObjectId = undefined;
          changes.prefabAssetId = undefined;
          that.set( changes, { silent: true, save: options.save,
            success: function() {
              if ( options.success ) {
                options.success();
              }
            }
          });

        } );
      },

      getPrefabIdMapping: function() {
        var instanceIdMapping = {};
        this.traverse( function( entity ) {
          if ( entity.getPrefabObject() ) {
            instanceIdMapping[ entity.getPrefabObject().id ] = entity.id;
          }
        });
        return instanceIdMapping;
      },

      /**
       * Scale this object to a fixed size in the space of its parent. e.g. world space
       * @method scaleToSize
       * @param  {Float} size    The size in units of the parent's space.
       * @param  {Object} options Options object.
       */
      scaleToSize: function( size, options ) {
        var scale = this._determineScaleToSize( size );
        var modelChanges = { "payload.scale": { "x": scale, "y": scale, "z": scale } };

        this.set( modelChanges, options );
      },

      _determineScaleToSize: function( size ) {

        var bb = this.getProperty("boundingbox");
        if (!bb) {
          console.warn("No bounding box specified for " + this.type + " " + this.id + " so we can't scale it.");
          return 1.0;
        }
        else {
          var aabb = {};
          aabb.min = new THREE.Vector3( bb.min.x, bb.min.y, bb.min.z);
          aabb.max = new THREE.Vector3( bb.max.x, bb.max.y, bb.max.z);
          // Determine the mesh's scale and origin.
          var  distance  =  aabb.min.distanceTo(  aabb.max  );
          var  scale  =  size  /  distance;
          if ( scale <= 0 ) {
            scale = 1.0;
          }
          return scale;
        }
      },

      //Return the transformed bounding box info for the children of this object
      // computeBoundingBox: function( options ) {
      //   var children = this.entityModel.get("children");
      //   var bb = { min: new THREE.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE ), max: new THREE.Vector3( -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE ) };

        // _.each( children, function( value, x ) {
        //   var child = this.getChildById( x );
        //   if ( children[x] && child ) {

        //     var childBB = child.computeBoundingBox();

        //     var boundingbox = child.getProperty("boundingbox");
        //     // var sourceObj = child.getSourceObject();
        //     // if ( sourceObj ) {
        //     //   payload = sourceObj.entityModel.get("payload");
        //     // }

        //     if ( boundingbox ) {
        //       childBB.min.x = Math.min( childBB.min.x, boundingbox.min.x );
        //       childBB.min.y = Math.min( childBB.min.y, boundingbox.min.y );
        //       childBB.min.z = Math.min( childBB.min.z, boundingbox.min.z );
        //       childBB.max.x = Math.max( childBB.max.x, boundingbox.max.x );
        //       childBB.max.y = Math.max( childBB.max.y, boundingbox.max.y );
        //       childBB.max.z = Math.max( childBB.max.z, boundingbox.max.z );
        //       //console.log( "child bb : ", childBB.min, childBB.max );
        //     }

        //     if ( childBB.min.x < childBB.max.x ) {
        //       var position = child.getPosition();
        //       var quaternion = child.getQuaternion();
        //       var scale = child.getScale();

        //       childBB.min.multiply( scale );
        //       childBB.min.applyQuaternion( quaternion );
        //       childBB.min.add( position );

        //       childBB.max.multiply( scale );
        //       childBB.max.applyQuaternion( quaternion );
        //       childBB.max.add( position );

        //       bb.min.x = Math.min( bb.min.x, Math.min( childBB.min.x, childBB.max.x ) );
        //       bb.min.y = Math.min( bb.min.y, Math.min( childBB.min.y, childBB.max.y ) );
        //       bb.min.z = Math.min( bb.min.z, Math.min( childBB.min.z, childBB.max.z ) );
        //       bb.max.x = Math.max( bb.max.x, Math.max( childBB.min.x, childBB.max.x ) );
        //       bb.max.y = Math.max( bb.max.y, Math.max( childBB.min.y, childBB.max.y ) );
        //       bb.max.z = Math.max( bb.max.z, Math.max( childBB.min.z, childBB.max.z ) );
        //       this.set({"payload.boundingbox" : bb}, { silent: true } );
        //     }
        //     else {
        //       bb.min.x = Math.min( bb.min.x, childBB.min.x );
        //       bb.min.y = Math.min( bb.min.y, childBB.min.y );
        //       bb.min.z = Math.min( bb.min.z, childBB.min.z );
        //       bb.max.x = Math.max( bb.max.x, childBB.max.x );
        //       bb.max.y = Math.max( bb.max.y, childBB.max.y );
        //       bb.max.z = Math.max( bb.max.z, childBB.max.z );
        //     }
        //   }

        // }, this );


      //   return bb;
      // },


      updateGeometryLoadingProgress: undefined,
      updateTextureLoadingProgress: undefined,
      updateAnimationLoadingProgress: undefined,

      updateDependencyLoadingProgress: function() {
        this.loadingProgress.dependencies = 0;
        //this.loadingProgress.total_dependencies = 0;
        _.each( this.dependencies, function( dependency, id ) {
          if ( dependency.asset && dependency.asset.loadingProgress ) {
            this.loadingProgress.dependencies += dependency.asset.loadingProgress.base;
          }
        }, this );
      },

      getComponentData: function( componentId, attribute ) {

        var thisComponents = this.entityModel.get("components");
        var thisComponent = thisComponents[ componentId ];
        if ( thisComponent ) {
          var returnObj = {};
          var prefabObj = this.getPrefabObject();
          if ( prefabObj ) {

            var prefabComponentData = prefabObj.getComponentData( componentId, attribute );
            if ( prefabComponentData ) {
              _.extend( returnObj, _.deepClone( prefabComponentData ) );
            }
          }
          _.extend( returnObj, _.deepClone( thisComponent.componentData ) );
          this._linkupComponentReferences( returnObj );
          if ( attribute ) {
            return returnObj[ attribute ];
          }
          else {
            return returnObj;
          }
        }
        else if ( !componentId ) {
          var compData = {};
          var comps = this.getComponents();
          _.each( comps, function( comp, id ) {
            compData[ id ] = this.getComponentData( id );
          }, this );
          return compData;
        }
        else {
          return null;
        }
      },

      getPreviousComponentData: function( componentId, attribute ) {

        var thisComponents = this.entityModel.previous("components");
        var thisComponent = thisComponents[ componentId ];
        if ( thisComponent ) {
          var returnObj = {};
          
          var prefabObj = this.getPrefabObject();
          if ( prefabObj ) {
            var prefabComponentData = prefabObj.getPreviousComponentData( componentId, attribute );
            if ( prefabComponentData ) {
              _.extend( returnObj, _.deepClone( prefabComponentData ) );
            }
          }
          _.extend( returnObj, _.deepClone( thisComponent.componentData ) );
          this._linkupComponentReferences( returnObj );
          if ( attribute ) {
            return returnObj[ attribute ];
          }
          else {
            return returnObj;
          }
        }
        else if ( !componentId ) {
          var compData = {};
          var comps = this.getComponents();
          _.each( comps, function( comp, id ) {
            compData[ id ] = this.getPreviousComponentData( id );
          }, this );
          return compData;
        }
        else {
          return null;
        }
      },

      /**
       * Returns the first component found with the provided script Id
       * @method getComponentByScriptId
       * @param  {String} scriptId The asset Id of the script asset used by the components
       * @return {Object} The first component matching the search.
       */
      getComponentByScriptId: function( scriptId ) {
        var comps = this.getComponents( { "scriptId": scriptId } );
        if ( _.isEmpty( comps )) {
          return null;
        }
        else {
          return _.values( comps )[0];
        }
      },

      /**
       * Returns all components with the provided script Id
       * @method getComponentsByScriptId
       * @param  {String} scriptId The asset Id of the script asset used by the components
       * @return {Object} An object containing all components matching the search, keyed by component ids.
       */
      getComponentsByScriptId: function( scriptId ) {
        return this.getComponents( { "scriptId": scriptId } );
      },

      /**
       * Returns all components with the provided script name
       * @method getComponentsByScriptName
       * @param  {String} scriptName The name of the script asset used by the components
       * @return {Object} An object containing all components matching the search, keyed by component ids.
       */
      getComponentsByScriptName: function( scriptName ) {
        return this.getComponents( { "scriptName": scriptName } );
      },

      /**
       * Returns the single component with the specified id, if it exists.
       * @method getComponentById
       * @param  {String} componentId The ID of the component that you're looking for.
       * @return {Object}             The component, if it exists.
       */
      getComponentById: function(componentId) {
        //console.warn('Deprecated use of getComponent, please use getComponents().get()');
        if (this.componentManager && this.componentManager.components[componentId] ) {
          return this.componentManager.components[componentId];
        }
        else {
          return null;
        }
      },

      /**
       * Return all of the components attached to this entity matching the specified filter
       * @method getComponents
       * @param  {Object} filter One or more filters to match. e.g. { "scriptName": name, "id": id, etc. }
       * @return {Object} The components matching the filter
       */
      getComponents: function( filter ) {
        if ( !filter ) {
          return this.componentManager.components;
        }
        else {
          var results = {};
          _.each( this.componentManager.components, function( component, id ) {
            if ( filter.id === id || ( component && (
              filter.scriptName === component.__verold__.scriptName ||
              filter.scriptId === component.__verold__.scriptId ) ) ) {
              results[ id ] = component;
            }
          }, this );
          return results;
        }
      },

      /**
       * Return all of the components attached to this entity (or its hierarchy) that match the specified filter
       * @method getComponentsInHierarchy
       * @param  {Object} filter One or more filters to match. e.g. { "scriptName": name, "id": id, etc. }
       * @return {Object}        The components matching the filter
       */
      getComponentsInHierarchy: function( filter ) {
        var results = {};
        var decendants = this.getDescendants();
        _.each( decendants, function( obj, id ) {
          _.extend( results, obj.getComponents( filter ) );
        }, this );
        return results;
      },

      /**
       * Adds a new component to the VeroldEntity. componentId is optional and, if not specified, a
       * unique id will be generated for you. This method is asynchronous as the component may have
       * external dependencies so, if you want a reference to the new component, specify a 'success'
       * callback in the 'options' object.
       * @method addComponent
       * @param  {Mixed} script         Either a string scriptId or a script asset
       * @param  {Object} componentData the parameters to pass into the component
       * @param  {String} [componentId] an identifier which is unique to the VeroldEntity (optional)
       * @param  {Object} options Standard options object (with 'success' callback, 'save' boolean, etc.)
       */
      addComponent: function( scriptId, componentData, componentId, options) {

        function componentAdded( componentId ) {
          //If this component is the one we just added, call the success callback
          if ( componentId === id ) {
           // that.entityModel.off( 'add', componentAdded, that );
            if ( options && _.isFunction( options.success )) {
              // if ( !that.componentManager.components[id] ) {
              //   console.log("VeroldEntity.addComponent call was successful but this engine doesn't support runtime")
              // }
              options.success( that.componentManager.components[id] );
            }
          }
        }

        var id = componentId ? componentId : uuid();

        var component = {
          scriptId: scriptId,
          componentData: componentData ? componentData : {},
          enabled: true
        };

        var script = this.veroldEngine.assetRegistry.getAssetById( scriptId );
        if ( script && script.entityModel.isBuiltIn ) {
          component.isBuiltIn = true;
        }
        var that = this;
        var json = {};
        json["components." + id] = component;
        this.componentManager.once( 'add', componentAdded, this );
        this.set( json, { save: options && options.save ? options.save : false });
      },

      /**
       * Removes a component
       * @method removeComponent
       * @param  {mixed} componentId either a componentId or a component object.
       * @param  {Object} options Standard options object (with 'success' callback, 'save' boolean, etc.)
       */
      removeComponent: function( componentId, options ) {

        function componentRemoved( compId ) {
          //If this component is the one we just added, call the success callback
          if ( componentId === compId ) {
           // that.componentManager.off( 'remove', componentRemoved, that );
            if ( options && _.isFunction( options.success )) {
              options.success( compId );
            }
          }
        }

        //var that = this;
        if (_.isObject(componentId)) {
          _.each( this.componentManager.components, function(c, id) {
            if ( c === componentId) {
              componentId = id;
            }
          }, this);
        }
        this.componentManager.once( 'remove', componentRemoved, this );
        var update = "components." + componentId;
        this.unset( update, { save: options && options.save ? options.save : false });
      },

      //Check this object's child references, parent reference, parent asset reference, etc.
      //and fix them, if possible.
      cleanupReferences: function( options ) {
        var changes = {};
        var that = this;
        var parentAsset = this.getParentAsset();
        if ( !parentAsset || parentAsset.id !== this.entityModel.get("parentAssetId")) {
          console.error("This object doesn't have a valid parentAssetId assigned to it. What's up wit' dat?");
          return;
        }
        else {

          var badParent = false;
          var parent = this.getParentObject();
          if (parent) {
            var child = parent.getChildById( this.id );
            if ( !child ) {
              badParent = true;
            }
          }
          else {
            badParent = true;
          }
          if ( badParent ) {
            parentAsset.traverse( function( veroldEntity, parentEntity ) {
              //If we find this object in the hierarchy, fix the parentId to point to actual parent
              if ( veroldEntity.id === that.id ) {
                changes.parentId = parentEntity.id;
                badParent = false;
              }
            });
            if ( badParent ) {
              _.each( parentAsset.objects, function( obj, id ) {
                //If the object has this object as a child, fix up the parentId
                var children = obj.getChildren();
                if ( children[ this.id ]) {
                  changes.parentId = obj.id;
                  badParent = false;
                }
              }, this );
            }
            if ( badParent && parent ) {
              parent.addChildById( this.id );
            }
            else {
              this.set( changes, options );
            }
          }
        }
      },

      registerComponentEvent: function(name, parameters, scope, action, category, filter ) {
        if(scope === 'other') {
          if ( filter && filter.length ) {
            for ( var i = 0; i < filter.length; i++ ) {
              var type = filter[i];
              var prototype = this.veroldEngine.assetRegistry.getPrototypeForType( type );
              prototype.events[name] = {'params': parameters, 'action': action, 'category': category};
            }
          }
          else {
            VAPI.VeroldEntity.prototype.events[name] = {'params': parameters, 'action': action, 'category': category};
          }
        } else {
          this.events[name] = {'params': parameters, 'action': action, 'category': category};
        }
      },

      removeComponentEvent: function(name, scope) {
        if(scope === 'other') {
          if(VAPI.VeroldObject.prototype.events[name]) {
            delete VAPI.VeroldObject.prototype.events[name];
          }
        } else {
          if(this.events[name]) {
            delete this.events[name];
          }
        }
      },

      getEvents: function() {
        var events = {};
        _.extend( events, events, this.events );
        var proto = Object.getPrototypeOf( this );
        while(proto) {
          if(proto.hasOwnProperty('events')) {
            _.extend( events, events, proto.events );
          }
          proto = Object.getPrototypeOf( proto );
        }
        return events;
      }
    };

    _.extend( VeroldEntity.prototype, Backbone.Events );

    window.VAPI = window.VAPI || {};
    window.VAPI.VeroldEntity = VeroldEntity;
    window.VAPI.VeroldObject = VeroldEntity;

    return VeroldEntity;
  });

/**
 * @module VAPI
 */
define( 'VeroldEngine/Objects/VeroldObject',[
    'underscore'
  , 'three'
  , 'VeroldEngine/VeroldEntity'
  ],
  function( _, THREE, VeroldEntity ) {

    var VeroldObject = function( properties ) {
      VeroldEntity.call( this );
      this._workVector3 = new THREE.Vector3();
    };

    VeroldObject.prototype = new VeroldEntity();

    VeroldObject.prototype.events = {
      toggleVisibility: {'params': [], 'action': true, 'category': 'Rendering'},
      setVisible: {'params': [], 'action': true, 'category': 'Rendering'},
      setInvisible: {'params': [], 'action': true, 'category': 'Rendering'}
    };

    VeroldObject.prototype.initialize = function( properties ) {
      VeroldEntity.prototype.initialize.call( this, properties);
      this.on('setVisible', this.setVisible, this );
      this.on('setInvisible', this.setInvisible, this );
      this.on('toggleVisibility', this.toggleVisibility, this );
    };

    VeroldObject.prototype.uninitialize = function( properties ) {
      VeroldEntity.prototype.uninitialize.call( this, properties);
      this.off('setVisible', this.setVisible, this );
      this.off('setInvisible', this.setInvisible, this );
      this.off('toggleVisibility', this.toggleVisibility, this );
    };

    VeroldObject.prototype.reset = function() {
      if ( this.threeData ) {
        this.threeData.position.copy( this.getPosition() );
        this.threeData.quaternion.copy( this.getQuaternion() );
        this.threeData.scale.copy( this.getScale() );
      }
    };

    /**
     * Position and orient this object identically with the one provided.
     * @method alignToObject
     * @param  {String} objectId The ID of the object to match alignment to.
     * @param  {Object} options Standard options object.
     */
    VeroldObject.prototype.alignToObject = function( objectId, options ) {
      var object;
      if ( !_.isString( objectId )) {
        if ( objectId instanceof VAPI.VeroldObject ) {
          object = objectId;
        }
        else {
          console.warn("VeroldObject.alignToObject - You must pass this method either a valid object ID or a reference to a VeroldObject");
          return;
        }
      }
      else {
        object = this.veroldEngine.getEntityById( objectId );
      }
      
      if ( object ) {
        //Figure out new position by transforming the target object's world space position into
        //the space of this object's parent.
        var worldPosition = object.getPositionInWorldSpace();
        var newPosition;
        var parentObj = this.getParentObject();
        if ( parentObj && parentObj.threeData ) {
          if ( parentObj.threeData.matrixWorldInverse ) {
            newPosition = worldPosition.applyMatrix4( parentObj.threeData.matrixWorldInverse );
          }
          else {
            var matrixWorldInverse = new THREE.Matrix4();
            matrixWorldInverse.getInverse( parentObj.threeData.matrixWorld );
            newPosition = worldPosition.applyMatrix4( matrixWorldInverse );
          }
        }
        else {
          newPosition = worldPosition;
        }

        var newQuaternion = object.getQuaternionInWorldSpace();
        
        if ( parentObj && parentObj.threeData && parentObj instanceof VAPI.VeroldObject ) {
          var parentQuat = parentObj.getQuaternionInWorldSpace();
          newQuaternion.multiply( parentQuat.inverse() );
        }

        //Also set the threeData. This is necessary to make alignToObject behave consistently when used
        //multiple times in a row. For example, the threeData can change in the interm and multiple backbone
        //sets will be ignored.
        if ( this.threeData ) {
          this.threeData.position.copy( newPosition );
          this.threeData.quaternion.copy( newQuaternion );
        }

        this.set(
          { payload: {
            position: {
              x: newPosition.x,
              y: newPosition.y,
              z: newPosition.z
            },
            orientation: {
              x: newQuaternion.x,
              y: newQuaternion.y,
              z: newQuaternion.z,
              w: newQuaternion.w
            }
          }
        }, options );
      }
    };

    /**
     * Return the position of this object in world space 
     * @method getPositionInWorldSpace
     * @param  {Vector3} outVector Optional vector to write the result to. Passing this in will avoid another
     * THREE.Vector3 from being created.
     * @return {Vector3}           Reference to the resulting position vector.
     */
    VeroldObject.prototype.getPositionInWorldSpace = function( outVector ) {
      var returnPosition = outVector;
      if ( !outVector ) {
        returnPosition = new THREE.Vector3();
      }
      if ( this.threeData ) {
        this.threeData.updateMatrixWorld();
        returnPosition.setFromMatrixPosition( this.threeData.matrixWorld );
        return returnPosition;
      }
      else {
        console.warn("getPositionInWorldSpace called before threeData has been loaded. Three.js data is currently required for world position to be calculated.");
        return returnPosition;
      }
    };

    /**
     * Return the euler rotation of this object in world space 
     * @method getQuaternionInWorldSpace
     * @param  {Quaternion} outQuaternion Optional quaternion to write the result to. Passing this in will avoid another
     * THREE.Quaternion from being created.
     * @return {Quaternion}           Reference to the resulting quaternion
     */
    VeroldObject.prototype.getQuaternionInWorldSpace = function( outQuaternion ) {
      var tempMatrix = new THREE.Matrix4();
      var returnQuaternion = outQuaternion;
      if ( !outQuaternion ) {
        returnQuaternion = new THREE.Quaternion();
      }
      if ( this.threeData ) {
        this.threeData.updateMatrixWorld();
        tempMatrix.extractRotation( this.threeData.matrixWorld );
        returnQuaternion.setFromRotationMatrix( tempMatrix );
        return returnQuaternion;
      }
      else {
        console.warn("getRotationInWorldSpace called before threeData has been loaded. Three.js data is currently required for world position to be calculated.");
        return returnQuaternion;
      }
    };

    /**
     * Return the center of this object in world space (using any bounding boxes found in its descendents)
     * @method getCenterInWorldSpace
     * @param  {Vector3} outVector Optional vector to write the result to. Passing this in will avoid another
     * THREE.Vector3 from being created.
     * @return {Vector3}           Reference to the resulting center vector.
     */
    VeroldObject.prototype.getCenterInWorldSpace = function( outVector ) {
      var returnVector = outVector;
      if ( !outVector ) {
        returnVector = new THREE.Vector3();
      }
      this.getCenter( returnVector );
      this.transformLocalToWorldSpace( returnVector, returnVector );
      
      return returnVector;
    };

    /**
     * Return the provided vector (defined in local space) after converting it to world space
     * @method transformLocalToWorldSpace
     * @param  {Vector3} inVector Local vector.
     * @param  {Vector3} outVector Optional vector to write the result to. Passing this in will avoid another
     * THREE.Vector3 from being created.
     * @return {Vector3}           Reference to the resulting transformed vector.
     */
    VeroldObject.prototype.transformLocalToWorldSpace = function( inVector, outVector ) {
      
      if ( !inVector ) {
        console.warn("transformLocalToWorldSpace called without an local vector as input.");
        return;
      }
      var returnVector = outVector;
      if ( !outVector ) {
        returnVector = new THREE.Vector3();
      }
      returnVector.copy( inVector );
      if ( this.threeData ) {
        this.threeData.updateMatrixWorld();
        returnVector.applyMatrix4( this.threeData.matrixWorld );
        return returnVector;
      }
      else {
        console.warn("transformLocalToWorldSpace called before threeData has been loaded. Three.js data is currently required for world position to be calculated.");
        return returnVector;
      }
    };

    /**
     * Returns the object with the provided Id, if it exists in this object's hierarchy.
     * @method getObjectById
     * @param  {String} objectID The ID of the object
     * @return {Object} The object or null if not found.
     */
    VeroldObject.prototype.getObjectById = function( objectID ) {
      return this.getObject({ id: objectID });
    };

    VeroldObject.prototype.getDataSizeTotalDownload = function( options ) {
      if ( !options ) {
        options = {};
      }
      // options.notRecursive = true;
      var totalSize = this.getDataSizeGeometryDownload( options );
      totalSize += this.getDataSizeTextureDownload( options );
      return 0;
    };

    VeroldObject.prototype.getDataSizeTotalInMemory = function() {
      // if ( !options ) {
      //   options = {};
      // }
      // options.notRecursive = true;
      var totalSize = this.getDataSizeGeometryInMemory();
      totalSize += this.getDataSizeTextureInMemory();
      return 0;
    };

    VeroldObject.prototype.getDataSizeGeometryDownload = function() {
      // if ( !options ) {
      //   options = {};
      // }
      // options.notRecursive = true;
      var geometries = this.getListOfReferencedGeometries();
      var totalSize = 0;
      _.each( geometries, function( obj, id ) {
        if ( obj ) {
          totalSize += obj.getDataSizeGeometryDownload();
        }
      }, this );
      return totalSize;
    };

    VeroldObject.prototype.getDataSizeGeometryInMemory = function( ) {
      // if ( !options ) {
      //   options = {};
      // }
      // options.notRecursive = true;
      var geometries = this.getListOfReferencedGeometries();
      var totalSize = 0;
      _.each( geometries, function( obj, id ) {
        if ( obj ) {
          totalSize += obj.getDataSizeGeometryInMemory();
        }
      }, this );
      return totalSize;
    };

    VeroldObject.prototype.getDataSizeTextureDownload = function( ) {
      // if ( !options ) {
      //   options = {};
      // }
      // options.notRecursive = true;
      var textures = this.getListOfReferencedTextures();
      var totalSize = 0;
      _.each( textures, function( obj, id ) {
        if ( obj ) {
          totalSize += obj.getDataSizeTextureDownload();
        }
      }, this );
      return totalSize;
    };

    VeroldObject.prototype.getDataSizeTextureInMemory = function() {
      // if ( !options ) {
      //   options = {};
      // }
      // options.notRecursive = true;
      var textures = this.getListOfReferencedTextures();
      var totalSize = 0;
      _.each( textures, function( obj, id ) {
        if ( obj ) {
          totalSize += obj.getDataSizeTextureInMemory();
        }
      }, this );
      return totalSize;
    };

    VeroldObject.prototype.registerInitialDependencies = function( type ) {
      var children = this.entityModel.get("children");
      _.each( children, function( included, id ) {
        if ( included ) {
          var obj = this.getParentAsset().getObjectById( id );
          if ( obj ) {
            obj.registerInitialDependencies( type );
          }
        }
      }, this );
    };

    VeroldObject.prototype.unregisterInitialDependencies = function( type ) {
      var children = this.entityModel.get("children");
      _.each( children, function( included, id ) {
        if ( included ) {
          var obj = this.getParentAsset().getObjectById( id );
          if ( obj ) {
            obj.unregisterInitialDependencies( type );
          }
        }
      }, this );
    };

    VeroldObject.prototype.setVisibility = function( visible, save ) {
      console.warn("setVisibility is deprecated. Please use setVisible and setInvisible.");
      this.setProperty( "visible", visible, { save: save } );
    };

    /**
     * Set this object as visible. Any rendered object in its hierarchy will become visible.
     * @method setVisible
     * @param {Object} options Standard options structure containing 'success' and 'failure' callbacks, 'save' boolean, etc.
     */
    VeroldObject.prototype.setVisible = function( options ) {
      this.setProperty( "visible", true, options );
      this.veroldEngine.needsRender = true;
    };

    /**
     * Set this object as invisible. Any rendered object in its hierarchy will become invisible.
     * @method setInvisible
     * @param {Object} options Standard options structure containing 'success' and 'failure' callbacks, 'save' boolean, etc.
     */
    VeroldObject.prototype.setInvisible = function( options ) {
      this.setProperty( "visible", false, options );
      this.veroldEngine.needsRender = true;
    };

    /**
     * Toggle the objet's visibility. If it was invisible, it will become visible, etc.
     * @method toggleVisibility
     * @param {Object} options Standard options structure containing 'success' and 'failure' callbacks, 'save' boolean, etc.
     */
    VeroldObject.prototype.toggleVisibility = function( options ) {
      var visible = this.getProperty( 'visible') ? false : true;
      this.setProperty( "visible", visible, options );
      this.veroldEngine.needsRender = true;
    };

    window.VAPI = window.VAPI || {};
    window.VAPI.VeroldObject = VeroldObject;

    return VeroldObject;

});

define('VeroldEngine/Objects/CameraObject',[ 'underscore'
       , 'three'
       , 'VeroldEngine/Objects/VeroldObject'
  ],
  function(_, THREE, VeroldObject ) {

    var defaultCamera = {
      name : "Camera_With_No_Name",
      type : "PerspectiveCamera",
      orientation : { x : 0, y : 0, z : 0, w : 1 },
      position : { x : 5, y : 5, z : 5 },
      fov : 50,
      aspect : 16.0/9.0,
      near : 0.01,
      far : 12000.0,
      right : 1.0,
      left : -1.0,
      top : 1.0,
      bottom : -1.0,
    };

    var CameraObject = function( properties ) {

      VeroldObject.call( this );

    };

    CameraObject.prototype = new VeroldObject();

    CameraObject.prototype.events = {
    };

    CameraObject.prototype._loadThreeData = function( changes, options ) {

      if ( this.isInstance() ) {
        this._initPrefabBindings();
      }
      //Setup the default values, if they're not already defined.
      var type = defaultCamera.type;
      var payload = this.entityModel.get("payload");
      if ( changes.payload && changes.payload.type ) {
        type = payload.type;
      }

      this._createThreeCamera( type );
      this.threeData.veroldEntityId = this.id;
      payload.fov = changes.payload.fov !== undefined ? changes.payload.fov : defaultCamera.fov;
      payload.aspect = changes.payload.aspect !== undefined ? changes.payload.aspect : defaultCamera.aspect;
      payload.near = changes.payload.near !== undefined ? changes.payload.near : defaultCamera.near;
      payload.far = changes.payload.far !== undefined ? changes.payload.far : defaultCamera.far;
      payload.left = changes.payload.left !== undefined ? changes.payload.left : defaultCamera.left;
      payload.right = changes.payload.right !== undefined ? changes.payload.right : defaultCamera.right;
      payload.top = changes.payload.top !== undefined ? changes.payload.top : defaultCamera.top;
      payload.bottom = changes.payload.bottom !== undefined ? changes.payload.bottom : defaultCamera.bottom;
      this.applyPayloadSettings_loaded( payload, options );
      this.trigger( "load_base", this);
    };

    CameraObject.prototype.applyPayloadSettings_loaded = function( changes, options ) {

      if ( changes ) {
        var payload = this.entityModel.get("payload");
        var typeChange;
        if (changes.type) {
          typeChange = payload.type;
        }

        var curType = this.threeData instanceof THREE.PerspectiveCamera ? "PerspectiveCamera" : "OrthographicCamera";
        if ( typeChange && typeChange !== curType ) {
          this._createThreeCamera( typeChange );
        }

        if ( curType === "PerspectiveCamera" ) {
          this.threeData.fov = changes.fov ? payload.fov : this.threeData.fov;
          this.threeData.aspect = changes.aspect ? payload.aspect : this.threeData.aspect;
          this.threeData.near = changes.near ? payload.near : this.threeData.near;
          this.threeData.far = changes.far ? payload.far : this.threeData.far;
        }
        else if ( curType === "OrthographicCamera" ) {
          this.threeData.near = changes.near ? payload.near : this.threeData.near;
          this.threeData.far = changes.far ? payload.far : this.threeData.far;
          this.threeData.left = changes.left ? payload.left : this.threeData.left;
          this.threeData.right = changes.right ? payload.right : this.threeData.right;
          this.threeData.top = changes.top ? payload.top : this.threeData.top;
          this.threeData.bottom = changes.bottom ? payload.bottom : this.threeData.bottom;
        }

        this.threeData.updateProjectionMatrix();

        //Call the base objects function to update position, orientation, etc.
        VeroldObject.prototype.applyPayloadSettings_loaded.call( this, changes );
      }

      this.trigger("updated", this);
    };

    CameraObject.prototype._createThreeCamera = function( type ) {

      if ( type === "PerspectiveCamera" ) {
        this.threeData = new THREE.PerspectiveCamera();
      }
      else if ( type === "OrthographicCamera" ) {
        this.threeData = new THREE.OrthographicCamera();
      }

    };

    /**
     * Make the camera look at the given VeroldObject
     * @param  {VeroldObject} veroldObject The object to look at.
     * @param  {Boolean} fitToField   Set this to true if you can the camera to move
     * itself so that the target object fills the camera's field of view.
     */
    // CameraObject.prototype.lookAt = function( veroldObject, fitToField ) {
    //   if ( veroldObject && veroldObject instanceof VAPI.VeroldObject ) {
    //     veroldObject.getCenterInWorldSpace( this._workVector3 );
    //     if ( this.threeData ) {
    //       this.threeData.lookAt( this._workVector3 );
    //       if ( fitToField ) {
    //         var bb = veroldObject.getProperty("boundingbox");
    //         if ( bb ) {
    //           var dist = new THREE.Vector3();
    //           dist.set( bb.max.x - bb.min.x, bb.max.y - bb.min.y, bb.max.z - bb.min.z);
    //           var scale = new THREE.Vector3();
    //           if ( veroldObject.threeData ) {
    //             scale.setFromMatrixScale( veroldObject.threeData.matrixWorld );
    //           }
    //           else {
    //             scale.copy( veroldObject.getScale() );
    //           }
    //           dist.multiply( scale );
    //           var size = dist.length();
    //           var minDist;
    //           if ( this.getProperty("type") === "PerspectiveCamera") {
    //             minDist = Math.abs( size / (2.0 * Math.tan( this.getProperty("fov") * Math.PI / 360.0 )) );
    //           }
    //           else {
    //             minDist = this.getProperty("near");
    //           }
    //           //If the distance that the camera is positioned at is inside of the newly calculated distance,
    //           //move it out to this distance
    //           this._workVector3.sub( this.getPosition() );
    //           var length = this._workVector3.length();
    //           minDist = Math.max( length, minDist );
    //           this._workVector3.divideScalar( length );
    //           this._workVector3.multiplyScalar( length - minDist );
    //           this.threeData.position.copy( this._workVector3 );
              
    //         }
    //       }
    //     }
    //     else {
    //       console.warn("CameraObject.lookAt called before threeData has been loaded. Three.js data is currently required for lookAt functionality.");
    //     }
    //   }
    // };

    
    window.VAPI = window.VAPI || {};
    window.VAPI.CameraObject = CameraObject;

    return CameraObject;
  });

define('VeroldEngine/Objects/LightObject',[ 'underscore'
       , 'three'
       , 'VeroldEngine/Objects/VeroldObject'
  ],
  function(_, THREE, VeroldObject ) {

    var defaultLight = {
      type : "DirectionalLight",
      color : 0xbbbbbb,
      intensity : 1.0,
      position : { x : 20, y : -20, z : 20 },
      target : null,
      distance : 10.0,
      //quaternion : { x : 0, y : 0, z : 0, w : 1},
      orientation : { x : 0, y : 0, z : 0, w : 1},
      scale : { x : 1, y : 1, z : 1 },
      castShadow : false,
      shadowCameraNear : 1.4,
      shadowCameraFar : 50,
      shadowCameraLeft : -12.0,
      shadowCameraRight : 12.0,
      shadowCameraTop : 12.0,
      shadowCameraBottom : -12.0,
      shadowBias : -0.0015,
      shadowDarkness : 0.5,
      shadowMapWidth : 1024,
      shadowMapHeight : 1024,
      shadowCameraVisible : false,
      shadowCascade : false,
      shadowCascadeCount : 3,
      shadowCascadeNearZ : [ -1.000, 0.9, 0.97 ],
      shadowCascadeFarZ  : [  0.9, 0.97, 0.992 ],
      shadowCascadeWidth : [ 1024, 1024, 1024 ],
      shadowCascadeHeight : [ 1024, 1024, 1024 ],
      shadowCascadeBias : [ -0.0002, -0.0004, -0.001 ],
      shadowCascadeOffset : new THREE.Vector3(0,0,0),
    };

    var LightObject = function( properties ) {
      VeroldObject.call( this );
    };

    LightObject.prototype = new VeroldObject();

    LightObject.prototype.events = {
      'setColor': { 'scope': 'local', 'action': true, 'category': 'Materials', 'params': [ 
        { 'name': 'value', 'type': 'c', 'description': 'The colour to set.', 'default': 0xff0000 },
        { 'name': 'animationTime', 'type': 'f', 'description': 'The length of time that the change will take. i.e. this lets you animate the change.', default: 0.0, 'min': 0.0 }, 
        // { 'name': 'easeIn', 'type': 'f', 'description': 'Percentage of animation time to spend speeding up.', 'default': 0.25 },
        // { 'name': 'easeOut', 'type': 'f', 'description': 'Percentage of animation time to spend slowing down.', 'default': 0.25 },
        ]
      },
      'setIntensity': { 'scope': 'local', 'action': true, 'category': 'Materials', 'params': [ 
        { 'name': 'value', 'type': 'f', 'description': 'The intensity to set.', 'default': 1.0 },
        { 'name': 'animationTime', 'type': 'f', 'description': 'The length of time that the change will take. i.e. this lets you animate the change.', default: 0.0, 'min': 0.0 }, 
        // { 'name': 'easeIn', 'type': 'f', 'description': 'Percentage of animation time to spend speeding up.', 'default': 0.25 },
        // { 'name': 'easeOut', 'type': 'f', 'description': 'Percentage of animation time to spend slowing down.', 'default': 0.25 },
        ]
      },
    };

    LightObject.prototype.initialize = function( properties ) {
      VeroldObject.prototype.initialize.call( this, properties);

      this.on('setColor', this.setColor, this );
      this.on('setIntensity', this.setIntensity, this );

      var payload = this.entityModel.get("payload");

      payload.intensity = payload.intensity !== undefined ? payload.intensity : defaultLight.intensity;
      payload.distance = payload.distance !== undefined ? payload.distance : defaultLight.distance;
      payload.scale = payload.scale !== undefined ? payload.scale : defaultLight.scale;
      payload.shadowBias = payload.shadowBias !== undefined ? payload.shadowBias : defaultLight.shadowBias;
      payload.shadowMapWidth = payload.shadowMapWidth !== undefined ? payload.shadowMapWidth : defaultLight.shadowMapWidth;
      payload.shadowMapHeight = payload.shadowMapHeight !== undefined ? payload.shadowMapHeight : defaultLight.shadowMapHeight;
      payload.shadowCameraLeft = payload.shadowCameraLeft !== undefined ? payload.shadowCameraLeft : defaultLight.shadowCameraLeft;
      payload.shadowCameraRight = payload.shadowCameraRight !== undefined ? payload.shadowCameraRight : defaultLight.shadowCameraRight;
      payload.shadowCameraTop = payload.shadowCameraTop !== undefined ? payload.shadowCameraTop : defaultLight.shadowCameraTop;
      payload.shadowCameraBottom = payload.shadowCameraBottom !== undefined ? payload.shadowCameraBottom : defaultLight.shadowCameraBottom;
      payload.shadowCameraNear = payload.shadowCameraNear !== undefined ? payload.shadowCameraNear : defaultLight.shadowCameraNear;
      payload.shadowCameraFar = payload.shadowCameraFar !== undefined ? payload.shadowCameraFar : defaultLight.shadowCameraFar;
      payload.shadowCascade = payload.shadowCascade !== undefined ? payload.shadowCascade : defaultLight.shadowCascade;
      payload.shadowCascadeCount = payload.shadowCascadeCount !== undefined ? payload.shadowCascadeCount : defaultLight.shadowCascadeCount;
      payload.shadowCascadeNearZ = payload.shadowCascadeNearZ !== undefined ? payload.shadowCascadeNearZ : defaultLight.shadowCascadeNearZ;
      payload.shadowCascadeFarZ = payload.shadowCascadeFarZ !== undefined ? payload.shadowCascadeFarZ : defaultLight.shadowCascadeFarZ;
      payload.shadowCascadeWidth = payload.shadowCascadeWidth !== undefined ? payload.shadowCascadeWidth : defaultLight.shadowCascadeWidth;
      payload.shadowCascadeHeight = payload.shadowCascadeHeight !== undefined ? payload.shadowCascadeHeight : defaultLight.shadowCascadeHeight;
      payload.shadowCascadeBias = payload.shadowCascadeBias !== undefined ? payload.shadowCascadeBias : defaultLight.shadowCascadeBias;
      payload.shadowCascadeOffset = payload.shadowCascadeOffset !== undefined ? payload.shadowCascadeOffset : defaultLight.shadowCascadeOffset;
    };

    LightObject.prototype.uninitialize = function() {
      this.off('setColor', this.setColor, this );
      this.off('setIntensity', this.setIntensity, this );
    };

    LightObject.prototype._loadThreeData = function(  changes, options  ) {
      
      if ( this.isInstance() ) {
        this._initPrefabBindings();
      }
      //Setup the default values, if they're not already defined.
      var type = defaultLight.type;
      var color = defaultLight.color;
      if ( changes.payload ) {
        type = this.getProperty("type");
        color = this.getProperty("color");
      }

      this._createThreeLight( type, color );
      this.threeData.veroldEntityId = this.id;
      this.applyPayloadSettings_loaded( changes.payload, options );
      //Never let the shadow debug come on when loading.
      this.threeData.shadowCameraVisible = false;
      this.trigger( "load_base", this);
    };

    LightObject.prototype.applyPayloadSettings_loaded = function(  changes, options  ) {

      if ( changes ) {
        var payload = this.entityModel.get("payload");
        var typeChange;
        if ( changes.type ) {
          typeChange = payload.type;

          var curType = this.threeData instanceof THREE.DirectionalLight ? "DirectionalLight" : null;
          curType = this.threeData instanceof THREE.PointLight ? "PointLight" : curType;
          curType = this.threeData instanceof THREE.AmbientLight ? "AmbientLight" : curType;
          curType = this.threeData instanceof THREE.SpotLight ? "SpotLight" : curType;
          curType = this.threeData instanceof THREE.HemisphereLight ? "HemisphereLight" : curType;
          if ( typeChange !== curType ) {
            this._createThreeLight( typeChange, payload.color );
          }
        }

        var type = this.entityModel.get("payload").type;
        if ( type === "DirectionalLight" ) {

          this.threeData.intensity = changes.intensity !== undefined ? payload.intensity : this.threeData.intensity;
          // this.threeData.castShadow = changes.castShadow !== undefined ? payload.castShadow : this.threeData.castShadow;
          if ( changes.target !== undefined ) {
            if ( _.isString( payload.target ) ) {
              var that = this;
              var targetObj = this.getParentAsset().getObjectById( payload.target );
              if ( targetObj ) {
                targetObj.load({ load_base : function() {
                  that.threeData.target = targetObj.threeData;
                }})
              }
            }
            else {
              this.threeData.target = new THREE.Object3D();
            }
          }
          if ( changes.shadowCameraNear !== undefined ) {
            this.threeData.shadowCameraNear = payload.shadowCameraNear;
            _.each( this.threeData.shadowCascadeArray, function( light ) {
              light.shadowCameraNear = payload.shadowCameraNear;
            }, this );
          }
          if ( changes.shadowCameraFar !== undefined ) {
            this.threeData.shadowCameraFar = payload.shadowCameraFar;
            _.each( this.threeData.shadowCascadeArray, function( light ) {
              light.shadowCameraFar = payload.shadowCameraFar;
            }, this );
          }

          this.threeData.shadowCameraLeft = changes.shadowCameraLeft !== undefined ? payload.shadowCameraLeft : this.threeData.shadowCameraLeft;
          this.threeData.shadowCameraRight = changes.shadowCameraRight !== undefined ? payload.shadowCameraRight : this.threeData.shadowCameraRight;
          this.threeData.shadowCameraTop = changes.shadowCameraTop !== undefined ? payload.shadowCameraTop : this.threeData.shadowCameraTop;
          this.threeData.shadowCameraBottom = changes.shadowCameraBottom !== undefined ? payload.shadowCameraBottom : this.threeData.shadowCameraBottom;
          this.threeData.shadowBias = changes.shadowBias !== undefined ? payload.shadowBias : this.threeData.shadowBias;

          this.threeData.shadowCascadeNearZ = changes.shadowCascadeNearZ !== undefined ? payload.shadowCascadeNearZ : this.threeData.shadowCascadeNearZ;
          this.threeData.shadowCascadeFarZ = changes.shadowCascadeFarZ !== undefined ? payload.shadowCascadeFarZ : this.threeData.shadowCascadeFarZ;
          this.threeData.shadowCascadeBias = changes.shadowCascadeBias !== undefined ? payload.shadowCascadeBias : this.threeData.shadowCascadeBias;
          this.threeData.shadowCameraVisible = changes.shadowCameraVisible !== undefined ? payload.shadowCameraVisible : this.threeData.shadowCameraVisible;

          if ( changes.shadowMapWidth && changes.shadowMapWidth !== this.threeData.shadowMapWidth ||
                changes.shadowMapHeight && changes.shadowMapHeight !== this.threeData.shadowMapHeight ) {
            this.threeData.shadowMapWidth = changes.shadowMapWidth !== undefined ? Math.min( payload.shadowMapWidth, this.veroldEngine.getGPUCapability( "MAX_TEXTURE_SIZE" )) : this.threeData.shadowMapWidth;
            this.threeData.shadowMapHeight = changes.shadowMapHeight !== undefined ? Math.min( payload.shadowMapHeight, this.veroldEngine.getGPUCapability( "MAX_TEXTURE_SIZE" )) : this.threeData.shadowMapHeight;

            this.disposeShadowMap();
          }
          if ( changes.shadowCascadeWidth || changes.shadowCascadeHeight ) {
            for ( var i = 0; i < changes.shadowCascadeWidth.length; i++ ) {
              if ( this.threeData.shadowCascadeWidth[i] === payload.shadowCascadeWidth[i] && this.threeData.shadowCascadeHeight[i] === payload.shadowCascadeHeight[i] ) {
                break;
              }
              this.threeData.shadowCascadeWidth[i] = Math.min( payload.shadowCascadeWidth[i], this.veroldEngine.getGPUCapability( "MAX_TEXTURE_SIZE" ) );
              this.threeData.shadowCascadeHeight[i] = Math.min( payload.shadowCascadeHeight[i], this.veroldEngine.getGPUCapability( "MAX_TEXTURE_SIZE" ) );
              if ( this.threeData.shadowCascadeArray[i] ) {
                this.threeData.shadowCascadeArray[i].shadowMapWidth = this.threeData.shadowCascadeWidth[i];
                this.threeData.shadowCascadeArray[i].shadowMapHeight = this.threeData.shadowCascadeHeight[i];
              }
              this.disposeShadowMapCascade();
            }
          }


          if ( changes.castShadow !== undefined && this.threeData.castShadow !== changes.castShadow ) {
            this.threeData.castShadow = changes.castShadow;
            if ( !changes.castShadow ) {
              this.disposeShadowMap();
              if ( this.threeData.shadowCascade ) {
                if ( this.threeData.parent ) {
                  var oldParent = this.threeData.parent;
                  this.threeData.parent.remove( this.threeData );
                  oldParent.add( this.threeData );
                  //console.log("Adding and removing a light from its parent.");
                }
                this.disposeShadowMapCascade();
                this.threeData.shadowCascadeArray = [];
              }
            }
            else {
              this.threeData.shadowMap = null;
            }
          }
          if ( changes.shadowCascadeOffset !== undefined ) {
            this.threeData.shadowCascadeOffset.x = payload.shadowCascadeOffset.x;
            this.threeData.shadowCascadeOffset.y = payload.shadowCascadeOffset.y;
            this.threeData.shadowCascadeOffset.z = payload.shadowCascadeOffset.z;
          }
          if ( changes.shadowCascade !== undefined && changes.shadowCascade !== this.threeData.shadowCascade ) {
            this.threeData.shadowCascade = payload.shadowCascade;
            if ( this.threeData.parent ) {
              var oldParent = this.threeData.parent;
              this.threeData.parent.remove( this.threeData );
              oldParent.add( this.threeData );
              //console.log("Adding and removing a light from its parent.");
            }
            if ( this.threeData.shadowCascade ) {
              this.disposeShadowMap();
            }
            else {
              this.disposeShadowMapCascade();
              this.threeData.shadowCascadeArray = [];
            }
          }

          //Manually update shadow camera size when scaling the shadowmap
          if ( this.threeData.shadowCamera ) {
            this.threeData.shadowCamera.near = this.threeData.shadowCameraNear;
            this.threeData.shadowCamera.far = this.threeData.shadowCameraFar;
            this.threeData.shadowCamera.left = this.threeData.shadowCameraLeft;
            this.threeData.shadowCamera.right = this.threeData.shadowCameraRight;
            this.threeData.shadowCamera.top = this.threeData.shadowCameraTop;
            this.threeData.shadowCamera.bottom = this.threeData.shadowCameraBottom;
            this.threeData.shadowCamera.updateProjectionMatrix();
          }
          // if ( this.threeData.shadowCamera ) {
          //   this.threeData.shadowCamera.updateProjectionMatrix();
          // }
          _.each( this.threeData.shadowCascadeArray, function( light ) {
            if ( light.shadowCamera ) {
              light.shadowCamera.near = light.shadowCameraNear;
              light.shadowCamera.far = light.shadowCameraFar;
              light.shadowCamera.left = light.shadowCameraLeft;
              light.shadowCamera.right = light.shadowCameraRight;
              light.shadowCamera.top = light.shadowCameraTop;
              light.shadowCamera.bottom = light.shadowCameraBottom;
              light.shadowCamera.updateProjectionMatrix();
            }
          }, this );

        }
        else if ( type === "PointLight" ) {
          this.threeData.intensity = changes.intensity !== undefined ? payload.intensity : this.threeData.intensity;
          this.threeData.distance = changes.scale !== undefined ? payload.scale.x : this.threeData.distance;
        }
        else if ( type === "AmbientLight" ) {

        }
        else if ( type === "SpotLight" ) {

        }
        else if ( type === "HemisphereLight" ) {

        }
        else {
          console.error( this.veroldEngine.engineName + " - Invalid light type, \"" + type + "\"!");
        }

        if ( changes.color ) {
          this.threeData.color.setHex( payload.color );
        }

        //Call the base objects function to update position, orientation, etc.
        VeroldObject.prototype.applyPayloadSettings_loaded.call( this, changes );
      }

      this.trigger("updated", this);
    };

    LightObject.prototype.disposeShadowMap = function() {
      if ( this.threeData.shadowMap ) {
        this.threeData.shadowMap.dispose();
        this.threeData.shadowMap = undefined;
        if ( this.threeData.cameraHelper && this.threeData.cameraHelper.parent ) {
          this.threeData.cameraHelper.parent.remove( this.threeData.cameraHelper );
        }
        if ( this.threeData.shadowCamera && this.threeData.shadowCamera.parent ) {
          this.threeData.shadowCamera.parent.remove( this.threeData.shadowCamera );
        }
        this.threeData.shadowCamera = undefined;
        this.threeData.cameraHelper = undefined;
      }
    };

    LightObject.prototype.disposeShadowMapCascade = function() {
      _.each( this.threeData.shadowCascadeArray, function( vLight ) {
        if ( vLight.shadowMap ) {
          vLight.shadowMap.dispose();
          vLight.shadowMap = undefined;
          if ( vLight.cameraHelper && vLight.cameraHelper.parent ) {
            vLight.cameraHelper.parent.remove( vLight.cameraHelper );
          }
          if ( vLight.shadowCamera && vLight.shadowCamera.parent ) {
            vLight.shadowCamera.parent.remove( vLight.shadowCamera );
          }
          vLight.shadowCamera = undefined;
          vLight.cameraHelper = undefined;
        }
      }, this );

    };

    LightObject.prototype._createThreeLight = function( type, color ) {

      if ( this.threeData ) {
        console.warn("TODO: Update referencers of this light!");
        //cleanup the light data.
      }
      var colour = new THREE.Color( color );
      if ( type === "DirectionalLight" ) {
        this.threeData = new THREE.DirectionalLight( colour );
        //this.threeData.shadowCameraVisible = true;
        this.threeData.shadowCascade = defaultLight.shadowCascade;
        this.threeData.shadowCascadeCount = defaultLight.shadowCascadeCount;
        this.threeData.shadowCascadeNearZ = defaultLight.shadowCascadeNearZ;
        this.threeData.shadowCascadeFarZ = defaultLight.shadowCascadeFarZ;
        this.threeData.shadowCascadeWidth = defaultLight.shadowCascadeWidth;
        this.threeData.shadowCascadeHeight = defaultLight.shadowCascadeHeight;
        this.threeData.shadowCascadeBias = defaultLight.shadowCascadeBias;
        this.threeData.shadowCascadeOffset = new THREE.Vector3();
        this.threeData.shadowCascadeOffset.copy( defaultLight.shadowCascadeOffset );
        //this.threeData.position.set( 20, 45, 50 );
      }
      else if ( type === "PointLight" ) {
        this.threeData = new THREE.PointLight( colour );
      }
      else if ( type === "AmbientLight" ) {
        this.threeData = new THREE.AmbientLight( colour );
      }
      else if ( type === "SpotLight" ) {
        this.threeData = new THREE.SpotLight( colour );
      }
      else if ( type === "HemisphereLight" ) {
        this.threeData = new THREE.HemisphereLight( colour );
      }
      this.threeData.veroldEntityId = this.id;
      this.threeData.name = this.entityModel.get("name");

    };

    LightObject.prototype.unload = function( options ) {
      if ( this.threeData) {
        if ( this.threeData.shadowMap ) {
          console.log( this.veroldEngine.engineName + " - Deallocating shadow map texture for light " + this.entityModel.get("name") );
          this.disposeShadowMap();
        }
        if ( this.threeData.shadowCascadeArray && this.threeData.shadowCascadeArray.length > 0 ) {
          console.log( this.veroldEngine.engineName + " - Deallocating shadow cascade textures for light " + this.entityModel.get("name") );
          this.disposeShadowMapCascade();
        }
      }

      VeroldObject.prototype.unload.call( this, options );
    };

    LightObject.prototype.setColor = function( newValue, animationTime ) {
      var that = this;
      var ellapsedTime = 0.0;
      var newR, newG, newB, oldR, oldG, oldB;
      var oldValue;

      function animateValue( delta ) {
        ellapsedTime += delta;
        if ( ellapsedTime > animationTime ) {
          that.veroldEngine.off( 'update', animateValue, this );
          that.setProperty( 'color', newValue );
        }
        else {
          //Interpolate
          var interp = Math.min( ellapsedTime / animationTime, 1.0 );
          var interpR = (1.0 - interp) * oldR + interp * newR;
          var interpG = (1.0 - interp) * oldG + interp * newG;
          var interpB = (1.0 - interp) * oldB + interp * newB;
          that.threeData.color.setRGB( interpR, interpG, interpB );
          // that.setUniform( attribute, interpValue );
        }
      }
      if ( animationTime ) {
        oldValue = that.getProperty( 'color' );
        oldR = ( oldValue >> 16 & 255 ) / 255;
        oldG = ( oldValue >> 8 & 255 ) / 255;
        oldB = ( oldValue & 255 ) / 255;
        newR = ( newValue >> 16 & 255 ) / 255;
        newG = ( newValue >> 8 & 255 ) / 255;
        newB = ( newValue & 255 ) / 255;
        this.veroldEngine.on( 'update', animateValue, this );
      }
      else {
        this.setProperty( 'color', newValue );
      }
    };

    LightObject.prototype.setIntensity = function( newValue, animationTime ) {
      var that = this;
      var ellapsedTime = 0.0;
      var oldValue;

      function animateValue( delta ) {
        ellapsedTime += delta;
        if ( ellapsedTime > animationTime ) {
          that.veroldEngine.off( 'update', animateValue, this );
          that.setProperty( 'intensity', newValue );
        }
        else {
          //Interpolate
          var interp = Math.min( ellapsedTime / animationTime, 1.0 );
          var interpValue = (1.0 - interp) * oldValue + interp * newValue;
          that.threeData.intensity = interpValue;
        }
      }
      if ( animationTime ) {
        oldValue = that.getProperty( 'intensity' );
        this.veroldEngine.on( 'update', animateValue, this );
      }
      else {
        this.setProperty( 'intensity', newValue );
      }
    };

    window.VAPI = window.VAPI || {};
    window.VAPI.LightObject = LightObject;

    return LightObject;
  });

define( 'VeroldEngine/Util/BufferGeometryUtilities',[ 'underscore', 'three' ],
  function( _, THREE ) {

    var BufferGeometryUtilities = function( geometry ) {
      this.geometry = geometry;
    };

    BufferGeometryUtilities.prototype = {

      constructor: BufferGeometryUtilities,

      computeTangents: function( ) {
        this.geometry.computeTangents();
        this.fixZeroLengthTangents();
      },

      computeUVs: function() {
        var g = this.geometry
          , position = new THREE.Vector3()
          , uvs, positions, nVertices;

        if ( g.attributes[ "position" ] === undefined ) {
          console.log( "Missing required attribute: position." );
          return;
        }

        positions = g.attributes[ "position" ].array;
        nVertices = positions.length / 3;
        uvs = new Float32Array( 2 * nVertices );

        for ( var idx = 0; idx < nVertices; ++idx ) {
          position.x = positions[ idx * 3 ];
          position.y = positions[ idx * 3 + 1 ];
          position.z = positions[ idx * 3 + 2 ];
          position.normalize();
          position.addScalar( 1.0 );
          position.multiplyScalar( 0.5 );
          uvs[ idx * 2 + 0 ] = position.x;
          uvs[ idx * 2 + 1 ] = position.y;
        }

        g.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );
      },

      /**
       * Compute wireframe indices.
       * @method computeWireframeIndices
       */
      computeWireframeIndices: function( ) {
        var offsets = this.geometry.offsets
          , wire_indices = []
          , wire_buffer;

        if ( offsets &&
             this.geometry.attributes &&
             this.geometry.attributes.index &&
             this.geometry.attributes.index.array ) {

          var indices = this.geometry.attributes.index.array;

          // Reverse the triangulation of polygons with more than 3 vertices to
          // recover the wireframe.
          for ( var iOffset = 0; iOffset < offsets.length; ++iOffset ) {
            var offset = offsets[ iOffset ]
              , polySize = offset.polygonSize !== undefined ? offset.polygonSize : 3
              , nPolyIndices = ( polySize - 2 ) * 3
              , nPolys = offset.count / nPolyIndices;
      
            offset.wireframe = {
              "start": wire_indices.length,
              "count": nPolys * polySize * 2
            };
      
            for ( var iPoly = 0; iPoly < nPolys; ++iPoly ) {
              wire_indices.push( indices[ offset.start + iPoly * nPolyIndices + 0 ] );
              wire_indices.push( indices[ offset.start + iPoly * nPolyIndices + 1 ] );
      
              for ( var iVtx = 0; iVtx < polySize - 2; ++iVtx ) {
                wire_indices.push( wire_indices[ wire_indices.length - 1 ] );
                wire_indices.push( indices[ offset.start + iPoly * nPolyIndices + ( iVtx * 3 + 2 ) ] );
              }
      
              wire_indices.push( wire_indices[ wire_indices.length - 1 ] );
              wire_indices.push( indices[ offset.start + iPoly * nPolyIndices + 0 ] );
            }
          }
        }
    
        wire_buffer = new Uint16Array( wire_indices.length );
    
        for ( var idx = 0; idx < wire_indices.length; ++idx ) {
          wire_buffer[ idx ] = wire_indices[ idx ];
        }

        this.geometry.addAttribute( "index_wireframe", new THREE.BufferAttribute( wire_buffer, 1 ) );
      },

      fixZeroLengthTangents: function( ) {
        var g = this.geometry
          , normal = new THREE.Vector3()
          , tangent = new THREE.Vector3()
          , normals, tangents, nVertices;

        if ( g.attributes[ "normal" ] === undefined ||
             g.attributes[ "tangent" ] === undefined ) {
          console.warn( "Missing required attributes: normal and tangent." );
          return;
        }

        normals = g.attributes.normal.array;
        tangents = g.attributes.tangent.array;

        nVertices = tangents.length / 4;

        for ( var iVtx = 0; iVtx < nVertices; ++iVtx ) {
          tangent.x = tangents[ iVtx * 4 ];
          tangent.y = tangents[ iVtx * 4 + 1 ];
          tangent.z = tangents[ iVtx * 4 + 2 ];

          if ( tangent.lengthSq() === 0 ) {
            var maxIdx = 0;

            normal.x = normals[ iVtx * 3 ];
            normal.y = normals[ iVtx * 3 + 1 ];
            normal.z = normals[ iVtx * 3 + 2 ];

            for ( var idx = 1; idx < 3; ++idx) {
              if ( Math.abs( normal.getComponent( idx ) ) >
                   Math.abs( normal.getComponent( maxIdx ) ) ) {
                maxIdx = idx;
              }
            }

            swapIdx = ( maxIdx + 1 ) % 3;

            tangent.set( 0, 0, 0 );
            tangent.setComponent( maxIdx, normal.getComponent( swapIdx ) );
            tangent.setComponent( swapIdx, -normal.getComponent( maxIdx ) );
            tangent.normalize();

            tangents[ iVtx * 4 + 0 ] = tangent.x;
            tangents[ iVtx * 4 + 1 ] = tangent.y;
            tangents[ iVtx * 4 + 2 ] = tangent.z;
          }
        }
      }

    };

    window.VAPI = window.VAPI || {};
    window.VAPI.BufferGeometryUtilities = BufferGeometryUtilities;

    return BufferGeometryUtilities;
  } );

define('VeroldEngine/Loaders/BufferedBinaryLoader',[
  'three',
  'underscore',
  'async',
  'VeroldEngine/Util/BufferGeometryUtilities'
] , function( THREE, _, async, BufferGeometryUtilities ) {

  var BufferedBinaryLoader = function( veroldEngine ) {
    this.veroldEngine = veroldEngine;
  };

  BufferedBinaryLoader.prototype.constructor = BufferedBinaryLoader;

  BufferedBinaryLoader.prototype.load = function( url, fn, progressFn, forceDownload ) {
    var that = this;

    loadDescriptor(this.veroldEngine, url, function( err, descriptor ) {
      if ( err ) {
        console.warn( "Error loading descriptor: ", err );
        return fn( null );
      }

      //console.log( "Descriptor: ", descriptor );

      var urlPrefix = dirname( url ) + '/';

      loadAttributes(that.veroldEngine, urlPrefix, descriptor, forceDownload, 1600, function( err, attributes ) {
        if ( err ) {
          console.warn( "Error loading attributes: " + err );
          return fn( null );
        }

        fn( createGeometry(that.veroldEngine, descriptor, attributes ) );
      }, progressFn );
    } );
  };

  var createGeometry = function(engine, descriptor, attributes ) {
    var geometry = new THREE.BufferGeometry()
      , geometryUtils = new BufferGeometryUtilities( geometry )
      , color, sizes, i;

    function resizeAttribute( values, fromSize, toSize ) {
      var iComp
        , iValue
        , minSize = Math.min( fromSize, toSize )
        , nValues = values.length / fromSize
        , newValues = new Float32Array( nValues * toSize );

      for ( iValue = 0; iValue < nValues; ++iValue ) {
        for ( iComp = 0; iComp < minSize; ++iComp ) {
          newValues[ iValue * toSize + iComp ] =
            values[ iValue * fromSize + iComp ];
        }

        for ( ; iComp < toSize; ++iComp ) {
          newValues[ iValue * toSize + iComp ] = 0;
        }
      }

      return newValues;
    }

    // Resize attributes to be compatible with Three.js shaders.
    sizes = {
      'position': 3,
      'normal': 3,
      'tangent': 4,
      'color': 4,
      'uv': 2,
      'uv2': 2,
      'skinIndex': 4,
      'skinWeight': 4
    };

    _.each( sizes, function( size, name ) {
      var attribute = attributes[ name ];

      if ( attribute !== undefined && attribute.itemSize !== size ) {
        attribute.array = resizeAttribute( attribute.array, attribute.itemSize,
          size );

        attribute.itemSize = size;
      }
    } );

    // Add attributes to the geometry.
    _.each( attributes, function( attribute, name ) {
      geometry.addAttribute(
        name,
        new THREE.BufferAttribute( attribute.array, attribute.itemSize )
      );
    } );

    geometry.drawcalls = descriptor.offsets;
    geometry.offsets = descriptor.offsets;
    geometry.bones = descriptor.bones;
    geometry.bindPose = descriptor.bind_pose;

    // Create an empty position array if it doesn't exist.
    if ( attributes.position === undefined ) {
      geometry.addAttribute(
        'position',
        new THREE.BufferAttribute( new Float32Array( 0 ), 3 )
      );
    }

    // Compute vertex normals if they don't exist.
    if ( attributes.normal === undefined ) {
      geometry.computeVertexNormals();
    }

    // Add vertex colors if they don't exist.
    if ( attributes.color === undefined ) {
      color = new Float32Array( attributes.position.array.length / 3 * 4 );

      for ( i = 0; i < color.length; ++i ) {
        color[ i ] = 1.0;
      }

      geometry.addAttribute( 'color', new THREE.BufferAttribute( color, 4 ) );
    }

    // Compute UVs if they don't exist.
    if ( attributes.uv === undefined ) {
      geometryUtils.computeUVs();
    }

    // Compute tangents if they don't exist.
    if ( attributes.tangent !== undefined ) {
      geometry.hasTangents = true;
    }
    else {
      // This must be called after UVs are loaded.
      geometryUtils.computeTangents();
    }

    // Add a wireframe attribute.
    // geometry.addWireframeAttribute();

    return geometry;
  };

  var loadAttributes = function(engine, urlPrefix, descriptor, forceDownload, maxCount, fn, progressFn ) {
    var vertexAttrs = descriptor.vertex_attributes
      , files = []
      , attributes = {}
      , progressId;

    function addFile( name, path, type, itemSize ) {
      files.push( {
        'attribute': name,
        'path': path,
        'type': type,
        'itemSize': itemSize,
        'progress': { 'loaded': 0, 'total': 0 }
      } );
    }

    function addIndexFile( name, path ) {
      addFile( name, path, Uint16Array, 1 );
    }

    function addAttributeFile( name, attrDesc ) {
      if ( attrDesc && shouldDownload( attrDesc ) ) {
        addFile( name, attrDesc.path, Float32Array, attrDesc.value_size );
      }
    }

    function shouldDownload( attrDesc ) {
      return forceDownload || !attrDesc.generated || attrDesc.count > maxCount;
    }

    function updateProgress() {
      var progressObj = {
        loaded: 0,
        total: 0
      };

      _.each( files, function( file ) {
        progressObj.loaded += file.progress.loaded;
        progressObj.total += file.progress.total;
      } );

      progressFn( progressObj );

      progressId = setTimeout( updateProgress, 300 );
    }

    addIndexFile(     'index',      descriptor.indices );
    addAttributeFile( 'position',   vertexAttrs.positions );
    addAttributeFile( 'normal',     vertexAttrs.normals );
    addAttributeFile( 'tangent',    vertexAttrs.tangents );
    addAttributeFile( 'color',      vertexAttrs.colors );
    addAttributeFile( 'uv',         vertexAttrs.uvs1 );
    addAttributeFile( 'uv2',        vertexAttrs.uvs2 );
    addAttributeFile( 'skinIndex',  vertexAttrs.skin_indices );
    addAttributeFile( 'skinWeight', vertexAttrs.skin_weights );

    async.forEach( files, function( file, next ) {
      if ( shouldDownload( file ) ) {
        var url = urlPrefix + file.path;

        loadArrayBuffer(engine, url, file.type, function( err, array ) {
          if ( err ) {
            return next( err );
          }

          attributes[ file.attribute ] = {
            'array': array,
            'itemSize': file.itemSize
          };

          next();
        },
        function( evt, sizeHeader ) {
          if ( sizeHeader ) {
            file.progress.total = parseInt( sizeHeader, 10 );
          }
          else if ( evt.lengthComputable ) {
            file.progress.total = evt.total;
          }

          file.progress.loaded = evt.loaded;
        } );
      }
      else {
        next();
      }
    },
    function( err ) {
      clearTimeout( progressId );

      if ( err ) {
        console.warn( "Error loading attributes", err );
        return fn( err );
      }

      fn( null, attributes );
    } );

    if ( progressFn ) {
      updateProgress();
    }
  };

  var loadArrayBuffer = function(engine, url, type, fn, progressFn ) {
    loadFile(engine, url, 'arraybuffer', function( err, response ) {
      if ( err ) {
        return fn( err );
      }

      fn( null, new type( response ) );
    }, progressFn );
  };

  var loadDescriptor = function(engine, url, fn ) {
    loadFile(engine, url, null, function( err, response ) {
      if ( err ) {
        return fn( err );
      }

      fn( null, JSON.parse( response ) );
    } );
  };

  var loadFile = function(engine, url, responseType, fn, progressFn ) {
    var that = this
      , xhr = new XMLHttpRequest();

    function abortDownload() {
      xhr.abort();
      engine.off( "shutdown", abortDownload, that );
    }

    function onDownloadProgress( evt ) {
      var sizeHeader = xhr.getResponseHeader( 'x-goog-meta-uncompressed-size' );
      if ( progressFn ) {
        progressFn( evt, sizeHeader );
      }
    }

    xhr.addEventListener( "progress", onDownloadProgress, false );
    xhr.open( 'GET', url, true );

    if ( responseType ) {
      xhr.responseType = responseType;
    }

    engine.on( "shutdown", abortDownload, that );

    xhr.onreadystatechange = function() {
      if ( xhr.readyState === 4 ) {
        engine.off( "shutdown", abortDownload, that );
        xhr.removeEventListener( "progress", onDownloadProgress );

        if ( xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)) {
          return fn( null, this.response );
        }
        else {
          return fn( new Error( "Invalid status: " + xhr.statusText ) );
        }
      }
    };

    xhr.onerror = function(err) {
      engine.off( "shutdown", abortDownload, that );
      fn( err );
    };

    xhr.send();
  };

  var dirname = function( path ) {
    return path.replace(/\\/g,'/').replace(/\/[^\/]*$/, '');
  };

  return BufferedBinaryLoader;
} );


define('VeroldEngine/Loaders/VeroldGeometryLoader',['three', 'underscore', 'async' ], function(THREE, _, async) {
  var batchSize = 50000, delay = 0, nWorkers = 8;

  var WorkerPool = function(script, n) {
    var i, that = this;

    this.script = script;
    this.workers = [];
    this.queue = [];

    for (i = 0; i < n; i++) {
      this.makeWorker(i, null);
    }

    this.idx = 0;
  };

  WorkerPool.prototype.constructor = WorkerPool;

  WorkerPool.prototype.makeWorker = function(idx, worker) {
    var that = this;

    this.workers[idx] = { worker: worker, busy: false };

    if (worker) {
      worker.onmessage = function(event) {
        switch (event.data.type) {
        case 'result':
          worker.terminate();

          that.workers[idx].worker = undefined;
          that.workers[idx].busy = false;
          that.workers[idx].fnDone(event.data.result);
          that.workers[idx].fnDone = undefined;
          that.workers[idx].fnProgress = undefined;

          that.dequeue(idx);

          break;

        case 'progress':
          if (typeof that.workers[idx].fnProgress === 'function') {
            that.workers[idx].fnProgress(event.data.progress);
          }
          break;
        }
      };

      worker.onerror = function(error) {
        throw error;
      };
    }
  };

  WorkerPool.prototype.loadGeometry = function(url, fnDone, fnProgress) {
    var that = this, found = false;

    _.each(this.workers, function(worker, idx) {
      if (!found && !worker.busy) {
        that.makeWorker(idx, new Worker(that.script));
        found = true;
        that.workers[idx].busy = true;
        that.workers[idx].fnDone = fnDone;
        that.workers[idx].fnProgress = fnProgress;
        that.workers[idx].worker.postMessage(url);
      }
    });

    if (!found) {
      that.queue.push({ url: url, fnDone: fnDone, fnProgress: fnProgress });
    }
  };

  WorkerPool.prototype.dequeue = function(idx) {
    var job, worker;

    if (this.queue.length) {
      this.makeWorker(idx, new Worker(this.script));

      job = this.queue.shift();

      worker = this.workers[idx];

      worker.busy = true;
      worker.fnDone = job.fnDone;
      worker.fnProgress = job.fnProgress;
      worker.worker.postMessage(job.url);
    }
  };

  var workerPool = new WorkerPool('/worker.js', nWorkers);

  var VeroldGeometryLoader = function() {};

  VeroldGeometryLoader.prototype.constructor = VeroldGeometryLoader;

  VeroldGeometryLoader.prototype.createVertices = function(geometry, data, start, count, fn) {
    var vertex, that = this;

    for (var iVertex = start; iVertex < data.xChannel.length && iVertex < start + count; ++iVertex) {
      vertex = new THREE.Vector3();
      vertex.x = data.xChannel[iVertex];
      vertex.y = data.yChannel[iVertex];
      vertex.z = data.zChannel[iVertex];
      geometry.vertices.push(vertex);
    }

    if (start + count >= data.xChannel.length) {
      fn();
    } else {
      setTimeout(function() {
        that.createVertices(geometry, data, start + count, count, fn);
      }, delay);
    }
  }

  VeroldGeometryLoader.prototype.createFaces = function(geometry, block, start, count, fn) {
    var iBlock, iTri, tri, that = this;

    switch (block.format) {
    default:
      console.warn('unrecognized format: ' + block.format);
      break;

    case 'triangles':
      for (iTri = start; iTri < block.indices.length / 3 && iTri < start + count; ++iTri) {

        tri = new THREE.Face3();
        tri.a = block.indices[iTri * 3];
        tri.b = block.indices[iTri * 3 + 1];
        tri.c = block.indices[iTri * 3 + 2];

        geometry.faces.push(tri);

      }
      break;
    }

    if (start + count >= block.indices.length / 3) {
      fn();
    } else {
      setTimeout(function() {
        that.createFaces(geometry, block, start + count, count, fn);
      }, delay);
    }
  }

  VeroldGeometryLoader.prototype.addComputedValues = function(geometry, data, start, count, fn) {
    var face, iface, that = this;

    for (iFace = start; iFace < geometry.faces.length && iFace < start + count; ++iFace) {
      face = geometry.faces[iFace];

      if (face instanceof THREE.Face3) {
        face.vertexNormals.push(new THREE.Vector3(data.xNormChannel[face.a], data.yNormChannel[face.a], data.zNormChannel[face.a]))
        face.vertexNormals.push(new THREE.Vector3(data.xNormChannel[face.b], data.yNormChannel[face.b], data.zNormChannel[face.b]))
        face.vertexNormals.push(new THREE.Vector3(data.xNormChannel[face.c], data.yNormChannel[face.c], data.zNormChannel[face.c]))

        if (data.tangents) {
          face.vertexTangents.push(new THREE.Vector4(data.tangents[face.a].x, data.tangents[face.a].y, data.tangents[face.a].z, data.tangents[face.a].w));
          face.vertexTangents.push(new THREE.Vector4(data.tangents[face.b].x, data.tangents[face.b].y, data.tangents[face.b].z, data.tangents[face.b].w));
          face.vertexTangents.push(new THREE.Vector4(data.tangents[face.c].x, data.tangents[face.c].y, data.tangents[face.c].z, data.tangents[face.c].w));
        }

        if (data.rChannel && data.gChannel && data.bChannel && data.aChannel) {
          var scale = 255.0; // if values are between 0 and 255, scale them to 0..1
          face.vertexColors.push(new THREE.Color().setRGB( data.rChannel[face.a]/scale, data.gChannel[face.a]/scale, data.bChannel[face.a]/scale));
          face.vertexColors.push(new THREE.Color().setRGB( data.rChannel[face.b]/scale, data.gChannel[face.b]/scale, data.bChannel[face.b]/scale));
          face.vertexColors.push(new THREE.Color().setRGB( data.rChannel[face.c]/scale, data.gChannel[face.c]/scale, data.bChannel[face.c]/scale));
        }

      } else if (face instanceof THREE.Face4) {
        face.vertexNormals.push(new THREE.Vector3(data.xNormChannel[face.a], data.yNormChannel[face.a], data.zNormChannel[face.a]))
        face.vertexNormals.push(new THREE.Vector3(data.xNormChannel[face.b], data.yNormChannel[face.b], data.zNormChannel[face.b]))
        face.vertexNormals.push(new THREE.Vector3(data.xNormChannel[face.c], data.yNormChannel[face.c], data.zNormChannel[face.c]))
        face.vertexNormals.push(new THREE.Vector3(data.xNormChannel[face.d], data.yNormChannel[face.d], data.zNormChannel[face.d]))

        if (data.tangents) {
          face.vertexTangents.push(new THREE.Vector4(data.tangents[face.a].x, data.tangents[face.a].y, data.tangents[face.a].z, data.tangents[face.a].w));
          face.vertexTangents.push(new THREE.Vector4(data.tangents[face.b].x, data.tangents[face.b].y, data.tangents[face.b].z, data.tangents[face.b].w));
          face.vertexTangents.push(new THREE.Vector4(data.tangents[face.c].x, data.tangents[face.c].y, data.tangents[face.c].z, data.tangents[face.c].w));
          face.vertexTangents.push(new THREE.Vector4(data.tangents[face.d].x, data.tangents[face.d].y, data.tangents[face.d].z, data.tangents[face.d].w));
        }

        if (data.rChannel && data.gChannel && data.bChannel && data.aChannel) {
          var scale = 255.0; // if values are between 0 and 255, scale them to 0..1
          face.vertexColors.push(new THREE.Color().setRGB( data.rChannel[face.a]/scale, data.gChannel[face.a]/scale, data.bChannel[face.a]/scale));
          face.vertexColors.push(new THREE.Color().setRGB( data.rChannel[face.b]/scale, data.gChannel[face.b]/scale, data.bChannel[face.b]/scale));
          face.vertexColors.push(new THREE.Color().setRGB( data.rChannel[face.c]/scale, data.gChannel[face.c]/scale, data.bChannel[face.c]/scale));
          face.vertexColors.push(new THREE.Color().setRGB( data.rChannel[face.d]/scale, data.gChannel[face.d]/scale, data.bChannel[face.d]/scale));
        }
      }
    }

    if (start + count >= geometry.faces.length) {
      if (data.tangents) {
        geometry.hasTangents = true;
      }

      fn();
    } else {
      setTimeout(function() {
        that.addComputedValues(geometry, data, start + count, count, fn);
      }, delay);
    }
  }

  VeroldGeometryLoader.prototype.addUVs = function(geometry, data, start, count, fn) {

    function normalizeUV( uv ) {
      var quo = Math.sqrt(uv.u * uv.u + uv.v * uv.v);
      uv.u /= quo;
      uv.v /= quo;
    };

    var iFace, face, uvs, UV0, UV1, UV2, UV3, UVArray, that = this;

    if (data.uChannel && data.vChannel) {
      for (iFace = start; iFace < geometry.faces.length && iFace < start + count; ++iFace) {
        face = geometry.faces[iFace];
        uvs = [];

        if (face instanceof THREE.Face3) {
          uvs.push(new THREE.Vector2(data.uChannel[face.a], 1.0 - data.vChannel[face.a]))
          uvs.push(new THREE.Vector2(data.uChannel[face.b], 1.0 - data.vChannel[face.b]))
          uvs.push(new THREE.Vector2(data.uChannel[face.c], 1.0 - data.vChannel[face.c]))
          geometry.faceVertexUvs[0][iFace] = uvs;
        } else if (face instanceof THREE.Face4) {
          uvs.push(new THREE.Vector2(data.uChannel[face.a], 1.0 - data.vChannel[face.a]))
          uvs.push(new THREE.Vector2(data.uChannel[face.b], 1.0 - data.vChannel[face.b]))
          uvs.push(new THREE.Vector2(data.uChannel[face.c], 1.0 - data.vChannel[face.c]))
          uvs.push(new THREE.Vector2(data.uChannel[face.d], 1.0 - data.vChannel[face.d]))
          geometry.faceVertexUvs[0][iFace] = uvs;
        }
      }
    }
    //If no UVs exist, we'll create them.
    else {
      console.log("No UV's found so we're creating them.");

      for (iFace = start; iFace < geometry.faces.length && iFace < start + count; ++iFace) {
        var vec;
        face = geometry.faces[iFace];
        uvs = [];

        if (face instanceof THREE.Face3) {
          vec = new THREE.Vector3( data.xChannel[face.a], data.yChannel[face.a], data.zChannel[face.a] )
          vec.normalize();
          uvs.push( new THREE.Vector2( vec.x, vec.y ) );
          vec = new THREE.Vector3( data.xChannel[face.b], data.yChannel[face.b], data.zChannel[face.b] )
          vec.normalize();
          uvs.push( new THREE.Vector2( vec.x, vec.y ) );
          vec = new THREE.Vector3( data.xChannel[face.c], data.yChannel[face.c], data.zChannel[face.c] )
          vec.normalize();
          uvs.push( new THREE.Vector2( vec.x, vec.y ) );
          geometry.faceVertexUvs[0][iFace] = uvs;
        } else if (face instanceof THREE.Face4) {
          vec = new THREE.Vector3( data.xChannel[face.a], data.yChannel[face.a], data.zChannel[face.a] )
          vec.normalize();
          uvs.push( new THREE.Vector2( vec.x, vec.y ) );
          vec = new THREE.Vector3( data.xChannel[face.b], data.yChannel[face.b], data.zChannel[face.b] )
          vec.normalize();
          uvs.push( new THREE.Vector2( vec.x, vec.y ) );
          vec = new THREE.Vector3( data.xChannel[face.c], data.yChannel[face.c], data.zChannel[face.c] )
          vec.normalize();
          uvs.push( new THREE.Vector2( vec.x, vec.y ) );
          vec = new THREE.Vector3( data.xChannel[face.d], data.yChannel[face.d], data.zChannel[face.d] )
          vec.normalize();
          uvs.push( new THREE.Vector2( vec.x, vec.y ) );
          geometry.faceVertexUvs[0][iFace] = uvs;
        }
      }
    }

    if (start + count >= geometry.faces.length) {
      fn();
    } else {
      setTimeout(function() {
        that.addUVs(geometry, data, start + count, count, fn);
      }, delay);
    }
  }

  VeroldGeometryLoader.prototype.addSkinningData = function(geometry, data, start, count, fn) {
    var that = this;
    var i, l, x, y, z, w, a, b, c, d;
    if ( data.skinWeights ) {
      for ( i = start, l = data.skinWeights.length; i < l && i < start + count; i += 2 ) {
        x = data.skinWeights[ i     ];
        y = data.skinWeights[ i + 1 ];
        z = 0;
        w = 0;
        geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );
      }
    }

    if ( data.skinIndices ) {
      for ( i = start, l = data.skinIndices.length; i < l && i < start + count; i += 2 ) {
        a = data.skinIndices[ i     ];
        b = data.skinIndices[ i + 1 ];
        c = 0;
        d = 0;
        geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );
      }
    }
    if (!data.skinIndices) data.skinIndices = [];
    if ( start + count >= data.skinIndices.length) {
      fn();
    } else {
      setTimeout(function() {
        that.addSkinningData(geometry, data, start + count, count, fn);
      }, delay);
    }
  }

  VeroldGeometryLoader.prototype.createGeometry = function(data, fn) {
    var geometry = new THREE.Geometry(), that = this;

    if (!data.faces) {
      fn(null);
      return;
    }

    this.createVertices(geometry, data, 0, batchSize, function() {
      setTimeout(function() {
        async.forEachSeries(data.faces, function(block, next) {
          that.createFaces(geometry, block, 0, batchSize, function() {
            next();
          });
        }, function() {
          if (!geometry.faces[0]) {
            console.log("The geometry, \"" + geometry + "\", has no faces!  Skipping it.");
            fn(null);
            return;
          }

          that.addSkinningData(geometry, data, 0, batchSize, function() {
            that.addComputedValues(geometry, data, 0, batchSize, function() {
              that.addUVs(geometry, data, 0, batchSize, function() {
                geometry.computeBoundingBox();

                if (!geometry.faces[0].vertexNormals[0]) {
                  //console.log("Computing normals, this might take a while...");
                  geometry.computeVertexNormals();
                }
                // if (!geometry.faces[0].centroid[0]) {
                //   //console.log("Computing face centroids, this might take a while...");
                //   geometry.computeCentroids();
                // }
                if (!geometry.faces[0].normal[0]) {
                  //console.log("Computing face normals, this might take a while...");
                  geometry.computeFaceNormals();
                }

                //  Compute tangents  if  we  have  UVs.
                if (!geometry.hasTangents) {
                  //console.log("Computing tangents, this might take a while..." );
                  geometry.computeTangents();
                }

                fn(geometry);
              });
            });
          });
        });
      }, 0);
    });
  };

  VeroldGeometryLoader.prototype.loadGeometry = function(url, fnDone, fnProgress) {
    var that = this
      , startTime = new Date()
      , endTime;

    workerPool.loadGeometry(url, function(result) {
      setTimeout(function(){
        that.createGeometry(result, function(geometry) {
          endTime = new Date();

          if ( geometry ) {
            console.log('Finished loading: ' + url + ' took: ' + ((endTime.getTime() - startTime.getTime()) / 1000) + ' seconds');
          }
          else {
            console.warn('Error loading: ' + url + ' took: ' + ((endTime.getTime() - startTime.getTime()) / 1000) + ' seconds');
          }

          fnDone(geometry);
        });
      }, 0);
    }, fnProgress);
  };

  // @FIXME, put this somewhere else eventually
  /*
  window.THREE.JSONLoader.prototype.loadGeometry = function(url, fnDone, fnProgress, texturePath) {
    var that = this
      , startTime = new Date()
      , endTime;

      texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );

      this.onLoadStart();

    workerPool.loadGeometry(url, function(result) {
      that.createModel( result, function(geometry) {
        endTime = new Date();

        console.log('Finished loading: ' + url + ' took: ' + ((endTime.getTime() - startTime.getTime()) / 1000) + ' seconds');

        fnDone(geometry);
                that.onLoadComplete();
      }, texturePath );
    }, fnProgress);
  }
  */
  THREE.JSONLoader.prototype.load = function ( url, callback, texturePath, callbackProgress, engine ) {

    var scope = this;

    // todo: unify load API to for easier SceneLoader use

    texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );

    this.onLoadStart();
    this.loadAjaxJSON( this, url, callback, texturePath, callbackProgress, engine );

  };
  // Hack to allow JSON loader to to get correct download progress reporting
  THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress, engine ) {

    var that = this;
    var xhr = new XMLHttpRequest();

    var length = 0;

    function abortDownload() {
      xhr.abort();
      engine.off("shutdown", abortDownload, that);
      if ( callback ) {
        callback();
      }
    }

    xhr.withCredentials = this.withCredentials;

    engine.on("shutdown", abortDownload, this);

    //We don't want to call the progress function as often as possible
    //so we'll limit it to every 100 ms.
    var sendProgressUpdate = true;
    var downloadFinished = false;
    var progressId;
    function markProgressToSend() {
      if ( downloadFinished ) {
        sendProgressUpdate = false;
        return;
      }
      else {
        sendProgressUpdate = true;

        progressId = setTimeout( markProgressToSend, 500 );
      }
    }
    markProgressToSend();
    var downloadSize = 0;

    xhr.onreadystatechange = function () {
      
      if ( xhr.readyState === xhr.DONE ) {

        downloadFinished = true;
        clearTimeout( progressId );
        callbackProgress = null;
        if ( xhr.status === 200 || xhr.status === 0 ) {

          if ( xhr.responseText ) {

            var json = JSON.parse( xhr.responseText );
            
            //Call the progress callback one last time so that the application
            //knows 100% has been downloaded.
            if ( callbackProgress ) {
              callbackProgress( { total: downloadSize, loaded: downloadSize } );
            }
            context.createModel( json, callback, texturePath );

          } else {

            console.warn( "THREE.JSONLoader: [" + url + "] seems to be unreachable or file there is empty" );

          }

          // in context of more complex asset initialization
          // do not block on single failed file
          // maybe should go even one more level up

          context.onLoadComplete();

        } else {

          console.error( "THREE.JSONLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );

        }
        engine.off("shutdown", abortDownload, that);

      } else if ( xhr.readyState === xhr.LOADING ) {

        if ( sendProgressUpdate ) {
          setTimeout( function() {
            if ( callbackProgress ) {

              if ( length === 0 ) {

                length = parseInt(xhr.getResponseHeader('x-goog-meta-uncompressed-size') || xhr.getResponseHeader("Content-Length"), 10);

              }
              downloadSize = length;
              callbackProgress( { total: length, loaded: parseInt(xhr.responseText.length, 10) } );
            }
          }, 0);
          sendProgressUpdate = false;
        }

      } else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

        length = parseInt(xhr.getResponseHeader('x-goog-meta-uncompressed-size') || xhr.getResponseHeader("Content-Length"), 10);

      }

    };

    xhr.open( "GET", url, true );
    xhr.send( null );

  };

  //Copied wholesale from Zelimir's repo to get needed preprocessing of geometry with animation info.
  //https://github.com/zfedoran/three.js/blob/dev/src/loaders/JSONLoader.js#L111
  THREE.JSONLoader.prototype.createModel = function ( json, callback, texturePath ) {

    var scope = this,
    geometry = new THREE.Geometry(),
    scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

    if ( json.skinning !== undefined &&
         json.skinning.indices !== undefined &&
         json.skinning.indices.length > 0 ) {
      json.bones = json.skinning.bones;
      json.skinIndices = json.skinning.indices;
      json.skinWeights = json.skinning.weights;
    }

    parseModel( scale );

    parseSkin();
    parseMorphing( scale );

    //geometry.computeCentroids();
    geometry.computeFaceNormals();

    function parseModel( scale ) {

        function isBitSet( value, position ) {

            return value & ( 1 << position );

        }

        var i, j, fi,

        offset, zLength,

        colorIndex, normalIndex, uvIndex, materialIndex,

        type,
        isQuad,
        hasMaterial,
        hasFaceVertexUv,
        hasFaceNormal, hasFaceVertexNormal,
        hasFaceColor, hasFaceVertexColor,

        vertex, face, faceA, faceB, color, hex, normal,

        uvLayer, uv, u, v,

        faces = json.faces,
        vertices = json.vertices,
        normals = json.normals,
        colors = json.colors,

        nUvLayers = 0;

        if ( json.uvs !== undefined ) {

            // disregard empty arrays

            for ( i = 0; i < json.uvs.length; i++ ) {

                if ( json.uvs[ i ].length ) nUvLayers ++;

            }

            for ( i = 0; i < nUvLayers; i++ ) {

                geometry.faceVertexUvs[ i ] = [];

            }

        }

        offset = 0;
        zLength = vertices.length;

        while ( offset < zLength ) {

            vertex = new THREE.Vector3();

            vertex.x = vertices[ offset ++ ] * scale;
            vertex.y = vertices[ offset ++ ] * scale;
            vertex.z = vertices[ offset ++ ] * scale;

            geometry.vertices.push( vertex );

        }

        geometry.faceEdgeMasks = [];

        offset = 0;
        zLength = faces.length;

        while ( offset < zLength ) {

            type = faces[ offset ++ ];


            isQuad              = isBitSet( type, 0 );
            hasMaterial         = isBitSet( type, 1 );
            hasFaceVertexUv     = isBitSet( type, 3 );
            hasFaceNormal       = isBitSet( type, 4 );
            hasFaceVertexNormal = isBitSet( type, 5 );
            hasFaceColor        = isBitSet( type, 6 );
            hasFaceVertexColor  = isBitSet( type, 7 );

            // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

            if ( isQuad ) {

                faceA = new THREE.Face3();
                faceA.a = faces[ offset ];
                faceA.b = faces[ offset + 1 ];
                faceA.c = faces[ offset + 3 ];

                faceB = new THREE.Face3();
                faceB.a = faces[ offset + 1 ];
                faceB.b = faces[ offset + 2 ];
                faceB.c = faces[ offset + 3 ];

                offset += 4;

                if ( hasMaterial ) {

                    materialIndex = faces[ offset ++ ];
                    faceA.materialIndex = materialIndex;
                    faceB.materialIndex = materialIndex;

                }

                // to get face <=> uv index correspondence

                fi = geometry.faces.length;

                geometry.faceEdgeMasks[ fi ]     = 1 | 4;
                geometry.faceEdgeMasks[ fi + 1 ] = 1 | 2;

                if ( hasFaceVertexUv ) {

                    for ( i = 0; i < nUvLayers; i++ ) {

                        uvLayer = json.uvs[ i ];

                        geometry.faceVertexUvs[ i ][ fi ] = [];
                        geometry.faceVertexUvs[ i ][ fi + 1 ] = []

                        for ( j = 0; j < 4; j ++ ) {

                            uvIndex = faces[ offset ++ ];

                            u = uvLayer[ uvIndex * 2 ];
                            v = uvLayer[ uvIndex * 2 + 1 ];

                            uv = new THREE.Vector2( u, v );

                            if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
                            if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

                        }

                    }

                }

                if ( hasFaceNormal ) {

                    normalIndex = faces[ offset ++ ] * 3;

                    faceA.normal.set(
                        normals[ normalIndex ++ ],
                        normals[ normalIndex ++ ],
                        normals[ normalIndex ]
                    );

                    faceB.normal.copy( faceA.normal );

                }

                if ( hasFaceVertexNormal ) {

                    for ( i = 0; i < 4; i++ ) {

                        normalIndex = faces[ offset ++ ] * 3;

                        normal = new THREE.Vector3(
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ]
                        );


                        if ( i !== 2 ) faceA.vertexNormals.push( normal );
                        if ( i !== 0 ) faceB.vertexNormals.push( normal );

                    }

                }


                if ( hasFaceColor ) {

                    colorIndex = faces[ offset ++ ];
                    hex = colors[ colorIndex ];

                    faceA.color.setHex( hex );
                    faceB.color.setHex( hex );

                }


                if ( hasFaceVertexColor ) {

                    for ( i = 0; i < 4; i++ ) {

                        colorIndex = faces[ offset ++ ];
                        hex = colors[ colorIndex ];

                        if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
                        if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

                    }

                }

                geometry.faces.push( faceA );
                geometry.faces.push( faceB );

            } else {

                face = new THREE.Face3();
                face.a = faces[ offset ++ ];
                face.b = faces[ offset ++ ];
                face.c = faces[ offset ++ ];

                if ( hasMaterial ) {

                    materialIndex = faces[ offset ++ ];
                    face.materialIndex = materialIndex;

                }

                // to get face <=> uv index correspondence

                fi = geometry.faces.length;

                geometry.faceEdgeMasks[ fi ] = 1 | 2 | 4;

                if ( hasFaceVertexUv ) {

                    for ( i = 0; i < nUvLayers; i++ ) {

                        uvLayer = json.uvs[ i ];

                        geometry.faceVertexUvs[ i ][ fi ] = [];

                        for ( j = 0; j < 3; j ++ ) {

                            uvIndex = faces[ offset ++ ];

                            u = uvLayer[ uvIndex * 2 ];
                            v = uvLayer[ uvIndex * 2 + 1 ];

                            uv = new THREE.Vector2( u, v );

                            geometry.faceVertexUvs[ i ][ fi ].push( uv );

                        }

                    }

                }

                if ( hasFaceNormal ) {

                    normalIndex = faces[ offset ++ ] * 3;

                    face.normal.set(
                        normals[ normalIndex ++ ],
                        normals[ normalIndex ++ ],
                        normals[ normalIndex ]
                    );

                }

                if ( hasFaceVertexNormal ) {

                    for ( i = 0; i < 3; i++ ) {

                        normalIndex = faces[ offset ++ ] * 3;

                        normal = new THREE.Vector3(
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ++ ],
                            normals[ normalIndex ]
                        );

                        face.vertexNormals.push( normal );

                    }

                }


                if ( hasFaceColor ) {

                    colorIndex = faces[ offset ++ ];
                    face.color.setHex( colors[ colorIndex ] );

                }


                if ( hasFaceVertexColor ) {

                    for ( i = 0; i < 3; i++ ) {

                        colorIndex = faces[ offset ++ ];
                        face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

                    }

                }

                geometry.faces.push( face );

            }

        }

    };

    function parseSkin() {

      var i, l, x, y, z, w, a, b, c, d;

      if ( json.skinWeights ) {

        for ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {

          x = json.skinWeights[ i     ];
          y = json.skinWeights[ i + 1 ];
          z = 0;
          w = 0;

          geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

        }

      }

      if ( json.skinIndices ) {

        for ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {

          a = json.skinIndices[ i     ];
          b = json.skinIndices[ i + 1 ];
          c = 0;
          d = 0;

          geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

        }

      }

      geometry.bones = json.bones;
      geometry.animation = json.animation;

    };

    function parseMorphing( scale ) {

      if ( json.morphTargets !== undefined ) {

        var i, l, v, vl, dstVertices, srcVertices;

        for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

          geometry.morphTargets[ i ] = {};
          geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
          geometry.morphTargets[ i ].vertices = [];

          dstVertices = geometry.morphTargets[ i ].vertices;
          srcVertices = json.morphTargets [ i ].vertices;

          for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

            var vertex = new THREE.Vector3();
            vertex.x = srcVertices[ v ] * scale;
            vertex.y = srcVertices[ v + 1 ] * scale;
            vertex.z = srcVertices[ v + 2 ] * scale;

            dstVertices.push( vertex );

          }

        }

      }

      if ( json.morphColors !== undefined ) {

        var i, l, c, cl, dstColors, srcColors, color;

        for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

          geometry.morphColors[ i ] = {};
          geometry.morphColors[ i ].name = json.morphColors[ i ].name;
          geometry.morphColors[ i ].colors = [];

          dstColors = geometry.morphColors[ i ].colors;
          srcColors = json.morphColors [ i ].colors;

          for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

            color = new THREE.Color( 0xffaa00 );
            color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
            dstColors.push( color );

          }

        }

      }

    };

    //var materials = this.initMaterials( json.materials, texturePath );

    //if ( this.needsTangents( materials ) ) geometry.computeTangents();

    callback( geometry );

  };

  return VeroldGeometryLoader;
});

define( 'VeroldEngine/Util/GeometryUtilities',[ 'underscore', 'three' ],
  function( _, THREE ) {

    var GeometryUtilities = function(veroldEngine, geometry ) {
      this.veroldEngine = veroldEngine;
      this.geometry = geometry;
    };

    GeometryUtilities.prototype = {

      constructor: GeometryUtilities,

      /**
      * Computes tangents for the geometry asynchronously and calls the provided
      * callback when done. This method can also be setup to yeild execution
      * periodically during computation.
      * @method
      * @param  {[type]} finish_Callback  Called when the computation is complete.
      * @param  {[type]} numFacesToBatch The number of faces to process before
      * yielding to allow the cpu to run waiting code.
      * @return {[type]}                 [description]
      */
      computeTangentsAsync: function ( finish_Callback, progress_Callback, numFacesToBatch ) {

        // based on http://www.terathon.com/code/tangent.html
        // tangents go to vertices

        var that = this
          , g = this.geometry
          , sdir = new THREE.Vector3()
          , tdir = new THREE.Vector3()
          , tmp = new THREE.Vector3()
          , tmp2 = new THREE.Vector3()
          , n = new THREE.Vector3()
          , abort = false
          , f, fl, v, vl, i, il, vertexIndex
          , face, uv, vA, vB, vC, uvA, uvB, uvC
          , x1, x2, y1, y2, z1, z2
          , s1, s2, t1, t2, r, t, test
          , w, progressStep, progress;

        function abortCompute() {
          abort = true;
          console.log( "Aborting tangent computation due to engine shutdown." );
          that.veroldEngine.globalEvents.off( "shutdown", abortCompute, that );
          return;
        }

        that.veroldEngine.globalEvents.on( "shutdown", abortCompute, this );

        for ( f = 0; f < g.faces.length; ++f ) {
          face = g.faces[ f ];
          for ( i = 0; i < face.vertexNormals.length; i++ ) {
            face.vertexTangents[ i ] = new THREE.Vector4();
          }
        }

        if ( numFacesToBatch === undefined ) {
          numFacesToBatch = 100000;
        }

        var arraySize = g.vertices.length * 3 * 4
          , tan1Buffer = new ArrayBuffer( arraySize )
          , tan2Buffer = new ArrayBuffer( arraySize )
          , tan1View = new Float32Array( tan1Buffer )
          , tan2View = new Float32Array( tan2Buffer )
          , tanTmp = new THREE.Vector3();

        function getVector( bufferView, index ) {
          tanTmp.set( bufferView[ index * 3 ], bufferView[ index * 3 + 1 ], bufferView[ index * 3 + 2 ] );
          return tanTmp;
        }

        function addVector( bufferView, index, vector ) {
          bufferView[ index * 3 ] += vector.x;
          bufferView[ index * 3 + 1 ] += vector.y;
          bufferView[ index * 3 + 2 ] += vector.z;
        }

        function handleTriangle( context, a, b, c, ua, ub, uc ) {

          vA = context.vertices[ a ];
          vB = context.vertices[ b ];
          vC = context.vertices[ c ];

          uvA = uv[ ua ];
          uvB = uv[ ub ];
          uvC = uv[ uc ];

          x1 = vB.x - vA.x;
          x2 = vC.x - vA.x;
          y1 = vB.y - vA.y;
          y2 = vC.y - vA.y;
          z1 = vB.z - vA.z;
          z2 = vC.z - vA.z;

          s1 = uvB.x - uvA.x;
          s2 = uvC.x - uvA.x;
          t1 = uvB.y - uvA.y;
          t2 = uvC.y - uvA.y;

          r = 1.0 / ( s1 * t2 - s2 * t1 );
          sdir.set( ( t2 * x1 - t1 * x2 ) * r,
                ( t2 * y1 - t1 * y2 ) * r,
                ( t2 * z1 - t1 * z2 ) * r );
          tdir.set( ( s1 * x2 - s2 * x1 ) * r,
                ( s1 * y2 - s2 * y1 ) * r,
                ( s1 * z2 - s2 * z1 ) * r );

          function checkAndFix( vector, component ) {
            if ( !vector[ component ] && vector[ component ] != 0 ) {
              vector[ component ] = 0;
            }
            else if ( vector[ component ] === Infinity ) {
              vector[ component ] = 1.0;
            }
            else if ( vector[ component ] === -Infinity ) {
              vector[ component ] = -1.0;
            }
          }

          checkAndFix( sdir, "x" );
          checkAndFix( sdir, "y" );
          checkAndFix( sdir, "z" );
          checkAndFix( tdir, "x" );
          checkAndFix( tdir, "y" );
          checkAndFix( tdir, "z" );

          addVector( tan1View, a, sdir );
          addVector( tan1View, b, sdir );
          addVector( tan1View, c, sdir );

          addVector( tan2View, a, tdir );
          addVector( tan2View, b, tdir );
          addVector( tan2View, c, tdir );

        }

        function runBatch( f, callback ) {
          var batchCounter = 0;

          for ( f; batchCounter < numFacesToBatch && f < g.faces.length; f++, batchCounter++ ) {
            face = g.faces[ f ];
            callback( face, f );
          }

          face = null;

          if ( f < g.faces.length ) {
            progress += progressStep * numFacesToBatch;
            if ( progress_Callback ) {
              progress_Callback( progress );
            }
          }

        }

        function forEachFace( callback, progressStart, progressFinish, finishedCallback ) {
          var currentBatchId;

          f = 0;
          progress = progressStart;
          progressStep = ( progressFinish - progressStart ) / g.faces.length;

          function runNextBatch() {
            if ( abort ) {
              clearTimeout( currentBatchId );
              return;
            }
            else if ( f >= g.faces.length ) {
              progress_Callback( progressFinish );
              finishedCallback();
              return;
            }
            else {
              runBatch( f, callback );
              f += numFacesToBatch;
              currentBatchId = setTimeout( runNextBatch, 0 );
            }
          }

          runNextBatch();
        }

        function handleAllTriangles( face, index ) {
          uv = g.faceVertexUvs[ 0 ][ index ]; // use UV layer 0 for tangents
          if ( face instanceof THREE.Face3 ) {
            handleTriangle( g, face.a, face.b, face.c, 0, 1, 2 );
          }
          else if ( face instanceof THREE.Face4 ) {
            handleTriangle( g, face.a, face.b, face.d, 0, 1, 3 );
            handleTriangle( g, face.b, face.c, face.d, 1, 2, 3 );
          }

        }

        function computeTangentsForFace( face, index ) {

          for ( i = 0; i < face.vertexNormals.length; ++i ) {

            n.copy( face.vertexNormals[ i ] );

            vertexIndex = face[ faceIndex[ i ] ];

            t = getVector( tan1View, vertexIndex );

            // Gram-Schmidt orthogonalize

            tmp.copy( t );
            tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

            // Calculate handedness

            tmp2.crossVectors( face.vertexNormals[ i ], t );
            //test = tmp2.dot( tan2[ vertexIndex ] );
            test = tmp2.dot( getVector( tan2View, vertexIndex ) );
            w = ( test < 0.0 ) ? -1.0 : 1.0;

            face.vertexTangents[ i ].set( tmp.x, tmp.y, tmp.z, w );

          }
        }

        var faceIndex = [ 'a', 'b', 'c', 'd' ];

        forEachFace( handleAllTriangles, 0, 0.3, function() {
          sdir = null;
          tdir = null;

          forEachFace( computeTangentsForFace, 0.3, 1.0, function() {
            g.hasTangents = true;
            tanTmp = null;
            tan1View = null;
            tan2View = null;
            tan1Buffer = null;
            tan2Buffer = null;
            tmp = null;
            tmp2 = null;
            n = null;

            that.veroldEngine.globalEvents.off( "shutdown", abortCompute, that );

            if ( finish_Callback ) {
              finish_Callback();
            }
          } );
        } );
      },

      computeUVs: function( ) {
        var g = this.geometry
          , indices = [ 'a', 'b', 'c', 'd' ]
          , tempVec = new THREE.Vector3();

        for ( var iFace = 0; iFace < g.faces.length; ++iFace ) {
          var face = g.faces[ iFace ]
            , nVertices = 3
            , uvs = [];

          if ( face instanceof THREE.Face4 ) {
            nVertices = 4;
          }

          for ( var idx = 0; idx < nVertices; ++idx) {
            var vtxIdx = indices[ idx ]
              , vtx = g.vertices[ face[ vtxIdx ] ];

            tempVec.set( vtx.x, vtx.y, vtx.z );
            tempVec.normalize();
            tempVec.addScalar( 1.0 );
            tempVec.multiplyScalar( 0.5 );
            uvs.push( new THREE.Vector2( tempVec.x, tempVec.y ) );
          }

          g.faceVertexUvs[ 0 ][ iFace ] = uvs;
        }
      },

      computeVertexNormalsAsync: function ( areaWeighted, finish_Callback, progress_Callback, numFacesToBatch ) {
        var that = this
          , g = this.geometry
          , ab = new THREE.Vector3()
          , bc = new THREE.Vector3()
          , cb = new THREE.Vector3()
          , db = new THREE.Vector3()
          , dc = new THREE.Vector3()
          , abort = false
          , vA, vB, vC, vD
          , v, vl, f, fl
          , face, vertices, tmpVec
          , progressStep, progress;

        function abortCompute() {
          abort = true;
          console.log( "Aborting normal computation due to engine shutdown." );
          that.veroldEngine.globalEvents.off( "shutdown", abortCompute, that );
          return;
        }

        that.veroldEngine.globalEvents.on( "shutdown", abortCompute, this );
        tmpVec = new THREE.Vector3();

        // Create internal buffers for reuse when calling this method repeatedly
        // (otherwise memory allocation / deallocation every frame is big
        // resource hog).

        function addVector( bufferView, index, vector ) {
          bufferView[ index * 3 ] += vector.x;
          bufferView[ index * 3 + 1 ] += vector.y;
          bufferView[ index * 3 + 2 ] += vector.z;
        }

        function runBatch( f, callback ) {
          var batchCounter = 0;

          for ( f; batchCounter < numFacesToBatch && f < g.faces.length; ++f, ++batchCounter ) {
            face = g.faces[ f ];
            callback( face, f );
          }

          face = null;

          if ( f < g.faces.length ) {
            progress += progressStep * numFacesToBatch;
            if ( progress_Callback ) {
              progress_Callback( progress );
            }
          }
        }

        function forEachFace( callback, progressStart, progressFinish, finishedCallback ) {
          var currentBatchId;

          f = 0;
          progress = progressStart;
          progressStep = ( progressFinish - progressStart ) / g.faces.length;

          function runNextBatch() {
            if ( abort ) {
              clearTimeout( currentBatchId );
              return;
            }
            else if ( f >= g.faces.length ) {
              progress_Callback( progressFinish );
              finishedCallback();
              return;
            }
            else {
              runBatch( f, callback );
              f += numFacesToBatch;
              currentBatchId = setTimeout( runNextBatch, 0 );
            }
          }

          runNextBatch();
        }

        function accumulateNormals( face, index ) {
          if ( face instanceof THREE.Face3 ) {
            addVector( vertices, face.a, face.normal );
            addVector( vertices, face.b, face.normal );
            addVector( vertices, face.c, face.normal );
          }
          else if ( face instanceof THREE.Face4 ) {
            addVector( vertices, face.a, face.normal );
            addVector( vertices, face.b, face.normal );
            addVector( vertices, face.c, face.normal );
            addVector( vertices, face.d, face.normal );
          }
        }

        function normalizeVerts() {
          for ( v = 0, vl = g.vertices.length; v < vl; ++v ) {
            tmpVec.x = vertices[ v * 3 ];
            tmpVec.y = vertices[ v * 3 + 1];
            tmpVec.z = vertices[ v * 3 + 2];
            tmpVec.normalize();
            vertices[ v * 3 ] = tmpVec.x;
            vertices[ v * 3 + 1 ] = tmpVec.y;
            vertices[ v * 3 + 2 ] = tmpVec.z;
          }
        }

        function setVertexNormals( face, index ) {
          if ( face instanceof THREE.Face3 ) {
            face.vertexNormals[ 0 ].set( vertices[ face.a * 3 ], vertices[ face.a * 3 + 1 ], vertices[ face.a * 3 + 2 ] );
            face.vertexNormals[ 1 ].set( vertices[ face.b * 3 ], vertices[ face.b * 3 + 1 ], vertices[ face.b * 3 + 2 ] );
            face.vertexNormals[ 2 ].set( vertices[ face.c * 3 ], vertices[ face.c * 3 + 1 ], vertices[ face.c * 3 + 2 ] );
          }
          else if ( face instanceof THREE.Face4 ) {
            face.vertexNormals[ 0 ].set( vertices[ face.a * 3 ], vertices[ face.a * 3 + 1 ], vertices[ face.a * 3 + 2 ] );
            face.vertexNormals[ 1 ].set( vertices[ face.b * 3 ], vertices[ face.b * 3 + 1 ], vertices[ face.b * 3 + 2 ] );
            face.vertexNormals[ 2 ].set( vertices[ face.c * 3 ], vertices[ face.c * 3 + 1 ], vertices[ face.c * 3 + 2 ] );
            face.vertexNormals[ 3 ].set( vertices[ face.d * 3 ], vertices[ face.d * 3 + 1 ], vertices[ face.d * 3 + 2 ] );
          }
        }

        function weightByTriArea( face, index ) {
          // vertex normals weighted by triangle areas
          // http://www.iquilezles.org/www/articles/normals/normals.htm

          if ( face instanceof THREE.Face3 ) {

            cb.set( g.vertices[ face.c * 3 ] - g.vertices[ face.b * 3 ],
            g.vertices[ face.c * 3 + 1 ] - g.vertices[ face.b * 3 + 1],
            g.vertices[ face.c * 3 + 2 ] - g.vertices[ face.b * 3 + 2 ] );

            ab.set( g.vertices[ face.a * 3 ] - g.vertices[ face.b * 3 ],
            g.vertices[ face.a * 3 + 1 ] - g.vertices[ face.b * 3 + 1],
            g.vertices[ face.a * 3 + 2 ] - g.vertices[ face.b * 3 + 2 ] );

            cb.cross( ab );

            addVector( vertices, face.a, cb );
            addVector( vertices, face.b, cb );
            addVector( vertices, face.c, cb );

          }
          else if ( face instanceof THREE.Face4 ) {

            vA = g.vertices[ face.a ];
            vB = g.vertices[ face.b ];
            vC = g.vertices[ face.c ];
            vD = g.vertices[ face.d ];

            // abd

            db.set(
              g.vertices[ face.d * 3 ] - g.vertices[ face.b * 3 ],
              g.vertices[ face.d * 3 + 1 ] - g.vertices[ face.b * 3 + 1],
              g.vertices[ face.d * 3 + 2 ] - g.vertices[ face.b * 3 + 2 ] );

            ab.set(
              g.vertices[ face.a * 3 ] - g.vertices[ face.b * 3 ],
              g.vertices[ face.a * 3 + 1 ] - g.vertices[ face.b * 3 + 1],
              g.vertices[ face.a * 3 + 2 ] - g.vertices[ face.b * 3 + 2 ] );

            db.cross( ab );

            addVector( vertices, face.a, db );
            addVector( vertices, face.b, db );
            addVector( vertices, face.d, db );

            // bcd

            dc.set(
              g.vertices[ face.d * 3 ] - g.vertices[ face.c * 3 ],
              g.vertices[ face.d * 3 + 1 ] - g.vertices[ face.c * 3 + 1],
              g.vertices[ face.d * 3 + 2 ] - g.vertices[ face.c * 3 + 2 ]
            );

            bc.set(
              g.vertices[ face.b * 3 ] - g.vertices[ face.c * 3 ],
              g.vertices[ face.b * 3 + 1 ] - g.vertices[ face.c * 3 + 1],
              g.vertices[ face.b * 3 + 2 ] - g.vertices[ face.c * 3 + 2 ]
            );

            dc.cross( bc );

            addVector( vertices, face.b, dc );
            addVector( vertices, face.c, dc );
            addVector( vertices, face.d, dc );

          }
        }

        if ( numFacesToBatch === undefined ) {
          numFacesToBatch = 100000;
        }

        if ( g.__tmpVertices === undefined ) {

          var arraySize = g.vertices.length * 3 * 4
            , vertexBuffer = new ArrayBuffer( arraySize )
            , vertexBufferView = new Float32Array( vertexBuffer );

          g.__tmpVertices = vertexBufferView;
          vertices = g.__tmpVertices;

          for ( f = 0, fl = g.faces.length; f < fl; ++f ) {
            face = g.faces[ f ];
            if ( face instanceof THREE.Face3 ) {
              face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
            }
            else if ( face instanceof THREE.Face4 ) {
              face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
            }
          }
        }
        else {
          vertices = g.__tmpVertices;
          for ( v = 0, vl = g.vertices.length; v < vl; ++v ) {
            vertices[ v * 3 ] = 0.0;
            vertices[ v * 3 + 1] = 0.0;
            vertices[ v * 3 + 2] = 0.0;
          }
        }

        function finishPart1() {
          normalizeVerts();
          forEachFace( setVertexNormals, 0.5, 1.0, finishPart2 );
        }

        function finishPart2() {
          ab = null;
          bc = null;
          db = null;
          dc = null;

          that.veroldEngine.globalEvents.off( "shutdown", abortCompute, that );

          if ( finish_Callback ) {
            finish_Callback();
          }
        }

        if ( areaWeighted ) {
          forEachFace( weightByTriArea, 0.1, 0.5, finishPart1 );
        }
        else {
          forEachFace( accumulateNormals, 0.1, 0.5, finishPart1 );
        }
      },

      /**
      * This function is run prior to computing tangent vectors with Three.js.
      * It fixes the tangent calculation at UV seams by duplicating vertices
      * that have discontinuous UV coordinates (i.e. those that lie on UV
      * seams).  This is necessary because Three.js averages tangent vectors on
      * a per-vertex basis, in much the same way that smooth vertex normals are
      * calculated.  It does this without regard for UV seams, which leads to
      * incorrect, for the purpose of normal mapping, tangent vectors.
      */
      splitUVSeams: function( ) {
        // Step 1:
        //
        // Create a list of (face, face-vertex) pairs for each vertex.  For
        // example, if two faces, say 1 and 5, share vertex 0, we might get:
        //
        //   vtxToUvList[0] = [ [ 1, 0 ], [ 5, 2 ] ]
        //
        // Here, [ 1, 0 ] refers to the first vertex of face 1 and [ 5, 2 ]
        // refers to the third vertex of face 5.

        var g = this.geometry
          , indices = [ 'a', 'b', 'c', 'd' ]
          , vtxToUvList = []
          , faceVertexUvs, nOriginalVertices;

        vtxToUvList[ g.vertices.length - 1 ] = undefined;

        for ( var iFace = 0; iFace < g.faces.length; ++iFace ) {
          var face = g.faces[ iFace ]
            , nVertices = 3;

          if ( face instanceof THREE.Face4 ) {
            nVertices = 4;
          }

          for ( var idx = 0; idx < nVertices; ++idx ) {
            var vertexNo = face[ indices[ idx ] ];
            if ( vtxToUvList[ vertexNo ] ) {
              vtxToUvList[ vertexNo ].push( [ iFace, idx ] );
            }
            else {
              vtxToUvList[ vertexNo ] = [ [ iFace, idx ] ];
            }
          }
        }

        // Step 2:
        //
        // Use the vtxToUvList mapping to quickly identify shared vertices that
        // have multiple sets of UVs (i.e. vertices lying on UV seams).
        // Duplicate any such vertices until each vertex has a unique UV
        // coordinate.

        // Only consider the first UV layer.
        faceVertexUvs = g.faceVertexUvs[ 0 ];

        // Cache this value because we will be appending to the vertex array
        // while looping over its elements.
        nOriginalVertices = g.vertices.length;

        for ( var iVtx = 0; iVtx < nOriginalVertices; ++iVtx ) {

          // Get the array of (face, face-vertex) pairs.
          var pairs = vtxToUvList[ iVtx ];

          // Skip unreferenced vertices.
          if ( !pairs ) {
            continue;
          }

          // For each pair, look for a pair with matching UV coordinates.  If a
          // a match exists, these pairs can reference the same vertex;
          // otherwise, duplicate the vertex and have each pair reference a
          // different vertex.
          for ( var iPair = 1; iPair < pairs.length; ++iPair ) {
            var faceNo1    = pairs[ iPair ][ 0 ]
              , vtxNo1     = pairs[ iPair ][ 1 ]
              , face1      = g.faces[ faceNo1 ]
              , uv1        = faceVertexUvs[ faceNo1 ][ vtxNo1 ]
              , foundMatch = false;

            for ( var jPair = 0; jPair < iPair; ++jPair ) {
              var faceNo2 = pairs[ jPair ][ 0 ]
                , vtxNo2  = pairs[ jPair ][ 1 ]
                , face2   = g.faces[ faceNo2 ]
                , uv2     = faceVertexUvs[ faceNo2 ][ vtxNo2 ];

              // Do the face-vertices have identical UV coordinates?
              if ( uv1.x === uv2.x && uv1.y === uv2.y ) {

                // Make each face reference the same vertex.
                face1[ indices[ vtxNo1 ] ] = face2[ indices[ vtxNo2 ] ];

                foundMatch = true;
                break;
              }
            }

            // No match was found, so duplicate the vertex and have the current
            // face reference the copy.
            if ( !foundMatch ) {

              // Duplicate the vertex, color and normal.
              g.vertices.push( g.vertices[ iVtx ] );

              if ( g.colors !== undefined && g.colors.length > 0 ) {
                g.colors.push( g.colors[ iVtx ] );
              }

              if ( g.normals !== undefined && g.normals.length > 0 ) {
                g.normals.push( g.normals[ iVtx ] );
              }

              if ( g.skinIndices !== undefined && g.skinIndices.length > 0 ) {
                g.skinIndices.push( g.skinIndices[ iVtx ] );
              }

              if ( g.skinWeights !== undefined && g.skinWeights.length > 0 ) {
                g.skinWeights.push( g.skinWeights[ iVtx ] );
              }

              // TODO: what about the morph data?

              // Update the face's vertex index.
              face1[ indices[ vtxNo1 ] ] = g.vertices.length - 1;
            }
          }
        }
      }
    };

    window.VAPI = window.VAPI || {};
    window.VAPI.GeometryUtilities = GeometryUtilities;

    return GeometryUtilities;
  } );


define( 'VeroldEngine/Loaders/MultiGeometryLoader',[ 'three'
    , 'VeroldEngine/Loaders/BufferedBinaryLoader'
    , 'VeroldEngine/Loaders/VeroldGeometryLoader'
    , 'VeroldEngine/Util/GeometryUtilities'
  ],
  function( THREE, BufferedBinaryLoader, VeroldGeometryLoader, GeometryUtilities ) {
    // Global download queue for geometry
    var __geometryQueue = [],
        __downloading = 0,
        __maxDownloads = 5,
        __geometryQueueId = null;

    var __processQueue = function() {
      while (__geometryQueue.length > 0 && __downloading < __maxDownloads) {
        (__geometryQueue.shift())();
      }

      if (__geometryQueue.length) {
        __geometryQueueId = setTimeout(__processQueue, 100);
      } else {
        clearTimeout(__geometryQueueId);
        __geometryQueueId = null;  
      }
    };

    var MultiGeometryLoader = function( veroldEngine ) {
      this.veroldEngine = veroldEngine;
      // Weights for download progress.
      this.kDownloadWeight = 0.50;
      this.kNormalWeight   = 0.15;
      this.kTangentWeight  = 0.35;
    };

    MultiGeometryLoader.prototype = {

      constructor: MultiGeometryLoader,

      load: function( path, callback, progress, opt ) {
        var that = this;

        __geometryQueue.push(function() {
          var downloadWeight = 1.0
            , totalSize = 0.0
            , loader;

          __downloading ++;

          var updateDownloadProgress = function( progressObj ) {
            totalSize = progressObj.total;

            progress( {
              "percent": downloadWeight * progressObj.loaded / progressObj.total,
              "total": progressObj.total
            } );
          };

          var updateAttributeProgress = function( progressObj ) {
            progressObj.total = totalSize;
            progress( progressObj );
          };

          var complete = function( geometry ) {

            that._verifyGeometry( geometry, callback, updateAttributeProgress );
          };

          // We support three types of files:
          //  * descriptor.json - buffered geometry
          //  * .js             - modified JSONLoader
          //  * .vgo            - old, custom binary format

          if ( path.match( /descriptor.json$/ ) ) {
            loader = new BufferedBinaryLoader( that.veroldEngine );
            loader.load( path, function( geometry ) {
              __downloading --;
              callback( geometry );
            }, updateDownloadProgress, opt.downloadAll );
          }
          else if ( path.slice( -3 ) === ".js" ) {
            loader = new THREE.JSONLoader();

            downloadWeight = that.kDownloadWeight;

            loader.load( path, function( geometry ) {
              __downloading --;
              complete( geometry );
            }, false, updateDownloadProgress, that.veroldEngine );
          }
          else if ( path.slice( -4 ) === ".vgo" ) {
            loader = new VeroldGeometryLoader( that.veroldEngine );
            loader.loadGeometry( path, function( geometry ) {
              __downloading --;
              complete( geometry );
            }, updateDownloadProgress );
          }
          else {
            __downloading --;
            console.error( "MultiGeometryLoader: Unrecognized mesh file type, \"" + path + "\"" );
            callback( null );
          }
        });
  
        if (!__geometryQueueId) {
          __geometryQueueId = setTimeout(__processQueue, 0);
        }
      },

      _computeMissingVertexAttributes: function( geometry, callback, progress ) {
        var that = this
          , geometryUtils = new GeometryUtilities(this.veroldEngine, geometry );

        // Generate UVs if they don't exist.
        if ( geometry.faceVertexUvs[ 0 ].length === 0 ) {
          console.log( "Generating UV's for the mesh." );
          geometryUtils.computeUVs();
        }

        // Split the mesh along UV seams so that correct tangents are computed.
        geometryUtils.splitUVSeams();

        // Generate vertex normals if they don't exist.
        if ( !geometry.faces[ 0 ].vertexNormals[ 0 ] ) {
          console.log( "Generating normals for the mesh." );
          this._computeVertexNormals( geometry, function( ) {
            if ( !geometry.hasTangents ) {
              console.log( "Generating tangents for the mesh." );
              that._computeTangents( geometry, function( ) {
                callback( geometry );
              }, progress );
            }
          }, progress );
        }
        else if ( !geometry.hasTangents ) {
          console.log( "Generating tangents for the mesh." );
          this._computeTangents( geometry, function( ) {
            callback( geometry );
          }, progress );
        }
        else {
          callback( geometry );
        }
      },

      _computeTangents: function( geometry, callback, progress ) {
        var that = this;

        var updateProgress = function( percent ) {
          var progressObj = { "percent": 0 };

          progressObj.percent += that.kDownloadWeight;
          progressObj.percent += that.kNormalWeight;
          progressObj.percent += that.kTangentWeight * percent;

          progress( progressObj );
        };

        var geometryUtils = new GeometryUtilities(this.veroldEngine, geometry )
          , batchSize = geometry.faces.length / 20;

        batchSize = Math.max( batchSize, 500 );
        batchSize = Math.round( batchSize );

        geometryUtils.computeTangentsAsync( function() {
          callback();
        }, updateProgress, batchSize );
      },

      _computeVertexNormals: function( geometry, callback, progress ) {
        var that = this;

        var updateProgress = function( percent ) {
          var progressObj = { "percent": 0 };

          progressObj.percent += that.kDownloadWeight;
          progressObj.percent += that.kNormalWeight * percent;

          progress( progressObj );
        };

        var geometryUtils = new GeometryUtilities(this.veroldEngine, geometry )
          , batchSize = geometry.faces.length / 20;

        batchSize = Math.max( batchSize, 500 );
        batchSize = Math.round( batchSize );

        geometryUtils.computeVertexNormalsAsync( false, function() {
          callback();
        }, updateProgress, batchSize );
      },

      _verifyGeometry: function( geometry, callback, progress ) {
        if ( geometry && geometry.faces[ 0 ] ) {
          this._computeMissingVertexAttributes( geometry, callback, progress );
        }
        else {
          callback( null );
        }
      },
    };

    window.VAPI = window.VAPI || {};
    window.VAPI.MultiGeometryLoader = MultiGeometryLoader;

    return MultiGeometryLoader;

  } );


/**
 * @module VAPI
 */
define( 'VeroldEngine/Objects/BaseMeshObject',[ 'underscore'
    , 'three'
    , 'VeroldEngine/Loaders/MultiGeometryLoader'
    , 'VeroldEngine/Materials/EngineMaterials'
    , 'VeroldEngine/Objects/VeroldObject'
  ],
  function( _, THREE, MultiGeometryLoader, EngineMaterials, VeroldObject ) {

    /**
     * An object with a mesh and material
     * @class BaseMeshObject
     * @constructor
     */
    var BaseMeshObject = function( ) {
      VeroldObject.call( this );
    };

    BaseMeshObject.prototype = new VeroldObject();

    BaseMeshObject.prototype.events = {
      'setMaterial': { 'scope': 'local', 'action': true, 'category': 'Materials', 'params': [ 
        { 'name': 'material', 'type': 'asset', 'filter': {'material': true } }, 
        { 'name': 'materialIndex', 'type': 'i', 'description': 'Optional - if this mesh contains multiple materials, this is the material number that you want to change.', 'default': 0}] 
      },
      castShadowsEnable: {'params': [], 'action': true, 'category': 'Rendering'},
      castShadowsDisable: {'params': [], 'action': true, 'category': 'Rendering'},
      castShadowsToggle: {'params': [], 'action': true, 'category': 'Rendering'},
      // animateMaterial: {'params': [], 'action': true, 'category': 'Rendering'},
    };

    BaseMeshObject.prototype.initialize = function( properties ) {
      var returnVal = VeroldObject.prototype.initialize.call( this, properties );
      if ( returnVal === false ) {
        return false;
      }
      this.veroldEngine.on( "materialUnloaded", this.onMaterialUnloaded, this );

      this.on('setMaterial', this.setMaterial, this );
      this.on('castShadowsEnable', this.castShadowsEnable, this );
      this.on('castShadowsDisable', this.castShadowsDisable, this );
      this.on('castShadowsToggle', this.castShadowsToggle, this );
      
    };

    BaseMeshObject.prototype.uninitialize = function( properties ) {
      this.veroldEngine.off( "materialUnloaded", this.onMaterialUnloaded, this );
      VeroldObject.prototype.uninitialize.call( this, properties );

      this.off('setMaterial', this.setMaterial, this );
      this.off('castShadowsEnable', this.castShadowsEnable, this );
      this.off('castShadowsDisable', this.castShadowsDisable, this );
      this.off('castShadowsToggle', this.castShadowsToggle, this );
    };

    BaseMeshObject.prototype.unload = function( options ) {
      var srcObject = this.getSourceObject();
      if ( srcObject ) {
        srcObject.off("sourceGeometryChanged", this.onSourceGeometryChanged, this );
      }
      if ( this.threeData ) {
        this.threeData.material = null;
        var parentAsset = this.getParentAsset();
        parentAsset.trigger( "meshUnloaded", this );

        // If the mesh is not an instance, deallocate the geometry data.
        console.log( this.veroldEngine.engineName + " - Deallocating geometry for mesh " + this.entityModel.get( "name" ) );

        if ( !this.isInstance() ) {
          if ( this.threeData.geometry ) {
            this.threeData.geometry.dispose();
          }
        }

        this.threeData.geometry = null;
      }

      VeroldObject.prototype.unload.call( this, options );
    };

    /**
     * return the material attached to the mesh three data
     * @method getMaterial
     * @return {object} The Verold Material object attached to the mesh
     */
    BaseMeshObject.prototype.getMaterial = function() {
      var matId = this.getProperty( "material" );
      if ( _.isArray( matId ) ) {
        var material = [];
        _.each( matId, function( mat ) {
          var matAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( mat );
          if ( !matAsset ) {
            matAsset = this.veroldEngine.assetRegistry.Materials.getMissingMaterial();
          }
          material.push( matAsset );
        }, this );
        return material;
      }
      else if ( this.veroldEngine.assetRegistry.Materials.getAssetById( matId ) ) {
        return this.veroldEngine.assetRegistry.Materials.getAssetById( matId );
      }
      else {
        return this.veroldEngine.assetRegistry.Materials.getMissingMaterial();
      }
    };

    BaseMeshObject.prototype.getDataSizeGeometryDownload = function() {
      var totalSize = this.getProperty( "size" );
      return totalSize ? totalSize : this.getDataSizeGeometryDownloadUncompressed();
    };

    BaseMeshObject.prototype.getDataSizeGeometryInMemory = function() {
      var totalSize = this.getProperty( "size_uncompressed" );
      return totalSize ? totalSize : 0;
    };

    BaseMeshObject.prototype.getDataSizeGeometryDownloadUncompressed = function() {
      var totalSize = this.getProperty( "size_uncompressed" );
      return totalSize ? totalSize : 0;
    };

    BaseMeshObject.prototype.getListOfReferencedGeometries = function() {
      var ref = VeroldObject.prototype.getListOfReferencedGeometries.call( this )
        , geometryId = this.getProperty( "geometryId" );

      if ( geometryId ) {
        var geometryAsset = this.veroldEngine.assetRegistry.Geometries.getAssetById( geometryId );

        if ( geometryAsset ) {
          ref[ geometryId ] = geometryAsset;
        }
      }
      else {
        var mesh = this.getSourceObject();
        if ( !mesh ) {
          mesh = this;
        }

        ref[ mesh.id ] = mesh;
      }

      return ref;
    };

    BaseMeshObject.prototype.getListOfReferencedTextures = function() {
      var ref = VeroldObject.prototype.getListOfReferencedTextures.call( this )
        , mat = this.getProperty( "material" )
        , material, textures;

      if ( _.isArray( mat )) {
        
        _.each( mat, function( matId ) {
          material = this.veroldEngine.assetRegistry.Materials.getAssetById( matId );
          if ( material ) {
            textures = material.getListOfReferencedTextures();
            _.each( textures, function( texAsset, texId ) {
              ref[ texId ] = texAsset;
            }, this );
          }
        }, this );
      }
      else {
        material = this.veroldEngine.assetRegistry.Materials.getAssetById( mat );
        if ( material ) {
          return material.getListOfReferencedTextures();
        }
      }

      return ref;
    };


    //Registers that the parent asset contains a mesh instance loaded from the s
    BaseMeshObject.prototype.registerInitialDependencies = function( type ) {
      VeroldObject.prototype.registerInitialDependencies.call( this, type );
      var parentAsset = this.getParentAsset();
      if ( _.isUndefined( type ) || type === "geometry" ) {
        var geometryId = this.getProperty( "geometryId" );
        if ( !geometryId ) {
          geometryId = this.id;
        }
        parentAsset.registerGeometry( geometryId );
      }
      if ( _.isUndefined( type ) || type === "material" ) {
        var materials = this.getProperty( "material" );
        if ( _.isArray( materials ) ) {
          _.each( materials, function( matId ) {
            parentAsset.registerMaterial( matId );
          }, this );
        }
        else { // single material
          parentAsset.registerMaterial( materials );
        }
      }
    };

    //Unregisters that the parent asset contains a mesh instance loaded from the s
    BaseMeshObject.prototype.unregisterInitialDependencies = function( type ) {
      VeroldObject.prototype.unregisterInitialDependencies.call( this, type );
      var parentAsset = this.getParentAsset();
      if ( _.isUndefined( type ) || type === "geometry" ) {
        var geometryId = this.getProperty( "geometryId" );
        if ( !geometryId ) {
          geometryId = this.id;
        }
        parentAsset.unregisterGeometry( geometryId );
      }
      if ( _.isUndefined( type ) || type === "material" ) {
        var materials = this.getProperty( "material" );
        if ( _.isArray( materials ) ) {
          _.each( materials, function( matId ) {
            parentAsset.unregisterMaterial( matId );
          }, this );
        }
        else { // single material
          parentAsset.unregisterMaterial( materials );
        }
      }
    };

    BaseMeshObject.prototype._loadThreeData = function( json ) {
      var that = this;

      // If this is an instance, load the source and clone it; otherwise,
      // create a new mesh.
      if ( this.isInstance() ) {
        var srcObject = this.getSourceObject();

        this._initPrefabBindings();
        
        srcObject.load( {
          load_base: function( srcObject ) {
            if ( srcObject.type !== that.type ) {
              that.set( { "type": srcObject.type }, { save: true } );
            }

            srcObject.on("sourceGeometryChanged", that.onSourceGeometryChanged, that );
            that.threeData = srcObject.cloneThreeData();

            // If the material is a multi-material, we want it to be recreated
            // for the instance.  We share material pointers but not arrays of
            // pointers.
            if ( that.threeData.material instanceof THREE.MeshFaceMaterial ) {
              that.threeData.material = null;
            }

            var matID = that.getProperty( "material" );
            if ( _.isObject( matID ) && !_.isArray( matID ) ) {
              matID = _.toArray( matID );
            }
            that.applyMaterialChange( matID, that._getMaterialType() );

            that.threeData.veroldEntityId = that.id;
            
            var parentAsset = that.getParentAsset();
            parentAsset.trigger( "meshLoaded", that );

            that.applyPayloadSettings_loaded( json.payload );
            that.trigger( "load_base", that );
          }
        } );
      }
      // Otherwise, we need to create a new mesh from new geometry.
      else {
        this.listenToOnce( this, "load_base", function( object ) {
          // Force material to be considered as changed so that, even if it
          // isn't specified, the mesh will be initialized with a Verold
          // material.
          if ( !json.payload.material ) {
            json.payload.material = true;
          }

          that.applyPayloadSettings_loaded( json.payload );

          //that.veroldEngine.on("update", that.onUpdate_Source, that );
        } );

        this._createThreeMesh();
      }
    };

    BaseMeshObject.prototype.applyPayloadSettings_loaded = function( changes ) {
      var that = this;
      VeroldObject.prototype.applyPayloadSettings_loaded.call( this, changes );

      if ( changes === undefined ) {
        return;
      }

      this.applyMaterialChange( this.getProperty("material"), this._getMaterialType() );

      if ( changes && changes.hasOwnProperty( "customDepthMaterial" ) ) {
        var depthMatId = this.getProperty("customDepthMaterial");
        var depthMatAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( depthMatId );
        if ( depthMatAsset ) {
          depthMatAsset.once( 'load', function() {
            if ( that.veroldEngine.assetRegistry.Materials.materialObjectTypes[ that._getMaterialType() ].skinning === true ) {
              that.threeData.customDepthMaterial = depthMatAsset.threeData.depth_skinned;
            }
            else {
              that.threeData.customDepthMaterial = depthMatAsset.threeData.depth_static;
            }
          });
          depthMatAsset.load();
        }
      }

      if ( changes.hasOwnProperty( "geometry" ) ) {
        if ( _.isObject( this.getProperty("geometry")) ) {
          if ( !this.isInstance() ) {
            that.applyPrimitiveMeshChanges();
            if ( that.threeData.geometry ) {
              that.threeData.geometry.dispose();
            }
          }
        }
      }

      this.trigger( "updated", this );
    };

    BaseMeshObject.prototype.applyPayloadSettings_unloaded = function( changes ) {
      var parentAsset;
      if ( changes && changes.hasOwnProperty( "material" ) ) {
        var prevMaterial = this.getPreviousProperty("material")
          , currentMaterial = this.getProperty("material")
          , matAsset;

        if ( _.isArray( currentMaterial ) ) {
          _.each( currentMaterial, function( matId, index ) {

            matAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( matId );

            if ( matAsset ) {
              parentAsset = this.getParentAsset();

              if ( prevMaterial === undefined ) {
                parentAsset.registerMaterial( matId );
              }
              else if ( prevMaterial[ index ] !== matId ) {
                parentAsset.registerMaterial( matId );
                parentAsset.unregisterMaterial( prevMaterial[ index ] );
              }
            }
          }, this );
        }
        else {
          matAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( currentMaterial );

          if ( matAsset ) {
            parentAsset = this.getParentAsset();

            if ( prevMaterial === undefined ) {
              parentAsset.registerMaterial( currentMaterial );
            }
            else if ( prevMaterial !== currentMaterial ) {
              parentAsset.registerMaterial( currentMaterial );
              parentAsset.unregisterMaterial( prevMaterial );
            }
          }
        }

        this.trigger( "sizeNeedsUpdate", this );
      }
      if ( changes && changes.hasOwnProperty( "customDepthMaterial" ) ) {
        var prevDepthMatId = this.getPreviousProperty("customDepthMaterial");
        var depthMatId = this.getProperty("customDepthMaterial");
        var depthMatAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( depthMatId );
        if ( depthMatAsset ) {
          parentAsset = this.getParentAsset();

          if ( prevDepthMatId === undefined ) {
            parentAsset.registerMaterial( depthMatId );
          }
          else if ( prevDepthMatId !== depthMatId ) {
            parentAsset.registerMaterial( depthMatId );
            parentAsset.unregisterMaterial( prevDepthMatId );
          }
        }
      }
    };

    BaseMeshObject.prototype.applyMaterialChange = function( material, matType ) {
      var depthMatType = null;
      var prevMaterial = this.getPreviousProperty("material");
      if ( this.veroldEngine.assetRegistry.Materials.materialObjectTypes[ matType ].skinning === true ) {
        depthMatType = "depth_skinned";
      }
      else {
        depthMatType = "depth_static";
      }

      if ( this.isInstance() && !material ) {
        material = this.getProperty("material");
      }

      if ( _.isObject( material ) ) {
        
        //For extra safety, force the multi-material to not change in length
        if ( this.threeData.geometry.offsets ) {
          var numMaterials = this.threeData.geometry.offsets[ this.threeData.geometry.offsets.length - 1].materialIndex + 1;
          if ( _.size(material) < numMaterials ) {
            console.warn("Material array has shrunk for mesh, " + this.id + ". It should be " + numMaterials + " but is " + _.size(material) );
            material = material.concat( new Array( numMaterials - _.size(material) ));
          }
        }

        var materials = [];

        if ( !this.threeData.material ) {
          materials = new Array( _.size( material ));
          this.threeData.material = new THREE.MeshFaceMaterial( materials );
        }

        _.each( prevMaterial, function( matId, index ) {
          var materialAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( matId );
          if ( materialAsset ) {
            materialAsset.entityModel.off("change:payload", this.onMaterialSettingsChanged, this );
          }
        }, this );

        _.each( material, function( matId, index ) {
          var materialAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( matId );
          if ( materialAsset ) {
            materialAsset.entityModel.on("change:payload", this.onMaterialSettingsChanged, this );
            materialAsset.load();
            // if ( !this.threeData.material.materials ) {
            //   this.threeData.material.materials = new Array( _.size( material ));
            // }
            this.threeData.material.materials[ index ] = materialAsset.getThreeData()[ matType ];
            // TODO: This is a hack to force only one of the materials to be
            // used for depth rendering (because Three.js doesn't support
            // MeshFaceMaterials in shadows yet).
            var payload = materialAsset.entityModel.get( "payload" );
            if ( payload.alphaBlendMode === 2 ) {
              //this.threeData.customDepthMaterial = materialAsset.getThreeData()[ depthMatType ];
            }
          }
          else {
            this.threeData.material.materials[ index ] = this.veroldEngine.assetRegistry.Materials.getMissingMaterial().threeData[ matType ];
          }
        }, this );
      }
      else {
        var prevMaterialAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( prevMaterial );
        if ( prevMaterialAsset ) {
          prevMaterialAsset.entityModel.off("change:payload", this.onMaterialSettingsChanged, this );
        }
        var materialAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( material );
        if ( materialAsset ) {
          materialAsset.entityModel.on("change:payload", this.onMaterialSettingsChanged, this );
          materialAsset.load();
          this.threeData.material = materialAsset.getThreeData()[ matType ];
          this.threeData.customDepthMaterial = null;
          var payload = materialAsset.entityModel.get( "payload" );
          if ( payload.alphaBlendMode === 2 && payload.diffuseTexture ) {
            this.threeData.customDepthMaterial = materialAsset.getThreeData()[ depthMatType ];
          }
        }
        else {
          this.threeData.material = this.veroldEngine.assetRegistry.Materials.getMissingMaterial().threeData[ matType ];
          this.threeData.customDepthMaterial = null;
        }
      }
    };

    BaseMeshObject.prototype.onMaterialSettingsChanged = function( materialChanges ) {
      if ( materialChanges && this.threeData ) {
        var payloadChanges = materialChanges.changed.payload;
        //Check if the material has been set to use masked transparency
        if ( payloadChanges.alphaBlendMode !== undefined ) {
          if ( payloadChanges.alphaBlendMode === 2 ) {
            var matType = this._getMaterialType();
            var depthMatType = null;
            if ( this.veroldEngine.assetRegistry.Materials.materialObjectTypes[ matType ].skinning === true ) {
              depthMatType = "depth_skinned";
            }
            else {
              depthMatType = "depth_static";
            }
            var materialAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( materialChanges.get("id") );
            this.threeData.customDepthMaterial = materialAsset.getThreeData()[ depthMatType ];
          }
          else {
            this.threeData.customDepthMaterial = null;
          }
        }

      }
    };

    BaseMeshObject.prototype.onSourceGeometryChanged = function( newGeo ) {
      if ( this.threeData ) {
        if ( this.threeData.geometry ) {
          this.threeData.geometry = newGeo;
        }
      }
    };

    BaseMeshObject.prototype.applyPrimitiveMeshChanges = function( geoChanges ) {

      var geoDef = this.getProperty("geometry")
        , newGeo = this._createGeometricPrimitive( geoDef )
        , boundingbox = {};

      newGeo.groupsNeedUpdate = true;
      newGeo.computeBoundingBox();

      boundingbox.min = {
        x: newGeo.boundingBox.min.x,
        y: newGeo.boundingBox.min.y,
        z: newGeo.boundingBox.min.z
      };

      boundingbox.max = {
        x: newGeo.boundingBox.max.x,
        y: newGeo.boundingBox.max.y,
        z: newGeo.boundingBox.max.z
      };

      this.set({ "payload.boundingbox" : boundingbox }, { silent: true });

      if ( newGeo ) {
        this.threeData.geometry = newGeo;
        this.trigger( "sourceGeometryChanged", newGeo );
      }
    };

    BaseMeshObject.prototype._createGeometricPrimitive = function( props, flipSided ) {
      var geometry = null;

      switch ( props.type ) {
        default:
          console.error(
            this.veroldEngine.engineName +
            " - BaseMeshObject: Unrecognized geometry type, \"" +
            props.type +
            "\""
          );
          break;

        case "Box":
        case "Cube":
          {
            var scale = props.scale ?
              props.scale : { "x": 1, "y": 1, "z": 1 };

            geometry = new THREE.BoxGeometry(
              scale.x,
              scale.y,
              scale.z,
              props.segmentsX,
              props.segmentsY,
              props.segmentsZ,
              flipSided
            );
          }
          break;

        case "Cylinder":
          geometry = new THREE.CylinderGeometry(
            props.radiusTop,
            props.radiusBottom,
            props.height,
            props.segmentsRadius,
            props.segmentsHeight,
            props.openEnded
          );
          break;

        case "Plane":
          {
            var uvMult = props.uvMult ? props.uvMult : 1.0
              , xform = new THREE.Matrix4().makeRotationX( -Math.PI / 2 );

            geometry = new THREE.PlaneBufferGeometry(
              props.scale.x,
              props.scale.y,
              props.segmentsX,
              props.segmentsY,
              uvMult
            );

            geometry.applyMatrix( xform );
          }
          break;

        case "Sphere":
          geometry = new THREE.SphereGeometry(
            props.radius,
            props.segments,
            props.rings
          );
        break;

        case "Torus":
          geometry = new THREE.TorusGeometry(
            props.radius,
            props.tube,
            props.segmentsR,
            props.segmentsT,
            props.arc
          );
          break;
      }

      if ( geometry ) {
        geometry.computeTangents();
        geometry.dynamic = true;
      }

      return geometry;
    };

    BaseMeshObject.prototype._createThreeMesh_geometryLoaded = function( geometry ) {
      var obj, name;

      // Create a THREE.Mesh instance if the geometry exists; otherwise,
      // create a THREE.Object instance.
      if ( geometry ) {
        var payload = this.entityModel.get( "payload" );

        if ( !payload.boundingbox ) {
          var boundingbox = {};

          geometry.computeBoundingBox();

          boundingbox.min = {
            x: geometry.boundingBox.min.x,
            y: geometry.boundingBox.min.y,
            z: geometry.boundingBox.min.z
          };

          boundingbox.max = {
            x: geometry.boundingBox.max.x,
            y: geometry.boundingBox.max.y,
            z: geometry.boundingBox.max.z
          };

          this.set({ "payload.boundingbox": boundingbox }, { save: true });
        }
        
        // Only set dynamic here because it affects only the source geometry.
        var dynamic = this.getProperty( "dynamic" );
        geometry.dynamic = dynamic !== undefined ? dynamic : false;
        
        geometry.computeBoundingSphere();
        obj = this._allocateMesh( geometry );
        obj.castShadow = true;
        obj.receiveShadow = true;
        obj.material = null;

        var parentAsset = this.getParentAsset();
        parentAsset.trigger( "meshLoaded", this );
      }
      else {
        console.warn(
          this.veroldEngine.engineName +
          " - The mesh, " + this.id + ", failed to download."
        );

        obj = new THREE.Object3D();
      }

      // Store the Verold ID with the object.
      obj.veroldEntityId = this.id;
      this.threeData = obj;

      // Generate a unique name.
      name = this.entityModel.get( "name" );
      if ( name ) {
        obj.name = name;
      }

      // Notify listeners that the mesh is loaded.
      if ( geometry ) {
        this.trigger( "load_base", this );
      }
      else {
        this.trigger( "load_base_failure", this );
      }
    };

    BaseMeshObject.prototype._createThreeMesh = function( ) {
      if ( this.threeData ) {
        // TODO: cleanup the mesh data?
        console.warn( "TODO: THREE.Mesh is being recreated. Update referencers of this mesh!" );
      }

      var that = this
        , payload = this.entityModel.get( "payload" )
        , geometryJSON = payload._geometry || payload.geometry
        , geometryId = payload.geometryId
        , geometryName = payload.geometryName;

      var complete = function( geometry ) {
        that._createThreeMesh_geometryLoaded( geometry );
      };

      // If the geometry value is a string, we'll interpret it as the path to
      // a file that contains the geometry information.  Otherwise, the
      // geometry object describes a geometric primitive.
      if ( geometryId && geometryName ) {
        var geometryAsset = this.veroldEngine.assetRegistry.Geometries.getAssetById( geometryId );

        if ( geometryAsset ) {
          geometryAsset.load({ load_base: function() {
            var bufferGeometry = geometryAsset.createBufferGeometry( geometryName );

            if ( bufferGeometry ) {
              complete( bufferGeometry );
            }
            else {
              console.warn( that.veroldEngine.engineName + " - BaseMeshObject: Failed to create geometry", geometryId, geometryName );
            }
          } } );
        }
        else {
          console.error( this.veroldEngine.engineName + " - BaseMeshObject: No such geometry asset (" + geometryId + ")");
        }
      }
      else if ( geometryJSON ) {
        if ( _.isString( geometryJSON ) ) {
          var entityPath = this.entityModel.getPath()
            , opt = { "downloadAll": payload.downloadAll === true }
            , loader = new MultiGeometryLoader( this.veroldEngine );

          loader.load( entityPath, complete, function( progressObj ) {
            that._updateLoadingProgress( progressObj );
          }, opt );
        }
        else {
          var geometry = that._createGeometricPrimitive( geometryJSON, payload.flipSided );
          complete( geometry );
        }
      }
      else {
        console.error( this.veroldEngine.engineName + " - BaseMeshObject: No geometry specified for mesh." );
      }
    };

    /**
     * Return the parent model object, if there is one
     * @param  {Object} [object]  the object who's parent we want to get. if null, the object is this
     * @return {VAPI.ModelObject} The model parent object. If none, will return null
     */
    BaseMeshObject.prototype.getParentModel = function( object ) {
      if ( !object ) {
        object = this;
      }

      var parent = object.getParentObject();
      if ( parent ) {
        if ( parent.type === "model" || parent.type === "prefab" ) {
          return parent;
        }
        else {
          return this.getParentModel( parent );
        }
      }
      else {
        return null;
      }
    };

    BaseMeshObject.prototype.onMaterialUnloaded = function( materialID ) {
      var that = this
        , matType = this._getMaterialType();

      function _setMissingMat( index ) {
        var missingMat = that.veroldEngine.assetRegistry.Materials.getMissingMaterial()
          , matID = missingMat.id;

        console.log(
          "Material that is in-use by " + that.id + " has been deleted."
        );

        if ( index !== undefined ) {
          matID = that.getProperty( "material" );
          matID[ index ] = missingMat.id;
        }

        that.applyMaterialChange( matID, matType );
      }

      var matAsset = this.veroldEngine.assetRegistry.Materials.getAssetById( materialID );
      if ( matAsset ) {
        matAsset.entityModel.off("change:payload", this.onMaterialSettingsChanged, this );
      }

      if ( this.threeData && this.threeData.material ) {
        if ( this.threeData.material.materials ) {
          for ( var idx in this.threeData.material.materials ) {
            var matID = this.threeData.material.materials[ idx ].veroldEntityId;
            if ( matID === materialID ) {
              _setMissingMat( idx );
            }
          }
        }
        else if ( this.threeData.material.veroldEntityId === materialID ) {
          _setMissingMat();
        }
      }
    };

    /**
     * Returns true if this mesh has multiple materials assigned.
     * @method isMultiMaterial
     * @return {Boolean} True if this mesh has multiple materials assigned.
     */
    BaseMeshObject.prototype.isMultiMaterial = function() {
      var current = this.getMaterial();
      return _.isArray( current );
    };

    /**
     * Set the given material to be used by this mesh.
     * @method setMaterial
     * @param {String} materialId The Id of the material asset
     * to be used.
     */
    BaseMeshObject.prototype.setMaterial = function( materialId, materialIndex ) {
      if ( !_.isString( materialId ) ) {
        if ( materialId instanceof VAPI.MaterialAsset ) {
          materialId = materialId.id;
        }
        else {
          console.error("BaseMeshObject:setMaterial should be passed a valid Id of a material asset.");
          return;
        }
      }
      var current = this.getProperty("material");
      if ( this.isMultiMaterial() ) {
        var newMaterials = [];
        for ( var i in current ) {
          newMaterials.push( current[i] );
        }
        if ( materialIndex >= 0 ) {
          newMaterials[ materialIndex ] = materialId;
          this.setProperty( "material", newMaterials );
        }
        else {
          for ( var i in current ) {
            newMaterials[i] = materialId;
          }
          this.setProperty( "material", newMaterials );
        }
      }
      else {
        this.setProperty( "material", materialId );
      }
    };

    BaseMeshObject.prototype._updateLoadingProgress = function( progressObj ) {
      this.loadingProgress.geometry = progressObj.percent * progressObj.total;
      this.trigger( "load_progress", this );
    };

    /**
     * Set this mesh to cast shadows.
     * @method castShadowsEnable
     * @param {Object} options Standard options structure containing 'success' and 'failure' callbacks, 'save' boolean, etc.
     */
    BaseMeshObject.prototype.castShadowsEnable = function( options ) {
      this.setProperty( "castShadow", true, options );
      this.veroldEngine.needsRender = true;
    };

    /**
     * Set this mesh to not cast shadows.
     * @method castShadowsDisable
     * @param {Object} options Standard options structure containing 'success' and 'failure' callbacks, 'save' boolean, etc.
     */
    BaseMeshObject.prototype.castShadowsDisable = function( options ) {
      console.log("OFFFFF");
      this.setProperty( "castShadow", false, options );
      this.veroldEngine.needsRender = true;
    };

    /**
     * Toggle the mesh's shadow-casting setting.
     * @method castShadowsToggle
     * @param {Object} options Standard options structure containing 'success' and 'failure' callbacks, 'save' boolean, etc.
     */
    BaseMeshObject.prototype.castShadowsToggle = function( options ) {
      var castShadow = this.getProperty( 'castShadow') ? false : true;
      this.setProperty( "castShadow", castShadow, options );
      this.veroldEngine.needsRender = true;
    };

    window.VAPI = window.VAPI || {};
    window.VAPI.BaseMeshObject = BaseMeshObject;

    return BaseMeshObject;
  } );


define('VeroldEngine/Objects/SkinnedMeshObject',[ 'underscore'
       , 'async'
       , 'three'
       , 'VeroldEngine/Objects/BaseMeshObject'
  ],
  function(_, async, THREE, BaseMeshObject ) {

    var SkinnedMeshObject = function( ) {
      BaseMeshObject.call( this );
    };

    SkinnedMeshObject.prototype = new BaseMeshObject();

    _.extend( SkinnedMeshObject.prototype, {

      initialize: function( properties ) {
        var returnVal = BaseMeshObject.prototype.initialize.call( this, properties );

        if ( returnVal === false ) {
          return false;
        }
      },

      unload: function( options ) {
        BaseMeshObject.prototype.unload.call( this, options );
      },

      applyPayloadSettings_loaded: function( changes, options  ) {
        BaseMeshObject.prototype.applyPayloadSettings_loaded.call( this, changes );
      },

      _allocateMesh: function( geometry ) {
        var useVertexTexture = this.getProperty( "useVertexTexture" ) !== false && this.veroldEngine.getGPUCapability( "MAX_VERTEX_TEXTURE_IMAGE_UNITS" ) > 0 ? true : false;
        var mesh = new THREE.SkinnedMesh(
          geometry,
          undefined, // material
          useVertexTexture       // useVertexTexture
        );
        //TODO - fix skinned mesh bounding boxes so this isn't necessary!
        mesh.frustumCulled = false;

        return mesh;
      },

      _getBindPose: function( geometry, fn ) {
        if ( geometry.bindPose ) {
          return fn( geometry.bindPose );
        }

        var that = this
          , srcObject = this.isInstance() ? this.getSourceObject() : this
          , payload = srcObject.entityModel.get( "payload" )
          , assetRegistry = this.veroldEngine.assetRegistry
          , poseAsset = assetRegistry.Poses.getAssetById( payload.pose );

        if ( !poseAsset ) {
          return fn( null );
        }

        poseAsset.load( {
          load: function( poseAsset ) {
            var parentAsset = srcObject.getParentAsset()
              , parentPayload = parentAsset.entityModel.get( "payload" )
              , version = parentPayload.formatVersion !== undefined ?
                  parentPayload.formatVersion : 4.0
              , bindPose = null;

            if ( poseAsset && poseAsset.threeData ) {
              var poses = poseAsset.threeData;

              if ( version >= 5.0 ) {
                var meshName = that.entityModel.get( "name" );

                for ( var name in poses ) {
                  var pose = poses[ name ];

                  if ( pose.type === "BindPose" && pose.children[ meshName ] ) {
                    return fn( pose.children );
                  }
                }
              }
              else if ( version >= 4.0 && poses.length > 0 ) {
               return fn( poses[ 0 ] );
              }
            }

            return fn( null );
          }
        } );
      },

      _createThreeMesh_geometryLoaded: function( geometry ) {
        geometry.boneNames = geometry.bones;
        geometry.bones = undefined;

        BaseMeshObject.prototype._createThreeMesh_geometryLoaded.call( this, geometry );
      },

      _getMaterialType: function( ) {
        // In the case where animation and bone data was not present at load
        // time, we may have created an instance of THREE.Mesh rather than an
        // instance of THREE.SkinnedMesh.  See _allocateMesh for details.
        if ( this.threeData instanceof THREE.SkinnedMesh ) {
          return "skinned";
        }
        else if ( this.threeData instanceof THREE.Mesh ) {
          return "static";
        }

        return "skinned";
      },

      /**
       * Bind this skinned mesh to the specified object hierarchy.
       * @method bindToHierarchy
       * @param {Object} root The root object of the hierarchy
       * @param {Function} fn Callback function
       */
      bindToHierarchy: function( root, fn ) {
        if ( !root ||
             !this.threeData ||
             !this.threeData.geometry ||
             !this.threeData.geometry.boneNames ) {
          if ( fn ) {
            fn();
          }

          return;
        }

        var objectMap = root.getDecendants()
          , objectIds = Object.keys( objectMap )
          , objectsByName = {}
          , boneNames = this.threeData.geometry.boneNames
          , bones = []
          , that = this;

        // Create a map from object name -> object.
        for ( var iObject = 0; iObject < objectIds.length; ++iObject ) {
          var object = objectMap[ objectIds[ iObject ] ]
            , name = object.entityModel.get( "name" );

          objectsByName[ name ] = object;
        }

        objectsByName[ root.entityModel.get( "name" ) ] = root;

        // Create an array of THREE.js objects (bones) in the same order as
        // boneNames.
        for ( var iBone = 0; iBone < boneNames.length; ++iBone ) {
          var boneName = boneNames[ iBone ]
            , object = objectsByName[ boneName ];

          if ( object ) {
            bones.push( object.threeData );
          }
          else {
            bones.push( null );
          }
        }

        // Apply the bind pose to the objects.
        this._getBindPose( this.threeData.geometry, function( bindPose ) {
          if ( !bindPose ) {
            console.warn( "Failed to get bind pose for " + that.entityModel.get( "name" ) );
            if ( fn ) {
              fn();
            }

            return;
          }

          function getBindMatrix( bindPose, obj ) {
            var xform = new THREE.Matrix4()
              , parentXform = new THREE.Matrix4()
              , position = new THREE.Vector3()
              , quaternion = new THREE.Quaternion()
              , scale = new THREE.Vector3();

            if ( !obj ) {
              return xform;
            }

            pose = bindPose ? bindPose[ obj.name ] : null;

            if ( pose ) {
              position.set(
                pose.position[ 0 ],
                pose.position[ 1 ],
                pose.position[ 2 ] );

              quaternion.set(
                pose.quaternion[ 0 ],
                pose.quaternion[ 1 ],
                pose.quaternion[ 2 ],
                pose.quaternion[ 3 ] );

              scale.set(
                pose.scale[ 0 ],
                pose.scale[ 1 ],
                pose.scale[ 2 ] );

              xform.compose( position, quaternion, scale );
            }
            else {
              xform.compose( obj.position, obj.quaternion, obj.scale );
            }

            parentXform = getBindMatrix( bindPose, obj.parent );
            xform.multiplyMatrices( parentXform, xform );

            return xform;
          }

          var boneInverses = []
            , bindMatrix
            , skeleton;

          for ( var iBone = 0; iBone < boneNames.length; ++iBone ) {
            var invXform = new THREE.Matrix4()
              , xform;

            xform = getBindMatrix( bindPose, bones[ iBone ] );
            invXform.getInverse( xform );
            boneInverses.push( invXform );
          }

          // Get the mesh's bind matrix.
          bindMatrix = getBindMatrix( bindPose, that.threeData );

          skeleton = new THREE.Skeleton( bones, boneInverses, that.threeData.skeleton.useVertexTexture );

          that.threeData.bind( skeleton, bindMatrix );

          if ( fn ) {
            fn();
          }
        } );
      }

    } );

    window.VAPI = window.VAPI || {};
    window.VAPI.SkinnedMeshObject = SkinnedMeshObject;

    return SkinnedMeshObject;
  });

define( 'VeroldEngine/Objects/StaticMeshObject',[ 'underscore' , 'VeroldEngine/Objects/BaseMeshObject'
  ],
  function( _, BaseMeshObject ) {

    var StaticMeshObject = function( ) {
      BaseMeshObject.call( this );
    };

    StaticMeshObject.prototype = new BaseMeshObject();

    _.extend( StaticMeshObject.prototype, {

      _allocateMesh: function( geometry ) {
        return new THREE.Mesh( geometry );
      },

      _getMaterialType: function( ) {
        return "static";
      }

    } );

    window.VAPI = window.VAPI || {};
    window.VAPI.StaticMeshObject = StaticMeshObject;

    return StaticMeshObject;

  } );


/**
 * @module VAPI
 */
define( 'VeroldEngine/Objects/ModelObject',[ 'underscore'
    , 'three'
    , 'async'
    , 'VeroldEngine/Objects/VeroldObject'
  ],
  function( _, THREE, async, VeroldObject ) {

    /**
     * Model object holds animation properties
     * @class ModelObject
     * @mixin Backbone.Events
     * @constructor
     */
    var ModelObject = function( properties ) {
      VeroldObject.call( this );
      this.isBound = false;
    };

    ModelObject.prototype = new VeroldObject();

    _.extend( ModelObject.prototype, {

      initialize: function( properties ) {
        var returnVal = VeroldObject.prototype.initialize.call( this, properties);

        if ( returnVal === false ) {
          return false;
        }

        if ( !this.entityModel.get( "prefabInstanceId" ) ) {
          this.entityModel.set( { "prefabInstanceId" : this.id } );
        }

        return returnVal;
      },

      unload: function( options ) {
        if ( this.animation ) {
          this.animation.stop();
        }

        VeroldObject.prototype.unload.call( this, options );
      },

      _loadThreeData: function( changes, options ) {
        var that = this;

        this.traverse( function( obj ) {
          if ( !obj.entityModel.get( "prefabInstanceId" ) ) {
            obj.entityModel.set( { "prefabInstanceId": this.id } );
          }
        } );

        // this.computeBoundingBox();

        var json = that.entityModel.toJSON();
        VeroldObject.prototype._loadThreeData.call( that, json, options );
    
      },

      applyPayloadSettings_loaded: function( changes, options ) {
        var payload = this.entityModel.get( "payload" )
          , that = this;

        VeroldObject.prototype.applyPayloadSettings_loaded.call( this, changes );

        // Bind child skinned-meshes to the node hierarchy that is rooted at
        // this ModelObject.

        async.series( [ function( callback ) {

          // Load the entire hierarchy.
          if ( that.isBound ) {
            return callback();
          }

          that.load( {
            load_hierarchy: function() {
              that.bindChildMeshes( function() {
                callback();
              } );
            }
          } );

        },
        function( callback ) {

          that.trigger( "updated", that );
          callback();

        } ] );
      },

      /**
       * Bind SkinnedMeshObject children to this model's hierarchy.
       * @method bindChildMeshes
       */
      bindChildMeshes: function( fn ) {
        var skinnedMeshes = []
          , that = this;

        this.traverse( function( obj ) {
          if ( obj.type === "skinned_mesh" ) {
            skinnedMeshes.push( obj );
          }
        } );

        async.forEachSeries( skinnedMeshes, function( obj, next ) {
          obj.bindToHierarchy( that, function() {
            next();
          } );
        },
        function() {
          that.isBound = true;
          fn();
        } );
      }

    } );

    window.VAPI = window.VAPI || {};
    window.VAPI.ModelObject = ModelObject;

    return ModelObject;
  } );

/**
 * @module VAPI
 */
define('VeroldEngine/AssetRegistry/VeroldAsset',[ 'underscore'
       , 'three'
       , 'VeroldEngine/models/entity'
       , 'async'
       , 'VeroldEngine/libs/uuid'
       , 'VeroldEngine/VeroldEntity'
       , 'VeroldEngine/Objects/VeroldObject'
       , 'VeroldEngine/Objects/CameraObject'
       , 'VeroldEngine/Objects/LightObject'
       , 'VeroldEngine/Objects/SkinnedMeshObject'
       , 'VeroldEngine/Objects/StaticMeshObject'
       , 'VeroldEngine/Objects/ModelObject'
  ],
  function(_, THREE, EntityModel, async, uuid, VeroldEntity, VeroldObject, CameraObject, LightObject, SkinnedMeshObject, StaticMeshObject, ModelObject ) {

    //the base class asset
    /**
     * The base class asset
     * @class VeroldAsset
     * @constructor
     */
    var VeroldAsset = function( ) {

      VeroldEntity.call( this );
      this.objects = {};
      this.registry = undefined;
      //By default, components aren't loaded for objects inside of assets.
      this.loadComponents = false;
      this.waitingForEntities = {};
    };

    VeroldAsset.prototype = new VeroldEntity();

    VeroldAsset.prototype.events = {
      'triggerLoad': {'scope': 'local', 'params': [], 'action': true, 'category': 'Loading'},
    };

    VeroldAsset.prototype.initialize = function( properties ) {

      VeroldEntity.prototype.initialize.call( this, properties );

      this.initializeComponents();
      
      this.projectId = properties.projectId;
      
      //this.entityModel.on("sizeNeedsUpdate", this.onSizeNeedsUpdate, this );
      // this.veroldEngine.on("update", this.onUpdate, this );
      if ( !this.entityModel.get("dependencies") ) {
        this.entityModel.set({"dependencies" : { textures: {}, materials: {}, geometries: {}, animations: {} } }, {silent: true});
      }

      // if ( !this.entityModel.get("geometry_dependencies") ) {
      //   this.entityModel.set({"geometry_dependencies" : {} }, {silent: true});
      // }

      //this.entityModel.on( "change:dependencies", this.onDependenciesChanged, this );
      //this.entityModel.on( "change:geometries", this.onGeometriesChanged, this );

      this.entityModel.subEntities.on( "reset", this.onEntityLoadObjects, this );
      this.entityModel.subEntities.on( "add", this.onEntityAddObject, this );
      this.entityModel.subEntities.on( "remove", this.onEntityRemoveObject, this );

      this.on('triggerLoad', this.load, this );

      this._initAssetObjects();
      this.registry = properties.registry;
      if ( this.veroldEngine.state === "initialized" ) {
        this._initDependenciesList();
      }
    };

    VeroldAsset.prototype.uninitialize = function() {

      this.off('triggerLoad', this.load, this );

      //this.entityModel.off("sizeNeedsUpdate", this.onSizeNeedsUpdate, this );
      // this.veroldEngine.off("update", this.onUpdate, this );
      this.entityModel.subEntities.off( "reset", this.onEntityLoadObjects, this );
      this.entityModel.subEntities.off( "add", this.onEntityAddObject, this );
      this.entityModel.subEntities.off( "remove", this.onEntityRemoveObject, this );

      //Uninitialize this asset ( will force unload the asset and its children)
      VeroldEntity.prototype.uninitialize.call( this );

      //Uninitialize all child objects. Most of these will probably already be unloaded
      //but, if not, this will force unload them.
      for ( var x in this.objects ) {
        this.objects[x].uninitialize();
        delete this.objects[x];
      }

    };


    VeroldAsset.prototype._initAssetObjects = function() {

      for ( var x = 0; x < this.entityModel.subEntities.models.length; x++ ) {
        var entityModel = this.entityModel.subEntities.models[x];
        //Some models could already have been added to the collection through the
        //initialization process of the other asset registries. So, if the asset
        //already seems to exist, we'll just skip it.
        if ( !this.objects[ entityModel.get("id") ] ) {
/*
          var newName = this.generateUniqueObjectName( entityModel.get("name") );
          entityModel.set({"name" : newName}, {silent: true});
*/
          this._registerEntityAsObject( entityModel );
        }
      }

      //Implementing a special traverse method that doesn't require the asset to already be
      //registered (the regular traverse method can't be used in this scope yet because getParentAsset
      //will return null)
      function traverse( obj, asset, fn ) {
        var children = obj.entityModel.get("children");
        _.each( children, function( included, id ) {
          if ( included ) {
            var object = asset.getObjectById( id );
            if ( object ) {
              fn( object, obj );
              traverse( object, asset, fn );
            }
          }
        }, this);
      }
      //Sanity check the asset's hierarchy to look for cycles and remove them if they exist
      var objectsVisited = {};
      var that = this;
      traverse( this, this, function( obj, parent ) {
        if ( objectsVisited[ obj.id ] ) {
          console.error("Cycle found in asset hierarchy. Fixing...");
          var parentObj = that.objects[ obj.entityModel.get("parentId") ];
          var changeJSON = {};
          changeJSON[ "children." + obj.id ] = false;
          if ( parentObj !== parent ) {
            parent.set( changeJSON, { silent: true } );
          }
          else {
            objectsVisited[ obj.id ].set( changeJSON, { silent: true } );
          }
        }
        else {
          objectsVisited[ obj.id ] = parent;
        }
      });
    };

    VeroldAsset.prototype._initDependenciesList = function() {
      if ( this.veroldEngine.isPrimaryEngine() && !this.dependenciesListInit ) {
        var children = this.entityModel.get("children");
        _.each( children, function( included, id ) {
          if ( included ) {
            var obj = this.getObjectById( id );
            if ( obj ) {
              obj.registerInitialDependencies();
            }
          }
        }, this );
        this.dependenciesListInit = true;
      }
    };

    /**
     * Returns the total download size of this asset, including all meshes and textures referenced.
     * @method getDataSizeTotalDownload
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeTotalDownload = function() {
      var totalSize = 0;
      totalSize += this.getDataSizeGeometryDownload();
      totalSize += this.getDataSizeTextureDownload();
    };

    /**
     * Returns the total amount of GPU memory occupied by this asset, including all meshes and textures referenced.
     * @method getDataSizeTotalInMemory
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeTotalInMemory = function() {
      var totalSize = 0;
      totalSize += this.getDataSizeGeometryInMemory();
      totalSize += this.getDataSizeTextureInMemory();
    };
    
    /**
     * Returns the total download size of all the meshes referenced by this asset.
     * @method getDataSizeGeometryDownload
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeGeometryDownload = function() {
      var totalSize = 0;
      var geometries = this.entityModel.get("dependencies").geometries;
      _.each( geometries, function( obj, id ) {
        var asset = this.getAssetById( obj.sourceAssetId );
        if ( asset ) {
          var size = 0;
          if ( asset !== this ) {
            size = asset.getDataSizeGeometryDownload( );
          }
          else {
            var srcObj = asset.getObjectById( id );
            size = srcObj.getDataSizeGeometryDownload();
          }
          if ( size ) {
            totalSize += size;
          }
        }
      }, this );
      return totalSize;
    };

    /**
     * Returns the total download size of all the meshes referenced by this asset after
     * being unzipped by the browser.
     * @method getDataSizeGeometryDownloadUncompressed
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeGeometryDownloadUncompressed = function() {
      var totalSize = 0;
      var geometries = this.entityModel.get("dependencies").geometries;
      _.each( geometries, function( obj, id ) {
        var asset = this.getAssetById( obj.sourceAssetId );
        if ( asset ) {
          //var srcObj = asset.getObjectById( id );
          var size = asset.getDataSizeGeometryDownloadUncompressed( );
          if ( size ) {
            totalSize += size;
          }
        }
      }, this );
      return totalSize;
    };

    /**
     * Returns the total amount of GPU memory occupied by all the meshes referenced by this asset.
     * @method getDataSizeGeometryInMemory
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeGeometryInMemory = function() {
      var totalSize = 0;
      var geometries = this.entityModel.get("dependencies").geometries;
      _.each( geometries, function( obj, id ) {
        var asset = this.getAssetById( obj.sourceAssetId );
        if ( asset ) {
          var size = 0;
          if ( asset !== this ) {
            size = asset.getDataSizeGeometryInMemory( );
          }
          else {
            var srcObj = asset.getObjectById( id );
            size = srcObj.getDataSizeGeometryInMemory();
          }
          if ( size ) {
            totalSize += size;
          }
        }
      }, this );
      return totalSize;
    };

    /**
     * Returns the total download size of all the textures referenced by this asset.
     * @method getDataSizeTextureDownload
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeTextureDownload = function() {
      var totalSize = 0;
      var textures = this.entityModel.get("dependencies").textures;
      _.each( textures, function( obj, id ) {
        var asset = this.getAssetById( id );
        var size;
        if ( asset ) {
          size = asset.getDataSizeTextureDownload( );
        }
        if ( size ) {
          totalSize += size;
        }
      }, this );
      return totalSize;
    };

    /**
     * Returns the total download size of all the textures referenced by this asset after
     * being unzipped by the browser.
     * @method getDataSizeTextureDownload_Uncompressed
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeTextureDownload_Uncompressed = function() {
      var totalSize = 0;
      var textures = this.entityModel.get("dependencies").textures;
      _.each( textures, function( obj, id ) {
        var asset = this.getAssetById( id );
        var size;
        if ( asset ) {
          size = asset.getDataSizeTextureDownload_Uncompressed( );
        }
        if ( size ) {
          totalSize += size;
        }
      }, this );
      return totalSize;
    };

    /**
     * Returns the total amount of GPU memory occupied by all the textures referenced by this asset.
     * @method getDataSizeTextureInMemory
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeTextureInMemory = function() {
      var totalSize = 0;
      var textures = this.entityModel.get("dependencies").textures;
      _.each( textures, function( obj, id ) {
        var asset = this.getAssetById( id );
        var size;
        if ( asset ) {
          size = asset.getDataSizeTextureInMemory( );
        }
        if ( size ) {
          totalSize += size;
        }
      }, this );
      return totalSize;
    };

    /**
     * Returns the total size of all the animations referenced by this asset after
     * being unzipped by the browser.
     * @method getDataSizeAnimationInMemory
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeAnimationInMemory = function() {
      var totalSize = 0;
      var animations = this.entityModel.get("dependencies").animations;
      _.each( animations, function( obj, id ) {
        var asset = this.getAssetById( id );
        var size;
        if ( asset ) {
          size = asset.getDataSizeAnimationInMemory( );
        }
        if ( size ) {
          totalSize += size;
        }
      }, this );
      return totalSize;
    };

    /**
     * Returns the total download size of all the animations referenced by this asset.
     * @method getDataSizeAnimationDownload
     * @return {Integer} The number of bytes of data.
     */
    VeroldAsset.prototype.getDataSizeAnimationDownload = function() {
      var totalSize = 0;
      var animations = this.entityModel.get("dependencies").animations;
      _.each( animations, function( obj, id ) {
        var asset = this.getAssetById( id );
        var size;
        if ( asset ) {
          size = asset.getDataSizeAnimationDownload( );
        }
        if ( size ) {
          totalSize += size;
        }
      }, this );
      return totalSize;
    };

    /**
     * Returns the asset with the provided Id, if it exists.
     * @method getAssetById
     * @param  {String} assetId The ID of the asset
     * @return {object} The asset or null if not found.
     */
    VeroldAsset.prototype.getAssetById = function( assetId ) {
      return this.veroldEngine.assetRegistry.getAssetById( assetId );
    };

    /**
     * Returns the first object inside this asset that matches one or more of the
     * provided filters.
     * @method getObject
     * @param  {Object} filters An object with keys to match. Keys can be 'name' or 'type' and
     * can be either single options or arrays of multiple values to match.
     * @return {Object}        The first object that matches the querry
     */
    VeroldAsset.prototype.getObject = function( filters ) {
      for ( var i in this.objects ) {
        if ( this.objects[i].isMatch( filters ) ) {
          return this.objects[i];
        }
      }
      return null;
    };

    /**
     * Returns the object with the provided Id, if it exists in the current asset.
     * @method getObjectById
     * @param  {String} objectID The ID of the object
     * @return {Object} The object or null if not found.
     */
    VeroldAsset.prototype.getObjectById = function( objectID ) {
      
      if ( this.objects[ objectID ] ) {
        return this.objects[ objectID ];
      }
      else if ( objectID === this.id ) {
        return this;
      }

      return null;
    };

    /**
     * Returns the object with the provided name, if it exists in the current asset.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @method getObjectByName
     * @param  {String} objectName The name of the object
     * @return {object} The object, if found, or null if not found.
     */
    VeroldAsset.prototype.getObjectByName = function( objectName ) {
      var results = this.getObjects( { name: objectName } );
      if ( results && results.length ) {
        return results[0];
      }
      else {
        return null;
      }
    };

    /**
     * Returns an array of objects inside this asset that match any of the provided filters.
     * @method getObjects
     * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
     * can be either single options or arrays of multiple values to match.
     * @return {array}        Array of objects that match the querry
     */
    VeroldAsset.prototype.getObjects = function( filters ) {

      if ( _.isObject( filters ) ) {
        var results = [];
        _.each( this.objects, function( object, id ) {
          if ( object.isMatch( filters ) ) {
            results.push( object );
          }
        }, this );
        return results;
      }
      else {
        return this.objects;
      }
    };

    /**
     * Returns a resource that matches the provided filters.
     * @method getResource
     * @param  {object} filters An object with properties to filter by
     * @return {object} a resource that match the filters
     */
    VeroldAsset.prototype.getResource = function (filters) {
      var resources = this.getResources(filters);

      if (resources.length > 0) {
        return resources[0];
      }

      return null;
    };

    /**
     * Returns a resource path that matches the provided filters.
     * @method getResourcePath
     * @param  {object} filters An object with properties to filter by
     * @return {string} A resource path that match the filters
     */
    VeroldAsset.prototype.getResourcePath = function (filters) {
      var resource = this.getResource(filters);

      if (resource) {
        return this.entityModel.getResourcePathPrefix() + resource.path;
      }

      return null;
    };

    /**
     * Returns an array of resource paths that match the provided filters.
     * @method getResourcePaths
     * @param  {object} filters An object with properties to filter by
     * @return {array} Array of resource paths that match the filters
     */
    VeroldAsset.prototype.getResourcePaths = function (filters) {
      var resources = this.getResources(filters);

      return _.map(resources, _.bind(function (resource) {
        return this.entityModel.getResourcePathPrefix() + resource.path;
      }, this));
    };

    /**
     * Returns an array of resources that match the provided filters.
     * @method getResources
     * @param  {object} filters An object with properties to filter by
     * @return {array} Array of resources that match the filters
     */
    VeroldAsset.prototype.getResources = function (filters) {
      return this.entityModel.getResources();
    };

    //Override load_dependencies for assets so that we can track loading progress
    //and bind the load_dependency event to when they're all finished loading
    VeroldAsset.prototype.load_dependencies = function() {
      var that = this;
      //Bind to loading progress of dependencies
      var dependencies = this.entityModel.get("dependencies");
      var texKeys = _.keys( dependencies.textures );
      var animKeys = _.keys( dependencies.animations );
      var dependencyKeys = texKeys.concat( animKeys );
      
      async.forEach( dependencyKeys, function( id, next ) {
        //Get the source object and bind to its progress event.
        var srcAsset = that.getAssetById( id );
        if ( srcAsset ) {
          if (srcAsset.type === "animation" ) {
            srcAsset.on("load_progress", that.onAnimationLoadProgress, that );
          }
          else {
            srcAsset.on("load_progress", that.onTextureLoadProgress, that );
          }
          srcAsset.once("load", function() {
            next();
          }, that );
          srcAsset.load();
        }
        else {
          next();
        }
      }, function() {
        that.trigger("load_dependencies", that );
      });
    };

    //Override load_hierarchy for assets so that we can track loading progress
    VeroldAsset.prototype.load_hierarchy = function( callbacks ) {
      VeroldEntity.prototype.load_hierarchy.call( this, callbacks );
      //Bind to loading progress of dependencies
      var dependencies = this.entityModel.get("dependencies");
      _.each( dependencies.geometries, function( obj, id ) {
        //Get the source object and bind to its progress event.
        var srcAsset = this.getAssetById( obj.sourceAssetId );
        var srcObj = srcAsset.getObjectById( id );
        if ( srcObj ) {
          srcObj.on("load_progress", this.onGeometryLoadProgress, this );
        }
      }, this );
      
    };

    VeroldAsset.prototype.unload = function( options ) {
      //Unbind to loading progress of dependencies
      var dependencies = this.entityModel.get("dependencies");
      _.each( dependencies.geometries, function( obj, id ) {
        //Get the source object and bind to its progress event.
        var srcAsset = this.getAssetById( obj.sourceAssetId );
        if ( srcAsset ) {
          var srcObj = srcAsset.getObjectById( id );
          if ( srcObj ) {
            srcObj.off("load_progress", this.onGeometryLoadProgress, this );
          }
        }
      }, this );
      _.each( dependencies.textures, function( obj, id ) {
        //Get the source object and bind to its progress event.
        var srcAsset = this.getAssetById( id );
        if ( srcAsset ) {
          srcAsset.off("load_progress", this.onTextureLoadProgress, this );
        }
      }, this );

      _.each( dependencies.animations, function( obj, id ) {
        //Get the source object and bind to its progress event.
        var srcAsset = this.getAssetById( id );
        if ( srcAsset ) {
          srcAsset.off("load_progress", this.onAnimationLoadProgress, this );
        }
      }, this );

      VeroldEntity.prototype.unload.call( this, options );

      //Whenever an asset is unloaded, run through it's hierarchy and discard any orphaned objects.
      this.cleanOrphanObjects( {save: true});
    };

    VeroldAsset.prototype.cleanOrphanObjects = function( options ) {
      var allObjects = _.clone( this.objects );
      this.traverse( function( obj ) {
        delete allObjects[ obj.id ];
      });
      if ( !options ) {
        options = {};
      }
      options.nonRecursive = true;
      _.each( allObjects, function( obj, id ) {
        console.log( this.type + " asset has orphaned " + obj.type + ", " + obj.id );
        if ( obj.entityModel.isPersistent ) {
          this.destroyObject( obj.id, options );
        }
      }, this );
    };

    VeroldAsset.prototype.onGeometryLoadProgress = function() {
      this.loadingProgress.geometriesNeedUpdate = true;
    };

    VeroldAsset.prototype.onTextureLoadProgress = function() {
      this.loadingProgress.texturesNeedUpdate = true;
    };

    VeroldAsset.prototype.onAnimationLoadProgress = function() {
      this.loadingProgress.animationsNeedUpdate = true;
    };

    VeroldAsset.prototype.getLoadingProgress = function() {
      var geoSize = this.getDataSizeGeometryInMemory();
      var texSize = this.getDataSizeTextureDownload_Uncompressed();
      var animSize = this.getDataSizeAnimationInMemory();
      var size = texSize + geoSize + animSize;
      if ( size ) {
        return ((this.loadingProgress.geometry ? this.loadingProgress.geometry : 0) + 
          (this.loadingProgress.textures ? this.loadingProgress.textures : 0) +
          (this.loadingProgress.animations ? this.loadingProgress.animations : 0)) / size;
      }
      else {
        return 1;
      }
    };

    VeroldAsset.prototype.getLoadingProgressGeometry = function() {
      //The download progress size reported is the unzipped size which
      //is equal to the in-memory size, not the download size.
      var size = this.getDataSizeGeometryInMemory();
      if ( size ) {
        return (this.loadingProgress.geometry ? this.loadingProgress.geometry : 0) / size;
      }
      else {
        return 1;
      }
    };

    VeroldAsset.prototype.getLoadingProgressTextures = function() {
      var size = this.getDataSizeTextureDownload_Uncompressed();
      if ( size ) {
        return (this.loadingProgress.textures ? this.loadingProgress.textures : 0) / size;
      }
      else {
        return 1;
      }
    };

    VeroldAsset.prototype.getLoadingProgressAnimations = function() {
      var size = this.getDataSizeAnimationInMemory();
      if ( size ) {
        return (this.loadingProgress.animations ? this.loadingProgress.animations : 0) / size;
      }
      else {
        return 1;
      }
    };

    VeroldAsset.prototype.updateGeometryLoadingProgress = function() {
      var totalProgress = 0;
      var dependencies = this.entityModel.get("dependencies");
      _.each( dependencies.geometries, function( obj, id ) {
        //Get the source object and bind to its progress event.
        var srcAsset = this.getAssetById( obj.sourceAssetId );
        if ( srcAsset ) {
          var srcObj = srcAsset.getObjectById( id );
          //obj.current = srcObj.loadingProgress.base;
          if ( srcObj && srcObj.loadingProgress.geometry ) {
            totalProgress += srcObj.loadingProgress.geometry;
          }
        }
      }, this );
      this.loadingProgress.geometry = totalProgress;
    };

    VeroldAsset.prototype.updateTextureLoadingProgress = function() {
      var totalProgress = 0;
      var dependencies = this.entityModel.get("dependencies");
      _.each( dependencies.textures, function( obj, id ) {
        //Get the source object and bind to its progress event.
        var textureAsset = this.getAssetById( id );
        //obj.current = textueAsset.loadingProgress.base;
        if ( textureAsset && textureAsset.loadingProgress.textures ) {
          totalProgress += textureAsset.loadingProgress.textures;
        }
      }, this );
      this.loadingProgress.textures = totalProgress;
    };

    VeroldAsset.prototype.updateAnimationLoadingProgress = function() {
      var totalProgress = 0;
      var dependencies = this.entityModel.get("dependencies");
      _.each( dependencies.animations, function( obj, id ) {
        //Get the source object and bind to its progress event.
        var animationAsset = this.getAssetById( id );
        //obj.current = textueAsset.loadingProgress.base;
        if ( animationAsset && animationAsset.loadingProgress.animations ) {
          totalProgress += animationAsset.loadingProgress.animations;
        }
      }, this );
      this.loadingProgress.animations = totalProgress;
    };

    VeroldAsset.prototype.registerDependency = function( assetId ) {
      var asset = this.veroldEngine.getEntityById( assetId );
      if ( asset ) {
        switch( asset.type ) {
          case 'texture2D':
          case 'renderTexture2D':
          case 'textureCube':
          case 'renderTextureCube':
            this.registerTexture( assetId );
            break;
          case 'material':
            this.registerMaterial( assetId );
            break;
          case 'geometry':
            this.registerGeometry( assetId );
            break;
          case 'animation':
            this.registerAnimation( assetId );
            break;
        }
      }
    };

    //When a new mesh is added to an asset, this method gets called to register that
    //this mesh is a part of the asset. Each unique mesh is added to the list just once
    //so that the list can be used to track loading progress and total data size.
    VeroldAsset.prototype.registerGeometry = function( geometryId ) {
      if ( this.veroldEngine && this.veroldEngine.isPrimaryEngine() ) {
        var geometryAsset = this.veroldEngine.assetRegistry.getAssetById( geometryId )
          , sourceObjId = geometryId
          , sourceAssetId = geometryId;

        // The following supports backwards compatibility with mesh objects
        // being treated as geometry assets.  In the future, if/when mesh
        // objects are migrated to geometry assets, this should be removed.
        if ( !geometryAsset ) {
          var mesh = this.getObjectById( geometryId );

          if ( mesh ) {
            var sourceMesh = mesh.getSourceObject();

            if ( sourceMesh ) {
              sourceObjId = sourceMesh.id;
              sourceAssetId = mesh.getSourceAsset().id;
            }
            else {
              sourceObjId = mesh.id;
              sourceAssetId = this.id;
            }
          }
          else {
            console.warn( this.veroldEngine.engineName + " - VeroldAsset: Failed to register geometry.", geometryId );
            return;
          }
        }
        else {
          geometryAsset.on( 'load_progress', this.onGeometryLoadProgress, this );
        }

        var geometries = this.entityModel.get("dependencies").geometries;
        if ( !geometries[ sourceObjId ] ) {
          geometries[ sourceObjId ] = { count: 1, sourceAssetId: sourceAssetId };
        }
        else {
          geometries[ sourceObjId ].count++;
        }
      }
    };

    //Unregisters a mesh as a dependency of this asset
    VeroldAsset.prototype.unregisterGeometry = function( geometryId ) {
      if ( this.veroldEngine && this.veroldEngine.isPrimaryEngine() ) {
        var geometryAsset = this.veroldEngine.assetRegistry.getAssetById( geometryId )
          , sourceObjId = geometryId
          , sourceAssetId = geometryId;

        // The following supports backwards compatibility with mesh objects
        // being treated as geometry assets.  In the future, if/when mesh
        // objects are migrated to geometry assets, this should be removed.
        if ( !geometryAsset ) {
          var mesh = this.getObjectById( geometryId );

          if ( mesh ) {
            var sourceMesh = mesh.getSourceObject();

            if ( sourceMesh ) {
              sourceObjId = sourceMesh.id;
              sourceAssetId = mesh.getSourceAsset().id;
            }
            else {
              sourceObjId = mesh.id;
              sourceAssetId = this.id;
            }
          }
          else {
            console.warn( this.veroldEngine.engineName + " - VeroldAsset: Failed to register geometry.", geometryId );
            return;
          }
        }

        var geometries = this.entityModel.get("dependencies").geometries;
        if ( geometries[ sourceObjId ] ) {
          geometries[ sourceObjId ].count--;
          if ( geometries[ sourceObjId ].count === 0 ) {
            delete geometries[ sourceObjId ];
          }
        }
      }
    };

    //Registers a material as a dependency of this asset
    VeroldAsset.prototype.registerMaterial = function( materialId ) {
      if ( this.veroldEngine && this.veroldEngine.isPrimaryEngine() && materialId ) {
        var material = this.veroldEngine.assetRegistry.getAssetById( materialId );
        if ( !material ) {
          return;
        }
        var materials = this.entityModel.get("dependencies").materials;
        var that = this;
        if ( !materials[ materialId ] ) {
          materials[ materialId ] = { count: 1 };
          //Bind to texture changes on this material so that we can register or unregister textures as needed.
          materials[ materialId ].onTextureChange = function( newTexId, oldTexId ) {
            //console.log("Texture changes for material, " + materialId + ", registered to " + this.id + ": Texture " + oldTexId + " changed to " + newTexId );
            for ( var j = 0; j < materials[ materialId ].count; j++ ) {
              if ( newTexId ) {
                that.registerTexture( newTexId );
              }
              if ( oldTexId ) {
                that.unregisterTexture( oldTexId );
              }
            }
          };
          
          material.on("textureChange", materials[ materialId ].onTextureChange, this );
        }
        else {
          materials[ materialId ].count++;
        }
        
        //Register all the textures with this asset that are currently registered to the material.
        _.each( material.entityModel.get("dependencies").textures, function( tex, id ) {
          for ( var i = 0; i < tex.count; i++ ) {
            this.registerTexture( id );
          }
        }, this );
      }
    };

    //Unregisters a material as a dependency of this asset
    VeroldAsset.prototype.unregisterMaterial = function( materialId ) {
      if ( this.veroldEngine && this.veroldEngine.isPrimaryEngine() ) {
        var materials = this.entityModel.get("dependencies").materials;
        if ( materials[ materialId ] ) {
          //Decrement the reference count for this material
          materials[ materialId ].count--;
          var material = this.veroldEngine.assetRegistry.getAssetById( materialId );
          if ( !material ) {
            return;
          }
          //If this material is no longer referenced, remove it completely.
          if ( materials[ materialId ].count === 0 ) {
            //Unbind the event callback for texture changes on this material
            material.off("textureChange", materials[ materialId ].onTextureChange, this );
            delete materials[ materialId ];
          }
          //Unregister all the textures attached to this material
          _.each( material.entityModel.get("dependencies").textures, function( tex, id ) {
            for ( var i = 0; i < tex.count; i++ ) {
              this.unregisterTexture( id );
            }
          }, this );
        }
      }
    };

    //Registers a texture as a dependency of this asset
    VeroldAsset.prototype.registerTexture = function( textureId ) {
      var textureAsset = this.getAssetById( textureId );
      if ( this.veroldEngine && this.veroldEngine.isPrimaryEngine() && textureId && textureId !== "null" ) {
        var textures = this.entityModel.get("dependencies").textures;
        if ( !textures[ textureId ] ) {
          textures[ textureId ] = { count: 1 };
        }
        else {
          textures[ textureId ].count++;
        }
        if ( textureAsset ) {
          textureAsset.on( 'load_progress', this.onTextureLoadProgress, this );
        }
        this.trigger( "textureChange", textureId, null );
      }
    };

    //Unregisters a texture as a dependency of this asset
    VeroldAsset.prototype.unregisterTexture = function( textureId ) {
      if ( this.veroldEngine && this.veroldEngine.isPrimaryEngine() ) {
        var textures = this.entityModel.get("dependencies").textures;
        if ( textures[ textureId ] ) {
          textures[ textureId ].count--;
          if ( textures[ textureId ].count === 0 ) {
            delete textures[ textureId ];
          }
          this.trigger( "textureChange", null, textureId );
        }
      }
    };

    //Registers an animation as a dependency of this asset
    VeroldAsset.prototype.registerAnimation = function( animationId ) {
      var animationAsset = this.getAssetById( animationId );
      if ( this.veroldEngine && this.veroldEngine.isPrimaryEngine() && animationId && animationId !== "null" ) {
        var animations = this.entityModel.get("dependencies").animations;
        if ( !animations[ animationId ] ) {
          animations[ animationId ] = { count: 1 };
        }
        else {
          animations[ animationId ].count++;
        }
        if ( animationAsset ) {
          animationAsset.on( 'load_progress', this.onAnimationLoadProgress, this );
        }
      }
    };

    //Unregisters an animation as a dependency of this asset
    VeroldAsset.prototype.unregisterAnimation = function( animationId ) {
      if ( this.veroldEngine && this.veroldEngine.isPrimaryEngine() ) {
        var animations = this.entityModel.get("dependencies").textures;
        if ( animations[ animationId ] ) {
          animations[ animationId ].count--;
          if ( animations[ animationId ].count === 0 ) {
            delete animations[ animationId ];
          }
        }
      }
    };

    // onUpdate = function() {
      
    //   if ( this.loadingProgress.geometriesNeedUpdate ) {
    //     this.updateGeometryLoadingProgress();
    //     this.loadingProgress.geometriesNeedUpdate = false;
    //     this.trigger("load_progress", this );
    //   }
    //   if ( this.loadingProgress.texturesNeedUpdate ) {
    //     this.updateTextureLoadingProgress();
    //     this.loadingProgress.texturesNeedUpdate = false;
    //     this.trigger("load_progress", this );
    //   }
    // },
    VeroldAsset.prototype.whenObjectRegistered = function( objectId, callback ) {
      var obj = this.getObjectById( objectId );
      if ( obj && callback ) {
        callback.call( this, obj );
      }
      else if ( callback ) {
        if ( !this.waitingForEntities[ objectId ] ) {
          this.waitingForEntities[ objectId ] = [];
        }
        this.waitingForEntities[ objectId ].push( callback );
      }
    };

    VeroldAsset.prototype.onEntityLoadObjects = function( models ) {
      for ( var x = 0; x < models.models.length; x++ ) {
        this._registerEntityAsObject( models.models[x] );
      }
    };

    VeroldAsset.prototype.onEntityAddObject = function( model ) {
      //console.log( "Child " + model.get("type") + ", " + model.id + " added to " + this.id + ". Now registering it.");
      model.set( {"parentAssetId" : this.id }, {silent: true});

      this._registerEntityAsObject( model );
      var newObject = this.getObjectById( model.get("id") );
      if ( newObject ) {
        newObject.initializeComponents();
        var callbacks = this.waitingForEntities[ newObject.id ];
        if ( callbacks ) {
          for ( var i = 0; i < callbacks.length; i++ ) {
            callbacks[i].call( this, newObject );
          }
        }
      }
      else {
        console.error("Failed to register object, " + model.id + ": ", model );
      }
      this.trigger( "objectCreated", newObject );

    };

    VeroldAsset.prototype.onEntityRemoveObject = function( model ) {
      this._unregisterEntityAsObject( model );
      this.trigger("objectDeleted", model );
    };

    //After the backbone model has been added to the collection, this function is called
    //to create the object and register it as part of this asset.
    VeroldAsset.prototype._registerEntityAsObject = function( entityModel ) {

      if (!entityModel) {
        console.error( this.veroldEngine.engineName + " - VeroldAsset: Trying to create an object with no backbone model.");
        return;
      }
      var newObject;
      var type = entityModel.get("type");

      if ( type === "camera" ) {
        newObject = new CameraObject();
      }
      else if ( type === "light" ) {
        newObject = new LightObject();
      }
      else if ( type === "mesh" ) {
        newObject = new StaticMeshObject();
      }
      else if ( type === "skinned_mesh" ) {
        newObject = new SkinnedMeshObject();
      }
      else if ( type === "prefab" ) {
        console.error("Trying to add a prefab as an object!!");
        entityModel.set( {"type" : "model"} );
        newObject = new VeroldObject();
      }
      // else if ( type === "primitive" ) {
      //   entityModel.set( {"type" : "mesh"} );
      //   newObject = new StaticMeshObject();
      // }
      else if ( type === "model" ) {
        newObject = new ModelObject();
      }
      else if ( type === "node" ) {
        newObject = new VeroldObject();
      }
      else {
        console.warn("TODO: support for object type, " + type + ", under asset type, " + this.type );
        return;
      }

      //console.log( this.veroldEngine.engineName + " - Registering new " + type + " object, " + entityModel.get("id") + ", as part of " + this.type + " ASSET, " + this.id );

      var returnVal = newObject.initialize( {
        "entityModel": entityModel,
        "veroldEngine": this.veroldEngine,
        "type": type,
      });

      if ( returnVal === false ) {
        console.error("Failed to initialize " + type + " object, " + entityModel.id + ", under " + this.entityModel.get("type") + " asset, " + this.id );
        newObject.uninitialize();
        //entityModel.destroy();
        return;
      }
      this.objects[ newObject.id ] = newObject;
      this.veroldEngine.entities[ newObject.id ] = newObject;
    };

    VeroldAsset.prototype._unregisterEntityAsObject = function( entityModel ) {
      if (!entityModel) console.error( this.veroldEngine.engineName + " - VeroldAsset: unregistering an object with no backbone model.");
      if ( this.objects[ entityModel.id ] ) {
        this.objects[ entityModel.id ].unload( { nonRecursive: true });
        delete this.objects[ entityModel.id ];
      }
    };

    /**
     * Creates a new object and stores it in the asset. Note that this doesn't add the object
     * as a child. You will need to call addChild to do this.
     * @param  {Object} json    Object definition.
     * @param  {Object} options Standard options object (including 'success' and 'failure' callbacks)
     */
    VeroldAsset.prototype.createObject = function( json, options ) {

      var that = this;
      
      function registered( obj ) {

        if ( obj.entityModel.isPersistent && (!options || ( !options.remote && !options.undo ) ) ) {
          that.veroldEngine.globalEvents.trigger( "entityAddedChange", obj.entityModel );
        }
        
        if ( options.success ) {
          options.success( obj );
        }
      }

      if ( !options ) { options = {}; }

      if ( !json.id && !options.persistent ) {
        console.error( this.veroldEngine.engineName + " - VeroldEntity.createObject : You must specify a unique id for non-persistent objects.");
        return;
      }
      else if ( this.objects[ json.id ] && options.persistent ) {
        console.error( this.veroldEngine.engineName + " - VeroldEntity.createObject : Trying to create object with id, " + json.id + ", that already exists.");
        return;
      }
      if ( !json.payload) { json.payload = {}; }
      if ( !json.components) { json.components = {}; }

      if (!json.name) { json.name = ""; }
      //json.name = this.generateUniqueObjectName( json.name );
      json.id = this.generateUniqueObjectID( json.id );
      json.parentAssetId = this.id;

      if ( !json.type ) {console.error( this.veroldEngine.engineName + " - VeroldEntity.createObject : Can't create a new VeroldEntity without specifying a type!");}
      var entityModel = new EntityModel( json );
      entityModel.veroldEngine = this.veroldEngine;
      entityModel.isPersistent = options.persistent || options.alreadyInDatabase ? true : false;
      if ( options.alreadyInDatabase || !entityModel.isPersistent ) {
        this._addEntityObject( entityModel, {
          success: registered,
          failure : options.failure
        } );
      }
      else {
        this._addNewEntityObject( entityModel, {
          success: registered,
          failure : options.failure
        } );
      }
    };

    /**
     * Destroys the asset and causes any instances of the asset to be removed.
     * @param  {Object} options Standard options object.
     */
    VeroldAsset.prototype.destroy = function( options ) {
      this.flaggedForDelete = true;
      this.registry.destroyAsset( this.id, options );
    };

    /**
     * Deletes the object and its hierarchy from this asset.
     * @method destroyObject
     * @param  {String} objectID The ID of the object to destroy
     * @param  {Object} options  The standard options object
     */
    VeroldAsset.prototype.destroyObject = function( objectID, options ) {
      var object = this.objects[ objectID ];
      if ( !object ) {
        console.warn( this.veroldEngine.engineName + " - VeroldAsset.destroyObject : You must specify a valid object ID to destroy.");
        if ( options && options.failure ) {
          options.failure();
        }
        return;
      }
      if ( object.entityModel.isPersistent && (!options || ( !options.remote && !options.undo ) ) ) {
        this.veroldEngine.globalEvents.trigger( "entityRemovedChange", object.entityModel );
      }
      if ( !options ) { options = {}; }
      object.flaggedForDelete = true;
      var entityModel = object.entityModel;
      var children = entityModel.get("children");
      var parent = object.getParentObject();
      var that = this;

      function deleteObject() {

        if ( entityModel.isPersistent && options.save ) {
          var tmuStuff = {};
          if ( window.socket ) {
            tmuStuff.connectionId = window.socket.io.engine.id;
          }
          else {
            tmuStuff.connectionId = null;
          }
          tmuStuff.syncObjects = { stream1: 'sceneUpdates' };
          tmuStuff.parentAssetId = that.id;
          if ( options.nonRecursive ) {
            tmuStuff.beforeSend = function(xhr) {
              xhr.setRequestHeader('X-Verold-Recursive', 'false');
            };
          }
          tmuStuff.success = function() {
            if ( options.success ) {
              options.success();
            }
          };
          entityModel.veroldEngine = undefined;
          entityModel.destroy( tmuStuff );
        }
        else {
          that.entityModel.subEntities.remove( entityModel );
          if ( options.success ) {
            options.success();
          }
        }
      }

      //If we're permanently deleting persistent entities, use server-side recursion.
      if ( entityModel.isPersistent && options.save ) {
        deleteObject();
      }
      else if ( !options.nonRecursive ) {
        
        var childrenKeys = _.keys( children );
        async.forEach( childrenKeys, function( id, next ) {
          if ( children[id] ) {
            that.destroyObject( id, {
              success: next,
              failure: next,
              save: false
            } );
          }
          else {
            next();
          }
        }, function() {
          if ( parent && !parent.flaggedForDelete && parent.getChildren()[object.id] ) {
            parent.removeChild( object, { save: options.save,
              success: function() {
                deleteObject();
              }
            } );
          }
          else {
            deleteObject();
          }
        } );
      }
      else {
        if ( parent && !parent.flaggedForDelete && parent.getChildren()[object.id] ) {
          parent.removeChild( object, { save: options.save,
            success: function() {
              deleteObject();
            }
          } );
        }
        else {
          deleteObject();
        }
      }
    };

    //Clones the asset in the database as well as the threeJS data, if loaded.
    VeroldAsset.prototype.clone = function( options ) {


      if ( !options ) { options = {}; }
      if ( options.persistent ) {
        var that = this;
        var cloneJSON = {};
        if ( window.socket ) {
          cloneJSON.connectionId = window.socket.io.engine.id;
        } else {
          cloneJSON.connectionId = null;
        }

        this.entityModel.getClone( cloneJSON, function( newEntity ) {
          that.veroldEngine.assetRegistry.whenAssetRegistered( newEntity.id, function( newAsset ) {
            var setNameJSON = { "name" : "" };
            if ( options.name !== undefined ) {
              setNameJSON.name = that.veroldEngine.assetRegistry.generateUniqueAssetName( options.name );
            }
            else {
              setNameJSON.name = that.veroldEngine.assetRegistry.generateUniqueAssetName( newAsset.entityModel.get("name") );
            }
            if ( setNameJSON.name !== newAsset.entityModel.get("name") ) {
              newAsset.set( setNameJSON, { save: options.persistent } );
            }
            
            if ( options.success ) { options.success( newAsset ); }
          } );
          
        });

      }
      else {
        console.error("TODO: need to implement cloning of non-persistent assets.");
        //Remember to clone components and link up in-hierarchy ID's properly.
      }

    };

    //Send the new entity model to the database, listen for the response
    //and then add it to the object collection.
    VeroldAsset.prototype._addNewEntityObject = function( entityModel, options ) {
      var that = this;

      var json = entityModel.toJSON();
      delete json.id;
      entityModel.unset("id", {silent : true});
      delete entityModel.id;
      entityModel.set( {"projectId": this.veroldEngine.assetRegistry.entityCollection.project.id }, {silent : true});

      if(window.socket && window.socket.socket) {
        json.connectionId = window.socket.io.engine.id;
        json.parentAssetId = this.id;
      }

      //if ( !this.objectsBeingCreated ) { this.objectsBeingCreated = {} };

      //The save will trigger the new entity to come in through the TMU. When it comes in, we
      //want to be able to match it up to this new entity and check if there is a callback waiting.
      if ( !json.payload ) { json.payload = {} };

      // json.payload.creationId = this._generateUuid;
      // this.objectsBeingCreated[ json.payload.creationId ] = { success : {} };
      // this.objectsBeingCreated[ json.payload.creationId ].success = options.success;

      entityModel.save( json, {wait: true,
        success: function(model, response) {
          console.log( that.veroldEngine.engineName + " - New object saved: ", json);
          that.whenObjectRegistered( model.id, options.success );
        },
        error: function(model, response) {
          if ( options && options.failure ) {
            options.failure( model, response );
          }
        }
      });

    };

    //Add the new entity model to the object collection without sending it to
    //the external datastore. i.e. this is for non-persistent objects or for when
    //the object already exists in the database
    VeroldAsset.prototype._addEntityObject = function( entityModel, options ) {
      this.entityModel.subEntities.add( entityModel );

      if ( options.success ) {
        options.success( this.getObjectById( entityModel.id ));
      }
    },

    VeroldAsset.prototype.onEntityNameChanged = function( model, value ) {
      var changeList = model.changed;

      if ( changeList.name ) {
        this.name = this.veroldEngine.assetRegistry.generateUniqueAssetName( value, this );
        if ( this.threeData && this.threeData.name !== undefined ) {
          this.threeData.name = value;
        }
        //If the name has been changed by generateUniqueAssetName
        if ( this.name !== this.entityModel.get("name")) {
          this.set({ "name" : this.name }, { silent: true });
        }
      }

    };

    //Given an input ID, we'll create a unique one based on it.
    //The resulting ID isn't valid for a persistent object but is
    //intended for temporary ones only.
    VeroldAsset.prototype.generateUniqueObjectID = function( objectID ) {
      var newId;
      /*
       , found;
      var asset;
      
      for ( var i in this.veroldEngine.assetRegistry.assets ) {
        asset = this.veroldEngine.assetRegistry.assets[ i ];
        if ( !asset.objects ) continue;
        if ( asset.objects[ objectID ] ) {
          found = true;
          break;
        }
      }
      */
     
      if ( this.objects[objectID] ) {
        newId = uuid();
      }
      else {
        newId = objectID;
      }

      return newId;
    };

    VeroldAsset.prototype.generateUniqueObjectName = function( assetName ) {
      var newName = assetName;
      var counter = 1;
      var found = false;
      do {
        if ( found ) {
          newName = assetName + "_" + counter++;
        }
        found = false;
        for ( var x in this.objects ) {
          var name = this.objects[x].entityModel.get("name");
          if ( name === newName ) {
            found = true;
            break;
          }
        }

      } while ( found );

      return newName;
    };

    window.VAPI = window.VAPI || {};
    window.VAPI.VeroldAsset = VeroldAsset;

    return VeroldAsset;
  });

define('VeroldEngine/Loaders/GenericLoader',[ 'underscore' ], function(_) {

  var GenericLoader = function(engine) {
    this.veroldEngine = engine;
  };

  GenericLoader.prototype.constructor = GenericLoader;

  GenericLoader.prototype.loadFile = function(url, responseType, fn, progressFn) {
    var that = this
      , xhr = new XMLHttpRequest()
      , progressObj = { total: 0, loaded: 0 }
      , progressId;

    function abortDownload() {
      xhr.abort();
      this.veroldEngine.off("shutdown", abortDownload, that);
      clearTimeout(progressId);

      if (_.isFunction(fn)) {
        fn(new Error("Download aborted"));
      }
    }

    function getContentLength() {
      var sizeStr = xhr.getResponseHeader('x-goog-meta-uncompressed-size')
        , lengthStr = xhr.getResponseHeader('Content-Length')
        , compressionFactor = 2.17
        , length;

      length = parseInt(sizeStr, 10);

      // If the needed header info isn't present, we'll estimate the
      // uncompressed size for the file.
      if (!length) {
        length = parseInt(lengthStr, 10);

        if (responseType !== "arraybuffer") {
          length *= 2.17;
        }

        length = Math.round(length);
      }

      return length;
    }

    function sendProgress() {
      if (_.isFunction(progressFn) && progressObj.total > 0) {
        progressFn(progressObj);
      }

      progressId = setTimeout(sendProgress, 400);
    }

    function updateProgress(event) {
      progressObj.total = getContentLength();
      progressObj.loaded = event.loaded;
    }

    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        // Remove the shutdown listener.
        that.veroldEngine.off("shutdown", abortDownload, that);

        // Stop updating progress.
        xhr.removeEventListener("progress", updateProgress);
        clearTimeout(progressId);

        // Send a final progress event.
        if (_.isFunction(progressFn)) {
          progressObj.total = progressObj.loaded = getContentLength();
          progressFn(progressObj);
        }

        // Check for download errors.
        // Handle status 0 for file:/// URLs (Cordova/iOS, etc)
        if (xhr.status === 0 || (200 <= xhr.status && xhr.status < 300)) {
          var data = xhr.response;

          if (responseType === "json") {
            // try {
              data = JSON.parse(xhr.response);
            // }
            // catch(err) {
            //   data = null;
            // }
          }

          fn(null, data);
        }
        else if (_.isFunction(fn)) {
          fn(new Error("Failed to download file"));
        }
      }
    };

    xhr.onerror = function(err) {
      if (_.isFunction(fn)) { 
        fn(err);
      }

      that.veroldEngine.off("shutdown", abortDownload, that);
      xhr.removeEventListener("progress", updateProgress);
      clearTimeout(progressId);
    };

    xhr.open("GET", url, true);

    xhr.addEventListener("progress", updateProgress, false);
    that.veroldEngine.on("shutdown", abortDownload, this);

    // A responseType of "json" may not be compatible with all browsers.  We
    // handle this case manually, using JSON.parse().
    if (responseType !== "json") {
      xhr.responseType = responseType;
    }

    xhr.send(null);

    sendProgress();
  };

  return GenericLoader;
});


define('VeroldEngine/AssetRegistry/ApplicationAsset',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/VeroldAsset'
       , 'VeroldEngine/Loaders/GenericLoader'
  ],
  function(_, THREE, VeroldAsset, GenericLoader ) {

    var ApplicationAsset = function( ) {
      VeroldAsset.call( this );

    };

    ApplicationAsset.prototype = new VeroldAsset();

    _.extend( ApplicationAsset.prototype, {

      initialize: function( properties ) {
        this.loadComponents = true;
        VeroldAsset.prototype.initialize.call( this, properties );

        var loadStartupScene = this.getProperty("loadStartupScene");
        if ( loadStartupScene === undefined ) {
          this.setProperty("loadStartupScene", null );
        }

        var useVeroldLoader = this.getProperty("useVeroldLoader");
        if ( useVeroldLoader === undefined ) {
          this.setProperty("useVeroldLoader", true );
        }

        var engineName = this.getProperty("engineName");
        if (engineName === undefined) {
          this.setProperty("engineName", "Default");
        }

        var container = this.getProperty("container");
        if (container === undefined) {
          this.setProperty("container", "#verold3d");
        }

        this.trigger( "load_base_and_hierarchy", this );
        this.trigger( "load_base_and_dependencies", this );
        this.trigger( "load_dependencies", this );
        this.trigger( "load_hierarchy", this );
        this.trigger( "load_hierarchy_dependencies", this );

      },

      // uninitialize: function(  ) {
      //   VeroldAsset.prototype.uninitialize.call( this, properties );
      // },

      _loadThreeData: function( changes, options ) {
        this.veroldEngine.setCurrentApp( this.id );
        var scene = this.veroldEngine.assetRegistry.getAssetById( this.getProperty("loadStartupScene") );
        if ( scene ) {
          scene.load();
        }
        this.trigger( "load_base", this );
      },

    });

    window.VAPI = window.VAPI || {};
    window.VAPI.ApplicationAsset = ApplicationAsset;

    return ApplicationAsset;
  });

/**
 * @module VAPI
 */
define('VeroldEngine/AssetRegistry/ApplicationRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/ApplicationAsset'
  ],
  function(_, THREE, ApplicationAsset ) {

    /**
     * All poses are registered and managed here
     * @class ApplicationRegistry
     * @param {Object} [properties] ApplicationRegistry properties
     * @constructor
     */
    var ApplicationRegistry = function( properties ) {
      this.assets = undefined;
    }

    ApplicationRegistry.prototype = {

      constructor: ApplicationRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.veroldEngine = properties.veroldEngine;
        //Check machine capabilities and set
      },

      uninitialize: function(  ) {
        for ( var x in this.assets ) {
          this.assets[x].uninitialize();
          delete this.assets[x];
        }
        this.assets = undefined;
        this.veroldEngine = undefined;
        //this.projectId = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      // _initComponents: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.loadComponents();

      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {
        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) {
          console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model.");
        }

        var newAsset = new ApplicationAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;

        //entityModel.trigger( "registered", this );
      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
      },

      update: function( delta ) {
      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    };

    return ApplicationRegistry;
  });


define('VeroldEngine/AssetRegistry/SceneAsset',[ 'underscore'
       , 'three'
       , 'async'
       , 'VeroldEngine/AssetRegistry/VeroldAsset'
       , 'VeroldEngine/Materials/EngineMaterials'
       //, 'VeroldEngine/LightManager'
       //, 'VeroldEngine/InstanceModelManager'
  ],
  function(_, THREE, async, VeroldAsset, EngineMaterials ) {

    var SceneAsset = function( properties ) {
      VeroldAsset.call( this );
    };

    SceneAsset.prototype = new VeroldAsset();

    SceneAsset.prototype.initialize = function( properties ) {
      this.loadComponents = true;
      VeroldAsset.prototype.initialize.call( this, properties);
      this.veroldEngine.on("materialUnloaded", this.onMaterialUnloaded, this );
      this.veroldEngine.on("prefabDeleted", this.onPrefabDeleted, this );
      this.veroldEngine.on("update", this.onUpdate, this );
      this.on('load', this._sceneLoaded, this );
    };

    SceneAsset.prototype.uninitialize = function( properties ) {
      this.veroldEngine.off("materialUnloaded", this.onMaterialUnloaded, this );
      this.veroldEngine.off("prefabDeleted", this.onPrefabDeleted, this );
      this.veroldEngine.off("update", this.onUpdate, this );
      this.off('load', this._sceneLoaded, this );
      VeroldAsset.prototype.uninitialize.call( this, properties);
    };

    SceneAsset.prototype._sceneLoaded = function() {
      this.veroldEngine.needsRender = true;
    };

    SceneAsset.prototype._initDependenciesList = function() {
      if ( this.veroldEngine.isPrimaryEngine() && !this.dependenciesListInit ) {
        VeroldAsset.prototype._initDependenciesList.call( this );
        var payload = this.entityModel.get("payload");
        var env = payload.environment !== undefined ? payload.environment : {};

        if ( env.groundPlaneMaterial ) {
          this.registerMaterial( env.groundPlaneMaterial );
        }
        else {
          this.registerMaterial( "missingMaterial" );
        }

        payload.fog = payload.fog !== undefined ? payload.fog : { type: "FogExp2" };
      }
    };

    /** 
     * Create an instance of a prefab/model asset and register it inside the scene asset.
     * Note that this function does not add the new instance as a child of anything. This must be
     * done after successful creation of the instance. i.e. Include a 'success' callback in the options
     * structure and then call scene.addChild( instance ).
     * @method createInstanceById
     * @param  {Object} prefabObject
     * @param  {Object} options - Usual options object. Can include a 'success' and 'failure' callback as
     * well as any overrides for the instance (like name, id, etc.).
     * 
     */
    SceneAsset.prototype.createInstanceById = function( prefabId, options ) {
      var prefab = this.getAssetById( prefabId );
      if ( prefab ) {
        this.createInstance( prefab, options );
      }
    };

    /** 
     * Create an instance of a prefab/model asset and register it inside the scene asset.
     * Note that this function does not add the new instance as a child of anything. This must be
     * done after successful creation of the instance. i.e. Include a 'success' callback in the options
     * structure and then call scene.addChild( instance ).
     * @method createInstance
     * @param  {Object} prefabObject
     * @param  {Object} options - Usual options object. Can include a 'success' and 'failure' callback as
     * well as any overrides for the instance (like name, id, etc.).
     * 
     */
    SceneAsset.prototype.createInstance = function( prefab, options ) {

      var instanceJSON = {};
      var prefabObject = prefab;

      if ( !prefabObject ) {
        console.error( this.veroldEngine.engineName + " - Please specify a prefab to create an instance of." );
        return;
      }
      if ( prefabObject.entityModel.isAsset() && prefabObject.type !== "prefab" && prefabObject.type !== "model" ) {
        console.error( this.veroldEngine.engineName + " - You can only create an instance of a prefab asset." );
        return;
      }
      if ( !options ) { options = {}; }
      if ( this === prefabObject ) {
        console.error( this.veroldEngine.engineName + " - Can't create an instance of an object inside itself.", prefabObject);
        return;
      }
      
      var that = this;
      if ( options.persistent && prefabObject.entityModel.isPersistent ) {
        //console.log("Requesting instance of " + prefabObject.id );

        if ( window.socket ) {
          instanceJSON.connectionId = window.socket.io.engine.id;
        } else {
          instanceJSON.connectionId = null;
        }
        instanceJSON.parentAssetId = this.getParentAsset().id;

        prefabObject.entityModel.getInstance( instanceJSON, function( newEntity ) {
          that.whenObjectRegistered( newEntity.id, options.success );
        });
      }
      else {
        if ( !options ) { options = {}; }
        
        var prefabAsset = prefabObject.getParentAsset();
        var newObjID = options.id ? options.id : (prefabObject.entityModel.get("id") + "_instance");
        newObjID = that.generateUniqueObjectID( newObjID );
        var newName = options.name !== undefined ? options.name : prefabObject.entityModel.get("name");
        //Copy the payload components from the prefab
        var newPayload = _.extend( {}, prefabObject.entityModel.get('payload'), options.payload );
        var newComponents = _.extend( {}, prefabObject.entityModel.get('components'), options.components );
        
        //The type of the instance should remain the same except for the top-most (which is a prefab, model or primitive)
        var newType = prefabObject.entityModel.get("type");
        if ( newType === "prefab" || newType === "model" ) {
          newType = prefabObject.entityModel.get('originalType') ? prefabObject.entityModel.get('originalType') : "model";
        }
        
        instanceJSON = {
          id: newObjID,
          name: newName,
          parentAssetId: this.id,
          prefabObjectId: prefabObject.id,
          prefabAssetId: prefabAsset.id,
          sourceObjectId: prefabObject.entityModel.get("sourceObjectId") ? prefabObject.entityModel.get("sourceObjectId") : prefabObject.id,
          sourceAssetId: prefabObject.entityModel.get("sourceAssetId") ? prefabObject.entityModel.get("sourceAssetId") : prefabAsset.id,
          type: newType,
          payload: newPayload,
          components: newComponents
        };

        if ( !options.prefabInstanceId ) {
          options.prefabInstanceId = instanceJSON.id;
        }
        instanceJSON.prefabInstanceId = options.prefabInstanceId;

        //Create an instance of this object
        //console.log("Creating instance model using createObject");
        this.createObject( instanceJSON, { persistent: options.persistent,
          success: function( inst ) {
            var children = prefabObject.entityModel.get("children");
            var childrenToAdd = {};
            for ( var x in children ) {
              if ( children[x] ) {
                childrenToAdd[x] = true;
              }
            }

            if ( !_.isEmpty( children )) {
              var ids = _.keys( children );
              async.forEach( ids, function( id, next ) {
                if ( children[ id ]) {
                  var child = prefabAsset.getObjectById( id );
                  that.createInstance( child, { persistent: options.persistent, prefabInstanceId: options.prefabInstanceId,
                    success: function( childInst ) {
                      
                      inst.addChild( childInst, {save: options.persistent, keepPrefabLinks: true } );
                      next();
                    }
                  });
                }
              }, function() {
                if (options.success) { options.success( inst ); }
              });
              
            }
            else {
              if (options.success) { options.success( inst ); }
            }
          }
        });
      }
    };

    SceneAsset.prototype.onUpdate = function() {
      
      if ( this.loadingProgress.geometriesNeedUpdate ) {
        this.updateGeometryLoadingProgress();
        this.loadingProgress.geometriesNeedUpdate = false;
        this.trigger("load_progress", this );
      }
      if ( this.loadingProgress.texturesNeedUpdate ) {
        this.updateTextureLoadingProgress();
        this.loadingProgress.texturesNeedUpdate = false;
        this.trigger("load_progress", this );
      }
      if ( this.loadingProgress.animationsNeedUpdate ) {
        this.updateAnimationLoadingProgress();
        this.loadingProgress.animationsNeedUpdate = false;
        this.trigger("load_progress", this );
      }
    };

    SceneAsset.prototype.getDataSizeGeometryDownload = function() {
      var totalSize = 0;
      totalSize = VeroldAsset.prototype.getDataSizeGeometryDownload.call( this );
      //totalSize = ground download size which is 0
      return totalSize;
    };

    SceneAsset.prototype.getDataSizeGeometryInMemory = function() {
      var totalSize = 0;
      totalSize = VeroldAsset.prototype.getDataSizeGeometryInMemory.call( this );
      //totalSize = ground plane size in memory
      return totalSize;
    };

    SceneAsset.prototype._loadThreeData = function( changes ) {

      this.threeData = new THREE.Scene();
      this.threeData.childIDs = {};
      this.threeData.veroldEntityId = this.id;
      this.threeData.name = this.entityModel.get("name");
      var payload = this.entityModel.get("payload");
      if ( !payload.environment ) {
        payload.environment = { };
        changes.payload.environment = {};
      }
      if ( !payload.fog ) {
        payload.fog = { type: "FogExp2" };
        changes.payload.fog = {};
      }
      var env = payload.environment;

      //Fill in default values, if not yet set.
      for ( var x in this.registry.defaultEnvironment ) {
        if ( env[x] === undefined ) {
          changes.payload.environment[x] = true;
          env[x] = this.registry.defaultEnvironment[x];
        }
      }

      this.applyPayloadSettings_loaded( changes.payload );
      this.trigger("load_base", this);

      var scenePass = new THREE.RenderPass();
      scenePass.clear = false;
      if ( this.veroldEngine.getBaseRenderer().addRenderPass ) {
        this.veroldEngine.getBaseRenderer().addRenderPass( scenePass );
      }
    };

    SceneAsset.prototype.applyPayloadSettings_loaded = function( changes ) {

      if ( changes.fog ) {
        //Fog Setup
        this.applyFogSettings( changes.fog );
      }
      if ( changes.environment ) {
        //Environment Setup
        this.applyEnvironmentSettings( changes.environment );
        this.trigger("updated", this);
      }

    };

    SceneAsset.prototype.applyEnvironmentSettings = function( changes ) {
      if ( this.threeData ) {
        var environmentJSON = this.entityModel.get("payload").environment;
        var that = this;

        if ( !this.threeData.ground ) { //|| changes.groundPlaneTesselation || changes.groundPlaneMaterialScale ) {
          var uvMult;
          var tesselation;

          //If the ground plane already exists, we must be updating something that requires recreating the ground geometry.
          if ( this.threeData.ground ) {
            this.threeData.remove( this.threeData.ground );
            this.threeData.ground.dispose();
            // var sceneAsset = this.veroldEngine.assetRegistry.Scenes.assets[ this.threeData.veroldEntityId ];
            // var fullEnvJSON = sceneAsset.entityModel.get("payload").environment;
            // environmentJSON.groundPlaneMaterialScale = changes.groundPlaneMaterialScale ? environmentJSON.groundPlaneMaterialScale : fullEnvJSON.groundPlaneMaterialScale;
            // environmentJSON.groundPlaneTesselation = changes.groundPlaneTesselation ? environmentJSON.groundPlaneTesselation : fullEnvJSON.groundPlaneTesselation;
          }

          // var tesselation = changes.groundPlaneTesselation ? environmentJSON.groundPlaneTesselation : this.registry.defaultEnvironment.groundPlaneTesselation;
          environmentJSON.groundPlaneMaterialScale = environmentJSON.groundPlaneMaterialScale !== undefined ? environmentJSON.groundPlaneMaterialScale : 40;
          //TODO DisablingTesselation
          var planeGeo = new THREE.PlaneBufferGeometry( 1.0, 1.0, 40, 40, environmentJSON.groundPlaneMaterialScale, -0.5 );
          // planeGeo.addWireframeAttribute();
          //var planeGeo = new THREE.BoxGeometry( 1.0, 1.0, 1.0, 1, 1, 1 );
          planeGeo.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
          planeGeo.computeTangents();
          planeGeo.dynamic = false;
          //planeGeo.computeBoundingSphere();
          this.threeData.ground = new THREE.Mesh( planeGeo );
          this.threeData.ground.frustumCulled = false;
          this.threeData.ground.material = null;
          this.threeData.ground.castShadow = false;
          this.threeData.ground.receiveShadow = true;
          this.threeData.ground.name = "Ground";
          //this.threeData.ground.position.y = -0.5;
          this.threeData.add( this.threeData.ground );
          this.applyGroundSettings( changes );
        }
        else if ( this.threeData.ground ) {
          this.applyGroundSettings( changes );
        }
      }
    };

    SceneAsset.prototype.applyFogSettings = function( changes ) {
      if (this.threeData) {
        var fogJSON = this.entityModel.get("payload").fog;
        if (!this.threeData.fog || changes.type ) {

          if ( fogJSON.type === "FogExp2" ) {
            this.threeData.fog = new THREE.FogExp2(  this.registry.defaultFog.color,  this.registry.defaultFog.density  );
          }
          else {
            console.log( this.veroldEngine.engineName + " - SceneAsset.applyFogSettings: Invalid fog type, " + fogJSON.type + ", in scene!");
          }
        }

        if ( changes.color !== undefined ) {
          this.threeData.fog.color.setHex( fogJSON.color );

        }
        if ( changes.density !== undefined ) {
          this.threeData.fog.density = fogJSON.density;
        }
      }
    };

    SceneAsset.prototype.applyGroundSettings = function( changes ) {
      if ( this.threeData.ground && changes ) {
        //console.log("Applying ground settings ", changes);
        var that = this;
        var environmentJSON = this.entityModel.get("payload").environment;

        if ( changes.groundPlaneOn !== undefined ) {
          this.threeData.ground.visible = environmentJSON.groundPlaneOn;
        }
        if ( changes.groundPlaneScale !== undefined ) {
          this.threeData.ground.scale.set( environmentJSON.groundPlaneScale, 1.0, environmentJSON.groundPlaneScale );
        }

        if ( changes.groundPlaneMaterial !== undefined ) {

          //Until a material is loaded, we'll hide the ground plane.
          var visability = that.threeData.ground.visible;
          that.threeData.ground.visible = false;
          var groundMat = this.veroldEngine.assetRegistry.Materials.getAssetById( environmentJSON.groundPlaneMaterial );
          if ( !groundMat ) {
            groundMat = that.veroldEngine.assetRegistry.Materials.getMissingMaterial();
          }
          var prevPayload = this.entityModel.previous("payload");
          // if ( !prevPayload || (prevPayload.environment && prevPayload.environment.groundPlaneMaterial !== groundMat.id )) {
          //   this.registerDependency( groundMat.id );
          // }
          this.registerMaterial( groundMat.id );
          if ( prevPayload && prevPayload.environment ) {
            this.unregisterMaterial( prevPayload.environment.groundPlaneMaterial );
          }

          groundMat.listenToOnce( groundMat, "load_base", function onLoad( material ) {
            that.threeData.ground.material = material.threeData.static;
            that.threeData.ground.visible = visability;
          });

          groundMat.load();
        }

        /*if ( environmentJSON.groundPlaneTesselation !== undefined ) {
          var maxEdgeLength = 1.0 / environmentJSON.groundPlaneTesselation;
          THREE.GeometryUtils.tessellate(this.threeData.ground.geometry, environmentJSON.groundPlaneTesselation);
        }*/
      }
      else {
        console.error("Can't set ground properties when no ground exists.");
      }
    };

    SceneAsset.prototype.unload = function( options ) {
      if ( this.threeData ) {
        console.log( this.veroldEngine.engineName + " - Unloading scene, " + this.entityModel.get("name"));

        if ( this.threeData && this.threeData.ground ) {
          this.threeData.remove( this.threeData.ground );
          this.threeData.ground.geometry.dispose();
          this.threeData.ground.geometry = null;
          this.threeData.ground = null;
        }

        VeroldAsset.prototype.unload.call( this, options );
      }
    };

    SceneAsset.prototype.onMaterialUnloaded = function( materialID ) {
      if ( this.threeData ) {
        if ( this.threeData.ground && this.threeData.ground.material.veroldEntityId === materialID ) {
          var that = this;
          console.log("Material that is in-use by ground plane has been deleted");
          if ( this.veroldEngine.state !== "uninitializing") {
            var material = this.veroldEngine.assetRegistry.Materials.getMissingMaterial();
            material.load( {
              load_base: function() {
                that.threeData.ground.material = material.threeData["static"];
              }
            });
          }
        }
      }
    };

    SceneAsset.prototype.onPrefabDeleted = function( modelID ) {
      if ( this.threeData ) {
        var changeMade = false;
        var objectsToRemove = {};
        _.each( this.objects, function( obj, id ) {
          if ( obj ) {
            var sourceObjectId = obj.entityModel.get("sourceObjectId");
            var prefabObjectId = obj.entityModel.get("prefabObjectId");
            if ( sourceObjectId === modelID || prefabObjectId === modelID ) {
              objectsToRemove[id] = true;
              changeMade = true;
            }
          }
        }, this);
        if ( changeMade ) {
          _.each( objectsToRemove, function( remove, id ) {
            var obj = this.getObjectById( id );
            if ( obj && obj.getParentObject() ) {
              obj.getParentObject().removeChildById( id, { save: false });
            }
          }, this );

          _.each( objectsToRemove, function( remove, id ) {
            this.destroyObject( id, { save: true } );
          }, this );

          this.save();
        }
      }
    };

    window.VAPI = window.VAPI || {};
    window.VAPI.SceneAsset = SceneAsset;

    return SceneAsset;
  });

define('VeroldEngine/AssetRegistry/SceneRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/SceneAsset'
       //, 'VeroldEngine/CameraManager'
       //, 'VeroldEngine/LightManager'
       //, 'VeroldEngine/InstanceModelManager'
  ],
  function(_, THREE, SceneAsset ) {

    var SceneRegistry = function( properties ) {
      this.assets = undefined;

      this.defaultEnvironment = {
        groundPlaneOn: true,
        groundPlaneTesselation: 120,
        groundPlaneMaterial: null,
        groundPlaneScale: 250,
      };

      this.defaultFog = {
        type : "FogExp2",
        color : 0xbbbbbb,
        density : 0.0008
      };
    };

    SceneRegistry.prototype = {

      constructor: SceneRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.veroldEngine = properties.veroldEngine;

      },
      uninitialize: function() {

        for ( var x in this.assets ) {
          this.assets[x].uninitialize();
          delete this.assets[x];
        }

        this.assets = undefined;
        this.veroldEngine = undefined;
        this.projectId = undefined;
      },

      initSystemAssets: function() {
        // for ( var tex in this.environmentTextures ) {
        //   if ( this.veroldEngine.isPrimaryEngine() ) {
        //     this.veroldEngine.assetRegistry.createAsset( this.environmentTextures[tex] );
        //   }
        // }
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      // _initComponents: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.loadComponents();

      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      /**
       * Return all assets inside this registry.
       * @method getAllAssets
       * @return {Array} An array of all assets in this registry.
       */
      // getAllAssets: function( ) {
      //   return this.assets;
      // },

      //Returns the asset specified. null if invalid
      //options
        //autoLoad - boolean that's set to true to make this call automatically load the asset's data
        //success - callback on successful load of the data. Not valid if autoLoad is false
        //failure - callback on failure while loading the data. Not valid if autoLoad is false
        //progress - callback on loading progress. Not valid if autoLoad is false
      // getAsset: function( assetID, options ) {
      //   return this.veroldEngine.assetRegistry.getAsset( assetID, options );
      // },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {
        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model.");

        var newAsset = new SceneAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;

      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
      },

      update: function( delta ) {

      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },
    };

    return SceneRegistry;
  });

define('VeroldEngine/AssetRegistry/PrefabAsset',[ 'underscore'
       , 'async'
       , 'three'
       , 'VeroldEngine/AssetRegistry/VeroldAsset'

  ],
  function(_, async, THREE, VeroldAsset ) {

    var PrefabAsset = function( properties ) {
      VeroldAsset.call( this );
    };

    PrefabAsset.prototype = new VeroldAsset();

    // _.extend( PrefabAsset.prototype, {

    PrefabAsset.prototype.initialize = function( properties ) {
        VeroldAsset.prototype.initialize.call( this, properties);
        var json = this.entityModel.toJSON();
        var payload = {};
        if ( !json.payload ) { json.payload = {}; }
        if ( !json.payload.orientation ) { payload.orientation = this.registry.defaultPrefab.orientation; }
        if ( !json.payload.position ) { payload.position = this.registry.defaultPrefab.position; }
        if ( !json.payload.scale ) { payload.scale = this.registry.defaultPrefab.scale; }
        payload.castShadow = json.payload.castShadow !== undefined ?  json.payload.castShadow : false;
        payload.receiveShadow = json.payload.receiveShadow !== undefined ?  json.payload.receiveShadow : false;
        payload.opacity = json.payload.opacity !== undefined ?  json.payload.opacity : 1.0;
        payload.selectable = json.payload.selectable !== undefined ?  json.payload.selectable : true;
        this.set({payload: payload}, { save: false});
        this.veroldEngine.on("prefabDeleted", this.onPrefabDeleted, this );
        this.veroldEngine.on("update", this.onUpdate, this );
      };

      PrefabAsset.prototype.uninitialize = function( ) {
        this.veroldEngine.off("prefabDeleted", this.onPrefabDeleted, this );
        this.veroldEngine.off("update", this.onUpdate, this );
        VeroldAsset.prototype.uninitialize.call( this );
      };

      PrefabAsset.prototype.onUpdate = function() {
        
        if ( this.loadingProgress.geometriesNeedUpdate ) {
          this.updateGeometryLoadingProgress();
          this.loadingProgress.geometriesNeedUpdate = false;
          this.trigger("load_progress", this );
        }
        if ( this.loadingProgress.texturesNeedUpdate ) {
          this.updateTextureLoadingProgress();
          this.loadingProgress.texturesNeedUpdate = false;
          this.trigger("load_progress", this );
        }
        if ( this.loadingProgress.animationsNeedUpdate ) {
          this.updateAnimationLoadingProgress();
          this.loadingProgress.animationsNeedUpdate = false;
          this.trigger("load_progress", this );
        }
      };

      //If the source asset for an object inside this prefab was deleted, remove the object
      PrefabAsset.prototype.onPrefabDeleted = function( modelID ) {
        if ( modelID && modelID !== this.id && this.threeData ) {
          var changeMade = false;
          var objectsToRemove = {};
          _.each( this.objects, function( obj, id ) {
            if ( obj ) {
              var sourceObjectId = obj.entityModel.get("sourceObjectId");
              var prefabObjectId = obj.entityModel.get("prefabObjectId");
              if ( sourceObjectId === modelID || prefabObjectId === modelID ) {
                objectsToRemove[id] = true;
                changeMade = true;
              }
            }
          }, this);
          if ( changeMade ) {
            _.each( objectsToRemove, function( remove, id ) {
              var obj = this.getObjectById( id );
              if ( obj && obj.getParentObject() ) {
                obj.getParentObject().removeChildById( id, { save: false });
              }
            }, this );

            _.each( objectsToRemove, function( remove, id ) {
              this.destroyObject( id, { save: true } );
            }, this );

            this.save();
          }
        }
      };

      PrefabAsset.prototype.applyPayloadSettings_loaded = function( changes, options ) {

        if ( !options ) { options = {}; }


        this.trigger("updated", this);

      };

      PrefabAsset.prototype.linkupPrefab = function( instObj, prefabObj, options ) {
        var that = this;
        if ( instObj && prefabObj ) {
          var changes = {"prefabObjectId" : prefabObj.id, "prefabAssetId" : this.id };
          if ( !instObj.entityModel.get("sourceObjectId") ) {
            changes.sourceObjectId = prefabObj.id;
            changes.sourceAssetId = this.id;
          }
          if ( options.prefabInstanceId ) {
            changes.prefabInstanceId = options.prefabInstanceId;
          }

          instObj._uninitPrefabBindings();

          instObj.set( changes, { silent: true, save: false });

          instObj._initPrefabBindings();

          //Reverting to prefab will handle erasing extra values that should be inherited from prefab
          instObj.revertToPrefab( { save: options.save, nonRecursive: true, 
            success: function() {
              var prefabChildren = prefabObj.entityModel.get("children");
              var instanceChildren = instObj.entityModel.get("children");
              
              var ids = _.keys( prefabChildren );
              var instIds = _.keys( instanceChildren );
              var index = 0;
              async.forEach( ids, function( id, next ) {
                if ( prefabChildren[ id ] ) {
                  var instChild = instObj.getParentAsset().getObjectById( instIds[ index ] );
                  var prefabChild = prefabObj.getParentAsset().getObjectById( id );
                  index++;
                  
                  that.linkupPrefab( instChild, prefabChild, {
                    save: options.save,
                    success: function() {
                      next();
                    },
                    prefabInstanceId: options.prefabInstanceId
                  });
                }
                else {
                  next();
                }
              }, function() {
                if ( options && options.success ) {
                  options.success();
                }
              });
            }
          });
        }
      };

    // });

    window.VAPI = window.VAPI || {};
    window.VAPI.PrefabAsset = PrefabAsset;

    return PrefabAsset;
  });

define('VeroldEngine/AssetRegistry/ModelAsset',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/PrefabAsset'

  ],
  function(_, THREE, PrefabAsset ) {

    var ModelAsset = function( properties ) {
      PrefabAsset.call( this );
    };

    ModelAsset.prototype = new PrefabAsset();

    _.extend( ModelAsset.prototype, {

      applyPayloadSettings_loaded: function( changes, options ) {

        if ( !options ) { options = {}; }

        this.trigger("updated", this);

      },

      update: function() {

      },

    });

    window.VAPI = window.VAPI || {};
    window.VAPI.ModelAsset = ModelAsset;

    return ModelAsset;
  });

define('VeroldEngine/AssetRegistry/PrefabRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/PrefabAsset'
       , 'VeroldEngine/AssetRegistry/ModelAsset'

  ],
  function(_, THREE, PrefabAsset, ModelAsset ) {

    var PrefabRegistry = function( properties ) {
      this.assets = undefined;
      this.defaultPrefab = {
        name : "Prefab_With_No_Name",
        position : { x : 0, y : 0, z : 0 },
        orientation : { x : 0, y : 0, z : 0, w : 1 },
        scale : { x : 1, y : 1, z : 1 },
        castShadow : false,
        receiveShadow : false,
        opacity : 1.0,
        visible : true,
        selectable : true,

      };
      this.builtInPrefabs = {
        "ReflectionCapturePlane" : {
          id: "reflection_capture_plane_prefab",
          type: "prefab",
          name: "reflection_capture_plane_prefab",
          components: {
            "reflection_capture" : {
              scriptId: "reflection_capture_planar",
              componentData: {},
              enabled: true
            }
          }
        },
        "CubeMapCapture": {
          id: "cubemap_capture_prefab",
          "type": 'prefab',
          name: 'cubemap_capture_prefab',
          components: {
            cubemap_capture: {
              scriptId: 'cubemap_capture',
              componentData: {},
              enabled: true
            }
          }
        },
        "SphereMapCapture": {
          id: "spheremap_capture_prefab",
          "type": 'prefab',
          name: 'spheremap_capture_prefab',
          components: {
            spheremap_capture: {
              scriptId: 'spheremap_capture',
              componentData: {},
              enabled: true
            }
          }
        },
        "Curve" : {
          id: "curve_prefab",
          type: "prefab",
          name: "curve_prefab",
          components: {
            "curve" : {
              scriptId: "curve_component",
              componentData: {},
              enabled: true
            }
          }
        },
        "Annotation" : {
          id : "annotation_prefab",
          type : "prefab",
          name : "annotation_prefab",
          components : {
            "annotation" : {
              scriptId : "annotation_component",
              componentData : {
                Title : "Annotation Title",
                Description : "A description for your annotation"
              },
              enabled : true
            }
          }
        }
      }
      this.meshRegistry = {};
    };

    PrefabRegistry.prototype = {

      constructor: PrefabRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.veroldEngine = properties.veroldEngine;

      },

      uninitialize: function() {

        for ( var x in this.assets ) {
          this.assets[x].uninitialize();
          delete this.assets[x];
        }

        this.assets = undefined;
        this.veroldEngine = undefined;
      },

      initSystemAssets: function() {
        if ( this.veroldEngine.isPrimaryEngine() ) {
          _.each( this.builtInPrefabs, function( prefabJSON ) {
            this.createAsset( prefabJSON, {
              success: function( model ) {
                //model.createObject( CubeMeshJSON );
              }
            } );
          }, this );
        }
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {

        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model.");

        var newAsset;
        if ( entityModel.get("type") === "prefab" ) {
          newAsset = new PrefabAsset();
        }
        else if ( entityModel.get("type") === "model" ) {
          newAsset = new ModelAsset();
        }
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;
      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.trigger("prefabDeleted", assetID );
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
      },

      update: function( delta ) {

      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

      requestNewRegNumber: function() {
        if ( !this.meshRegNum ) {
          this.meshRegNum = 1;
        }
        else {
          this.meshRegNum++;
        }
        return this.meshRegNum;
      },

      createPrefab  : function( object, options ) {
        if (!options) {
          options = {};
        }
        var that = this;
        var save = options && options.save ? true : false;
        this.veroldEngine.assetRegistry.createAsset( {
          type: "prefab",
          name: "New Prefab",
          id: options.id ? options.id : "new_prefab",
          parentFolderId: options.parentFolderId ? options.parentFolderId : undefined,
          originalType: object.type
        }, {
          persistent: options.persistent !== undefined ? options.persistent : false,
          success: function( prefab ) {

            object.copyTo( prefab.id, {
              persistent: options.persistent !== undefined ? options.persistent : false,
              success: function( copy ) {
                prefab.set( {
                  "name" : copy.entityModel.get("name"),
                  "payload" : copy.entityModel.get("payload"),
                  "components" : copy.entityModel.get("components"),
                  "children" : copy.entityModel.get("children"),
                  "sourceObjectId" : copy.entityModel.get("sourceObjectId"),
                  "sourceAssetId" : copy.entityModel.get("sourceAssetId"),
                  "parentId" : null
                }, { save: save,
                  success: function() {
                    //Since this is a prefab asset, we'll erase any existing prefab links.
                    prefab.traverse( function( obj ) {
                      obj.set( { "prefabObjectId" : undefined, "prefabAssetId" : undefined }, { save: save } );
                    });

                    //Get rid of the copied top-level object since this is the prefab asset now.
                    var changes = { "children": copy.entityModel.get("children") };
                    _.each( changes.children, function( included, id ) {
                      changes.children[ id ] = false;
                    });

                    copy.set( changes, {silent: true, save: save,
                      success: function() {
                        copy.destroy( { save: save } );
                        //Turn the object into an instance of this new prefab.
                        prefab.linkupPrefab( object, prefab, { save: save, prefabInstanceId : object.id } );

                        if ( options && options.success ) {
                          options.success( prefab );
                        }
                      }
                    });
                  }
                });

              }
            } );

          }
        });
      },

    };

    return PrefabRegistry;
  });

/**
 * @module VAPI
 */
define( 'VeroldEngine/AssetRegistry/GeometryAsset',[ 'underscore'
        , 'three'
        , 'VeroldEngine/AssetRegistry/VeroldAsset'
        , 'VeroldEngine/Loaders/GenericLoader'
        , 'VeroldEngine/Util/BufferGeometryUtilities'
  ],
  function( _, THREE, VeroldAsset, GenericLoader, BufferGeometryUtilities ) {

    /**
     * An object that holds geometry data
     * @class GeometryAsset
     * @constructor
     */
    var GeometryAsset = function( ) {
      VeroldAsset.call( this );

      this.threeData = undefined;
      this.buffer = undefined;
    };

    GeometryAsset.prototype = new VeroldAsset();

    _.extend( GeometryAsset.prototype, {

      initialize: function( properties ) {
        VeroldAsset.prototype.initialize.call( this, properties );
        this.state_dependencies = "loaded";

        // Geometries don't have a hierarchy so we'll mark it as already loaded.
        this.trigger( "load_hierarchy", this );
        this.trigger( "load_hierarchy_dependencies", this );
        this.trigger( "load_components", this );
      },

      _loadThreeData: function( changes, options ) {
        var that = this
          , descriptorSize = 0;

        var onDescriptorProgress = function( progressObj ) {
          descriptorSize = progressObj.total;
          that.loadingProgress.geometry = progressObj.loaded;
          that.trigger( "load_progress", that );
        };

        var onBufferProgress = function( progressObj ) {
          that.loadingProgress.geometry = descriptorSize;
          that.loadingProgress.geometry += progressObj.loaded;
          that.trigger( "load_progress", that );
        };

        var loader = new GenericLoader( this.veroldEngine )
          , descriptorPath = this.entityModel.getResourcePath(0);

        //TODO - geometry backwards compatibility - should be removed after migration
        if ( !descriptorPath ) {
          descriptorPath = this.entityModel.getPath();
        }

        loader.loadFile( descriptorPath, 'json', function( err, descriptor ) {
          if ( err ) {
            return console.warn( "Failed to load geometry descriptor", descriptorPath, err );
          }

          if ( _.isObject( descriptor ) ) {
            that.threeData = descriptor;

            if ( _.isString( descriptor.bufferPath ) ) {
              var bufferUrl = descriptorPath.replace(/\\/g,'/').replace(/[^\/]*$/, '') + descriptor.bufferPath;

              loader.loadFile( bufferUrl, 'arraybuffer', function( err, buffer ) {
                if ( err ) {
                  return console.warn( "Failed to load geometry buffer", bufferUrl, err );
                }

                that.buffer = buffer;
                that.applyPayloadSettings_loaded( changes, options );
                that.trigger( "load_base", that );
              }, onBufferProgress );
            }
          }
        }, onDescriptorProgress );
      },

      _addMissingAttributes: function( geometry ) {
        var attributes = geometry.attributes
          , utils = new BufferGeometryUtilities( geometry )
          , colors, i;

        // Create an empty position array if it doesn't exist.
        if ( attributes.position === undefined ) {
          geometry.addAttribute(
            'position',
            new THREE.BufferAttribute( new Float32Array( 0 ), 3 )
          );
        }

        // Compute vertex normals if they don't exist.
        if ( attributes.normal === undefined ) {
          geometry.computeVertexNormals();
        }

        // // Add vertex colors if they don't exist.
        // if ( attributes.color === undefined ) {
        //   colors = new Float32Array( attributes.position.array.length / 3 * 4 );

        //   for ( i = 0; i < colors.length; ++i ) {
        //     colors[ i ] = 1;
        //   }

        //   geometry.addAttribute(
        //     'color',
        //     new THREE.BufferAttribute( colors, 4 )
        //   );
        // }

        // Compute UVs if they don't exist.
        if ( attributes.uv === undefined ) {
          utils.computeUVs();
        }

        // Compute tangents if they don't exist.
        if ( attributes.tangent !== undefined ) {
          geometry.hasTangents = true;
        }
        else {
          // This must be called after UVs are loaded.
          utils.computeTangents();
        }
      },

      _createAttributes: function( geometry, descriptor, sizes ) {
        var vertexAttributes = descriptor.vertex_attributes
          , buffers = []
          , that = this;

        function addBuffer( name, buffer, type ) {
          if ( buffer ) {
            buffers.push( {
              'attribute': name,
              'offset': buffer.fileOffset,
              'length': buffer.count * buffer.value_size,
              'type': type,
              'itemSize': buffer.value_size
            } );
          }
        }

        function createArray( type, buffer, offset, n, fromSize, toSize ) {
          var fromArray
            , iAttribute
            , iValue
            , minSize = Math.min( fromSize, toSize )
            , nAttributes = n / fromSize
            , toArray;

          if ( fromSize === toSize ) {
            return new type( buffer, offset, n );
          }

          // The attribute size needs to be adjusted.
          fromArray = new type( buffer, offset, n );
          toArray = new type( n / fromSize * toSize );

          for ( iAttribute = 0; iAttribute < nAttributes; ++iAttribute ) {
            for ( iValue = 0; iValue < minSize; ++iValue ) {
              toArray[ iAttribute * toSize + iValue ] =
                fromArray[ iAttribute * fromSize + iValue ];
            }

            for ( ; iValue < toSize; ++iValue ) {
              toArray[ iAttribute * toSize + iValue ] = 0;
            }
          }

          return toArray;
        }

        if ( _.isObject( descriptor.indices ) ) {
          addBuffer( 'index', descriptor.indices, Uint16Array );
        }

        addBuffer( 'position',   vertexAttributes.positions,    Float32Array );
        addBuffer( 'normal',     vertexAttributes.normals,      Float32Array );
        addBuffer( 'tangent',    vertexAttributes.tangents,     Float32Array );
        addBuffer( 'color',      vertexAttributes.colors,       Float32Array );
        addBuffer( 'uv',         vertexAttributes.uvs1,         Float32Array );
        addBuffer( 'uv2',        vertexAttributes.uvs2,         Float32Array );
        addBuffer( 'skinIndex',  vertexAttributes.skin_indices, Float32Array );
        addBuffer( 'skinWeight', vertexAttributes.skin_weights, Float32Array );

        _.each( buffers, function( buffer ) {
          var size = sizes[ buffer.attribute ] || buffer.itemSize
            , array;

          array = createArray( buffer.type, that.buffer, buffer.offset,
            buffer.length, buffer.itemSize, size );

          geometry.addAttribute(
            buffer.attribute,
            new THREE.BufferAttribute( array, size )
          );
        } );

        // return attributes;
      },

      /**
       * Create a THREE.BufferGeometry object for the specified geometry.
       * @method createBufferGeometry
       * @param {String} id The ID of the geometry.
       * @return {Object} The THREE.BufferGeometry object.
       */
      createBufferGeometry: function( id ) {
        if ( !this.threeData || !this.buffer ) {
          console.warn( "Geometry not loaded" );
          return null;
        }

        if ( !this.threeData[ id ] ) {
          console.warn( "No geometry with specified ID", id );
          return null;
        }

        var descriptor = this.threeData[ id ]
          , geometry = new THREE.BufferGeometry()
          , utils = new BufferGeometryUtilities( geometry )
          , sizes = {};

        geometry.drawcalls = descriptor.offsets;
        geometry.offsets = descriptor.offsets;
        geometry.bones = descriptor.bones;
        geometry.bindPose = descriptor.bind_pose;

        // Create vertex attributes.
        this._createAttributes( geometry, descriptor, {
          'position': 3,
          'normal': 3,
          'tangent': 4,
          'color': 4,
          'uv': 2,
          'uv2': 2,
          'skinIndex': 4,
          'skinWeight': 4
        } );

        // Add missing attributes.
        this._addMissingAttributes( geometry );

        // Add a wireframe attribute.
        // geometry.addWireframeAttribute();

        return geometry;
      },

      /**
       * Returns the download size of this geometry.
       * @method getDataSizeGeometryDownload
       * @return {Integer} The number of bytes of data.
       */
      getDataSizeGeometryDownload: function( options ) {
        var resources = this.entityModel.getResources(),
          total = 0;
        
        //TODO - backward compatibility for old geometry. Remove after migration
        if ( !resources.length ) {
          return this.getProperty( "size" );
        }

        _.each( resources, function( resource ) {
          total += resource.contentLength;
        } );

        return total;
      },

      /**
       * Returns the download size of this geometry after being unzipped by the browser.
       * @method getDataSizeGeometryDownloadUncompressed
       * @return {Integer} The number of bytes of data.
       */
      getDataSizeGeometryDownloadUncompressed: function( options ) {
        var resources = this.entityModel.getResources(),
          total = 0;

        //TODO - backward compatibility for old geometry. Remove after migration
        if ( !resources.length ) {
          return this.getProperty( "size_uncompressed" );
        }

        _.each( resources, function( resource ) {
          var size = resource.contentLengthIdentity;

          if ( size === undefined ) {
            size = resource.contentLength;
          }

          total += size;
        } );

        return total;
      },

      /**
       * Returns the total amount of memory occupied by this geometry.
       * @method getDataSizeGeometryInMemory
       * @return {Integer} The number of bytes of data.
       */
      getDataSizeGeometryInMemory: function( options ) {
        return this.getDataSizeGeometryDownloadUncompressed( options );
      }

    } );

    window.VAPI = window.VAPI || {};
    window.VAPI.GeometryAsset = GeometryAsset;

    return GeometryAsset;
  } );


/**
 * VAPI
 */
define( 'VeroldEngine/AssetRegistry/GeometryRegistry',[ 'underscore'
        , 'VeroldEngine/AssetRegistry/GeometryAsset'
  ],
  function( _, GeometryAsset ) {

    /**
     * Geometry is registered and managed here
     * @class GeometryRegistry
     * @param {Object} properties Geometry Manager properties 
     * @constructor
     */
    var GeometryRegistry = function( properties ) {
      this.assets = undefined;
    };

    GeometryRegistry.prototype = {

      constructor: GeometryRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.projectId = properties.projectId;
        this.veroldEngine = properties.veroldEngine;

      },

      uninitialize: function() {
        _.each( this.assets, function( asset, id ) {
          asset.uninitialize();
          delete this.assets[ id ];
        }, this );

        this.assets = undefined;
        this.veroldEngine = undefined;
        this.projectId = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {Object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {Object} filters An object with keys to match. Keys can be
       * 'name' or 'type' and can be either single options or arrays of multiple
       * values to match.
       * @return {Array} Array of assets that match at least one of the queries.
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json The definition of the asset. Needs to at least
       * include and "id" and a "type" (e.g. "material", "prefab", etc.).
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {
        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      /**
       * Force-unloads the asset, if it is loaded.  This triggers a "remove"
       * event.  If the asset is persistent, it is deleted from the database.
       * @method destroyAsset
       * @param {String} assetID The ID of the asset to destroy.
       * @param {Object} options The standard options object.
       */
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {
        if ( !entityModel ) {
          console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model." );
        }

        var newAsset = new GeometryAsset();

        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        } );

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;
      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
        //this.veroldEngine.globalEvents.trigger( "engine::scene::geometryDeleted", assetID );
      },

      update: function( delta ) {
      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    };

    return GeometryRegistry;
  } );


define('VeroldEngine/AssetRegistry/MaterialAsset',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/VeroldAsset'
  ],
  function(_, THREE, VeroldAsset ) {

    var MaterialAsset = function( properties ) {
      VeroldAsset.call( this );
      this.currentFeatures = {};

    };

    MaterialAsset.prototype = new VeroldAsset();

    MaterialAsset.prototype.events = {
      'setColor': { 'scope': 'local', 'action': true, 'category': 'Materials', 'params': [ 
        { 'name': 'parameter', 'type': 'dd', 'description': 'The colour parameter to modify.', 'default': "diffuseColor", 'options': {
          'Diffuse': 'diffuseColor',
          'Rim Color': 'rimColor',
          'Specular': 'specularColor',
          'Emissive': 'emissiveColor'}},
        { 'name': 'value', 'type': 'c', 'description': 'The colour to set.', 'default': 0xff0000 },
        { 'name': 'animationTime', 'type': 'f', 'description': 'The length of time that the change will take. i.e. this lets you animate the change.', default: 0.0, 'min': 0.0 }, 
        // { 'name': 'easeIn', 'type': 'f', 'description': 'Percentage of animation time to spend speeding up.', 'default': 0.25 },
        // { 'name': 'easeOut', 'type': 'f', 'description': 'Percentage of animation time to spend slowing down.', 'default': 0.25 },
        ]
      },
      'setNumber': { 'scope': 'local', 'action': true, 'category': 'Materials', 'params': [ 
        { 'name': 'parameter', 'type': 'dd', 'description': 'The number parameter to modify.', 'default': "colorOpacity", 'options': {
          'Opacity': 'colorOpacity',
          'Rimlight Falloff': 'rimPower',
          'Specular Intensity': 'specularIntensity',
          'Glossiness': 'gloss',
          'Transmission Scale': 'scatterScale',
          'Scattering Amount': 'scatterLocalScale',
          'Normal Map Scale': 'normalScale',
          'Parallax Scale': 'parallaxScale',
          'Reflectivity': 'reflectionBias',
          //'Displacement Base Magnitude': 'displacementBaseMag',
          //'Displacement Tex Magnitude': 'displacementMag'
          //'Displacement Base Bias': 'displacementBaseBias',
          //'Displacement Tex Bias': 'displacementBias',
        }},
        { 'name': 'value', 'type': 'f', 'description': 'The value to set.', 'default': 1.0 },
        { 'name': 'animationTime', 'type': 'f', 'description': 'The length of time that the change will take. i.e. this lets you animate the change.', default: 0.0, 'min': 0.0 }]
      },
      'setVector2': { 'scope': 'local', 'action': true, 'category': 'Materials', 'params': [ 
        { 'name': 'parameter', 'type': 'dd', 'description': 'The vector parameter to modify.', 'default': "diffuseTextureOffset", 'options': {
          'Diffuse Texture Offset': 'diffuseTextureOffset',
          'Diffuse Texture Scale': 'diffuseTextureScale',
          'Diffuse Texture Pan': 'diffuseTexturePan',
          'AO Texture Offset': 'aoTextureOffset',
          'AO Texture Scale': 'aoTextureScale',
          'AO Texture Pan': 'aoTexturePan',
          'Specular Texture Offset': 'specularTextureOffset',
          'Specular Texture Scale': 'specularTextureScale',
          'Specular Texture Pan': 'specularTexturePan',
          'Normal Map Offset': 'normalTextureOffset',
          'Normal Map Scale': 'normalTextureScale',
          'Normal Map Pan': 'normalTexturePan',
          'SSS Texture Offset': 'sssTextureOffset',
          'SSS Texture Scale': 'sssTextureScale',
          'SSS Texture Pan': 'sssTexturePan',
          'Displacement Map Offset': 'displacementTextureOffset',
          'Displacement Map Scale': 'displacementTextureScale',
          'Displacement Map Pan': 'displacementTexturePan',
          'Emissive Texture Offset': 'emissiveTextureOffset',
          'Emissive Texture Scale': 'emissiveTextureScale',
          'Emissive Texture Pan': 'emissiveTexturePan',
        }},
        { 'name': 'value', 'type': 'v2', 'description': 'The colour to set.', 'default': { x: 1.0, y: 1.0 } },
        { 'name': 'animationTime', 'type': 'f', 'description': 'The length of time that the change will take. i.e. this lets you animate the change.', default: 0.0, 'min': 0.0 }, 
        // { 'name': 'easeIn', 'type': 'f', 'description': 'Percentage of animation time to spend speeding up.', 'default': 0.25 },
        // { 'name': 'easeOut', 'type': 'f', 'description': 'Percentage of animation time to spend slowing down.', 'default': 0.25 },
        ]
      },
      // 'animateColor': { 'scope': 'local', 'action': true, 'category': 'Materials', 'params': [ 
      //   { 'name': 'animationTime', 'type': 'f', 'description': 'The length of time that the animation will take.', 'filter': {'material': true } }, 
      //   { 'name': 'materialIndex', 'type': 'i', 'description': 'Optional - if this mesh contains multiple materials, this is the material number that you want to change.', 'default': 0}] 
      // },
      // animateMaterial: {'params': [], 'action': true, 'category': 'Rendering'},
    };

    MaterialAsset.prototype.initialize = function( properties ) {
      VeroldAsset.prototype.initialize.call( this, properties );
      //Materials don't have a hierarchy so we'll mark it as already loaded.
      //this.state_hierarchy = "loaded";
      //this.state_hierarchy_dependencies = "loaded";

      var payload = this.entityModel.get("payload");
      if ( !payload || !payload.materialType ) {
        this.entityModel.set( {"payload.materialType" : "Standard" }, { silent: true });
      }

      this.trigger( "load_hierarchy", this );
      this.trigger( "load_hierarchy_dependencies", this );
      this.trigger( "load_components", this );

      this.on('setColor', this.setColor, this );
      this.on('setNumber', this.setNumber, this );
      this.on('setVector2', this.setVector2, this );
    };

    MaterialAsset.prototype.uninitialize = function(  ) {
      VeroldAsset.prototype.uninitialize.call( this );
      this.off('setColor', this.setColor, this );
      this.off('setNumber', this.setNumber, this );
      this.off('setVector2', this.setVector2, this );
    };

    MaterialAsset.prototype._initDependenciesList = function() {
      if ( this.veroldEngine.isPrimaryEngine() && !this.dependenciesListInit ) {
        var payload = this.entityModel.get("payload");
        var matDef = this.registry.getMaterialDefinition( payload.materialType );

        _.each( matDef.Parameters, function( param, key ) {
          if ( this.isParameterUsed( key ) ) {
            if ( param.type === 't' ) {
              if ( payload[key] ) {
                this.registerTexture( payload[key] );
              }
              else {
                this.registerTexture( param.default );
              }
            }
          }
        }, this );
        _.each( matDef.uniforms, function( uniform, key ) {
          if ( uniform.type === 't' ) {
            this.registerTexture( uniform.default );
          }
        }, this );
        this.dependenciesListInit = true;
      }
    };

    MaterialAsset.prototype.getListOfReferencedTextures = function() {
      var ref = {};
      var payload = this.entityModel.get("payload");
      var matDef = this.registry.getMaterialDefinition( payload.materialType );

      _.each( matDef.Parameters, function( param, key ) {
        if ( param.type === 't' ) {
          if ( payload[key] && payload[key] !== "null") {
            ref[ payload[key] ] = this.getAssetById( payload[key] );
          }
          else if ( param.default ) {
            ref[ param.default ] = this.getAssetById( param.default );
          }
        }
      }, this );
      _.each( matDef.uniforms, function( uniform, key ) {
        if ( uniform.type === 't' && uniform.default ) {
          ref[ uniform.default ] = this.getAssetById( uniform.default );
        }
      }, this );
      return ref;
    };

    MaterialAsset.prototype._loadThreeData = function( changes, options ) {

      var json = this.entityModel.toJSON();
      var material = this._createThreeJSMaterialArray( json );

      if ( material ) {

        _.each( material, function( mat ) {
          mat.veroldEntityId = this.id;
        }, this );

        this.threeData = material;
        this.materialType = json.payload.materialType;

        //If this material doesn't have its list of enabled features yet,
        //build the list with all of them on.
        //if ( !json.payload.Features ) {
        this._createFeatureStructure();
        changes.payload.Features = true;
        //}
        //var that = this;
        //Make sure we're not trying to change the material type since we just created the material a second ago.
        changes.payload.materialType = false;

        this.applyPayloadSettings_loaded( changes.payload, options );
        //this.trigger("load", this);
        this.trigger("load_base", this);
      }

    };

    //Build the list of features for the material based on the type and turn them all on.
    MaterialAsset.prototype._createFeatureStructure = function() {
      var oldFeatures = this.entityModel.get("payload").Features;

      this.set( { "payload.Features" : {} }, { silent: true });
      var matDef = this.registry.getMaterialDefinition( this.entityModel.get("payload").materialType );

      var features = matDef.Features;
      var featuresStruct = {};
      _.each( features, function( feature, x ) {
        featuresStruct[ x ] = { enabled: true };
        if ( feature.enabled !== undefined ) {
          featuresStruct[ x ].enabled = feature.enabled;
        }
        if ( feature.SubFeatures ) {
          featuresStruct[x].SubFeatures = {};
          _.each( feature.SubFeatures, function( subFeature, y ) {
            featuresStruct[x].SubFeatures[y] = {enabled : true};
            if ( subFeature.enabled !== undefined ) {
              featuresStruct[ x ].SubFeatures[y].enabled = subFeature.enabled;
            }
          }, this );
        }
      }, this );
      this.set( { "payload.Features" : featuresStruct }, { silent: true });

      //Update the feature list
      if ( oldFeatures ) {
        this._applyFeatureStructure( oldFeatures );
      }
    };

    //Apply an existing set of features to this object. Only common features will
    //be updated with the value in the provided feature structure.
    MaterialAsset.prototype._applyFeatureStructure = function( features ) {
      var currentFeatures = this.entityModel.get("payload").Features;
      for ( var f in features ) {
        if ( currentFeatures[f] ) {
          var jsonKey = "payload.Features." + f + ".enabled";
          var json = {};
          json[ jsonKey ] = features[f].enabled;
          this.set( json, { silent: true });
          if ( features[f].SubFeatures !== undefined && currentFeatures[f].SubFeatures !== undefined ) {
            for ( var sf in features[f].SubFeatures ) {
              if ( currentFeatures[f].SubFeatures[sf] ) {
                var subJson = {};
                jsonKey = "payload.Features." + f + ".SubFeatures." + sf + ".enabled";
                subJson[ jsonKey ] = features[f].SubFeatures[sf].enabled;
                this.set( subJson, {silent: true});
              }
            }
          }
        }
      }
    };

    MaterialAsset.prototype._createThreeJSMaterialArray = function( json ) {
      if (!json.payload) { console.error("Trying to create a Verold material with no material type specified."); }
      var veroldMaterialType = json.payload.materialType;
      var materialDef = this.registry.getMaterialDefinition( veroldMaterialType );
      var materialParams = json.payload;

      var uniforms = THREE.UniformsUtils.clone( materialDef.uniforms );
      this.initSharedUniforms( uniforms );
      this.initUniformTextures( uniforms, json.payload.materialType );
      var materials = {};

      var parameters = {};

      for ( var x in this.registry.materialObjectTypes ) {
        parameters[x] = {
          "fragmentShader": materialDef.fragmentShader,
          "vertexShader": materialDef.vertexShader,
          "uniforms": {},
        };

        //Copy the uniform objects into this material object type
        //so that we can override some of them without affecting other
        //material object types.
        _.each( uniforms, function( obj, key ) {
          parameters[x].uniforms[ key ] = obj;
        }, this );
        
        parameters[x].defines = {};
        
        for ( var y in this.registry.materialObjectTypes[x] ) {
          if ( y === "defines") {
            for ( var d in this.registry.materialObjectTypes[x][y] ) {
              parameters[x][y][d] = this.registry.materialObjectTypes[x][y][d];
            }
          }
          else if ( y === "uniforms") {
            var copyUniforms = THREE.UniformsUtils.clone( this.registry.materialObjectTypes[x][y] );
            _.each( copyUniforms, function( uniform, key ) {
              parameters[x][y][ key ] = uniform;
            }, this );
          }
          else {
            parameters[x][y] = this.registry.materialObjectTypes[x][y];
          }
        }
        materials[x] = new THREE.ShaderMaterial( parameters[x] );
        materials[x].name = json.name;

        //Assign default renderParams
        _.each( materialDef.Parameters, function( param, paramName ) {
          if ( param.isRenderParam ) {
            materials[x][paramName] = param.value;
          }
        }, this );
      }
      return materials;
    };

    //Link up a uniform that is shared between materials
    //For now, just hardcode this for the 'time' uniform...
    MaterialAsset.prototype.initSharedUniforms = function( uniforms ) {
      uniforms.time = this.registry.getSharedUniform('time');
      uniforms.screenDimensions = this.registry.getSharedUniform('screenDimensions');
    };

    //We'll go through the uniforms and load the default textures so that, if any
    //aren't specified in the material JSON, we'll still have valid defaults.
    MaterialAsset.prototype.initUniformTextures = function( uniforms, matType ) {

      var matDef = this.registry.getMaterialDefinition( matType );

      var params = matDef.Parameters;
      for ( var u in uniforms ) {
        //Uniforms that are not user-editable parameters
        if ( uniforms[u].type === 't' && !params[u] && uniforms[u].default ) {
          this.setDefaultTexture( uniforms[u], uniforms[u].default, u );
        }
        //Uniforms that are user-editable parameters
        else if ( uniforms[u].type === 't' && params[u] && params[u].default ) {
          this.setDefaultTexture( uniforms[u], params[u].default, u );
        }
      }

    };

    MaterialAsset.prototype.setDefaultTexture = function( uniform, defaultTexture, uniformName ) {

      var texture = this.veroldEngine.assetRegistry.getAssetById( defaultTexture );
      texture.load( {
        load_base: function( textureAsset) {
          if ( !uniform.value ) { uniform.value = textureAsset.threeData; }
        },
        load_base_failure: function() {
          console.warn("Couldn't get default texture.");
        }
      } );
    };

    MaterialAsset.prototype.applyPayloadSettings_loaded = function( changes, options ) {

      var materialPayload = this.entityModel.get("payload");

      var materialDef = this.registry.getMaterialDefinition( materialPayload.materialType );

      //If the material type has changed, change the shader and copy over uniforms that match.
      if ( changes.materialType ) {

        //Record the old features that were enabled/disabled
        var oldFeatures = this.entityModel.get("payload").Features;
        var persistingFeatures = {}
        for ( var f in oldFeatures ) {
          persistingFeatures[f] = { enabled : oldFeatures[f].enabled };
          if ( oldFeatures[f].SubFeatures ) {
            persistingFeatures[f].SubFeatures = {};
            for ( var sf in oldFeatures[f].SubFeatures ) {
              persistingFeatures[f].SubFeatures[ sf ] = { enabled : oldFeatures[f].SubFeatures[ sf ].enabled };
            }
          }
        }

        //Reset all the features for the new material type
        this._createFeatureStructure();

        //Apply enabling/disabling for any features that are common between the previous material type and this one.
        this._applyFeatureStructure( oldFeatures );

        changes.Features = true;

        var oldUniforms = this.threeData.static.uniforms;

        for ( var x in this.registry.materialObjectTypes ) {

          this.threeData[x].fragmentShader = materialDef.fragmentShader;
          this.threeData[x].vertexShader = materialDef.vertexShader;
          this.threeData[x].uniforms = THREE.UniformsUtils.clone( materialDef.uniforms );
          this.initSharedUniforms( this.threeData[x].uniforms );
          this.initUniformTextures( this.threeData[x].uniforms, materialPayload.materialType );
          //Copy any existing parameters that match.
          for (var p in this.threeData[x].uniforms ) {

            var uniform = this.threeData[x].uniforms[p];
            if ( materialDef.Parameters[p] && materialDef.Parameters[p].defines ) {
              changes[p] = true;
            }
            if ( oldUniforms[ p ] && uniform.type === oldUniforms[ p ].type ) {
              uniform.value = oldUniforms[ p ].value;
            }
            else if ( uniform.type === 't') {
              changes[p] = true;
            }
          }
          this.updateFeatures();
          this.threeData[x].needsUpdate = true;

        }

        this.materialType = materialPayload.materialType;
      }

      //Update the material with raw parameters passed in.
      var transparencyNeedsUpdate = false;
      var featuresNeedUpdate = false;
      for ( var p in changes ) {
        //Check for feature support
        if ( materialDef.Parameters[p] ) {
          if ( materialDef.Parameters[p].defines ) {
            featuresNeedUpdate = true;
          }
          if ( materialDef.Parameters[p].feature ) {
            if ( !(materialDef.Features && materialDef.Features[ materialDef.Parameters[p].feature ] ) ) {
              continue;
            }
          }
          this.updateParameter( p );
          if ( materialDef.Parameters[ p ].transparency ) {
            transparencyNeedsUpdate = true;
          }
        }
        else if ( p === "Features" ) {
          //The material features have changed. Update the defines and recompile.
          featuresNeedUpdate = true;
          transparencyNeedsUpdate = true;
        }
      }
      if ( featuresNeedUpdate ) {
        //The material features have changed. Update the defines and recompile.
        this.updateFeatures();
        transparencyNeedsUpdate = true;
      }
      if ( transparencyNeedsUpdate ) {
        this.updateTransparency();
      }


    };

    MaterialAsset.prototype.applyPayloadSettings_unloaded = function( changes, options ) {
      if ( changes ) {
        var materialPayload = this.entityModel.get("payload");
        var materialDef = this.registry.getMaterialDefinition( materialPayload.materialType );

        _.each( changes, function( param, key ) {

          if ( materialDef.Parameters[ key ] ) {
            //If a texture has changed, update the size of all objects that rely on this material.
            if ( materialDef.Parameters[ key ].type === 't' ) {
              if ( this.isParameterUsed( key ) ) {
                //Get the previous texture value so that we can unregister is.
                var prevPayload = this.entityModel.previous("payload");
                if ( prevPayload[key] !== materialPayload[ key ] ) {
                  // this.unregisterDependency( prevPayload[key] );
                  // this.registerDependency( materialPayload[ key ] );
                  this.registerTexture( materialPayload[ key ] );
                  this.unregisterTexture( prevPayload[ key ] );
                }

                this.trigger( "sizeNeedsUpdate", this );
              }
            }
          }

        }, this );

      }
    };

    //Go through all the properties of the material that affect transparency and make
    //sure the 'transparent' flag in Three.JS is appropriately set.
    MaterialAsset.prototype.updateTransparency = function( ) {

      var payload = this.entityModel.get("payload");
      var materialDef = this.registry.getMaterialDefinition( payload.materialType );
      var transparencyOn = false;
      var features = payload.Features;
      for ( var key in materialDef.Parameters ) {
        if ( payload[ key ] !== undefined && !materialDef.Parameters[key].deprecated ) {
          var param = materialDef.Parameters[ key ];
          var featureEnabled = true;
          //Check if the feature (and subfeature) for this parameter is enabled or not.
          //If either is not enabled, we shouldn't consider turning transparency on for it.
          if ( param.group && features[ param.group ] ) {
            if ( !features[ param.group ].enabled ) {
              featureEnabled = false;
            }
            else {
              if ( param.subgroup && features[ param.group ].SubFeatures[ param.subgroup ] && !features[ param.group ].SubFeatures[ param.subgroup ].enabled ) {
                featureEnabled = false;
              }
            }
          }

          if ( featureEnabled ) {
            if ( param.transparency === "LessThanOne" ) {
              if ( payload[ key ] < 1.0 ) {
                transparencyOn = true;
                break;
              }
            }//if
            else if ( param.transparency === "GreaterThanOne" ) {
              if ( payload[ key ] > 1.0 ) {
                transparencyOn = true;
                break;
              }
            }//if
          }
        }//if
      }//for

      for ( var matObjType in this.registry.materialObjectTypes ) {
        this.threeData[ matObjType ].transparent = transparencyOn;
      }
    };

    MaterialAsset.prototype.isParameterUsed = function( key ) {
      var materialDef = this.registry.getMaterialDefinition( this.materialType );
      var param = materialDef.Parameters[key];
      var features = this.entityModel.get("payload").Features;
      if ( param ) {
        if ( param.group ) {
          var featureDef = materialDef.Features[ param.group ];
          if ( features && features[ param.group ] ) {
            if ( features[ param.group ].enabled ) {
              var subFeatures = features[ param.group ].SubFeatures;
              if ( param.subgroup ) {
                var subFeaturesDef = featureDef.SubFeatures[ param.subgroup ];
                if ( subFeatures ) {
                  if ( subFeatures[ param.subgroup ] && subFeatures[ param.subgroup ].enabled ) {
                    return true;
                  }
                  else {
                    return false;
                  }
                }
                else if ( subFeaturesDef && subFeaturesDef.enabled !== false ) {
                  return true;
                }
                else {
                  return false;
                }
              }
              else {
                return true;
              }
            }
            else {
              return false;
            }
          }
          else if ( featureDef && featureDef.enabled !== false ) {
            return true;
          }
          else {
            return false;
          }
        }
        else {
          return true;
        }
      }
      else {
        return false;
      }
    };

    //Update a uniform (or other type of parameter) for the Three.JS material from a key and value pair.
    //The key is checked against the material definition for the given type.
    MaterialAsset.prototype.updateParameter = function( key ) {

      var materialDef = this.registry.getMaterialDefinition( this.materialType );
      var value = this.entityModel.get("payload")[key];

      var matObjType;

      //If the parameter is valid, update to use its value.
      if ( materialDef.Parameters[ key ] ) {

        //If the parameter is deprecated, there won't be a uniform for it.
        //We'll look for a conversion to a new param and use that if the new
        //param hasn't been assigned yet. Otherwise, we'll skip the param.
        if ( materialDef.Parameters[ key ].deprecated ) {
          if ( materialDef.Parameters[ key ].deprecated.newParam ) {
            var newParamName = materialDef.Parameters[ key ].deprecated.newParam;
            var newParamValue = this.entityModel.get("payload")[ newParamName ];
            //matObjType = _.keys( this.registry.materialObjectTypes )[0];
            if ( newParamValue === undefined ) {
              var jsonKey = "payload." + newParamName;
              var json = {};
              json[ jsonKey ] = value * materialDef.Parameters[ key ].deprecated.convertFactor;
              this.set( json, { silent: true } );
              for ( matObjType in this.registry.materialObjectTypes ) {
                this.threeData[ matObjType ].uniforms[ newParamName ] = { type: materialDef.Parameters[ newParamName ].type, value: json[ jsonKey ] };
              }
            }
          }
          return;
        }
        //If the parameter is not a uniform but a parameter on the material object
        if ( materialDef.Parameters[ key ].isRenderParam ) {
          if ( _.isString( value )) {
            value = parseInt( value );
          }
          // if ( key === "perPixel" && VAPI.isMobile() ) {
          //   value = 0;
          // }
          // if ( key === "fog" && VAPI.isMobile() ) {
          //   value = 0;
          // }
          for ( matObjType in this.registry.materialObjectTypes ) {
            this.threeData[ matObjType ][key] = value;
            this.threeData[ matObjType ].needsUpdate = true;
          }
        }
        else {
          var feature, subFeature;
          var enabled = false;
          var payloadFeatures = this.entityModel.get("payload").Features;
          if ( materialDef.Parameters[ key ].group ) {
            feature = payloadFeatures[ materialDef.Parameters[ key ].group ];
            if ( feature && feature.enabled ) {
              if ( materialDef.Parameters[ key ].subgroup ) {
                subFeature = feature.SubFeatures[ materialDef.Parameters[ key ].subgroup ];
                if ( subFeature && subFeature.enabled ) {
                  enabled = true;
                }
              }
              else {
                enabled = true;
              }
            }
          }
          
          if ( enabled ) {
            if ( materialDef.Parameters[ key ].defines ) {
              var featureToEdit = subFeature ? subFeature : feature;
              // var payloadFeatures = this.entityModel.get("payload").Features;
              if ( featureToEdit ) {
                if ( !featureToEdit.defines ) {
                  featureToEdit.defines = {};
                }
                for ( var i in materialDef.Parameters[ key ].defines ) {
                  if ( materialDef.Parameters[ key ].type === 't' ) {
                    if ( value ) {
                      var tex = this.veroldEngine.assetRegistry.Textures.getAssetById( value );
                      if ( tex ) {
                        if ( i.slice(-9).toUpperCase() === "HDR_INPUT") {
                          switch( tex.getPixelFormat() ) {
                          case 'rgbm':
                            featureToEdit.defines[ i ] = THREE.HDRRGBM;
                            break;
                          case 'rgbd':
                            featureToEdit.defines[ i ] = THREE.HDRRGBD;
                            break;
                          case 'rgbe':
                            featureToEdit.defines[ i ] = THREE.HDRRGBE;
                            break;
                          default:
                            featureToEdit.defines[ i ] = 0;
                          }
                        }
                        else if ( i.slice(-8).toUpperCase() === "NUM_MIPS") {
                          featureToEdit.defines[ i ] = tex.getNumMips();
                        }
                        else if ( i.slice(-4).toUpperCase() === "RGBA") {
                          featureToEdit.defines[ i ] = tex.getNumChannels() === 4 ? 1 : 0;
                        }
                      }
                    }
                  }
                  else {
                    featureToEdit.defines[ i ] = value;
                  }
                }
              }
            }

            if ( materialDef.Parameters[ key ].animation && value && (value.x || value.y) && this.threeData ) {
              this.registry.timeValueInUse = true;
            }

            if ( materialDef.Parameters[ key ].type === 't' ) {
              var that = this;
              var tex;
              if ( !value || value === "null") {

                tex = this.veroldEngine.assetRegistry.Textures.getAssetById( materialDef.Parameters[ key ].default );
                tex.load( {
                  load_base: function( textureAsset ) {
                    that.setUniform( key, textureAsset.threeData );
                  }
                });
              }
              else {

                tex = this.veroldEngine.assetRegistry.Textures.getAssetById( value );
                if ( tex ) {
                  tex.load( {
                    load_base: function( textureAsset ) {
                      that.setUniform( key, textureAsset.threeData );
                    },
                    load_base_failure: function( textureAsset ) {
                      console.warn(that.veroldEngine.engineName + " - MaterialAsset.updateParameter: Unable to load texture, ", value, " to ", key);
                    }
                  });
                }
              }

            }
            else if ( materialDef.Parameters[ key ].type === 'c' ) {
              if ( _.isString( value ) ) {
                if ( value.slice(0, 2) !== "0x" ) {
                  value = parseInt( value, 10);
                  value = "0x" + value.toString(16);
                }
                value = parseInt( value, 16);
              }
              var newColor = new THREE.Color( value );
              if ( this.veroldEngine.getThreeRenderer().gammaInput ) {
                newColor.copyGammaToLinear( newColor );
              }
              this.setUniform( key, newColor );
            }
            else if ( materialDef.Parameters[ key ].type === 'b' ) {
              this.setUniform( key, value ? 1 : 0 );
            }
            else {
              this.setUniform( key, value );
            }
          }

        }//if

      }//if
    };

    MaterialAsset.prototype.setUniform = function( uniformName, value ) {
      if ( this.threeData ) {
        _.each( this.registry.materialObjectTypes, function( def, matObjType ) {
          if ( !def.uniforms || (def.uniforms && def.uniforms[ uniformName ] === undefined )) {
            this.threeData[ matObjType ].uniforms[ uniformName ].value = value;
          }
        }, this );
      }
    };

    MaterialAsset.prototype.updateFeatures = function() {

      function _setFeatureDefines( feature, featureDef, on ) {
        _.each( that.registry.materialObjectTypes, function( matTypeDef, matType ) {
          if ( matTypeDef.defines ) {
            _.each( matTypeDef.defines, function( value, define ) {
              this.threeData[ matType ].defines[ define ] = value;
            }, this );
          }

          //Pull out an alternate list of defines if we're on mobile.
          var defines = VAPI.isMobile() && featureDef.DefinesSimple ? featureDef.DefinesSimple : featureDef.Defines;
          // _.extend( defines, feature.defines );

          _.each( defines, function( value, define ) {
            if ( on ) {
              this.threeData[ matType ].defines[ define ] = value;
              //if there is an override for this define stored in the payload, use it.
              if ( feature.defines && feature.defines[ define ] !== undefined ) {
                this.threeData[ matType ].defines[ define ] = feature.defines[ define ];
              }
            }
            else {
              delete this.threeData[ matType ].defines[ define ];
            }
          }, this );
        }, that );
      }

      //Clear the existing defines.
      for ( var matType in this.registry.materialObjectTypes ) {
        this.threeData[ matType ].defines = {};
        this.threeData[ matType ].needsUpdate = true;
      }

      var that = this;
      var features = this.entityModel.get("payload").Features;
      var materialType = this.entityModel.get("payload").materialType;
      var featureDef = this.registry.getMaterialDefinition( materialType ).Features;
      //var subFeatureDef;

      //Using the list of features for the material, return a modified list
      //based on the capabilities of the hardware (if any modifications are needed)
      var supportedFeatures = this.getEnabledFeatures();
      _.each( features, function( feature, featureName ) {
        if ( supportedFeatures[ featureName ] && feature.enabled ) {
          //Enable the feature defines for the shader
          _setFeatureDefines( feature, featureDef[ featureName ], true );

          if ( feature.SubFeatures ) {
            _.each( feature.SubFeatures, function( subFeature, subFeatureName ) {
              if ( supportedFeatures[ subFeatureName ] && subFeature.enabled ) {
                _setFeatureDefines( subFeature, featureDef[ featureName ].SubFeatures[ subFeatureName ], true );
              }
              else {
                _setFeatureDefines( subFeature, featureDef[ featureName ].SubFeatures[ subFeatureName ], false );
              }
            }, this );
          }
        }
        else {
          //Disable features
          _setFeatureDefines( feature, featureDef[ featureName ], false );
        }
      }, this );

    };

    /**
     * Return a list of features that are both enabled for this material and that
     * also are supported on the current device.
     * @method getEnabledFeatures
     * @return {Array} An array of features
     */
    MaterialAsset.prototype.getEnabledFeatures = function() {

      function addRequirements( requirementsDef, currentReqs ) {
        var accumulatedReqs = {};
        _.each( requirementsDef, function( value, key ) {
          if ( currentReqs[ key ] === undefined ) {
            currentReqs[ key ] = 0;
          }
          accumulatedReqs[ key ] = currentReqs[ key ] + value;
        }, this );
        _.each( currentReqs, function( value, key ) {
          if ( requirementsDef[ key ] === undefined ) {
            accumulatedReqs[ key ] = value;
          }
        }, this );

        return accumulatedReqs;
      }

      function _checkFeatures( featureDefs, features ) {
        //Go through each feature defined for this material and record which are supported.
        _.each( featureDefs, function( featureDef, featureName ) {
          //If the feature is turned on in this material...
          if ( features[ featureName ] && features[ featureName ].enabled ) {
            //Add the requirements in the feature definition to our current total
            var newRequirements = addRequirements( featureDef.Requires, currentRequirements );
            var supported = true;
            
            //Check the current requirements against our device capabilities.
            _.each( newRequirements, function( value, requiredCap ) {
              if ( this.veroldEngine.getGPUCapability( requiredCap ) < value ) {
                console.warn( featureName + " is not supported on the current device because " + requiredCap + " is " + this.veroldEngine.getGPUCapability( requiredCap ) + " and we require at least " + newRequirements[requiredCap] );
                supported = false;
              }
            }, this );
            //Record whether the feature should be enabled or not.
            this.currentFeatures[ featureName ] = supported;
            if ( supported ) {
              currentRequirements = newRequirements;
            }
          }
          else {
            this.currentFeatures[ featureName ] = false;
          }

          if ( featureDef.SubFeatures && features[ featureName ].SubFeatures ) {
            _checkFeatures( featureDef.SubFeatures, features[ featureName ].SubFeatures );
          }
        }, that );
      }

      var that = this;
      var matType = this.getProperty("materialType");
      var features = this.getProperty("Features");
      if ( !this.registry.materialTypeLibrary.Library[ matType ] ) {
        matType = "Standard";
      }
      var featureDefs = this.registry.materialTypeLibrary.Library[ matType ].Features;
      var minRequirements = this.registry.getMinShaderRequirements();
      var currentRequirements = {};
      
      currentRequirements = addRequirements( minRequirements, currentRequirements );

      _checkFeatures( featureDefs, features );

      return this.currentFeatures;
    };

    /**
     * Get a list of all material features that can be enabled or disabled for this material
     * @method getAvailableFeatures
     * @return {Object} List of features available
     */
    MaterialAsset.prototype.getAvailableFeatures = function() {
      var matType = this.getProperty("materialType");
      var featureDefs = this.registry.materialTypeLibrary.Library[ matType ].Features;
      var result = {};
      _.each( featureDefs, function( value, key ) {
        result[ key ] = {};
        if ( value.SubFeatures !== undefined ) {
          _.each( value.SubFeatures, function( subVal, subKey ) {
            result[ key ][ subKey ] = {};
          }, this );
        }
      }, this );
      return result;
    };

    /**
     * Programmatically turn a material feature on or off. Changing a material feature
     * requires a material compilation so a slight pause will accompany a call to this
     * function.
     * @method enableFeature
     * @param  {String} featureName    Name of the primary feature to toggle.
     * @param  {String} subFeatureName Name of the sub feature to toggle (leave undefined if not changing).
     * @param  {Boolean} on             Are we turning the feature on or off.
     * @param  {Object} options        Standard options structure. e.g. { save: true, success: function(), etc.}
     */
    MaterialAsset.prototype.enableFeature = function( featureName, subFeatureName, on, options ) {

      on = !!on;
      if ( featureName && subFeatureName && 
        this.currentFeatures[ subFeatureName ] !== on && this.currentFeatures[ subFeatureName ] !== undefined && 
        this.currentFeatures[ featureName ] !== undefined ) {
        //turn on
        var featureKey = "payload.Features." + featureName + ".enabled";
        var subFeatureKey = "payload.Features." + featureName + ".SubFeatures." + subFeatureName + ".enabled";
        var json = {};
        json[ featureKey ] = on;
        this.set( json );
        //Check that the subFeature is a valid one for this principal feature.
        var matType = this.getProperty("materialType");
        var featureDefs = this.registry.materialTypeLibrary.Library[ matType ].Features;
        if ( featureDefs[ featureName ][ subFeatureName ] !== undefined ) {
          json[ subFeatureKey ] = on;
        }
        delete json[ featureKey ];
        this.set( json, options );
      }
      else if ( featureName && this.currentFeatures[ featureName ] !== on && this.currentFeatures[ featureName ] !== undefined ) {
        var featureKey = "payload.Features." + featureName + ".enabled";
        var json = {};
        json[ featureKey ] = on;
        this.set( json, options );
      }
    };

    MaterialAsset.prototype.unload = function( ) {
      if ( this.threeData ) {
        this.veroldEngine.trigger("materialUnloaded", this.id );
        console.log( this.veroldEngine.engineName + " - Unloading material, " + this.entityModel.get("name"));
        for ( var x in this.threeData ) {
          this.threeData[x].dispose();
          delete this.threeData[x];
        }
        this.threeData = null;

        VeroldAsset.prototype.unload.call( this );
      }
    };

    MaterialAsset.prototype.setColor = function( attribute, newValue, animationTime ) {
      var that = this;
      var ellapsedTime = 0.0;
      var newR, newG, newB, oldR, oldG, oldB;
      var oldValue;

      function animateValue( delta ) {
        ellapsedTime += delta;
        if ( ellapsedTime > animationTime ) {
          that.veroldEngine.off( 'update', animateValue, this );
          that.setProperty( attribute, newValue );
        }
        else {
          //Interpolate
          var interp = Math.min( ellapsedTime / animationTime, 1.0 );
          var interpR = (1.0 - interp) * oldR + interp * newR;
          var interpG = (1.0 - interp) * oldG + interp * newG;
          var interpB = (1.0 - interp) * oldB + interp * newB;
          var color = that.threeData.static.uniforms[ attribute ].value;
          color.setRGB( interpR, interpG, interpB );
          if ( that.veroldEngine.getThreeRenderer().gammaInput ) {
            color.copyGammaToLinear( color );
          }
          // that.setUniform( attribute, interpValue );
        }
      }
      if ( animationTime ) {
        oldValue = that.getProperty( attribute );
        oldR = ( oldValue >> 16 & 255 ) / 255;
        oldG = ( oldValue >> 8 & 255 ) / 255;
        oldB = ( oldValue & 255 ) / 255;
        newR = ( newValue >> 16 & 255 ) / 255;
        newG = ( newValue >> 8 & 255 ) / 255;
        newB = ( newValue & 255 ) / 255;
        this.veroldEngine.on( 'update', animateValue, this );
      }
      else {
        this.setProperty( attribute, newValue );
      }
    };

    MaterialAsset.prototype.setNumber = function( attribute, newValue, animationTime ) {
      var that = this;
      var ellapsedTime = 0.0;
      var oldValue;

      function animateValue( delta ) {
        ellapsedTime += delta;
        if ( ellapsedTime > animationTime ) {
          that.veroldEngine.off( 'update', animateValue, this );
          that.setProperty( attribute, newValue );
        }
        else {
          //Interpolate
          var interp = Math.min( ellapsedTime / animationTime, 1.0 );
          var interpValue = (1.0 - interp) * oldValue + interp * newValue;
          that.setUniform( attribute, interpValue );

          //Update transparency, if it has changed.
          //TODO - this is pretty close to a duplicate of the this.updateTransparency except that it doesn't 
          //loop through every param and doesn't compare against the payload value of the param.
          var payload = that.entityModel.get("payload");
          var materialDef = that.registry.getMaterialDefinition( payload.materialType );
          var transparencyOn = false;
          var features = payload.Features;
      
          if ( payload[ attribute ] !== undefined && !materialDef.Parameters[ attribute ].deprecated ) {
            var param = materialDef.Parameters[ attribute ];
            var featureEnabled = true;
            //Check if the feature (and subfeature) for this parameter is enabled or not.
            //If either is not enabled, we shouldn't consider turning transparency on for it.
            if ( param.group && features[ param.group ] ) {
              if ( !features[ param.group ].enabled ) {
                featureEnabled = false;
              }
              else {
                if ( param.subgroup && features[ param.group ].SubFeatures[ param.subgroup ] && !features[ param.group ].SubFeatures[ param.subgroup ].enabled ) {
                  featureEnabled = false;
                }
              }
            }

            if ( featureEnabled ) {
              if ( param.transparency === "LessThanOne" ) {
                if ( interpValue < 1.0 ) {
                  transparencyOn = true;
                }
              }//if
              else if ( param.transparency === "GreaterThanOne" ) {
                if ( interpValue > 1.0 ) {
                  transparencyOn = true;
                }
              }//if
            }
          }//if
          for ( var matObjType in that.registry.materialObjectTypes ) {
            that.threeData[ matObjType ].transparent = transparencyOn;
          }
      
        }
      }
      if ( animationTime ) {
        oldValue = that.getProperty( attribute );
        this.veroldEngine.on( 'update', animateValue, this );
      }
      else {
        this.setProperty( attribute, newValue );
      }
    };

    MaterialAsset.prototype.setVector2 = function( attribute, newValue, animationTime ) {
      var that = this;
      var ellapsedTime = 0.0;
      var newX, newY, oldX, oldY;
      var oldValue;

      function animateValue( delta ) {
        ellapsedTime += delta;
        if ( ellapsedTime > animationTime ) {
          that.veroldEngine.off( 'update', animateValue, this );
          that.setProperty( attribute, newValue );
        }
        else {
          //Interpolate
          var interp = Math.min( ellapsedTime / animationTime, 1.0 );
          var interpX = (1.0 - interp) * oldX + interp * newX;
          var interpY = (1.0 - interp) * oldY + interp * newY;
          that.threeData.static.uniforms[ attribute ].value.x = interpX;
          that.threeData.static.uniforms[ attribute ].value.y = interpY;
        }
      }
      if ( animationTime ) {
        oldValue = that.getProperty( attribute );
        oldX = oldValue.x;
        oldY = oldValue.y;
        newX = newValue.x;
        newY = newValue.y;
        this.veroldEngine.on( 'update', animateValue, this );
      }
      else {
        this.setProperty( attribute, newValue );
      }
    };

    window.VAPI = window.VAPI || {};
    window.VAPI.MaterialAsset = MaterialAsset;

    return MaterialAsset;
  });

/**
 * @license RequireJS text 2.0.10 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('text',['module'], function (module) {
    

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.10',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file.indexOf('\uFEFF') === 0) {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                errback(e);
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes,
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});


define('text!VeroldEngine/Materials/Uber.frag',[],function () { return '/**\r\n * Uber Shader\r\n * Shader used as a Verold material type\r\n * \r\n * Written by Mike Bond\r\n * March 2012\r\n */\r\nuniform float time;\r\nuniform int renderModeNormals;\r\nuniform float opacity;\r\n\r\n// Inverse logLuvMatrix matrix, for decoding\r\nconst mat3 InverseLogLuvMatrix = mat3(\r\n  6.0014, -2.7008, -1.7996,\r\n-1.3320,  3.1029, -5.7721,\r\n0.3008, -1.0882,  5.6268);\r\n\r\nvec3 HDRDecodeLOGLUV(in vec4 vLogLuv)\r\n{\r\n  // Based on http://www.xnainfo.com/content.php?content=28\r\n  float Le = vLogLuv.z * 255.0 + vLogLuv.w;\r\n  vec3 Xp_Y_XYZp;\r\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\r\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;\r\n  Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;\r\n  vec3 vRGB = InverseLogLuvMatrix * Xp_Y_XYZp;\r\n  return vRGB;\r\n}\r\n\r\nvec3 HDRDecodeRGBM( vec4 rgbm ) {\r\n  //Based on http://vemberaudio.se/graphics/RGBdiv8.pdf\r\n  return 9.0 * rgbm.rgb * rgbm.a;\r\n}\r\n\r\nvec3 HDRDecodeRGBD( vec4 rgbd ) {\r\n  //Based on http://vemberaudio.se/graphics/RGBdiv8.pdf\r\n  return rgbd.rgb / max(rgbd.a, 0.003);\r\n}\r\n\r\nvec3 HDRDecodeRGBE( vec4 rgbe ) {\r\n  //Based on http://www.graphics.cornell.edu/~bjw/rgbe/rgbe.c\r\n  float f = exp2( rgbe.w * 255.0 - (128.0 + 0.0) );\r\n  return rgbe.rgb * f;\r\n}\r\n\r\n#ifdef USE_LOGDEPTHBUF\r\n\tuniform float logDepthBufFC;\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\t\t#extension GL_EXT_frag_depth : enable\r\n\t\tvarying float vFragDepth;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIFFUSE_COLOR\r\nuniform vec3 diffuseColor;\r\nuniform float colorOpacity;\r\n\t#if defined( DIFFUSE_COLOR ) && defined( DIFFUSE_TEXTURE )\r\n\tuniform int alphaBlendMode;\r\n\tuniform int colorBlend;\r\n\tuniform int diffuseTextureChannel;\r\n\tuniform sampler2D diffuseTexture;\r\n\tuniform int diffuseUVChannel;\r\n\tuniform vec2 diffuseTextureOffset;\r\n\tuniform vec2 diffuseTextureScale;\r\n\tuniform vec2 diffuseTexturePan;\r\n\t#endif\r\n\t#if !defined( DEPTH_PASS )\r\n\t\t#ifdef AO_TEXTURE\r\n\t\tuniform sampler2D aoTexture;\r\n\t\tuniform int aoUVChannel;\r\n\t\tuniform vec2 aoTextureOffset;\r\n\t\tuniform vec2 aoTextureScale;\r\n\t\tuniform vec2 aoTexturePan;\r\n\t\t#endif\r\n\t\t\r\n\t#endif\r\n#else\r\nconst vec3 diffuseColor = vec3(0.0);\r\nconst float colorOpacity = 1.0;\r\n#endif\r\n\r\n#if !defined( DEPTH_PASS )\r\n\r\n\tuniform vec4 screenDimensions;\r\n\t#ifdef RIM_LIGHTING\r\n\t\tuniform vec3 rimColor;\r\n\t\tuniform float rimPower;\r\n\t#endif\r\n\t#ifdef SPECULAR_COLOR\r\n\tuniform vec3 specularColor;\r\n\t// uniform float gloss;\r\n\t\t#ifdef SPECULAR_TEXTURE\r\n\t\tuniform sampler2D specularTexture;\r\n\t\tuniform int specularUVChannel;\r\n\t\tuniform vec2 specularTextureOffset;\r\n\t\tuniform vec2 specularTextureScale;\r\n\t\tuniform vec2 specularTexturePan;\r\n\t\t#endif\r\n\r\n\t\t#if defined(PHONG_SPECULAR)\r\n\t\tuniform float specularIntensity;\r\n\t\tuniform float gloss;\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef REFLECTIONS\r\n\t\tuniform float reflectionFresnel;\r\n\t\tuniform float reflectionBias;\r\n\t\tfloat reflectionFactor = reflectionBias * reflectionBias;\r\n\t\t#if ( REFLECTIONS == 0 )\r\n\t\tuniform samplerCube environmentTexture;\r\n\t\t#else\r\n\t\tuniform sampler2D environmentTexture2D;\r\n\t\t#endif\r\n\r\n\t#endif\r\n\r\n\t#if defined( USE_COLOR ) && defined( DIFFUSE_COLOR )\r\n\t\tvarying vec3 vColor;\r\n\t#endif\r\n\r\n\t#ifdef NORMAL_TEXTURE\r\n\tuniform float normalScale;\r\n\tuniform sampler2D normalTexture;\r\n\tuniform int normalUVChannel;\r\n\tuniform vec2 normalTextureOffset;\r\n\tuniform vec2 normalTextureScale;\r\n\tuniform vec2 normalTexturePan;\r\n\tuniform bool normalTextureFlipY;\r\n\tuniform bool normalTextureFlipX;\r\n\t#ifdef PARALLAX_MAPPING\r\n\t\tuniform float parallaxScale;\r\n\t#endif\r\n\t#endif\r\n\r\n\t#ifdef EMISSIVE_COLOR\r\n\tuniform vec3 emissiveColor;\r\n\tuniform float emissiveIntensity;\r\n\t\t#ifdef EMISSIVE_TEXTURE\r\n\t\tuniform sampler2D emissiveTexture;\r\n\t\tuniform int emissiveUVChannel;\r\n\t\tuniform vec2 emissiveTextureOffset;\r\n\t\tuniform vec2 emissiveTextureScale;\r\n\t\tuniform vec2 emissiveTexturePan;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef SCATTERING\r\n\t\t#ifdef TRANSLUCENT_SCATTERING\r\n\t\tuniform vec3 scatterColor;\r\n\t\tuniform float scatterScale;\r\n\t\t#elif defined( LOCAL_SCATTERING )\r\n\t\tuniform vec3 scatterColor;\r\n\t\tuniform float scatterLocalScale;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SSS_TEXTURE\r\n\t\tuniform sampler2D sssTexture;\r\n\t\tuniform int sssUVChannel;\r\n\t\tuniform vec2 sssTextureOffset;\r\n\t\tuniform vec2 sssTextureScale;\r\n\t\tuniform vec2 sssTexturePan;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef IRIDESCENT_LAYER\r\n\tuniform vec3 diffuseColor2;\r\n\tuniform float twoToneExponent;\r\n\tuniform float metallicExponent;\r\n\tuniform float metallicMultiplier;\r\n\t\t#ifdef IRIDESCENT_TEXTURE\r\n\t\tuniform sampler2D iridescentTexture;\r\n\t\t#endif\r\n\t#endif\r\n#endif\r\n\r\nvarying vec4 vUv;\r\n// varying vec4 vPosition_WS;\r\nvarying vec4 vPosition_WS;\r\n\r\n#if !defined( DEPTH_PASS )\r\n\t#if defined( NORMAL_TEXTURE ) && defined( USE_LIGHTING )\r\n\t\t#if ( LIGHTING_MODEL == 1 )\r\n\t\tvarying vec4 vTangent_WS;\r\n\t\tvarying vec4 vBinormal_WS;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tvarying vec4 vNormal_WS;\r\n\t//varying vec4 vPosition_SS;\r\n\r\n\tuniform vec3 ambientLightColor;\r\n\r\n\t#ifdef USE_LIGHTING\r\n\t\tuniform int doubleSidedLighting;\r\n\t\t#if ( LIGHTING_MODEL == 1 )\r\n\t\t\t#if MAX_DIR_LIGHTS > 0\r\n\t\t\t\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\r\n\t\t\t\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\r\n\t\t\t#endif\r\n\r\n\t\t\t#if MAX_POINT_LIGHTS > 0\r\n\t\t\t\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\r\n\t\t\t\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\r\n\t\t\t\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\r\n\t\t\t#endif\r\n\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef USE_SHADOWMAP\r\n\t\t\t#if MAX_SHADOWS > 0\r\n\t\t\t\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\r\n\t\t\t\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\r\n\t\t\t\tuniform float shadowBias[ MAX_SHADOWS ];\r\n\t\t\t\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat unpackDepth( const in vec4 rgba_depth ) {\r\n\t\t\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\r\n\t\t\t\tfloat depth = dot( rgba_depth, bit_shift );\r\n\t\t\t\treturn depth;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef USE_FOG\r\n\t\tuniform vec3 fogColor;\r\n\t\tuniform float fogDensity;\r\n\t#endif\r\n\r\n\t#ifdef SPECULAR_COLOR\r\n\t\t#ifdef PHONG_SPECULAR\r\n\t\t\r\n\t\t//http://www.altdevblogaday.com/2011/08/23/shader-code-for-physically-based-lighting/\r\n\t\t// vec3 calculateBlinnPhong( in float NdotH, in float NdotL_sat, in float HdotL, in float NdotV, in float glossValue, in vec3 specularColorValue ) {\r\n\t\t// \t//BlinnPhong - Normal Distribution Function\r\n\t\t// \tfloat normalisation_term = glossValue * 0.125 + 0.25;\r\n\t\t// \tfloat specPower = pow( 8192.0, glossValue );\r\n\t\t// \tfloat specular_term = pow( clamp( NdotH, 0.0, 1.0), specPower ) * normalisation_term;\r\n\t\t\t\r\n\t\t// \t//Schlick-Fresnel - Reflectance Function\r\n\t\t// \tfloat base = clamp( 1.0 - HdotL, 0.0, 1.0);\r\n\t\t// \tfloat exponential = pow( base, 5.0 );\r\n\t\t// \t// vec3 fresnel_term = ( vec3(1.0) - specularColorValue ) * exponential + specularColorValue;\r\n\t\t// \tvec3 fresnel_term = specularColorValue * exponential + specularColorValue;\r\n\r\n\t\t// \t// //Schlick-Smith - Visibility Function\r\n\t\t// \tfloat k = 2.0 * inversesqrt( 3.14159 * (gloss + 2.0) );\r\n\t\t// \tfloat oneMinusK = 1.0 - k;\r\n\t\t// \tfloat visibility = 1.0 / ( (NdotL_sat * oneMinusK + k) * (NdotV * oneMinusK + k));\r\n\t\t// \treturn fresnel_term * (specular_term * NdotL_sat) * (visibility * specularIntensity);\r\n\t\t// }\r\n\r\n\t\t// From http://www.filmicworlds.com/2014/04/21/optimizing-ggx-shaders-with-dotlh/\r\n\t\tvec2 LightingFuncGGX_FV(float dotLH, float roughness)\r\n\t\t{\r\n\t\t\tfloat alpha = roughness*roughness;\r\n\r\n\t\t\t// F\r\n\t\t\tfloat F_a, F_b;\r\n\t\t\tfloat dotLH5 = pow(1.0-dotLH,5.0);\r\n\t\t\tF_a = 1.0;\r\n\t\t\tF_b = dotLH5;\r\n\r\n\t\t\t// V\r\n\t\t\tfloat vis;\r\n\t\t\tfloat k = alpha/2.0;\r\n\t\t\tfloat k2 = k*k;\r\n\t\t\tfloat invK2 = 1.0-k2;\r\n\t\t\tvis = 1.0 / (dotLH*dotLH*invK2 + k2);\r\n\r\n\t\t\treturn vec2(F_a*vis,F_b*vis);\r\n\t\t}\r\n\r\n\t\tfloat LightingFuncGGX_D(float dotNH, float roughness)\r\n\t\t{\r\n\t\t\tfloat alpha = roughness*roughness;\r\n\t\t\tfloat alphaSqr = alpha*alpha;\r\n\t\t\tfloat pi = 3.14159;\r\n\t\t\tfloat denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;\r\n\r\n\t\t\tfloat D = alphaSqr/(pi * denom * denom);\r\n\t\t\treturn D;\r\n\t\t}\r\n\r\n\t\t// #ifdef REFLECTIONS\r\n\t\t// float SpecularFuncGGX( in float roughness, in float dotNH, in float dotLH, in float dotNL, in float dotVN, inout float reflFactor)\r\n\t\t// #else\r\n\t\tfloat SpecularFuncGGX( in float roughness, in float dotNH, in float dotLH, in float dotNL )\r\n\t\t// #endif\r\n\t\t{\r\n\t\t\tdotNH = clamp( dotNH, 0.0, 1.0 );\r\n\t\t  dotLH = clamp( dotLH, 0.0, 1.0 );\r\n\t\t  dotNL = clamp( dotNL, 0.0, 1.0 );\r\n\r\n\t\t\tfloat D = LightingFuncGGX_D(dotNH,roughness);\r\n\t\t\tvec2 FV_helper = LightingFuncGGX_FV(dotLH,roughness);\r\n\t\t\t#ifdef REFLECTIONS\r\n\t\t\t\tfloat FV = reflectionFactor*FV_helper.x + (1.0-reflectionFactor)*FV_helper.y;\r\n\t\t\t// \tvec2 ref_helper = LightingFuncGGX_FV(dotVN,roughness);\r\n\t\t\t// \tfloat FV = reflectionBias*FV_helper.x + (1.0-reflectionBias)*FV_helper.y;\r\n\t\t\t// \tfloat ref = reflectionBias*ref_helper.x + (1.0-reflectionBias)*ref_helper.y;\r\n\t\t\t// \treflFactor = clamp( dotVN * D * ref + reflectionBias, 0.0, 1.0);\r\n\t\t\t#else\r\n\t\t\t\tfloat FV = FV_helper.x;\r\n\t\t\t#endif\r\n\t\t\tfloat specular = dotNL * D * FV;\r\n\t\t\t\r\n\t\t\treturn specular;\r\n\t\t}\r\n\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LOCAL_SCATTERING\r\n\t\tvoid calculateLocalScattering( \tin vec3 lightDirection, in float NdotL,\tout float diffuseWeight, in vec3 normal_Scatter, out float scatterWeight ) {\r\n\r\n\t\t\tfloat NdotL_Scatter = dot( normal_Scatter, lightDirection );\r\n\t\t\tfloat diffuseWeightHalf = clamp( 0.5 * NdotL_Scatter + 0.5, 0.0, 1.0 );\r\n\r\n\t\t\tscatterWeight = diffuseWeightHalf;\r\n\t\t\t\r\n\t\t\tdiffuseWeight = clamp( mix( NdotL_Scatter, NdotL, 0.15 ), 0.0, 1.0 );\r\n\t\t}\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DEPTH_PASS\r\n\tvec4 pack_depth( const in float depth ) {\r\n\r\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\r\n\tconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\r\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\r\n\tres = res.xxyz * -bit_mask + res;\r\n\treturn res;\r\n\r\n}\r\n#endif\r\n\r\nvoid main() {\r\n\r\n\t#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\r\n\t\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\r\n\t#endif\r\n\tvec2 uvOffset = vec2(0.0, 0.0);\r\n\tvec3 eyeVector_WS = normalize( cameraPosition - vPosition_WS.xyz );\r\n\r\n\t#if !defined( DEPTH_PASS ) && defined( USE_LIGHTING )\r\n\t\t\r\n\t\t#ifdef NORMAL_TEXTURE\r\n\t\t\tvec2 vNormalUv = mix( vUv.xy, vUv.zw, float(normalUVChannel));\r\n\t\t\tvNormalUv = vNormalUv * normalTextureScale + normalTextureOffset + normalTexturePan * time;\r\n\t\t\t\r\n\t\t\t#if defined( DISPLACEMENT_WITH_NORMAL ) && defined( NORMAL_TEXTURE )\r\n\t\t\t\tvec3 q0 = dFdx( eyeVector_WS.xyz );\r\n\t\t\t\tvec3 q1 = dFdy( eyeVector_WS.xyz );\r\n\t\t\t\tvec2 st0 = dFdx( vUv.st );\r\n\t\t\t\tvec2 st1 = dFdy( vUv.st );\r\n\t\t\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\r\n\t\t\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\r\n\t\t\t\tvec3 N = normalize( vNormal_WS.xyz );\r\n\t\t\t#endif\r\n\r\n\t\t\t#ifdef PARALLAX_MAPPING\r\n\t\t\t\t\r\n\t\t\t\tconst float n = 6.0;\r\n\t\t\t\tvec3 eyeVector_TS = normalize(vec3( vTangent_WS.w, vBinormal_WS.w, vNormal_WS.w ));\r\n\t\t\t\tfloat step = 1.0 / n;\r\n\t\t\t\tvec2 dt = vec2(-1.0, 1.0) * eyeVector_TS.xy * parallaxScale / (n * eyeVector_TS.z);\r\n\t\t\t\tfloat height = 1.0;\r\n\t\t\t\tvec2 t = vec2(0.0, 0.0);\r\n\t\t\t\tfloat parallaxDepth = texture2D( normalTexture, vNormalUv ).a;\r\n\t\t\t\tfloat fragColorMult = 1.0;\r\n\t\t\t\tfloat darkeningAmount = parallaxScale * 35.0;\r\n\t\t\t\tbool isSet = false;\r\n\t\t\t\tfor ( float i = 0.0; i < n; i++ ) {\r\n\t\t\t\t\tif ( parallaxDepth > height && !isSet ) {\r\n\t\t\t\t\t\tisSet = true;\r\n\t\t\t\t\t\tuvOffset = t;\r\n\t\t\t\t\t\tfragColorMult -= darkeningAmount * 0.2 * i;\r\n\t\t\t\t\t}\r\n\t\t\t\t\theight -= step;\r\n\t\t\t\t\tt += dt; \r\n\t\t\t\t \tparallaxDepth = texture2D( normalTexture, vNormalUv + t ).a;\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t#endif\r\n\t\t  vec3 normalTex = texture2D( normalTexture, vNormalUv + uvOffset ).xyz;\r\n\t\t#endif\r\n\t#endif\r\n\t#if defined( DIFFUSE_COLOR ) && defined( DIFFUSE_TEXTURE )\r\n\t\tvec2 vDiffuseUv = mix( vUv.xy, vUv.zw, float(diffuseUVChannel));\r\n\t\tvDiffuseUv = vDiffuseUv * diffuseTextureScale + diffuseTextureOffset + uvOffset + diffuseTexturePan * time;\r\n\t\tvec4 diffuseTex = texture2D( diffuseTexture, vDiffuseUv );\r\n\t\t#ifdef GAMMA_INPUT\r\n\t\t  diffuseTex.xyz *= diffuseTex.xyz;\r\n\t\t#endif\r\n\t#endif\r\n\t#if !defined( DEPTH_PASS )\r\n\t\r\n\t\t#if defined( SPECULAR_COLOR ) && defined( SPECULAR_TEXTURE )\r\n\t\t  vec2 vSpecularUv = mix( vUv.xy, vUv.zw, float(specularUVChannel) );\r\n\t\t\tvSpecularUv = vSpecularUv * specularTextureScale + specularTextureOffset + uvOffset + specularTexturePan * time;\r\n\t\t\tvec4 specularTex = texture2D( specularTexture, vSpecularUv );\r\n\t\t\t#ifdef GAMMA_INPUT\r\n\t\t\t  specularTex *= specularTex;\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t\t#if defined( EMISSIVE_COLOR ) && defined( EMISSIVE_TEXTURE )\r\n\t\t\tvec2 vEmissiveUv = mix( vUv.xy, vUv.zw, float(emissiveUVChannel) );\r\n\t\t\tvEmissiveUv = vEmissiveUv * emissiveTextureScale + emissiveTextureOffset + uvOffset + emissiveTexturePan * time;\r\n\t\t\tvec3 emissiveTex = texture2D( emissiveTexture, vEmissiveUv ).xyz;\r\n\t\t\t#ifdef GAMMA_INPUT\r\n\t\t\t  emissiveTex *= emissiveTex;\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t\t#if defined( DIFFUSE_COLOR ) && defined( AO_TEXTURE )\r\n\t\t\tvec2 vAOUv = mix( vUv.xy, vUv.zw, float(aoUVChannel) );\r\n\t\t\tvAOUv = vAOUv * aoTextureScale + aoTextureOffset + uvOffset + aoTexturePan * time;\r\n\t\t\tvec3 aoTex = texture2D( aoTexture, vAOUv).xyz;\r\n\t\t#endif\r\n\t\t#if defined( SCATTERING ) && defined( SSS_TEXTURE )\r\n\t\t\tvec2 vSSSUv = mix( vUv.xy, vUv.zw, float(sssUVChannel) );\r\n\t\t\tvSSSUv = vSSSUv * sssTextureScale + sssTextureOffset + uvOffset + sssTexturePan * time;\r\n\t\t\tvec3 sssTex = texture2D( sssTexture, vSSSUv).xyz;\r\n\t\t\t#ifdef GAMMA_INPUT\r\n\t\t\t  sssTex *= sssTex;\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t\t\r\n\t\t#if defined( NORMAL_TEXTURE ) && defined( USE_LIGHTING )\r\n\t\t\t#if ( LIGHTING_MODEL == 1 )\r\n\t\t\t\tnormalTex.xy = normalTex.xy * 2.0 - 1.0;\r\n\t\t\r\n\t\t\t\tif ( normalTextureFlipY ) {\r\n\t\t\t  \tnormalTex *= vec3( 1.0, -1.0, 1.0 );\r\n\t\t\t  }\r\n\t\t\t  if ( normalTextureFlipX ) {\r\n\t\t\t  \tnormalTex *= vec3( -1.0, 1.0, 1.0 );\r\n\t\t\t  }\r\n\t\t\t\t\r\n\t\t\t\tnormalTex.xy *= normalScale;\r\n\t\t\t\t//normalTex = normalize( normalTex );\r\n\t\t\t\t\r\n\t\t\t\t//Transform the normal to view space so that we can do lighting calculations, sample the environment map, etc.\r\n\t\t\t\t#if defined( DISPLACEMENT_WITH_NORMAL )\r\n\t\t\t\t\tmat3 T2V_Transform = mat3( S, T, N );\r\n\t\t\t\t#else\r\n\t\t\t\t\tmat3 T2W_Transform = mat3( vTangent_WS.xyz, vBinormal_WS.xyz, vNormal_WS.xyz );\r\n\t\t\t\t#endif\r\n\t\t\t\tvec3 normal_WS = T2W_Transform * normalTex;\r\n\t\t\t\tnormal_WS = normalize( normal_WS );\r\n\t\t\t\t\r\n\t\t\t\t#ifdef LOCAL_SCATTERING\r\n\t\t\t\t\t// vec3 normal_Scatter = mix( normal_WS, normalize(vNormal_WS.xyz), clamp( scatterLocalScale, 0.0, 1.0 ) );\r\n\t\t\t\t\tvec3 normal_Scatter = normal_WS;\r\n\t\t\t\t#endif\r\n\t\t\t\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tvec3 normal_WS = normalize( vNormal_WS.xyz );\r\n\r\n\t\t\t#ifdef LOCAL_SCATTERING\r\n\t\t\t\tvec3 normal_Scatter = normal_WS;\r\n\t\t\t#endif\r\n\r\n\t\t#endif\r\n\r\n\t\t#if defined( USE_LIGHTING )\r\n\t\t\t// if ( renderModeNormals != 1 && doubleSidedLighting > 0 && dot(vNormal_WS.xyz, eyeVector_WS ) > 0.0 ) {\r\n\t\t\t// \tnormal_WS *= vec3( -1.0 );\r\n\t\t\t// }\r\n\t\t#endif\r\n\r\n\t\t#ifdef DOUBLE_SIDED\r\n\t\t\tnormal_WS = normal_WS * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n\t\t#endif\r\n\t\tfloat NdotV = dot( eyeVector_WS, normal_WS );\r\n\r\n\t\t#ifdef SPECULAR_COLOR\r\n\t\t\tfloat glossValue;\r\n\t\t\t#ifdef SPECULAR_TEXTURE\r\n\t\t\t\t#ifdef PHONG_SPECULAR\r\n\t\t\t\t\tglossValue = gloss * specularTex.a;\r\n\t\t\t\t#endif\r\n\r\n\t\t\t#elif defined(PHONG_SPECULAR)\r\n\t\t\t\tglossValue = gloss;\r\n\t\t\t#endif\r\n\t\t#endif\r\n\r\n\t\t#ifdef REFLECTIONS\r\n\t\t\tfloat mipBias = 0.0;\r\n\t\t\t#ifdef SPECULAR_COLOR\r\n\t\t\t\tfloat numMips = float(ENVMAP_NUM_MIPS);\r\n\t\t\t\t// mipBias = pow((-numMips * glossValue + numMips) / numMips, 2.0) * numMips;\r\n\t\t\t\tmipBias = (-numMips * glossValue + numMips) * 0.7;\r\n\t\t\t#endif\r\n\t\t\tvec3 cameraToVertex = normalize( vPosition_WS.xyz - cameraPosition );\r\n\t\t\tvec3 vReflectWorldSpace = reflect( cameraToVertex, normal_WS );\r\n\t\t\t//Cube map reflection\r\n\t\t\t#if ( REFLECTIONS == 0 )\r\n\t\t\t\tvec4 reflectedColor = textureCube( environmentTexture, vec3( vReflectWorldSpace.x, vReflectWorldSpace.yz), mipBias );\r\n\t\t\t//Sphere map reflection\r\n\t\t\t#elif ( REFLECTIONS == 1 )\r\n\t\t\t\tvec4 reflectedColor = texture2D( environmentTexture2D, vReflectWorldSpace.xy * vec2( 0.5, -0.5 ) + 0.5, mipBias );\r\n\t\t\t//Planar reflection\r\n\t\t\t#elif ( REFLECTIONS == 2 )\r\n\r\n\t\t\t\tvec2 distort = (viewMatrix * vec4( normal_WS - vNormal_WS.xyz, 0.0 )).xy * -0.01;\r\n\t\t\t\tvec4 reflectedColor = texture2D( environmentTexture2D, vec2(-1.0, 1.0) * (gl_FragCoord.xy - screenDimensions.xy) / screenDimensions.zw + distort, mipBias );\r\n\t\t\t//Equirectangular reflection\r\n\t\t\t#elif ( REFLECTIONS == 3 )\r\n\t\t\t\tvec2 sampleUV;\r\n        sampleUV.y = clamp( vReflectWorldSpace.y * -0.5 + 0.5, 0.0, 1.0);\r\n        \r\n      \tsampleUV.x = atan( vReflectWorldSpace.z, vReflectWorldSpace.x ) * 0.15915494309189533576888376337251 + 0.5; // reciprocal( 2 PI ) + 0.5\r\n        \t\r\n        vec4 reflectedColor = texture2D( environmentTexture2D, sampleUV, mipBias );\t\r\n        \r\n\t\t\t#endif\r\n\r\n\t\t\t#if defined( ENVMAP_HDR_INPUT )\r\n\t\t\t\t#if ( ENVMAP_HDR_INPUT == HDR_TYPE_RGBM )\r\n\t\t\t\t\treflectedColor.xyz = HDRDecodeRGBM( reflectedColor );\r\n\t\t\t\t#elif ( ENVMAP_HDR_INPUT == HDR_TYPE_RGBD )\r\n\t\t\t\t\treflectedColor.xyz = HDRDecodeRGBD( reflectedColor );\r\n\t\t\t\t#elif ( ENVMAP_HDR_INPUT == HDR_TYPE_RGBE )\r\n\t\t\t\t\treflectedColor.xyz = HDRDecodeRGBE( reflectedColor );\r\n\t\t\t\t#elif ( ENVMAP_HDR_INPUT == HDR_TYPE_LOGLUV )\r\n\t\t\t\t\treflectedColor.xyz = HDRDecodeLOGLUV( reflectedColor );\r\n\t\t\t\t#else\r\n\t\t\t\t\t//TODO - gamma should be an option per texture. Currently, though, if the texture is HDR, it\'s assumed to be in linear space\r\n\t\t\t\t\t// #ifdef GAMMA_INPUT\r\n\t\t\t\t\t\t// reflectedColor.xyz *= reflectedColor.xyz;\r\n\t\t\t\t\t// #endif\r\n\t\t\t\t#endif\r\n\t\t\t#elif\r\n\t\t\t\t#ifdef GAMMA_INPUT\r\n\t\t\t\t\treflectedColor.xyz *= reflectedColor.xyz;\r\n\t\t\t\t#endif\r\n\t\t\t#endif\r\n\t\t\t\r\n\r\n\t\t#elif defined( IRIDESCENT_LAYER ) && defined( IRIDESCENT_TEXTURE )\r\n\t\t\tvec3 cameraToVertex = normalize( vPosition_WS.xyz - cameraPosition );\r\n\t\t\tvec3 vReflectWorldSpace = reflect( cameraToVertex, normal_WS );\r\n\t\t#endif\r\n\r\n\t\t//After using glossValue in reflection calculation, nudge it down a bit to avoid infinitely small point-highlights when gloss == 1.0\r\n\t\t#ifdef SPECULAR_COLOR\r\n\t\t\tglossValue -= 0.05;\r\n\t\t#endif\r\n\r\n\t\t#ifdef REFLECTIONS\r\n\t\t\t// float reflectionFactor = reflectionBias * reflectionBias;\r\n\t\t\t// reflectionFactor *= (1.0 - abs( reflectionBias ));\r\n\t\t\t// reflectionFactor = reflectionFactor + clamp( reflectionBias, 0.0, 1.0);\r\n\t\t\t// reflectionFactor = reflectionBias;\r\n\t\t\t// #if defined(SPECULAR_COLOR) && defined( SPECULAR_TEXTURE )\r\n\t\t\t// \treflectionFactor *= sqrt( specularTex.a );\r\n\t\t\t// #endif\r\n\t\t#endif\r\n\r\n\t\t#ifdef IRIDESCENT_LAYER\r\n\t\t\tfloat twoToneFactor = pow( abs(NdotV), twoToneExponent );\r\n\t\t\t#ifdef IRIDESCENT_TEXTURE\r\n\t\t\t\tvec3 iridescentTex = texture2D( iridescentTexture, vec2(twoToneFactor, vReflectWorldSpace.y * 0.5 + 0.5)).xyz;\r\n\t\t\t\t#ifdef GAMMA_INPUT\r\n\t\t\t\t\tiridescentTex *= iridescentTex;\r\n\t\t\t\t#endif\r\n\t\t\t\tvec3 baseColor = mix( diffuseColor, diffuseColor2, twoToneFactor ) * iridescentTex;\r\n\t\t\t#else\r\n\t\t\t\tvec3 baseColor = mix( diffuseColor, diffuseColor2, twoToneFactor );\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tvec3 baseColor = diffuseColor;\r\n\t\t#endif\r\n\r\n\t\t#if defined( USE_COLOR ) && defined( DIFFUSE_COLOR )\r\n\t\t\t//baseColor *= vec3( vPosition_WS.w, vPosition_SS.zw );\r\n\t\t\tbaseColor *= vColor;\r\n\t\t#endif\r\n\r\n\r\n\t\t#if defined( DIFFUSE_COLOR ) && defined( DIFFUSE_TEXTURE )\r\n\t\t\tvec3 diffuseColorValue = diffuseTex.xyz;\r\n\t\t\t#ifdef ALPHA_BLENDMODE\r\n\t\t\t\t#if ( ALPHA_BLENDMODE == 1 )\r\n\t\t\t\t\tif ( colorBlend != 0 ) {\r\n\t\t\t\t\t\tdiffuseColorValue = diffuseTex.xyz * baseColor;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tdiffuseColorValue = mix( baseColor, diffuseTex.xyz, diffuseTex.a);\r\n\t\t\t\t\t}\r\n\t\t\t\t#else\r\n\t\t\t\t\tdiffuseColorValue = diffuseTex.xyz * baseColor;\r\n\t\t\t\t#endif\r\n\t\t\t\t\t\r\n\t\t\t\t#if defined( ALPHATEST )\r\n\t\t\t\t\t#if ( ALPHA_BLENDMODE == 2 )\r\n\t\t\t\t\t\tif ( diffuseTex.a < float(ALPHATEST) ) discard;\r\n\t\t\t\t\t#endif\r\n\t\t\t\t#endif\r\n\t\t\t#endif\r\n\t\t\tfloat textureOpacity = clamp( float( alphaBlendMode ) + diffuseTex.a, 0.0, 1.0);\r\n\t\t\tfloat colorOpacityValue = colorOpacity * textureOpacity;\r\n\t\t#elif defined( DIFFUSE_COLOR )\r\n\t\t\tvec3 diffuseColorValue = baseColor;\r\n\t\t\tfloat colorOpacityValue = colorOpacity;\r\n\t\t#endif\r\n\t#endif //(#if !defined( DEPTH_PASS ))\r\n\t#if defined( DEPTH_PASS )\r\n\t\t#if defined( DIFFUSE_TEXTURE ) && defined( ALPHATEST )\r\n\t\t\t#if ( ALPHA_BLENDMODE == 2 )\r\n\t\t\t\tif ( diffuseTex.a < float(ALPHATEST) ) {\r\n\t\t\t\t\tdiscard;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tgl_FragColor = pack_depth( gl_FragCoord.z );\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tgl_FragColor = pack_depth( gl_FragCoord.z );\r\n\t\t#endif\r\n\t\t\r\n\t#else\r\n\t\t\r\n\t\t#if defined( SPECULAR_COLOR ) && defined( SPECULAR_TEXTURE )\r\n\t\t\tvec3 specularColorValue = specularTex.xyz * specularColor;\r\n\t\t#elif defined( SPECULAR_COLOR )\r\n\t\t\tvec3 specularColorValue = specularColor;\r\n\t\t#endif\r\n\r\n\t\tfloat totalOpacityValue = opacity;\r\n\r\n\t\t#ifdef SCATTERING\r\n\t\t\t#ifdef SSS_TEXTURE\r\n\t\t\t\tvec3 scatterColorValue = scatterColor * sssTex;\r\n\t\t\t#else\r\n\t\t\t\tvec3 scatterColorValue = scatterColor;\r\n\t\t\t#endif\r\n\t\t\t#ifdef LOCAL_SCATTERING\r\n\t\t\t\tscatterColorValue *= scatterLocalScale * 0.5;\r\n\t\t\t#endif\r\n\t\t#endif\r\n\r\n\t\t\r\n\t\tvec3 totalDiffuse = vec3( 0.0, 0.0, 0.0 );\r\n\t\tvec3 totalSpecular = vec3( 0.0 );\r\n\t\tvec3 totalScatter = vec3( 0.0 );\r\n\r\n\t\t#ifdef USE_LIGHTING\r\n\r\n\t\t\t#ifdef USE_SHADOWMAP\r\n\t\t\t\t#if MAX_SHADOWS > 0 && ( defined( DIFFUSE_COLOR ) || defined( SPECULAR_COLOR ) )\r\n\t\t\t\t\tfloat shadowValues[ MAX_DIR_LIGHTS ];\r\n\t\t\t\t\t#ifdef TRANSLUCENT_SCATTERING\r\n\t\t\t\t\t\tfloat shadowValuesScatter[ MAX_DIR_LIGHTS ];\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\t#ifdef SHADOWMAP_DEBUG\r\n\t\t\t\t\t\tvec3 shadowColour = vec3(1.0);\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor( int s = 0; s < MAX_DIR_LIGHTS; s ++ ) {\r\n\t\t\t\t\t\tshadowValues[ s ] = 1.0;\r\n\t\t\t\t\t\t#ifdef TRANSLUCENT_SCATTERING\r\n\t\t\t\t\t\t\tshadowValuesScatter[ s ] = 1.0;\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t} \r\n\t\t\t\t\t\r\n\t\t\t\t\t#ifdef SHADOWMAP_DEBUG\r\n\r\n\t\t\t\t\t\tvec3 frustumColors[3];\r\n\t\t\t\t\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\r\n\t\t\t\t\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\r\n\t\t\t\t\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t#ifdef SHADOWMAP_CASCADE\r\n\r\n\t\t\t\t\t\tint inFrustumCount = 0;\r\n\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\r\n\t\t\t\t\tfloat fDepth;\r\n\t\t\t\t\t//int lightIndex = 0;\r\n\t\t\t\t\tint frustumIndex = 0;\r\n\r\n\t\t\t\t\tfor( int s = 0; s < MAX_SHADOWS; s ++ ) {\r\n\r\n\t\t\t\t\t\tvec3 shadowCoord = vShadowCoord[ s ].xyz / vShadowCoord[ s ].w;\r\n\t\t\t\t\t\t// "if ( something && something )" \t\t breaks ATI OpenGL shader compiler\r\n\t\t\t\t\t\t// "if ( all( something, something ) )"  using this instead\r\n\r\n\t\t\t\t\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\t\t\t\t\tbool inFrustum = all( inFrustumVec );\r\n\r\n\t\t\t\t\t\t// don\'t shadow pixels outside of light frustum\r\n\t\t\t\t\t\t// use just first frustum (for cascades)\r\n\t\t\t\t\t\t// don\'t shadow pixels behind far plane of light frustum\r\n\r\n\t\t\t\t\t\t#ifdef SHADOWMAP_CASCADE\r\n\r\n\t\t\t\t\t\t\tinFrustumCount += int( inFrustum );\r\n\t\t\t\t\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\tbool frustumTest = all( frustumTestVec );\r\n\r\n\t\t\t\t\t\tif ( frustumTest ) {\r\n\r\n\t\t\t\t\t\t\tshadowCoord.z += shadowBias[ s ];\r\n\r\n\t\t\t\t\t\t\t#ifdef SHADOWMAP_TYPE_PCF_SOFT\r\n\r\n\t\t\t\t\t\t\t\t// Percentage-close filtering\r\n\t\t\t\t\t\t\t\t// (9 pixel kernel)\r\n\t\t\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\r\n\r\n\t\t\t\t\t\t\t\tfloat shadow = 0.0;\r\n\r\n\r\n\t\t\t\t\t\t\t\t//const float shadowDelta = 1.0 / 9.0;\r\n\t\t\t\t\t\t\t\t//const float kernelCornerWeight = 1.0 / 16.0;\r\n\t\t\t\t\t\t\t\t//const float kernelEdgeWeight = 1.0 / 8.0;\r\n\r\n\t\t\t\t\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ s ].x;\r\n\t\t\t\t\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ s ].y;\r\n\r\n\t\t\t\t\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\r\n\t\t\t\t\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\r\n\t\t\t\t\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\r\n\t\t\t\t\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\r\n\r\n\t\t\t\t\t\t\t\tmat3 shadowKernel;\r\n\t\t\t\t\t\t\t\tmat3 depthKernel;\r\n\r\n\t\t\t\t\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\r\n\t\t\t\t\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\r\n\t\t\t\t\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\r\n\t\t\t\t\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\r\n\t\t\t\t\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy ) );\r\n\t\t\t\t\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\r\n\t\t\t\t\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\r\n\t\t\t\t\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\r\n\t\t\t\t\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\r\n\r\n\t\t\t\t\t\t\t\t// depthKernel[0][0] = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx0, dy0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// depthKernel[0][1] = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx0, 0.0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// depthKernel[0][2] = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx0, dy1 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// depthKernel[1][0] = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( 0.0, dy0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// depthKernel[1][1] = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy, 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// depthKernel[1][2] = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( 0.0, dy1 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// depthKernel[2][0] = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx1, dy0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// depthKernel[2][1] = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx1, 0.0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// depthKernel[2][2] = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx1, dy1 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\r\n\t\t\t\t\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\r\n\t\t\t\t\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\r\n\t\t\t\t\t\t\t\tshadowKernel[0] *= vec3(0.25);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\r\n\t\t\t\t\t\t\t\tshadowKernel[1] *= vec3(0.25);\r\n\r\n\t\t\t\t\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\r\n\t\t\t\t\t\t\t\tshadowKernel[2] *= vec3(0.25);\r\n\r\n\t\t\t\t\t\t\t\tvec2 fractionalCoord = 1.0 - fract(shadowCoord.xy * shadowMapSize[s].xy );\r\n\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\r\n\t\t\t\t\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\r\n\r\n\t\t\t\t\t\t\t\tvec4 shadowValueVector;\r\n\t\t\t\t\t\t\t\tshadowValueVector.x = mix(shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\r\n\t\t\t\t\t\t\t\tshadowValueVector.y = mix(shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\r\n\t\t\t\t\t\t\t\tshadowValueVector.z = mix(shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\r\n\t\t\t\t\t\t\t\tshadowValueVector.w = mix(shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\r\n\r\n\t\t\t\t\t\t\t\tshadow = dot(shadowValueVector, vec4(1.0));\r\n\r\n\t\t\t\t\t\t\t\t#ifdef SHADOWMAP_CASCADE\r\n\t\t\t\t\t\t\t\t\tshadowValues[ 0 ] *= (1.0 - shadow);\r\n\t\t\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\t\t\tshadowValues[ s ] = (1.0 - shadow);\r\n\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t\t#ifdef TRANSLUCENT_SCATTERING\r\n\t\t\t\t\t\t\t\t\tdepthKernel[0] = mix( depthKernel[1], depthKernel[0], fractionalCoord.x );\r\n\t\t\t\t\t\t\t\t\tdepthKernel[1] = mix( depthKernel[2], depthKernel[1], fractionalCoord.x );\r\n\r\n\t\t\t\t\t\t\t\t\tvec4 depthValues;\r\n\t\t\t\t\t\t\t\t\tdepthValues.x = mix(depthKernel[0][1], depthKernel[0][0], fractionalCoord.y );\r\n\t\t\t\t\t\t\t\t\tdepthValues.y = mix(depthKernel[0][2], depthKernel[0][1], fractionalCoord.y );\r\n\t\t\t\t\t\t\t\t\tdepthValues.z = mix(depthKernel[1][1], depthKernel[1][0], fractionalCoord.y );\r\n\t\t\t\t\t\t\t\t\tdepthValues.w = mix(depthKernel[1][2], depthKernel[1][1], fractionalCoord.y );\r\n\t\t\t\t\t\t\t\t\tfloat totalDepth = dot(depthValues, vec4(1.0));// + dot(depthKernel[1], vec3(1.0)) + dot(depthKernel[2], vec3(1.0));\r\n\t\t\t\t\t\t\t\t\tfloat depthAvg = totalDepth / 4.0;\r\n\t\t\t\t\t\t\t\t\tfloat exponent = (shadowCoord.z - depthAvg ) * shadow;\r\n\t\t\t\t\t\t\t\t\t// exponent = clamp(exponent, 0.0, 100.0);\r\n\t\t\t\t\t\t\t\t\t// exponent = -pow(exponent * (1.0 - scatterScale) * 1000.0, 2.0);\r\n\t\t\t\t\t\t\t\t\t// shadowValuesScatter[ s ] = exp2( exponent );\r\n\t\t\t\t\t\t\t\t\texponent = clamp(exponent, 0.0, 1000.0) * 1000.0;\r\n\t\t\t\t\t\t\t\t\tshadowValuesScatter[ s ] = exp( (scatterScale - 1.0) * exponent );\r\n\t\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t#elif defined( SHADOWMAP_TYPE_PCF )\r\n\r\n\t\t\t\t\t\t\t\tfloat shadow = 0.0;\r\n\t\t\t\t\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\r\n\r\n\t\t\t\t\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ s ].x;\r\n\t\t\t\t\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ s ].y;\r\n\r\n\t\t\t\t\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\r\n\t\t\t\t\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\r\n\t\t\t\t\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\r\n\t\t\t\t\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\r\n\r\n\t\t\t\t\t\t\t\tfloat totalDepth = 0.0;\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tfDepth = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx0, dy0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// fDepth = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\r\n\t\t\t\t\t\t\t\ttotalDepth += fDepth;\r\n\r\n\t\t\t\t\t\t\t\tfDepth = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( 0.0, dy0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// fDepth = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\r\n\t\t\t\t\t\t\t\ttotalDepth += fDepth;\r\n\r\n\t\t\t\t\t\t\t\tfDepth = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx1, dy0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// fDepth = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\r\n\t\t\t\t\t\t\t\ttotalDepth += fDepth;\r\n\r\n\t\t\t\t\t\t\t\tfDepth = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx0, 0.0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// fDepth = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\r\n\t\t\t\t\t\t\t\ttotalDepth += fDepth;\r\n\r\n\t\t\t\t\t\t\t\tfDepth = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy, 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// fDepth = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy ) );\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\r\n\t\t\t\t\t\t\t\ttotalDepth += fDepth;\r\n\r\n\t\t\t\t\t\t\t\tfDepth = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx1, 0.0 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// fDepth = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\r\n\t\t\t\t\t\t\t\ttotalDepth += fDepth;\r\n\r\n\t\t\t\t\t\t\t\tfDepth = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx0, dy1 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// fDepth = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\r\n\t\t\t\t\t\t\t\ttotalDepth += fDepth;\r\n\r\n\t\t\t\t\t\t\t\tfDepth = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( 0.0, dy1 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// fDepth = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\r\n\t\t\t\t\t\t\t\ttotalDepth += fDepth;\r\n\r\n\t\t\t\t\t\t\t\tfDepth = unpackDepth( texture2DProj( shadowMap[ s ], vec4( shadowCoord.xy + vShadowCoord[ s ].w * vec2( dx1, dy1 ), 0.05, vShadowCoord[ s ].w ) ) );\r\n\t\t\t\t\t\t\t\t// fDepth = unpackDepth( texture2D( shadowMap[ s ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\r\n\t\t\t\t\t\t\t\ttotalDepth += fDepth;\r\n\r\n\t\t\t\t\t\t\t\t#ifdef SHADOWMAP_CASCADE\r\n\t\t\t\t\t\t\t\t\tshadowValues[ 0 ] *= (1.0 - shadow);\r\n\t\t\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\t\t\tshadowValues[ s ] = (1.0 - shadow);\r\n\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t\t#ifdef TRANSLUCENT_SCATTERING\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tfloat depthAvg = totalDepth / 9.0;\r\n\t\t\t\t\t\t\t\t\tfloat exponent = (shadowCoord.z - depthAvg ) * shadow;\r\n\t\t\t\t\t\t\t\t\t// exponent = clamp(exponent, 0.0, 10000.0);\r\n\t\t\t\t\t\t\t\t\t// exponent = -pow(exponent * (1.0 - scatterScale) * 100.0, 2.0);\r\n\t\t\t\t\t\t\t\t\t// shadowValuesScatter[ s ] = exp2( exponent );\r\n\t\t\t\t\t\t\t\t\texponent = clamp(exponent, 0.0, 1000.0) * 1000.0;\r\n\t\t\t\t\t\t\t\t\tshadowValuesScatter[ s ] = exp( (scatterScale - 1.0) * exponent );\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\tvec4 rgbaDepth = texture2DProj( shadowMap[ s ], vec4( vShadowCoord[ s ].w * ( shadowCoord.xy ), 0.05, vShadowCoord[ s ].w ) );\r\n\t\t\t\t\t\t\t\t// vec4 rgbaDepth = texture2D( shadowMap[ s ], shadowCoord.xy );\r\n\t\t\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\r\n\r\n\t\t\t\t\t\t\t\tif ( fDepth < shadowCoord.z ) {\r\n\r\n\t\t\t\t\t\t\t\t\t#ifdef SHADOWMAP_CASCADE\r\n\t\t\t\t\t\t\t\t\t\tshadowValues[ 0 ] *= 0.0;\r\n\t\t\t\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\t\t\t\tshadowValues[ s ] = 0.0;\r\n\t\t\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tshadowValues[ s ] = 1.0;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t#ifdef TRANSLUCENT_SCATTERING\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tfloat exponent = (shadowCoord.z - fDepth );\r\n\t\t\t\t\t\t\t\t\texponent = clamp(exponent, 0.0, 1000.0) * 1000.0;\r\n\t\t\t\t\t\t\t\t\tshadowValuesScatter[ s ] = exp( (scatterScale - 1.0) * exponent );\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tshadowValues[ s ] = 1.0;\r\n\t\t\t\t\t\t\t#ifdef TRANSLUCENT_SCATTERING\r\n\t\t\t\t\t\t\t\tshadowValuesScatter[ s ] = 1.0;\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t#ifdef SHADOWMAP_DEBUG\r\n\r\n\t\t\t\t\t\t\t#ifdef SHADOWMAP_CASCADE\r\n\r\n\t\t\t\t\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) shadowColour = frustumColors[ s ];\r\n\r\n\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\tif ( inFrustum ) shadowColour = frustumColors[ s ];\r\n\r\n\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t//frustumIndex ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\t\t\t#endif\r\n\t\t\t#if ( LIGHTING_MODEL == 1 )\r\n\t\t\t\t// point lights\r\n\r\n\t\t\t\t#if MAX_POINT_LIGHTS > 0\r\n\r\n\t\t\t\t\tvec3 pointDiffuse;\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor ( int p = 0; p < MAX_POINT_LIGHTS; p ++ ) {\r\n\r\n\t\t\t\t\t\t//Do distance calculation in world space because pointLightDistance[] is in world space\r\n\t\t\t\t\t\tvec3 pointVector_WS = pointLightPosition[ p ] - vPosition_WS.xyz;\r\n\t\t\t\t\t\tfloat pointVecLength = length( pointVector_WS );\r\n\t\t\t\t\t\tfloat pointDistance = 1.0 - clamp( ( pointVecLength / pointLightDistance[ p ] ), 0.0, 1.0 );\r\n\t\t\t\t\t\t// float pointDistance = 1.0 / dot( pointVector_WS, pointVector_WS );\r\n\t\t\t\t\t\tpointVector_WS /= pointVecLength;\r\n\t\t\t\t\t\t// vec3 pointVector_WS = normalize((viewMatrix * vec4( pointVector_WS, 0.0 )).xyz);\r\n\r\n\t\t\t\t\t\tpointDiffuse = vec3( 0.0 );\r\n\t\t\t\t\t\tfloat diffuseWeight;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tfloat NdotL = dot( normal_WS, pointVector_WS );\r\n\t\t\t\t\t\tfloat NdotL_sat = clamp( NdotL, 0.0, 1.0);\r\n\t\t\t\t\t\t//CALC DIFFUSE\r\n\t\t\t\t\t\t#ifdef LOCAL_SCATTERING\r\n\t\t\t\t\t\t\tfloat scatterWeight;\r\n\t\t\t\t\t\t\tcalculateLocalScattering( pointVector_WS, NdotL, diffuseWeight, normal_Scatter, scatterWeight );\r\n\t\t\t\t\t\t#elif defined( TRANSLUCENT_SCATTERING )\r\n\t\t\t\t\t\t\tfloat scatterWeight = 1.0;//scatterScale;\r\n\t\t\t\t\t\t\tdiffuseWeight = clamp( NdotL, 0.0, 1.0 );\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tdiffuseWeight = clamp( NdotL, 0.0, 1.0 );\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t    #if defined( PHONG_SPECULAR ) || defined( IRIDESCENT_LAYER )\r\n\t\t\t\t   \t\tvec3 h = pointVector_WS + eyeVector_WS;\r\n\t\t\t\t\t\t\tvec3 H = normalize( h );\r\n\t\t\t\t\t\t\tfloat NdotH = dot( normal_WS, H );\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t#ifdef DIFFUSE_COLOR\r\n\t\t\t    \t\tpointDiffuse = vec3(diffuseWeight);\r\n\t\t\t    \t#endif\r\n\r\n\t\t\t\t\t\t#ifdef IRIDESCENT_LAYER\r\n\t\t\t\t\t\t\tfloat pointMetallicWeight = pow( clamp( NdotH, 0.0, 1.0), metallicExponent ) * NdotL_sat;\r\n\t\t\t\t\t\t\tpointDiffuse += pointMetallicWeight * metallicMultiplier;\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t#ifdef DIFFUSE_COLOR\r\n\t\t\t    \t\tpointDiffuse *= diffuseColorValue;\r\n\t\t\t    \t#endif\r\n\r\n\t\t\t\t\t\t#if defined( SCATTERING )\r\n\t\t\t\t\t\t\t// pointDiffuse = scatterWeight * scatterColorValue + pointDiffuse;\r\n\t\t\t\t\t\t\ttotalScatter += scatterWeight * scatterColorValue + pointDiffuse;\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t#ifdef SPECULAR_COLOR\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// #if defined( PHONG_SPECULAR_SIMPLE )\r\n\t\t\t\t\t\t\t// \tfloat normalisation_term = glossValue * 0.125 + 0.25;\r\n\t\t\t\t\t\t\t// \tfloat specPower = pow( 8192.0, glossValue );\r\n\t\t\t\t\t\t\t// \tfloat specWeight = pow( clamp( NdotH, 0.0, 1.0), specPower ) * normalisation_term;\r\n\t\t\t\t\t\t\t// \ttotalSpecular = (specularColorValue * pointLightColor[ p ]) * specWeight + totalSpecular;\r\n\r\n\t\t\t\t\t\t\t// #elif defined( PHONG_SPECULAR )\r\n\t\t\t\t\t\t\t// \tfloat HdotL = dot( H, pointVector_WS );\r\n\t\t\t\t\t\t\t// \tvec3 specWeight = calculateBlinnPhong( NdotH, NdotL_sat, HdotL, NdotV, glossValue, specularColorValue );\r\n\t\t\t\t\t\t\t// \ttotalSpecular = ( pointLightColor[ p ] * (specWeight * pointDistance) ) + totalSpecular;\r\n\t\t\t\t\t\t\t// #endif\r\n\r\n\t\t\t\t\t\t\t#if defined( PHONG_SPECULAR_SIMPLE )\r\n\t\t\t\t\t\t\t\tfloat specPower = pow( 8192.0, glossValue );\r\n\t\t\t\t\t\t\t\tvec3 specWeight = specularColorValue * 20.0 * max( pow( NdotH, specPower ), 0.0 ) * NdotL_sat * glossValue;\r\n\r\n\t\t\t\t\t\t\t#elif defined( PHONG_SPECULAR )\r\n\t\t\t\t\t\t\t\tfloat HdotL = dot( H, pointVector_WS );\r\n\t\t\t\t\t\t\t\t// #ifdef REFLECTIONS\r\n\t\t\t\t\t\t\t\t// \tvec3 specWeight = specularColorValue * SpecularFuncGGX( 1.01 - glossValue, NdotH, HdotL, NdotL );\r\n\t\t\t\t\t\t\t\t// #else\r\n\t\t\t\t\t\t\t\t\tvec3 specWeight = specularColorValue * SpecularFuncGGX( 1.01 - glossValue, NdotH, HdotL, NdotL );\r\n\t\t\t\t\t\t\t\t// #endif\r\n\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t\ttotalSpecular = pointLightColor[ p ] * specWeight * pointDistance + totalSpecular;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t#ifdef RIM_LIGHTING\r\n\t\t    \t\t\r\n\t\t\t    \t\tfloat rimPow = clamp( 1.0 - abs( NdotV ), 0.0, 1.0 );\r\n\t\t\t    \t\tfloat VdotL = dot( -eyeVector_WS, pointVector_WS );\r\n\t\t\t    \t\trimPow *= clamp( VdotL, 0.0, 1.0 );\r\n\t\t\t    \t\trimPow = pow( rimPow, rimPower );\r\n\r\n\t\t\t    \t\tpointDiffuse = rimPow * rimColor + pointDiffuse;\r\n\r\n\t\t\t    \t#endif\r\n\r\n\r\n\t\t\t    \tpointDiffuse *= pointDistance * pointLightColor[ p ];\r\n\r\n\t\t\t    \ttotalDiffuse += pointDiffuse;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t\r\n\t\t\t\t// directional lights\r\n\r\n\t\t\t\t#if MAX_DIR_LIGHTS > 0\r\n\r\n\t\t\t    for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvec3 lightDirection_WS = directionalLightDirection[ i ].xyz;\r\n\t\t\t\t\t\tfloat shadowValue = 1.0;\r\n\t\t\t\t\t\tfloat shadowValueScatter = 1.0;\r\n\t\t\t\t\t\t// vec3 dirDiffuse = vec3(0.0);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t#if defined( USE_SHADOWMAP ) && (MAX_SHADOWS > 0) && ( defined( DIFFUSE_COLOR ) || defined( SPECULAR_COLOR ) )\r\n\r\n\t\t\t\t\t\t\tshadowValue = shadowValues[ i ];\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t#if defined( USE_SHADOWMAP ) && (MAX_SHADOWS > 0)\r\n\t\t\t\t\t\t\t#ifdef TRANSLUCENT_SCATTERING \r\n\t\t\t\t\t\t\t\tshadowValueScatter = shadowValuesScatter[ i ];\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\tfloat diffuseWeight;\r\n\r\n\t\t\t\t\t\tfloat NdotL = dot( normal_WS, lightDirection_WS );\r\n\t\t\t\t\t\tfloat NdotL_sat = clamp( NdotL, 0.0, 1.0);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//CALC DIFFUSE\r\n\t\t\t\t\t\t#ifdef LOCAL_SCATTERING\r\n\t\t\t\t\t\t\tfloat scatterWeight;\r\n\t\t\t\t\t\t\tcalculateLocalScattering( lightDirection_WS, NdotL, diffuseWeight, normal_Scatter, scatterWeight );\r\n\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tdiffuseWeight = NdotL_sat;\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\r\n\r\n\t\t\t\t\t\t#ifdef TRANSLUCENT_SCATTERING \r\n\t\t\t\t\t\t\t// totalDiffuse += shadowValueScatter * scatterColorValue * directionalLightColor[ i ];\r\n\t\t\t\t\t\t\ttotalScatter += shadowValueScatter * scatterColorValue * directionalLightColor[ i ];\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t#if defined( LOCAL_SCATTERING )\r\n\t\t\t\t\t\t\t// totalDiffuse += scatterWeight * scatterColorValue * directionalLightColor[ i ];\r\n\t\t\t\t\t\t\ttotalScatter += scatterWeight * scatterColorValue * directionalLightColor[ i ];\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t#if defined( PHONG_SPECULAR ) || defined( IRIDESCENT_LAYER )\r\n\t\t\t\t   \t\tvec3 h = lightDirection_WS + eyeVector_WS;\r\n\t\t\t\t\t\t\tvec3 H = normalize( h );\r\n\t\t\t\t\t\t\tfloat NdotH = dot( normal_WS, H );\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t#ifdef SPECULAR_COLOR\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t#if defined( PHONG_SPECULAR_SIMPLE )\r\n\t\t\t\t\t\t\t\tfloat specPower = pow( 8192.0, glossValue );\r\n\t\t\t\t\t\t\t\tvec3 specWeight = specularColorValue * 20.0 * max( pow( NdotH, specPower ), 0.0 ) * NdotL_sat * glossValue;\r\n\r\n\t\t\t\t\t\t\t#elif defined( PHONG_SPECULAR )\r\n\t\t\t\t\t\t\t\tfloat HdotL = dot( H, lightDirection_WS );\r\n\t\t\t\t\t\t\t\t// #ifdef REFLECTIONS\r\n\t\t\t\t\t\t\t\t// \tvec3 specWeight = specularColorValue * SpecularFuncGGX( 1.01 - glossValue, NdotH, HdotL, NdotL, NdotV, reflectionFactor );\r\n\t\t\t\t\t\t\t\t// #else\r\n\t\t\t\t\t\t\t\t\tvec3 specWeight = specularColorValue * SpecularFuncGGX( 1.01 - glossValue, NdotH, HdotL, NdotL );\r\n\t\t\t\t\t\t\t\t// #endif\r\n\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t\ttotalSpecular = (directionalLightColor[ i ]) * (specWeight * shadowValue * specularIntensity) + totalSpecular;\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t   \t\r\n\t\t\t\t\t\t#ifdef DIFFUSE_COLOR\r\n\t\t\t\t\t\t\tvec3 diffuse = vec3(diffuseWeight);\r\n\t\t\t\t\t\t\t#ifdef IRIDESCENT_LAYER\r\n\t\t\t\t\t\t\t\tfloat dirMetallicWeight = pow( clamp( NdotH, 0.0, 1.0), metallicExponent ) * NdotL_sat;\r\n\t\t\t\t\t\t\t\tdiffuse += dirMetallicWeight * metallicMultiplier;\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t\tdiffuse *= diffuseColorValue * directionalLightColor[ i ] * shadowValue;\r\n\r\n\t\t\t\t\t\t\ttotalDiffuse += diffuse;\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t#ifdef RIM_LIGHTING\r\n\t\t    \t\t\r\n\t\t\t    \t\tfloat rimPow = clamp( 1.0 - abs( NdotV ), 0.0, 1.0 );\r\n\r\n\t\t\t    \t\t//float diffuseWeightHalf = max( 0.5 * NdotL + 0.5, 0.0 );\r\n\t\t\t    \t\t//float rimPow = mix( diffuseWeight, diffuseWeightHalf, rimPower );\r\n\t\t\t    \t\tfloat VdotL = dot( -eyeVector_WS, lightDirection_WS );\r\n\t\t\t    \t\trimPow *= clamp( VdotL, 0.0, 1.0 );\r\n\t\t\t    \t\trimPow = pow( rimPow, rimPower );\r\n\r\n\t\t\t    \t\t#ifdef DIFFUSE_COLOR\r\n\t\t\t    \t\t\ttotalDiffuse += rimPow * rimColor * diffuseColorValue * directionalLightColor[ i ];\r\n\t\t\t    \t\t#else\r\n\t\t\t\t\t\t\t\ttotalDiffuse += rimPow * rimColor * directionalLightColor[ i ];\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t    \t#endif\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t#if defined( USE_SHADOWMAP ) && defined( SHADOWMAP_DEBUG )\r\n\t\t\t\t\t\t\t#ifdef DIFFUSE_COLOR\r\n\t\t\t\t\t\t\t\ttotalDiffuse *= shadowColour;\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t\t#ifdef SPECULAR_COLOR\r\n\t\t\t\t\t\t\t\ttotalSpecular *= shadowColour;\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\r\n\t\t\t    \t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t#endif\r\n\r\n\t\t#endif//USE_LIGHTING\r\n\t\r\n\t\t#if defined( REFLECTIONS ) && defined( SPECULAR_COLOR )\r\n\t\t\t//Multiply reflected colour by specular colour\r\n\t\t\treflectedColor *= vec4( specularColorValue, 1.0 );\r\n\t\t\t// reflectedColor *= gloss;\r\n\t\t#endif\r\n\r\n\t\t#ifdef DIFFUSE_COLOR\r\n\t\t\t#ifdef USE_LIGHTING\r\n\t\t\t\ttotalDiffuse += ambientLightColor * diffuseColorValue;\r\n\t\t\t#else\r\n\t\t\t\ttotalDiffuse += diffuseColorValue;\r\n\t\t\t#endif\r\n\t\t\t#ifdef AO_TEXTURE\r\n\t\t\t\ttotalDiffuse *= aoTex;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t \tfloat colorOpacityValue = 1.0;\r\n\t\t#endif\r\n\r\n\t\tfloat finalAlpha = colorOpacityValue;\r\n\t\t#ifdef REFLECTIONS\r\n\t\t\t//Schlick-Fresnel - Reflectance Function\r\n\t\t\tfloat fresnel = clamp( (pow( 1.0 - NdotV, 5.0 )) * reflectionFresnel + reflectionFactor, 0.0, 1.0 );\r\n\t\t\tvec3 reflectance_term = reflectedColor.xyz * fresnel;\r\n\t\t\tfinalAlpha += clamp( fresnel, 0.0, 1.0);\r\n\t\t#endif\r\n\t\t#if defined( SPECULAR_COLOR )\r\n\t\t\tfinalAlpha += clamp( dot( totalSpecular, vec3(0.3333)), 0.0, 1.0);\r\n\t\t#endif\r\n\t\tfinalAlpha *= totalOpacityValue;\r\n\t\t\r\n\r\n\t\tif ( renderModeNormals == 1 ) {\r\n\t\t\tnormal_WS.xyz =  0.5 * (viewMatrix * vec4( normal_WS.xyz, 0.0 )).xyz + 0.5;\r\n\t\t\tgl_FragColor = vec4( normal_WS.xyz, 1.0  );\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvec3 finalColor = totalDiffuse;\r\n\t\t\t#if defined( REFLECTIONS )\r\n\t\t\t\tfinalColor += reflectance_term;\r\n\t\t\t\t// finalColor = mix( finalColor, reflectedColor.xyz, exponential );\r\n\t\t\t#endif\r\n\t\t\t#if defined( SPECULAR_COLOR )\r\n\t\t\t\tfinalColor += totalSpecular;\r\n\t\t\t#endif\r\n\r\n\t\t\t#if defined( TRANSLUCENT_SCATTERING ) || defined( LOCAL_SCATTERING )\r\n\t\t\t\tfinalColor += totalScatter;\r\n\t\t\t#endif\r\n\r\n\t\t\t// #ifdef PARALLAX_MAPPING\r\n\t\t\t// \tfinalColor *= fragColorMult;\r\n\t\t\t// #endif\r\n\r\n\t\t\t#ifdef EMISSIVE_COLOR\r\n\t\t\t\t#ifdef EMISSIVE_TEXTURE\r\n\t\t\t\t \tfinalColor = emissiveIntensity * emissiveTex.xyz * emissiveColor + finalColor;\r\n\t\t\t\t#else\r\n\t\t\t\t \tfinalColor = emissiveIntensity * emissiveColor + finalColor;\r\n\t\t\t\t#endif\r\n\t\t\t#endif\r\n\t\t\t#ifdef GAMMA_OUTPUT\r\n\t\t\t\t//Gamma 2.0\r\n\t\t\t\t// finalColor = sqrt( finalColor );\r\n\t\t\t\t// #ifdef USE_LIGHTING\r\n\t\t\t\t\t//Filmic Tone-mapping with gamma 2.2 baked in and default values\r\n\t\t\t\t\t// finalColor = clamp( finalColor - vec3(0.0004), 0.0, 100.0 );\r\n\t\t\t\t\t// finalColor = (finalColor*(6.2*finalColor + 0.5)) / (finalColor*(6.2*finalColor + 1.7) + 0.06 );\r\n\t\t\t\t\t// // vec3 fcSqr62 = finalColor * finalColor * 6.2;\r\n\t\t\t\t\t// // finalColor = (finalColor * vec3(0.5) + fcSqr62) / ( finalColor * vec3(1.7) + fcSqr62 + 0.06 );\r\n\r\n\t    \t\t//Filmic Tone-mapping general - from Uncharted 2 talk - http://www.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting\r\n\t    \t\t// A = Shoulder Strength = 0.22\r\n\t\t\t    // B = Linear Strength = 0.30\r\n\t\t\t    // C = Linear Angle = 0.10\r\n\t\t\t    // D = Toe Strength = 0.20\r\n\t\t\t    // E = Toe Numerator = 0.01\r\n\t\t\t    // F = Toe Denominator = 0.30\r\n\t\t\t    // E/F = Toe Angle\r\n\t\t\t    // LinearWhite = Linear White Point Value = 11.2\r\n\t\t\t    // F(x) = ((x*(A*x+C*B) + D*E) / (x*(A*x+B) + D*F)) - E/F;\r\n\t\t\t    // FinalColor = F(LinearColour)/F(LinearWhite);\r\n\t\t\t   // #else\r\n\t\t\t   \tfinalColor = sqrt( finalColor );\r\n\t\t\t   // #endif\r\n\t\t\t#endif\r\n\t\t\tgl_FragColor = vec4( finalColor, finalAlpha );\r\n\t\t\t\r\n\t\t\t#if defined( USE_FOG )\r\n\t\t\t\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\t\t\t\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\r\n\t\t\t\t#else\r\n\t\t\t\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\r\n\t\t\t\t#endif\r\n\t\t\t\t#ifdef FOG_EXP2\r\n\t\t\t\t\tconst float LOG2 = 1.442695;\r\n\t\t\t\t\tfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\r\n\t\t\t\t\t// float fogFactor = exp2( - depth * LOG2 );\r\n\t\t\t\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\r\n\t\t\t\t#else\r\n\t\t\t\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\r\n\t\t\t\t#endif\r\n\t\t\t\tgl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\r\n\t\t\t#endif\r\n\r\n\r\n\t\t\t#ifdef LOG_LUV\r\n\t\t\tgl_FragColor = LogLuvEncode( gl_FragColor.xyz );\r\n\t\t\t#endif\r\n\t\t}\r\n\t#endif //#if !defined( DEPTH_PASS )\r\n}';});


define('text!VeroldEngine/Materials/Uber.vert',[],function () { return '\r\n/**\r\n * Shader used as a Verold material type\r\n * \r\n * Written by Mike Bond\r\n */\r\n\r\nattribute vec4 tangent;\r\n\r\nuniform float time;\r\n\r\n#ifdef USE_LOGDEPTHBUF\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\t\tvarying float vFragDepth;\r\n\t#endif\r\n\tuniform float logDepthBufFC;\r\n#endif\r\n\r\n#ifdef DISPLACEMENT\r\nuniform float displacementBaseMag;\r\nuniform float displacementBaseBias;\r\n\t#ifdef DISPLACEMENT_TEXTURE_RGBA\r\n\tuniform float displacementMag;\r\n\tuniform float displacementBias;\r\n\tuniform sampler2D displacementTexture;\r\n\tuniform int displacementUVChannel;\r\n\tuniform vec2 displacementTextureOffset;\r\n\tuniform vec2 displacementTextureScale;\r\n\tuniform vec2 displacementTexturePan;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec4 vNormal_WS;\r\n\r\n#ifdef USE_LIGHTING\r\n\t\r\n\t#if ( defined( NORMAL_TEXTURE ) || defined( DISPLACEMENT_TEXTURE_RGBA ) ) && !defined( DEPTH_PASS )\r\n\tvarying vec4 vTangent_WS;\r\n\tvarying vec4 vBinormal_WS;\r\n\t#endif\r\n\t\r\n#endif\r\n\r\nvarying vec4 vUv;\r\n// varying vec4 vPosition_VS;\r\nvarying vec4 vPosition_WS;\r\n\r\n#if !defined( DEPTH_PASS )\r\n\t\r\n\t#if defined( USE_COLOR ) && defined( DIFFUSE_COLOR )\r\n\t\tvarying vec3 vColor;\r\n\t#endif\r\n\t\r\n\t#if defined( USE_SHADOWMAP ) && defined( USE_LIGHTING )\r\n\t\t#if MAX_SHADOWS > 0\r\n\t\t\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\r\n\t\t\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\r\n\t\t#endif\r\n\t#endif\r\n#endif\r\n\r\n#ifdef USE_SKINNING\r\n\r\n\tuniform mat4 bindMatrix;\r\n\tuniform mat4 bindMatrixInverse;\r\n\r\n\t#ifdef BONE_TEXTURE\r\n\r\n\t\tuniform sampler2D boneTexture;\r\n\t\tuniform int boneTextureWidth;\r\n\t\tuniform int boneTextureHeight;\r\n\r\n\t\tmat4 getBoneMatrix( const in float i ) {\r\n\r\n\t\t\tfloat j = i * 4.0;\r\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\r\n\t\t\tfloat y = floor( j / float( boneTextureHeight ) );\r\n\r\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\r\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\r\n\r\n\t\t\ty = dy * ( y + 0.5 );\r\n\r\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\r\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\r\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\r\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\r\n\r\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\r\n\r\n\t\t\treturn bone;\r\n\t\t}\r\n\t#else\r\n\r\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\r\n\t\tmat4 getBoneMatrix( const in float i ) {\r\n\r\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\r\n\t\t\treturn bone;\r\n\t\t}\r\n\r\n\t#endif\r\n#endif\r\n\r\n//Only for m * v (not v * m!)\r\nvec3 mulVectorByMatrix4x4( in vec3 v, in mat4 m ) {\r\n\treturn (v.x * m[0] + ( v.y * m[1] + ( v.z * m[2] ) )).xyz;\r\n}\r\n\r\n//Only for m * p (not p * m!)\r\nvec4 mulPointByMatrix4x4( in vec3 v, in mat4 m ) {\r\n\treturn v.x * m[0] + ( v.y * m[1] + ( v.z * m[2] + m[3] ) );\r\n}\r\n\r\n\r\n\r\nvoid main() {\r\n\r\n#if defined( DISPLACEMENT_TEXTURE_RGBA ) || defined( DIFFUSE_TEXTURE ) ||\tdefined( SPECULAR_TEXTURE ) ||\tdefined( NORMAL_TEXTURE ) ||\tdefined( EMISSIVE_TEXTURE ) ||\tdefined( AO_TEXTURE ) ||\tdefined( SSS_TEXTURE )\r\n\tvUv.xy = uv;\r\n\tvUv.y = 1.0 - vUv.y;\r\n\tvUv.zw = uv2;\r\n\tvUv.w = 1.0 - vUv.w;\r\n#endif\r\n\r\n#ifdef DISPLACEMENT\r\n\tfloat texDisplacement = 0.0;\r\n\t#if defined( DISPLACEMENT_TEXTURE_RGBA )\r\n\t\t#if ( DISPLACEMENT_TEXTURE_RGBA == 0 )\r\n\t\t\r\n\t\t\tvec2 displacementUV = vUv.xy * displacementTextureScale + displacementTextureOffset + displacementTexturePan * time;\r\n\r\n\t\t\tvec4 displacementMap = texture2D( displacementTexture, displacementUV );\r\n\t\t\ttexDisplacement = displacementMag * displacementMap.x + displacementMag * (displacementBias * 0.5 - 0.5);\r\n\r\n\t\t#elif ( DISPLACEMENT_TEXTURE_RGBA == 1 )\r\n\t\t\t#define DISPLACEMENT_WITH_NORMAL\r\n\t\t\tvec2 displacementUV = vUv.xy * displacementTextureScale + displacementTextureOffset + displacementTexturePan * time;\r\n\t\t\tvec4 displacementMap = texture2D( displacementTexture, displacementUV );\r\n\t\t\t\r\n\t\t\ttexDisplacement = displacementMag * displacementMap.a + displacementMag * (displacementBias * 0.5 - 0.5);\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tfloat displacementAmount = displacementBaseMag * displacementBaseBias + texDisplacement;\r\n\tvec4 displacedPosition = vec4( (normal * displacementAmount ) + position.xyz, 1.0 );\r\n\t\r\n#else\r\n\tvec4 displacedPosition = vec4( position, 1.0 );\r\n\t\r\n#endif\r\n\r\nvec3 vNormal = normal;\r\nvec3 vTangent = tangent.xyz;\r\n\r\n#ifdef USE_SKINNING\r\n\r\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\r\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\r\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\r\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\r\n\r\n\tmat4 skinMatrix = mat4( 0.0 );\r\n        skinMatrix += skinWeight.x * boneMatX;\r\n\tskinMatrix += skinWeight.y * boneMatY;\r\n\tskinMatrix += skinWeight.z * boneMatZ;\r\n\tskinMatrix += skinWeight.w * boneMatW;\r\n        skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\r\n\r\n\tvNormal = (skinMatrix * vec4( vNormal, 0.0 )).xyz;\r\n\tvTangent = (skinMatrix * vec4( vTangent, 0.0 )).xyz;\r\n\r\n\tvec4 skinVertex    = bindMatrix * displacedPosition;\r\n\tdisplacedPosition  = boneMatX * skinVertex * skinWeight.x;\r\n\tdisplacedPosition += boneMatY * skinVertex * skinWeight.y;\r\n\tdisplacedPosition += boneMatZ * skinVertex * skinWeight.z;\r\n\tdisplacedPosition += boneMatW * skinVertex * skinWeight.w;\r\n\tdisplacedPosition  = bindMatrixInverse * displacedPosition;\r\n#endif\r\n\r\n// vPosition_VS = modelViewMatrix * displacedPosition;\r\nvPosition_WS = modelMatrix * displacedPosition;\r\n\r\n#ifdef USE_BILLBOARDING\r\n\tgl_Position = projectionMatrix * (viewMatrix * vec4(0.0, 0.0, 0.0, 1.0) + modelViewMatrix * displacedPosition );\r\n#else\r\n\tgl_Position = projectionMatrix * modelViewMatrix * displacedPosition;\r\n#endif\r\n\r\n// vPosition_VS = -vPosition_VS;\r\n\r\n// #ifdef USE_FISHEYE\r\n\t// vec4 tempPoint = modelViewMatrix * displacedPosition;\r\n\t// gl_Position.xy = vPosition_VS.xy / length( vPosition_VS.xyz );\r\n// #endif\r\n\r\n#if defined( USE_LOGDEPTHBUF ) && !defined(DEPTH_PASS)\r\n\tgl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\r\n\t#ifdef USE_LOGDEPTHBUF_EXT\r\n\t\tvFragDepth = 1.0 + gl_Position.w;\r\n\t#else\r\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\r\n\t#endif\r\n#endif\r\n\r\n\r\n#if !defined( DEPTH_PASS )\r\n\r\n\t#if defined( USE_COLOR )\r\n\t\t#if defined( DIFFUSE_COLOR )\r\n\t\t\t#ifdef GAMMA_INPUT\r\n\t\t\t\tvColor = color * color;\r\n\t\t\t#else\r\n\t\t\t\tvColor = color;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\t//Trying to make sure compiler includes color attribute for consistency, even if it\'s not used.\r\n\t\t\tvPosition_WS.w += color.x;\r\n\t\t\tvPosition_WS.w -= color.x;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t// normal, tangent and binormal vectors\r\n\t#if defined( DISPLACEMENT_WITH_NORMAL )\r\n\t\t//TODO - this calculation assumes that the material is being applied to the ground plane. i.e. it assumes\r\n\t\t//that tangent space equals object space.\r\n\t\t//What needs to be done is to compose the tangent basis (as we usually do) and to use it to transform the normal\r\n\t\t//in the displacement map to view space?\r\n\t\tdisplacementMap.xy = displacementMap.xy * 2.0 - 1.0;\r\n\t\tdisplacementMap.xyz = displacementMap.xzy;\r\n\t\tvNormal_WS.xyz = normalize((vec4( normalMatrix * displacementMap.xyz, 0) * viewMatrix ).xyz);\r\n\t#else\r\n\t\tvNormal_WS.xyz = normalize((vec4( normalMatrix * vNormal, 0) * viewMatrix ).xyz);\r\n\t#endif\r\n\r\n\t#ifdef FLIP_SIDED\r\n\t\tvNormal_WS = -vNormal_WS;\r\n\t#endif\r\n\r\n\t#ifdef USE_LIGHTING\r\n\r\n\t\t\r\n\t\t#if defined( NORMAL_TEXTURE ) \r\n\t\t\t\r\n\t\t\tvTangent_WS.xyz = normalize((vec4( normalMatrix * vTangent.xyz, 0) * viewMatrix ).xyz);\r\n\t\t\tvBinormal_WS.xyz = cross( vNormal_WS.xyz, vTangent_WS.xyz ) * tangent.w / clamp(abs(tangent.w), 0.0, 1.0);\r\n\r\n\t\t\t#if defined( DISPLACEMENT_WITH_NORMAL )\r\n\t\t\t\tvTangent_WS.xyz = cross( vNormal_WS.xyz, vBinormal_WS.xyz );\r\n\t\t\t#endif\r\n\t\t\r\n\t\t\t#if defined( PARALLAX_MAPPING )\r\n\t\t\t\t//TODO: fix this calculation after vNormal_WS etc. was changed to vNormal_WS etc. Also, vPosition_WS was changed to vPosition_VS\r\n\t\t\t\tmat3 mTangentToWorld = mat3( vTangent_WS.xyz, vBinormal_WS.xyz, vNormal_WS.xyz );\r\n\t\t\t\tvec3 eyeVector_WS = vPosition_WS.xyz - cameraPosition;\r\n\t\t\t\tvec3 eyeVector_TS = eyeVector_WS * mTangentToWorld;\r\n\t\t\t\t\r\n\t\t\t\t//Pack tangent-space eye vector into existing varyings\r\n\t\t\t\tvTangent_WS.w = eyeVector_TS.x;\r\n\t\t\t\tvBinormal_WS.w = eyeVector_TS.y;\r\n\t\t\t\tvNormal_WS.w = eyeVector_TS.z;\r\n\t\t\t#endif\r\n\r\n\t\t\t\r\n\t\t#endif\r\n\r\n\t\t#ifdef USE_SHADOWMAP\r\n\t\t \t#if MAX_SHADOWS > 0\r\n\r\n\t\t\t\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\r\n\r\n\t\t\t\t\t#ifdef USE_MORPHTARGETS\r\n\r\n\t\t\t\t\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * modelMatrix * vec4( morphed, 1.0 );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * modelMatrix * displacedPosition;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// vShadowCoord[ i ].z = log2(max(1e-6, 1.0 + vShadowCoord[ i ].w)) * logDepthBufFC - 1.0;\r\n\t\t\t\t\t\t// vShadowCoord[ i ].z *= vShadowCoord[ i ].w;\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\r\n\t#endif\r\n#endif\r\n}';});

/***
 * Written by Mike Bond
 * March 2012
 *
 * This file defines material types for use by the Verold material system
 * Material type definitions contain information about what shaders to use, 
 * what parameters are configurable per instance and multi-pass logic.
*/

define('VeroldEngine/Materials/VeroldMaterialTypeLibrary',["three",
	"text!VeroldEngine/Materials/Uber.frag",
	"text!VeroldEngine/Materials/Uber.vert",
	"VeroldEngine/VAPI",
	], function(THREE,
		shader_Uber_PS,
		shader_Uber_VS) {

	function generate(properties) {
			var MaterialFeatureDefines = {
				"Lighting" : {
					enabled: true,
					Requires: {

					},
					Defines: {
						"USE_LIGHTING" : "",
						"LIGHTING_MODEL" : 1,
					}
				},
				"Diffuse Color" : {
					Requires: {
						"MAX_FRAGMENT_UNIFORM_VECTORS" : 2,
						"MAX_VARYING_VECTORS" : 1
					},
					Defines: {
						"DIFFUSE_COLOR" : "",
					},
					SubFeatures: {

						"Diffuse Texture" : {
							Requires: {
								"MAX_TEXTURE_IMAGE_UNITS" : 1,
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 5
							},
							Defines: {
								"DIFFUSE_TEXTURE" : "",
								"ALPHA_BLENDMODE" : 1
							}

						},
						"AO Texture" : {
							enabled: false,
							Requires: {
								"MAX_TEXTURE_IMAGE_UNITS" : 1,
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 5
							},
							Defines: {
								"AO_TEXTURE" : ""
							}
						},
					}
				},
				"Rim Lighting" : {
					enabled: false,
					Requires: {
						"MAX_FRAGMENT_UNIFORM_VECTORS" : 2
					},
					Defines: {
						"RIM_LIGHTING" : ""
					}
				},

				"Normal Map" : {
					enabled: false,
					
					Requires: {
						"MAX_TEXTURE_IMAGE_UNITS" : 1,
						"MAX_FRAGMENT_UNIFORM_VECTORS" : 5,
						//"MAX_VARYING_VECTORS" : 2
					},
					Defines: {
						"NORMAL_TEXTURE" : ""
					},

					SubFeatures: {
						
						"Parallax" : {
							enabled: false,
							Requires: {
								//"MAX_TEXTURE_IMAGE_UNITS" : 1,
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 1
							},
							Defines: {
								"PARALLAX_MAPPING" : ""
							}
						},
						// "Bump Texture" : {
						// 	Requires: {
						// 		"MAX_TEXTURE_IMAGE_UNITS" : 1
						// 	},
						// 	Defines: {
						// 		"BUMP_TEXTURE" : ""
						// 	}
						// },
					}
				},
				
				"Displacement" : {
					enabled: false,
					Requires: {
						"MAX_FRAGMENT_UNIFORM_VECTORS" : 2
					},
					Defines: {
						"DISPLACEMENT" : ""
					},
					SubFeatures: {
						"Displacement Texture" : {
							Requires: {
								"MAX_VERTEX_TEXTURE_IMAGE_UNITS" : 1,
								"MAX_VERTEX_UNIFORM_VECTORS" : 6
							},
							Defines: {
								"DISPLACEMENT_TEXTURE_RGBA" : 1
							}
						},
					}
				},
				"Specular" : {
					Requires: {
						"MAX_FRAGMENT_UNIFORM_VECTORS" : 3
					},
					Defines: {
						"SPECULAR_COLOR" : "",
						"PHONG_SPECULAR" : ""
					},
					DefinesSimple: {
						"SPECULAR_COLOR" : "",
						"PHONG_SPECULAR" : "",
						"PHONG_SPECULAR_SIMPLE" : ""
					},
					SubFeatures: {
						"Specular Texture" : {
							enabled: false,
							Requires: {
								"MAX_TEXTURE_IMAGE_UNITS" : 1,
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 5
							},
							Defines: {
								"SPECULAR_TEXTURE" : ""
							}
						},
					}
				},
				// "KS Specular" : {
				// 	Requires: {
				// 		"MAX_FRAGMENT_UNIFORM_VECTORS" : 5
				// 	},
				// 	Defines: {
				// 		"SPECULAR_COLOR" : "",
				// 		"KS_SPECULAR" : ""
				// 	},
				// 	SubFeatures: {
				// 		"Specular Texture" : {
				// 			Requires: {
				// 				"MAX_TEXTURE_IMAGE_UNITS" : 1,
				// 				"MAX_FRAGMENT_UNIFORM_VECTORS" : 5
				// 			},
				// 			Defines: {
				// 				"SPECULAR_TEXTURE" : ""
				// 			}
				// 		},
				// 	}
				// },
				"Reflections" : {
					enabled: false,
					Requires: {
						"MAX_TEXTURE_IMAGE_UNITS" : 1,
						"MAX_FRAGMENT_UNIFORM_VECTORS" : 3
					},
					Defines: {
						"REFLECTIONS" : "0",
						"ENVMAP_HDR_INPUT": "0",
						"ENVMAP_NUM_MIPS": "12"
					},
				},
				"Local Scattering" : {
					Requires: {
						"MAX_FRAGMENT_UNIFORM_VECTORS" : 2
					},
					Defines: {
						"SCATTERING" : "",
						"LOCAL_SCATTERING" : ""
					},
					SubFeatures: {
						"Sub-surface Texture" : {
							enabled: false,
							Requires: {
								"MAX_TEXTURE_IMAGE_UNITS" : 1,
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 5
							},
							Defines: {
								"SSS_TEXTURE" : ""
							}
						}
					}
				},
				"Translucent Scattering" : {
					Requires: {
						"MAX_FRAGMENT_UNIFORM_VECTORS" : 2
					},
					Defines: {
						"SCATTERING" : "",
						"TRANSLUCENT_SCATTERING" : ""
					},
					SubFeatures: {
						"Sub-surface Texture" : {
							enabled: false,
							Requires: {
								"MAX_TEXTURE_IMAGE_UNITS" : 1,
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 5
							},
							Defines: {
								"SSS_TEXTURE" : ""
							}
						}
					}
				},
				"Emissive" : {
					enabled: false,
					Requires: {
						"MAX_FRAGMENT_UNIFORM_VECTORS" : 1
					},
					Defines: {
						"EMISSIVE_COLOR" : ""
					},
					SubFeatures: {
						"Emissive Texture" : {
							enabled: false,
							Requires: {
								"MAX_TEXTURE_IMAGE_UNITS" : 1,
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 5
							},
							Defines: {
								"EMISSIVE_TEXTURE" : ""
							}
						}
					}
				},
			};

			//The "Parameters" are displayed for the user in the UI. Each should have a description (to be used in tool-tips, etc.)
			//a name, a type and a default value. The user shouldn't need to provide a value for any of these (e.g. if they don't 
			//specify one of the textures, it'll get set to a default) and they shouldn't care whether the parameter is needed for 
			//the first pass, second pass, fallback technique, etc.
			//The group name can be used to organize the UI to make it more readable and understandable for the user.
			var MaterialParameters = {

				"diffuseColor": { name: "Base Color", description: "A color to tint the material with.", 
					type: "c", 
					value: new THREE.Color( 0xffffff ), 
					group : "Diffuse Color",
				},
				"rimColor": { name: "Rim Color", description: "The material color for light that is scattered around outside of material (e.g. tiny hairs on skin, etc.).", 
					type: "c", 
					value: new THREE.Color( 0xffffff ), 
					group : "Rim Lighting",
				},
				"rimPower": { name: "Rimlight Falloff", description: "This controls the falloff for the scattered light around a material. A lower value leads to more light 'leaking' around the edge of the model.", 
					type: "f", 
					value: 2.0, 
					min: 0.5, max: 8.0, stepSize: 0.050, 
					group : "Rim Lighting",
				},
				"colorOpacity": { name: "Opacity", description: "This controls the transparency of the material without affecting the reflectiveness. This is ideal for glass materials.", 
					type: "f", 
					value: 1.00, 
					min: 0.001, max: 1.000, stepSize: 0.050, 
					transparency : "LessThanOne", 
					group : "Diffuse Color",
				},
				"scatterColor": { name: "Scattering Color", description: "The most prominant color inside the object. As light passes through the object, it will pickup this color.", type: "c", 
					value: new THREE.Color( 0x000000 ), 
					group : "Scattering" },
				"scatterScale": { name: "Transmission Scale", description: "A value to adjust how much the sub-surface color shines through to the surface.", type: "f", value: 0.0000, 
					min: 0.0000, max: 1.0000, stepSize: 0.0010, 
					group : "Scattering" },
				"scatterLocalScale": { name: "Scattering Amount", description: "A value to adjust how much sub-surface-scattering occurs for the skin.", type: "f", value: 0.0000, 
					min: 0.0000, max: 5.0000, stepSize: 0.0100, 
					group : "Scattering" },
				"sssTexture" : { name: "Sub-surface Texture", description: "This texture represents the most prominant colors inside the object and is multiplied by the Transmissive Color.", type: "t", 
					value: null, 
					default: "white", 
					group : "Scattering", 
					subgroup: "Sub-surface Texture", },
				"sssUVChannel": { name: "UV Channel", description: "Which UV channel to use with the sub-surface map.", type: "dd", options: {"UV 0" : 0, "UV 1" : 1 }, value: 0,
					group : "Scattering", 
					subgroup: "Sub-surface Texture",
					betaFlag: false, },
				"sssTextureOffset" : { parent: "sssTexture", name: "Offset", description: "Shift the texture mapping by the specified amount.", type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -1.000, max: 1.000, stepSize: 0.001, 
					group : "Scattering", 
					subgroup: "Sub-surface Texture", },
				"sssTextureScale" : { parent: "sssTexture", name: "Tiling", description: "Scale the texture mapping. A higher number results in the texture displaying smaller on the models.",type: "v2", 
					value: new THREE.Vector2( 1, 1 ), 
					min: 0.00001, max: 200.000, stepSize: 0.001, 
					group : "Scattering", 
					subgroup: "Sub-surface Texture" },
				"sssTexturePan" : { parent: "sssTexture", name: "Panning", description: "The panning rate of the emissive texture. Higher is faster.",type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -16.000, max: 16.000, stepSize: 0.001, 
					group : "Scattering", 
					subgroup: "Sub-surface Texture", animation: true },
				"diffuseTexture" : { name: "Texture", description: "A texture that modifies the diffuse color of the material.", 
					type: "t", 
					value: null, 
					default: "white", 
					group : "Diffuse Color", 
					subgroup: 'Diffuse Texture',
				},
				"diffuseUVChannel": { name: "UV Channel", description: "Which UV channel to use with the diffuse map.", type: "dd", options: {"UV 0" : 0, "UV 1" : 1 }, value: 0,
					group : "Diffuse Color", 
					subgroup: 'Diffuse Texture',
					betaFlag: false,
				},
				"diffuseTextureOffset" : { parent: "diffuseTexture", name: "Offset", description: "Shift the texture mapping by the specified amount.", 
					type: "v2", 
					value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -1.000, max: 1.000, stepSize: 0.001, 
					group : "Diffuse Color", 
					subgroup: 'Diffuse Texture', 
				},
				"diffuseTextureScale" : { parent: "diffuseTexture", name: "Tiling", description: "Scale the texture mapping. A higher number results in the texture displaying smaller on the models.",
					type: "v2", 
					value: new THREE.Vector2( 1.000, 1.000 ), 
					min: 0.00001, max: 200.000, stepSize: 0.001, 
					group : "Diffuse Color", 
					subgroup: 'Diffuse Texture', 
				},
				"diffuseTexturePan" : { parent: "diffuseTexture", name: "Panning", description: "The panning rate of the color texture. Higher is faster.",
					type: "v2", 
					value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -16.000, max: 16.000, stepSize: 0.001, 
					group : "Diffuse Color", 
					subgroup: 'Diffuse Texture', animation: true
				},
				"alphaBlendMode": { name: "Alpha Mode", description: "This option controls whether the alpha channel of the color texture is used for transparency or just to blend with the Base Color (default).", 
					type: "dd", 
					options: { "Alpha Transparency" : 0, "Masked Transparency" : 2, "Color Blend" : 1 }, 
					defines: { "ALPHA_BLENDMODE" : "" },
					value: 1, 
					transparency: "LessThanOne", 
					group : "Diffuse Color", 
					subgroup: 'Diffuse Texture', 
				},
				"colorBlend": { name: "Color Blend", description: "This option controls whether the Base Color parameter modifies the color texture or not.", 
					type: "b", 
					value: true, 
					group : "Diffuse Color", 
					subgroup: 'Diffuse Texture', 
				},
				"aoTexture" : { name: "Texture", description: "A greyscale texture that contains ambient occlusion information. That is, it is multiplied by the light, producing local shadowing.", 
					type: "t", 
					value: null, 
					default: "white", 
					group : "Diffuse Color", 
					subgroup: 'AO Texture', 
				},
				"aoUVChannel": { name: "UV Channel", description: "Which UV channel to use with the AO map.", type: "dd", options: {"UV 0" : 0, "UV 1" : 1 }, value: 0,
					group : "Diffuse Color", 
					subgroup: 'AO Texture',
					betaFlag: false,
				},
				"aoTextureOffset" : { parent: "aoTexture", name: "Offset", description: "Shift the texture mapping by the specified amount.", type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -1.000, max: 1.000, stepSize: 0.001, 
					group : "Diffuse Color", 
					subgroup: 'AO Texture', 
				},
				"aoTextureScale" : { parent: "aoTexture", name: "Tiling", description: "Scale the texture mapping. A higher number results in the texture displaying smaller on the models.",
					type: "v2", 
					value: new THREE.Vector2( 1.000, 1.000 ), 
					min: 0.00001, max: 200.000, stepSize: 0.001, 
					group : "Diffuse Color", 
					subgroup: 'AO Texture', 
				},
				"aoTexturePan" : { parent: "aoTexture", name: "Panning", description: "The panning rate of the color texture. Higher is faster.",type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -16.000, max: 16.000, stepSize: 0.001, 
					group : "Diffuse Color", 
					subgroup: 'AO Texture', animation: true
				},
				"normalTexture"	: { name: "Texture", description: "The \"normal\" texture describes the detailed shape of a surface. For more information, see http://wiki.polycount.com/NormalMap", 
					type: "t", 
					value: null, default: "normalMap", 
					group : "Normal Map", 
				},
				"normalUVChannel": { name: "UV Channel", description: "Which UV channel to use with the normal map.", type: "dd", options: {"UV 0" : 0, "UV 1" : 1 }, value: 0,
					group : "Normal Map", 
					//subgroup: 'Normal Texture',
					betaFlag: false,
				},
				"normalScale": { name: "Scale", description: "A value to adjust the depth (or intensity) of the normal map.", type: "f", value: 1.0000, min: 0.000, max: 3.000, stepSize: 0.01, 
					group : "Normal Map", 
				},
				"normalTextureFlipY" : { parent: "normalTexture", name: "Flip Y Value", description: "Flip the green channel of the texture so that the y-value of the normal is reversed.", type: "b", value: false, 
					group : "Normal Map", 
				},
				"normalTextureFlipX" : { parent: "normalTexture", name: "Flip X Value", description: "Flip the red channel of the texture so that the x-value of the normal is reversed.", type: "b", value: false, 
					group : "Normal Map", 
				},
				"normalTextureOffset" : { parent: "normalTexture", name: "Offset", description: "Shift the texture mapping by the specified amount.", type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -1.000, max: 1.000, stepSize: 0.001, 
					group : "Normal Map", 
				},
				"normalTextureScale" : { parent: "normalTexture", name: "Tiling", description: "Scale the texture mapping. A higher number results in the texture displaying smaller on the models.",type: "v2", 
					value: new THREE.Vector2( 1.000, 1.000 ), 
					min: 0.00001, max: 200.000, stepSize: 0.001, 
					group : "Normal Map", 
				},
				"normalTexturePan" : { parent: "normalTexture", name: "Panning", description: "The panning rate of the normal texture. Higher is faster.",type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -16.000, max: 16.000, stepSize: 0.001, 
					group : "Normal Map", animation: true
				},
				"parallaxScale": { name: "Parallax Scale", description: "The amount of parallax effect. This requires height data in the alpha channel of the normal map texture.", type: "f", value: 0.01, 
					min: 0.001, max: 0.0200, stepSize: 0.001, 
					group: "Normal Map",
					subgroup : "Parallax" },
				"displacementBaseMag": { name: "Magnitude", description: "A uniform displacement amount for the vertices.", type: "f", value: 0.000, min: -1000.000, max: 1000.000, 
					hasSlider: false, 
					stepSize: 0.001, 
					group : "Displacement", 
				},
				"displacementBaseBias": { name: "Bias", description: "This value lets you shift the displacement in a negative or positive direction.", type: "f", value: 0.00, 
					min: -1.000, max: 1.000, stepSize: 0.001, 
					group : "Displacement", 
				},
				"displacementTexture" : { name: "Texture", description: "This texture contains normal and height information to deform a mesh's vertices. The height is expected in the alpha channel.",type: "t", value: null, default: "normalMap", 
					group : "Displacement",
					defines : { "DISPLACEMENT_TEXTURE_RGBA" : 0 },
					subgroup: 'Displacement Texture', 
				},
				"displacementUVChannel": { name: "UV Channel", description: "Which UV channel to use with the displacement map.", type: "dd", options: {"UV 0" : 0, "UV 1" : 1 }, value: 0,
					group : "Displacement", 
					subgroup: 'Displacement Texture',
					betaFlag: false,
				},
				"displacementMag": { name: "Magnitude", description: "This value controls how much the displacement texture affects the vertices.", type: "f", value: 0.000, min: -1000.000, max: 1000.000, 
					hasSlider: false, 
					stepSize: 0.001, 
					group : "Displacement", 
					subgroup: 'Displacement Texture', 
				},
				"displacementBias": { name: "Bias", description: "This value lets you shift the displacement from the texture in a negative or positive direction.", type: "f", value: 0.000, 
					min: -1.000, max: 1.000, stepSize: 0.001, 
					group : "Displacement", 
					subgroup: 'Displacement Texture', 
				},
				"displacementTextureOffset" : { parent: "displacementTexture", name: "Offset", description: "Shift the texture mapping by the specified amount.", type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -1.000, max: 1.000, stepSize: 0.001, 
					group : "Displacement", 
					subgroup: 'Displacement Texture', 
				},
				"displacementTextureScale" : { parent: "displacementTexture", name: "Tiling", description: "Scale the texture mapping. A higher number results in the texture displaying smaller on the models.",
					type: "v2", 
					value: new THREE.Vector2( 1, 1 ), 
					min: 0.00001, max: 200.000, stepSize: 0.001, 
					group : "Displacement", 
					subgroup: 'Displacement Texture', 
				},
				"displacementTexturePan" : { parent: "displacementTexture", name: "Panning", description: "The panning rate of the displacement texture. Higher is faster.",type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -16.000, max: 16.000, stepSize: 0.001, 
					group : "Displacement", 
					subgroup: 'Displacement Texture', animation: true 
				},
				"specularColor": { name: "Specular Color", description: "The specular color modifies the color of light reflected in a specular highlight. A darker color will result in a less reflective surface.", 
					type: "c", 
					value: new THREE.Color( 0xffffff ), 
					group : "Specular",
				},
				"gloss": { name: "Glossiness", description: ".", type: "f", value: 1.0, 
					min: 0.000, max: 1.000, stepSize: 0.001, 
					group : "Specular"  },
				// "specularPower": { name: "Specular Power", description: "This controls the tightness of the specular highlight. A larger number results in a smaller highlight and a shinier-looking surface.", 
				// 	type: "f", value: 20, 
				// 	min: 1.0, max: 250.0, stepSize: 1.0,
				// 	group : "Specular", 
				// 	deprecated : { newParam: "specularPowerBlinnPhong", convertFactor: 3 },
				// },
				// "specularPowerBlinnPhong": { name: "Specular Power", description: "This controls the tightness of the specular highlight. A larger number results in a smaller highlight and a shinier-looking surface.", 
				// 	type: "f", value: 45, 
				// 	min: 1.0, max: 2500.0, stepSize: 0.5,
				// 	group : "Specular", 
				// },
				"specularIntensity": { name: "Specular Intensity", description: "This controls the brightness of specular lighting. You can use this as an easy way to adjust specularity without reinporting your specular texture.", 
					type: "f", value: 1.0, 
					min: 0.0, max: 10.0, stepSize: 0.001,
					group : "Specular", 
				},
				// "ks_roughness": { name: "Skin Roughness", description: "A value that adjusts how rough the skin looks. Rougher skin will spread the reflected light more.", type: "f", value: 0.2, 
				// 	min: 0.000, max: 1.000, stepSize: 0.001, 
				// 	group : "Specular"  },
				// "ks_brightness": { name: "Skin Brightness", description: "A value that adjusts how much light is reflected by the skin.", type: "f", value: 0.0250, 
				// 	min: 0.000, max: 0.300, stepSize: 0.0001, 
				// 	group : "Specular"  },
				"specularTexture"	: { name: "Texture", description: "The specular texture modifies the color of light " +
														"reflected in a specular highlight. This can be grayscale or full-color. If you have a \"gloss\" map, you can put it in the alpha channel of this texture to affect the specular power on a per-pixel basis.", type: "t", value: null, default: "white", 
					group : "Specular", 
					subgroup: 'Specular Texture', 
				},
				"specularUVChannel": { name: "UV Channel", description: "Which UV channel to use with the specular map.", type: "dd", options: {"UV 0" : 0, "UV 1" : 1 }, value: 0,
					group : "Specular", 
					subgroup: 'Specular Texture',
					betaFlag: false,
				},
				"specularTextureOffset" : { parent: "specularTexture", name: "Offset", description: "Shift the texture mapping by the specified amount.", type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -1.000, max: 1.000, stepSize: 0.001, 
					group : "Specular", 
					subgroup: 'Specular Texture', 
				},
				"specularTextureScale" : { parent: "specularTexture", name: "Tiling", description: "Scale the texture mapping. A higher number results in the texture displaying smaller on the models.",
					type: "v2", 
					value: new THREE.Vector2( 1, 1 ), 
					min: 0.00001, max: 200.000, stepSize: 0.001, 
					group : "Specular", 
					subgroup: 'Specular Texture', 
				},
				"specularTexturePan" : { parent: "specularTexture", name: "Panning", description: "The panning rate of the specular texture. Higher is faster.",type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -16.000, max: 16.000, stepSize: 0.001, 
					group : "Specular", 
					subgroup: 'Specular Texture', animation: true
				},
				"emissiveColor": { name: "Glow Color", description: "The glow color will be added to the surface and won't be affected by external lights.", type: "c", value: new THREE.Color( 0xffffff ), 
					group : "Emissive", 
				},
				"emissiveIntensity": { name: "Emissive Intensity", description: "This controls the brightness of emissive color.", 
					type: "f", value: 1.0, 
					min: 0.0, max: 50.0, stepSize: 0.001,
					group : "Emissive", 
				},
				"emissiveTexture"	   : { name: "Texture", description: "The glow texture describes any surface that emits light and isn't affected by external lights.",type: "t", value: null, 
					default: "white", 
					group : "Emissive", 
					subgroup: 'Emissive Texture', 
				},
				"emissiveUVChannel": { name: "UV Channel", description: "Which UV channel to use with the emissive map.", type: "dd", options: {"UV 0" : 0, "UV 1" : 1 }, value: 0,
					group : "Emissive", 
					subgroup: 'Emissive Texture',
					betaFlag: false,
				},
				"emissiveTextureOffset" : { parent: "emissiveTexture", name: "Offset", description: "Shift the texture mapping by the specified amount.", type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -1.000, max: 1.000, stepSize: 0.001, 
					group : "Emissive", 
					subgroup: 'Emissive Texture', 
				},
				"emissiveTextureScale" : { parent: "emissiveTexture", name: "Tiling", description: "Scale the texture mapping. A higher number results in the texture displaying smaller on the models.",
					type: "v2", value: new THREE.Vector2( 1, 1 ), 
					min: 0.00001, max: 200.000, stepSize: 0.001, 
					group : "Emissive", 
					subgroup: 'Emissive Texture', 
				},
				"emissiveTexturePan" : { parent: "emissiveTexture", name: "Panning", description: "The panning rate of the emissive texture. Higher is faster.",type: "v2", value: new THREE.Vector2( 0.000, 0.000 ), 
					min: -16.000, max: 16.000, stepSize: 0.001, 
					group : "Emissive", 
					subgroup: 'Emissive Texture', animation: true
				},
				"environmentMappingType" : { name: "Reflection Type", description: "This controls how the reflection texture will map to the surface. 'Panorama' is also known as an 'equirectangular' map.", type: "dd", value: 3,
					options: { "Cube Map" : 0, "Sphere Map" : 1, "Planar" : 2, "Panorama": 3 }, 
					defines: { "REFLECTIONS" : "" },
					group : "Reflections",
					betaFlag: false,
				},
				"environmentTexture" : { name: "Env CubeMap", description: "A cube-map that represents the surrounding environment. Used for reflections.", type: "t", textureType: "Cube", value: null, 
					"default": "white_cube",
					group : "Reflections",
					defines: { "ENVMAP_HDR_INPUT" : 0, "ENVMAP_NUM_MIPS" : 12 },
					conditions : { environmentMappingType : { condition : "equal", value : 0 } },
					betaFlag: false,
				},
				"environmentTexture2D" : { name: "Env 2D Map", description: "A cube-map that represents the surrounding environment. Used for reflections.", type: "t", value: null, 
					"default": "white",
					group : "Reflections",
					defines: { "ENVMAP_HDR_INPUT" : 0, "ENVMAP_NUM_MIPS" : 12 },
					conditions : { environmentMappingType : { condition : "notEqual", value : 0 } },
					betaFlag: false,
				},
				"reflectionFresnel": { name: "Reflection Fresnel", description: "This controls the the angle that the environment reflection is visible at. A higher value will push reflections to edges only. Hint: A value of zero can be used for chrome-like surfaces.",
					type: "f", 
					value: 1.00, 
					min: 0.00, max: 1.00, stepSize: 0.01, 
					group : "Reflections", 
				},
				"reflectionBias": { name: "Reflectivity", description: "This value lets you tweak the amount of reflection visible.",type: "f", value: 0.50, min: 0.00, max: 1.00, stepSize: 0.01, 
					group : "Reflections", 
				},

				// "perPixel" : { name: "Lighting Type", description: "", type: "dd", value: 1,
				// 	options: { "Per-Vertex" : 0, "Per-Pixel" : 1 }, 
				// 	defines: { "LIGHTING_MODEL" : "" },
				// 	group : "Lighting",
				// },

				// "doubleSidedLighting" : { name: "Double-Sided Lighting", description: "Allows lighting to look correct on back-faces.", type: "b", value: false, group : "Lighting" },
				// "flipSided" : {name: "Flip Normals", description: ".", isRenderParam: true, type: "b", value: false, group : "Lighting"  },

				"fog" : {name: "Enable Fog", description: "This controls whether this material is affected by fog or not.", isRenderParam: true, type: "b", value: true, group : "Render Settings"  },
				//"lightsEnabled" : {name: "Enable Lighting", description: "This controls whether this material is affected by lights or not.",type: "b", value: true, group : "Render Settings"  },
				"depthWrite" : {name: "Enable Depth Write", description: "This controls whether the depth values of a mesh rendered with this material are recorded.", isRenderParam: true, type: "b", value: true, group : "Render Settings"  },
				"depthTest" : {name: "Enable Depth Test", description: "This controls whether a depth check is done before this material is rendered so that it can be occluded.", isRenderParam: true, type: "b", value: true, group : "Render Settings"  },
				"blending" : {name: "Blending Mode", description: "This controls how the material will be blended with the color behind it.", isRenderParam: true, type: "dd", options: {"None" : THREE.NoBlending, "Normal" : THREE.NormalBlending, "Additive" : THREE.AdditiveBlending, "Subtractive" : THREE.SubtractiveBlending, "Multiplicative" : THREE.MultiplyBlending }, value: THREE.NormalBlending, transparency : "GreaterThanOne", group : "Render Settings"  },
				"side" : {name: "Culling Mode", description: "This controls which side of the geometry will be visible.", isRenderParam: true, type: "dd", options: {"Front Only" : THREE.FrontSide, "Back Only" : THREE.BackSide, "Double-Sided" : THREE.DoubleSide }, value: THREE.FrontSide, group : "Render Settings"  },
				"polygonOffset": {name: "Polygon Offset", description: "Turns on rendering with polygon offsets. This can be used to work around z-fighting.", isRenderParam: true, type: "b", value: false, group : "Render Settings" },
				"polygonOffsetFactor": {name: "Polygon Offset Factor", description: "Scales the maximum Z slope, with respect to X or Y of the polygon.", isRenderParam: true, hasSlider: false, type: "f", value: 1.0, group : "Render Settings" },
				"polygonOffsetUnits": {name: "Polygon Offset Units", description: "Scales the minimum resolvable depth buffer value.", isRenderParam: true, hasSlider: false, type: "f", value: 1.0, group : "Render Settings" },
				"alphaTest": {name: "Alpha Test", description: "Pixels with an alpha value below the given value will not be rendered.", isRenderParam: true, type: "f", value: 0.2, min: 0.0, max: 1.0, step: 0.001, group : "Render Settings" },
				
				//"flipUVs" : {name: "Flip UV's", description: "This controls whether the textures for this material are flipped or not.", type: "b", value: false, group : "Render Settings"  },
			};

			var VeroldMaterialTypeLibrary = {

				//These textures are loaded and used by the material system only. They'll never be visible by the rest of the application or by the user.
				DefaultTextures: {
					white : {
						name: "White Texture",
						id: "white",
						type: "texture2D",
						payload: { 
							isLocal: true
						},
						resources: [{
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_White.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 300,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex_low",
								width: 64,
								height: 64,
								compression: 'none',
								pixelFormat: 'rgba',
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_White.dds",
							contentType: "image/x-dds",
							contentEncoding: "identity",
							contentLength: 2176,
							contentLengthIdentity: 4304,
							properties: {
								// type: "tex_dxt_low",
								width: 64,
								height: 64,
								compression: 'dxt',
								pixelFormat: 'rgb',
							}
						}]
					},
					black : {
						name: "Black Texture",
						id: "black",
						type: "texture2D",
						payload: { 
							isLocal: true
						},
						resources: [{
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_Black.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 209,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex_low",
								width: 64,
								height: 64,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_Black.dds",
							contentType: "image/x-dds",
							contentEncoding: "identity",
							contentLength: 2176,
							contentLengthIdentity: 2872,
							properties: {
								// type: "tex_dxt",
								width: 64,
								height: 64,
								compression: 'dxt',
								pixelFormat: 'rgb',
							}
						}]
					},
					normalMap : {
						name: "Default Normal Map",
						id: "normalMap",
						type: "texture2D",
						payload: { 
							isLocal: true
						},
						resources: [{
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_NormalMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 282,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								width: 64,
								height: 64,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_NormalMap.dds",
							contentType: "image/x-dds",
							contentEncoding: "identity",
							contentLength: 2872,
							contentLengthIdentity: 2872,
							properties: {
								// type: "tex_dxt",
								width: 64,
								height: 64,
								compression: 'dxt',
								pixelFormat: 'rgb',
							}
						}]
					},
					// environmentMap : { name: "Default EnvMap", id: "environmentMap", type: "texture2D", payload: { 
					// 		isHDR: true,
					// 		packing: THREE.HDRFull,
					// 		tex: {
					// 			path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap2_low.png",
					// 			width: 1024,
					// 			height: 512,
					// 			size: 102425,
					// 		},
					// 		tex_low: {
					// 			path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap2_low.png",
					// 			width: 1024,
					// 			height: 512,
					// 			size: 102425,
					// 		},
					// 		rgbd_tex: {
					// 			path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap2_low.png",
					// 			width: 1024,
					// 			height: 512,
					// 			size: 102425,
					// 		},
					// 		rgbd_tex_low: {
					// 			path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap2_low.png",
					// 			width: 1024,
					// 			height: 512,
					// 			size: 102425,
					// 		},
					// 		rgbd_tex_dxt: {
					// 			path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap2_low.dds",
					// 			width: 1024,
					// 			height: 512,
					// 			size: 528384,
					// 			size_uncompressed: 528384,
					// 		},
					// 		rgbd_tex_dxt_low: {
					// 			path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap2_low.dds",
					// 			width: 1024,
					// 			height: 512,
					// 			size: 528384,
					// 			size_uncompressed: 528384,
					// 		},
					// 		isLocal: true,
					// 		uMapping: "Clamp",
					// 		vMapping: "Clamp",
					// 		preferCompression: false
					// 	},
					// },
					"white_cube" : {
						name: "White Cubemap",
						id: "white_cube",
						type: "textureCube",
						payload: { 
							isLocal: true
						},
						resources: [{
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.dds",
							contentType: "image/x-dds",
							contentEncoding: "identity",
							contentLength: 3200,
							contentLengthIdentity: 3200,
							properties: {
								// type: "tex_dxt",
								width: 32,
								height: 32,
								compression: 'dxt',
								pixelFormat: 'rgb'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 0,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 1,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 2,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 3,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 4,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 5,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.dds",
							contentType: "image/x-dds",
							contentEncoding: "identity",
							contentLength: 3200,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex_dxt_low",
								width: 32,
								height: 32,
								compression: 'dxt',
								pixelFormat: 'rgb'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 0,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 1,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 2,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 3,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 4,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
						}, {
							path: properties.paths.glAssetsBaseUrl + "/textures/Materials/Default_EnvMap.png",
							contentType: "image/png",
							contentEncoding: "identity",
							contentLength: 176,
							contentLengthIdentity: 0,
							properties: {
								// type: "tex",
								cubeFace: 5,
								width: 32,
								height: 32,
								compression: 'none',
								pixelFormat: 'rgba'
							}
		        }]
		      },
				},
			
			

			Library: {

				/* -------------------------------------------------------------------------
				//	Simple shaders that are used as the defaults and support the most basic features.
				 ------------------------------------------------------------------------- */

				'Simple': {

					Category: "Simple",
					Description: ["Use this shader for basic materials that have no textures.",
					"It supports diffuse, specular and emissive colors as well as reflections and transparency."
					
					].join(" "),

					//Cooresponds to the group and subgroup for each param
					Features: {
						"Lighting" : MaterialFeatureDefines["Lighting"],
						"Diffuse Color" : {
							Requires: {
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 2
							},
							Defines: {
								"DIFFUSE_COLOR" : ""
							},
						},

						"Rim Lighting" : MaterialFeatureDefines["Rim Lighting"],
						
						//"Displacement" : MaterialFeatureDefines["Displacement"],
						"Specular" : {
							Requires: {
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 3
							},
							Defines: {
								"SPECULAR_COLOR" : "",
								"PHONG_SPECULAR" : ""
							},
						},
						"Reflections" : MaterialFeatureDefines["Reflections"],
						"Emissive" : {
							enabled: false,
							Requires: {
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 1
							},
							Defines: {
								"EMISSIVE_COLOR" : ""
							},
						}
					},

					//The "Parameters" are displayed for the user in the UI. Each should have a description (to be used in tool-tips, etc.)
					//a name, a type and a default value. The user shouldn't need to provide a value for any of these (e.g. if they don't 
					//specify one of the textures, it'll get set to a default) and they shouldn't care whether the parameter is needed for 
					//the first pass, second pass, fallback technique, etc.
					//The group name can be used to organize the UI to make it more readable and understandable for the user.
					Parameters: {

						"diffuseColor": MaterialParameters.diffuseColor,
						"colorOpacity": MaterialParameters.colorOpacity,
						"rimColor" : MaterialParameters.rimColor,
						"rimPower" : MaterialParameters.rimPower,
						"specularColor": MaterialParameters.specularColor,
						
						// "specularPower": MaterialParameters.specularPower,
						// "specularPowerBlinnPhong": MaterialParameters.specularPowerBlinnPhong,
						"specularIntensity": MaterialParameters.specularIntensity,
						"gloss": MaterialParameters.gloss,
						"emissiveColor": MaterialParameters.emissiveColor,
						"emissiveIntensity": MaterialParameters.emissiveIntensity,
						
						"environmentMappingType" : MaterialParameters.environmentMappingType,
						"environmentTexture" : MaterialParameters.environmentTexture,
						"environmentTexture2D" : MaterialParameters.environmentTexture2D,
						"reflectionFresnel": MaterialParameters.reflectionFresnel,
						"reflectionBias": MaterialParameters.reflectionBias,
						// "perPixel" : MaterialParameters.perPixel,
						// "doubleSidedLighting" : MaterialParameters.doubleSidedLighting,
						// "flipSided" : MaterialParameters.flipSided,
						
						"fog" : MaterialParameters.fog,
						//"lightsEnabled" : MaterialParameters.lightsEnabled,
						"depthWrite" : MaterialParameters.depthWrite,
						"depthTest" : MaterialParameters.depthTest,
						"alphaTest" : MaterialParameters.alphaTest,
						"blending" : MaterialParameters.blending,
						"side" : MaterialParameters.side,
						"polygonOffset" : MaterialParameters.polygonOffset,
						"polygonOffsetFactor" : MaterialParameters.polygonOffsetFactor,
						"polygonOffsetUnits" : MaterialParameters.polygonOffsetUnits,
					},
					
					// Techniques: {
					// 	Standard: {
							//Each pass defines a THREE.JS shader
							//Passes: [
								//{

									uniforms: THREE.UniformsUtils.merge( [

										THREE.UniformsLib[ "fog" ],
										THREE.UniformsLib[ "lights" ],
										THREE.UniformsLib[ "shadowmap" ],
										{

										"opacity": { type: "f", value: 1.0 },
										
										//"flipSided": { type: "i", value: 0 },
										"renderModeNormals": { type: "i", value: 0 },
										
										// "selectionColor": { type: "c", value: new THREE.Color( 0xffffff )},
										//x = max selection opacity, y = min blend value, z = max blend value
										// "selectionHighlightParams": { type: "v3", value: new THREE.Vector3( 0, 0, 0 )},
																		
										}

									] ),
									
									vertexShader: shader_Uber_VS,
									fragmentShader: shader_Uber_PS,
									
								//}
							//]//Passes array
					// 	},
						
					// }
				},//Simple
				/* -------------------------------------------------------------------------
				//	Standard shaders that are used as the defaults and support the most basic features.
				 ------------------------------------------------------------------------- */

				'Standard': {

					Category: "Standard",
					Description: ["Use this shader for basic materials that have textures.",
					"It supports normal-mapping, specular maps, and color maps as well as basic texture scaling."
					
					].join(" "),

					//Cooresponds to the group and subgroup for each param
					Features: {
						"Lighting" : MaterialFeatureDefines["Lighting"],
						"Diffuse Color" : MaterialFeatureDefines["Diffuse Color"],
						"Specular" : MaterialFeatureDefines["Specular"],
						"Rim Lighting" : MaterialFeatureDefines["Rim Lighting"],
						"Normal Map" : MaterialFeatureDefines["Normal Map"],
						"Displacement" : MaterialFeatureDefines["Displacement"],
						"Reflections" : MaterialFeatureDefines["Reflections"],
						"Emissive" : MaterialFeatureDefines["Emissive"],
					},

					//The "Parameters" are displayed for the user in the UI. Each should have a description (to be used in tool-tips, etc.)
					//a name, a type and a default value. The user shouldn't need to provide a value for any of these (e.g. if they don't 
					//specify one of the textures, it'll get set to a default) and they shouldn't care whether the parameter is needed for 
					//the first pass, second pass, fallback technique, etc.
					//The group name can be used to organize the UI to make it more readable and understandable for the user.
					Parameters: {

						"diffuseColor": MaterialParameters.diffuseColor,
						"colorOpacity": MaterialParameters.colorOpacity,
						"rimColor" : MaterialParameters.rimColor,
						"rimPower" : MaterialParameters.rimPower,
						"diffuseTexture" : MaterialParameters.diffuseTexture,
						"diffuseUVChannel" : MaterialParameters.diffuseUVChannel,
						"diffuseTextureOffset" : MaterialParameters.diffuseTextureOffset,
						"diffuseTextureScale" : MaterialParameters.diffuseTextureScale,
						"diffuseTexturePan" : MaterialParameters.diffuseTexturePan,
						"alphaBlendMode": MaterialParameters.alphaBlendMode,
						"colorBlend": MaterialParameters.colorBlend,
						"aoTexture" : MaterialParameters.aoTexture,
						"aoUVChannel" : MaterialParameters.aoUVChannel,
						"aoTextureOffset" : MaterialParameters.aoTextureOffset,
						"aoTextureScale" : MaterialParameters.aoTextureScale,
						"aoTexturePan" : MaterialParameters.aoTexturePan,
						"normalTexture"	: MaterialParameters.normalTexture,
						"normalUVChannel"	: MaterialParameters.normalUVChannel,
						"normalScale": MaterialParameters.normalScale,
						"normalTextureFlipY": MaterialParameters.normalTextureFlipY,
						"normalTextureFlipX": MaterialParameters.normalTextureFlipX,
						"normalTextureOffset" : MaterialParameters.normalTextureOffset,
						"normalTextureScale" : MaterialParameters.normalTextureScale,
						"normalTexturePan" : MaterialParameters.normalTexturePan,
						"parallaxScale" : MaterialParameters.parallaxScale,
						"displacementBaseMag": MaterialParameters.displacementBaseMag,
						"displacementBaseBias": MaterialParameters.displacementBaseBias,
						"displacementTexture" : MaterialParameters.displacementTexture,
						"displacementUVChannel" : MaterialParameters.displacementUVChannel,
						"displacementMag": MaterialParameters.displacementMag,
						"displacementBias": MaterialParameters.displacementBias,
						"displacementTextureOffset" : MaterialParameters.displacementTextureOffset,
						"displacementTextureScale" : MaterialParameters.displacementTextureScale,
						"displacementTexturePan" : MaterialParameters.displacementTexturePan,
						"specularColor": MaterialParameters.specularColor,
						// "specularPower": MaterialParameters.specularPower,
						// "specularPowerBlinnPhong": MaterialParameters.specularPowerBlinnPhong,
						"specularIntensity": MaterialParameters.specularIntensity,
						"gloss": MaterialParameters.gloss,
						"specularTexture"	: MaterialParameters.specularTexture,
						"specularUVChannel" : MaterialParameters.specularUVChannel,
						"specularTextureOffset" : MaterialParameters.specularTextureOffset,
						"specularTextureScale" : MaterialParameters.specularTextureScale,
						"specularTexturePan" : MaterialParameters.specularTexturePan,
						"emissiveColor": MaterialParameters.emissiveColor,
						"emissiveIntensity": MaterialParameters.emissiveIntensity,
						"emissiveTexture"	: MaterialParameters.emissiveTexture,
						"emissiveUVChannel" : MaterialParameters.emissiveUVChannel,
						"emissiveTextureOffset" : MaterialParameters.emissiveTextureOffset,
						"emissiveTextureScale" : MaterialParameters.emissiveTextureScale,
						"emissiveTexturePan" : MaterialParameters.emissiveTexturePan,
						"environmentMappingType" : MaterialParameters.environmentMappingType,
						"environmentTexture" : MaterialParameters.environmentTexture,
						"environmentTexture2D" : MaterialParameters.environmentTexture2D,
						"reflectionFresnel": MaterialParameters.reflectionFresnel,
						"reflectionBias": MaterialParameters.reflectionBias,
						// "perPixel" : MaterialParameters.perPixel,
						// "doubleSidedLighting" : MaterialParameters.doubleSidedLighting,
						// "flipSided" : MaterialParameters.flipSided,
						"fog" : MaterialParameters.fog,
						//"lightsEnabled" : MaterialParameters.lightsEnabled,
						"depthWrite" : MaterialParameters.depthWrite,
						"depthTest" : MaterialParameters.depthTest,
						"alphaTest" : MaterialParameters.alphaTest,
						"blending" : MaterialParameters.blending,
						"side" : MaterialParameters.side,
						"polygonOffset" : MaterialParameters.polygonOffset,
						"polygonOffsetFactor" : MaterialParameters.polygonOffsetFactor,
						"polygonOffsetUnits" : MaterialParameters.polygonOffsetUnits,
						//"flipUVs" : MaterialParameters.flipUVs,
					},
					// Techniques: {
					// 	Standard: {
							//Each pass defines a THREE.JS shader
							//Passes: [
								//{
									
									uniforms: THREE.UniformsUtils.merge( [

										THREE.UniformsLib[ "fog" ],
										THREE.UniformsLib[ "lights" ],
										THREE.UniformsLib[ "shadowmap" ],
										{
										//"flipSided": { type: "i", value: 0 },
										
										"opacity": { type: "f", value: 1.0 },
										"time": { type: "f", value: 1.0 },
										"renderModeNormals": { type: "i", value: 0 },
										// "selectionColor": { type: "c", value: new THREE.Color( 0xffffff )},
										//x = max selection opacity, y = min blend value, z = max blend value
										// "selectionHighlightParams": { type: "v3", value: new THREE.Vector3( 0, 0, 0 )},
										}

									] ),
									
									vertexShader: shader_Uber_VS,
									fragmentShader: shader_Uber_PS,
									
								//}
							//]//Passes array
					// 	},
						
					// }
				},//Standard

				'Iridescent': {

					Category: "Advanced",
					Description: ["This material has a metallic sheen with a glossy topcoat. It's ideal for glossy vehicle paint.",
					"It supports normal-mapping, emissive mapping, and reflections."
					
					].join(" "),
					
					//Cooresponds to the group and subgroup for each param
					Features: {
						"Lighting" : MaterialFeatureDefines["Lighting"],
						"Diffuse Color" : {
							Requires: {
								"MAX_FRAGMENT_UNIFORM_VECTORS" : 2
							},
							Defines: {
								"DIFFUSE_COLOR" : "",
								"IRIDESCENT_LAYER" : ""
							},
							SubFeatures: {
								"Diffuse Texture" : {
									Requires: {
										"MAX_TEXTURE_IMAGE_UNITS" : 1,
										"MAX_FRAGMENT_UNIFORM_VECTORS" : 5
									},
									Defines: {
										"DIFFUSE_TEXTURE" : "",
										"ALPHA_BLENDMODE" : 1
									}

								},
								"Iridescent Texture" : {
									enabled: false,
									Requires: {
										"MAX_TEXTURE_IMAGE_UNITS" : 1,
										"MAX_FRAGMENT_UNIFORM_VECTORS" : 1
									},
									Defines: {
										"IRIDESCENT_TEXTURE" : ""
									}
								},
								"AO Texture" : {
									enabled: false,
									Requires: {
										"MAX_TEXTURE_IMAGE_UNITS" : 1,
										"MAX_FRAGMENT_UNIFORM_VECTORS" : 4
									},
									Defines: {
										"AO_TEXTURE" : ""
									}
								},
							}
						},
						"Rim Lighting" : MaterialFeatureDefines["Rim Lighting"],
						"Normal Map" : MaterialFeatureDefines["Normal Map"],
						"Displacement" : MaterialFeatureDefines["Displacement"],
						"Specular" : MaterialFeatureDefines["Specular"],
						"Reflections" : MaterialFeatureDefines["Reflections"],
						"Emissive" : MaterialFeatureDefines["Emissive"],
					},
					
					//The "Parameters" are displayed for the user in the UI. Each should have a description (to be used in tool-tips, etc.)
					//a name, a type and a default value. The user shouldn't need to provide a value for any of these (e.g. if they don't 
					//specify one of the textures, it'll get set to a default) and they shouldn't care whether the parameter is needed for 
					//the first pass, second pass, fallback technique, etc.
					//The group name can be used to organize the UI to make it more readable and understandable for the user.
					Parameters: {


						"diffuseColor": { name: "Base Color 1", description: "The first color for a two-tone blend. This will be modified by the Iridescent Texture.", type: "c", value: new THREE.Color( 0x500017 ), 
							group : "Diffuse Color" },
						"diffuseColor2": { name: "Base Color 2", description: "The second color for the two-tone blend. This will be modified by the Iridescent Texture.", type: "c", value: new THREE.Color( 0x918686 ), 
							group : "Diffuse Color" },
						"twoToneExponent": { name: "Iridescent Bias", description: "This value controls how the colors blend together across the surface. Higher values will push Base Color 1 and the left of the Iridescent Texture toward edges that are tilted away from the viewer.", type: "f", value: 2, 
							min: 0.0, max: 12.0, stepSize: 0.01, 
							group : "Diffuse Color" },					
						
						"metallicMultiplier": { name: "Metallicity", description: "This value allows you to add a metallic look to the material. A higher value will make the metallic highlight brighter.", type: "f", value: 1.00, 
							min: 0.00, max: 12.00, stepSize: 0.01, 
							group : "Diffuse Color" },
						"metallicExponent": { name: "Metallic Sheen", description: "This value controls how tight the metallic highlight is.", type: "f", value: 8.0, min: 1.0, max: 16.0, stepSize: 0.1, 
							group : "Diffuse Color" },

						"colorOpacity": MaterialParameters.colorOpacity,
						
						"iridescentTexture" : { name: "Iridescent Texture", description: "A texture that contains colors which will be blended across the surface based on the view angle.", type: "t", value: null, default: "white", 
							group : "Diffuse Color", 
							subgroup : "Iridescent Texture",
						},

						"rimColor" : MaterialParameters.rimColor,
						"rimPower" : MaterialParameters.rimPower,
						"diffuseTexture" : MaterialParameters.diffuseTexture,
						"diffuseUVChannel" : MaterialParameters.diffuseUVChannel,
						"diffuseTextureOffset" : MaterialParameters.diffuseTextureOffset,
						"diffuseTextureScale" : MaterialParameters.diffuseTextureScale,
						"diffuseTexturePan" : MaterialParameters.diffuseTexturePan,
						"alphaBlendMode": MaterialParameters.alphaBlendMode,
						"colorBlend": MaterialParameters.colorBlend,
						"aoTexture" : MaterialParameters.aoTexture,
						"aoUVChannel" : MaterialParameters.aoUVChannel,
						"aoTextureOffset" : MaterialParameters.aoTextureOffset,
						"aoTextureScale" : MaterialParameters.aoTextureScale,
						"aoTexturePan" : MaterialParameters.aoTexturePan,
						"normalTexture"	: MaterialParameters.normalTexture,
						"normalUVChannel"	: MaterialParameters.normalUVChannel,
						"normalScale": MaterialParameters.normalScale,
						"normalTextureFlipY": MaterialParameters.normalTextureFlipY,
						"normalTextureFlipX": MaterialParameters.normalTextureFlipX,
						"normalTextureOffset" : MaterialParameters.normalTextureOffset,
						"normalTextureScale" : MaterialParameters.normalTextureScale,
						"normalTexturePan" : MaterialParameters.normalTexturePan,
						"displacementBaseMag": MaterialParameters.displacementBaseMag,
						"displacementBaseBias": MaterialParameters.displacementBaseBias,
						"displacementTexture" : MaterialParameters.displacementTexture,
						"displacementUVChannel" : MaterialParameters.displacementUVChannel,
						"displacementMag": MaterialParameters.displacementMag,
						"displacementBias": MaterialParameters.displacementBias,
						"displacementTextureOffset" : MaterialParameters.displacementTextureOffset,
						"displacementTextureScale" : MaterialParameters.displacementTextureScale,
						"displacementTexturePan" : MaterialParameters.displacementTexturePan,
						"specularColor": MaterialParameters.specularColor,
						// "specularPower": MaterialParameters.specularPower,
						// "specularPowerBlinnPhong": MaterialParameters.specularPowerBlinnPhong,
						"specularIntensity": MaterialParameters.specularIntensity,
						"gloss": MaterialParameters.gloss,
						"specularTexture"	: MaterialParameters.specularTexture,
						"specularUVChannel" : MaterialParameters.specularUVChannel,
						"specularTextureOffset" : MaterialParameters.specularTextureOffset,
						"specularTextureScale" : MaterialParameters.specularTextureScale,
						"specularTexturePan" : MaterialParameters.specularTexturePan,
						"emissiveColor": MaterialParameters.emissiveColor,
						"emissiveIntensity": MaterialParameters.emissiveIntensity,
						"emissiveTexture"	: MaterialParameters.emissiveTexture,
						"emissiveUVChannel" : MaterialParameters.emissiveUVChannel,
						"emissiveTextureOffset" : MaterialParameters.emissiveTextureOffset,
						"emissiveTextureScale" : MaterialParameters.emissiveTextureScale,
						"emissiveTexturePan" : MaterialParameters.emissiveTexturePan,
						"environmentMappingType" : MaterialParameters.environmentMappingType,
						"environmentTexture" : MaterialParameters.environmentTexture,
						"environmentTexture2D" : MaterialParameters.environmentTexture2D,
						"reflectionFresnel": MaterialParameters.reflectionFresnel,
						"reflectionBias": MaterialParameters.reflectionBias,
						// "perPixel" : MaterialParameters.perPixel,
						// "doubleSidedLighting" : MaterialParameters.doubleSidedLighting,
						// "flipSided" : MaterialParameters.flipSided,
						"fog" : MaterialParameters.fog,
						//"lightsEnabled" : MaterialParameters.lightsEnabled,
						"depthWrite" : MaterialParameters.depthWrite,
						"depthTest" : MaterialParameters.depthTest,
						"alphaTest" : MaterialParameters.alphaTest,
						"blending" : MaterialParameters.blending,
						"side" : MaterialParameters.side,
						"polygonOffset" : MaterialParameters.polygonOffset,
						"polygonOffsetFactor" : MaterialParameters.polygonOffsetFactor,
						"polygonOffsetUnits" : MaterialParameters.polygonOffsetUnits,
						//"flipUVs" : MaterialParameters.flipUVs,
					},		
					// Techniques: {
					// 	Standard: {
							//Each pass defines a THREE.JS shader
							//Passes: [
								//{
									
									uniforms: THREE.UniformsUtils.merge( [

										THREE.UniformsLib[ "fog" ],
										THREE.UniformsLib[ "lights" ],
										THREE.UniformsLib[ "shadowmap" ],
										{

										"opacity": { type: "f", value: 1.0 },
										"time": { type: "f", value: 1.0 },
										
										//"flipSided": { type: "i", value: 0 },
										"renderModeNormals": { type: "i", value: 0 },
										// "selectionColor": { type: "c", value: new THREE.Color( 0xffffff )},
										//x = max selection opacity, y = min blend value, z = max blend value
										// "selectionHighlightParams": { type: "v3", value: new THREE.Vector3( 0, 0, 0 )},

										}

									] ),
									
									vertexShader: shader_Uber_VS,
									fragmentShader: shader_Uber_PS,
									
									
									
								//}
							//]//Passes array
					// 	},
						
					// }//Techniques
				},//Iridescent

				'Transmissive': {

					Category: "Advanced",
					Description: ["This material has a metallic sheen with a glossy topcoat. It's ideal for glossy vehicle paint.",
					"It supports normal-mapping, emissive mapping, and reflections."
					
					].join(" "),


					//Cooresponds to the group and subgroup for each param
					Features: {
						"Lighting" : MaterialFeatureDefines["Lighting"],
						"Diffuse Color" : MaterialFeatureDefines["Diffuse Color"],
						"Scattering" : MaterialFeatureDefines["Translucent Scattering"],
						"Rim Lighting" : MaterialFeatureDefines["Rim Lighting"],
						"Normal Map" : MaterialFeatureDefines["Normal Map"],
						"Displacement" : MaterialFeatureDefines["Displacement"],
						"Specular" : MaterialFeatureDefines["Specular"],
						"Reflections" : MaterialFeatureDefines["Reflections"],
						"Emissive" : MaterialFeatureDefines["Emissive"],
					},

					//The "Parameters" are displayed for the user in the UI. Each should have a description (to be used in tool-tips, etc.)
					//a name, a type and a default value. The user shouldn't need to provide a value for any of these (e.g. if they don't 
					//specify one of the textures, it'll get set to a default) and they shouldn't care whether the parameter is needed for 
					//the first pass, second pass, fallback technique, etc.
					//The group name can be used to organize the UI to make it more readable and understandable for the user.
					Parameters: {

						"diffuseColor": MaterialParameters.diffuseColor,
						"colorOpacity": MaterialParameters.colorOpacity,
						"scatterColor": MaterialParameters.scatterColor,
						"scatterScale": MaterialParameters.scatterScale,
						"rimColor" : MaterialParameters.rimColor,
						"rimPower" : MaterialParameters.rimPower,
						"diffuseTexture" : MaterialParameters.diffuseTexture,
						"diffuseUVChannel" : MaterialParameters.diffuseUVChannel,
						"diffuseTextureOffset" : MaterialParameters.diffuseTextureOffset,
						"diffuseTextureScale" : MaterialParameters.diffuseTextureScale,
						"diffuseTexturePan" : MaterialParameters.diffuseTexturePan,
						"alphaBlendMode": MaterialParameters.alphaBlendMode,
						"colorBlend": MaterialParameters.colorBlend,
						"sssTexture" : MaterialParameters.sssTexture,
						"sssUVChannel" : MaterialParameters.sssUVChannel,
						"sssTextureOffset": MaterialParameters.sssTextureOffset,
						"sssTextureScale": MaterialParameters.sssTextureScale,
						"sssTexturePan": MaterialParameters.sssTexturePan,
						"aoTexture" : MaterialParameters.aoTexture,
						"aoUVChannel" : MaterialParameters.aoUVChannel,
						"aoTextureOffset" : MaterialParameters.aoTextureOffset,
						"aoTextureScale" : MaterialParameters.aoTextureScale,
						"aoTexturePan" : MaterialParameters.aoTexturePan,
						"normalTexture"	: MaterialParameters.normalTexture,
						"normalUVChannel"	: MaterialParameters.normalUVChannel,
						"normalScale": MaterialParameters.normalScale,
						"normalTextureFlipY": MaterialParameters.normalTextureFlipY,
						"normalTextureFlipX": MaterialParameters.normalTextureFlipX,
						"normalTextureOffset" : MaterialParameters.normalTextureOffset,
						"normalTextureScale" : MaterialParameters.normalTextureScale,
						"normalTexturePan" : MaterialParameters.normalTexturePan,
						"displacementBaseMag": MaterialParameters.displacementBaseMag,
						"displacementBaseBias": MaterialParameters.displacementBaseBias,
						"displacementTexture" : MaterialParameters.displacementTexture,
						"displacementUVChannel" : MaterialParameters.displacementUVChannel,
						"displacementMag": MaterialParameters.displacementMag,
						"displacementBias": MaterialParameters.displacementBias,
						"displacementTextureOffset" : MaterialParameters.displacementTextureOffset,
						"displacementTextureScale" : MaterialParameters.displacementTextureScale,
						"displacementTexturePan" : MaterialParameters.displacementTexturePan,
						"specularColor": MaterialParameters.specularColor,
						// "specularPower": MaterialParameters.specularPower,
						// "specularPowerBlinnPhong": MaterialParameters.specularPowerBlinnPhong,
						"specularIntensity": MaterialParameters.specularIntensity,
						"gloss": MaterialParameters.gloss,
						"specularTexture"	: MaterialParameters.specularTexture,
						"specularUVChannel" : MaterialParameters.specularUVChannel,
						"specularTextureOffset" : MaterialParameters.specularTextureOffset,
						"specularTextureScale" : MaterialParameters.specularTextureScale,
						"specularTexturePan" : MaterialParameters.specularTexturePan,
						"emissiveColor": MaterialParameters.emissiveColor,
						"emissiveIntensity": MaterialParameters.emissiveIntensity,
						"emissiveTexture"	: MaterialParameters.emissiveTexture,
						"emissiveUVChannel" : MaterialParameters.emissiveUVChannel,
						"emissiveTextureOffset" : MaterialParameters.emissiveTextureOffset,
						"emissiveTextureScale" : MaterialParameters.emissiveTextureScale,
						"emissiveTexturePan" : MaterialParameters.emissiveTexturePan,
						"environmentMappingType" : MaterialParameters.environmentMappingType,
						"environmentTexture" : MaterialParameters.environmentTexture,
						"environmentTexture2D" : MaterialParameters.environmentTexture2D,
						"reflectionFresnel": MaterialParameters.reflectionFresnel,
						"reflectionBias": MaterialParameters.reflectionBias,
						// "perPixel" : MaterialParameters.perPixel,
						// "doubleSidedLighting" : MaterialParameters.doubleSidedLighting,
						// "flipSided" : MaterialParameters.flipSided,
						"fog" : MaterialParameters.fog,
						//"lightsEnabled" : MaterialParameters.lightsEnabled,
						"depthWrite" : MaterialParameters.depthWrite,
						"depthTest" : MaterialParameters.depthTest,
						"alphaTest" : MaterialParameters.alphaTest,
						"blending" : MaterialParameters.blending,
						"side" : MaterialParameters.side,
						"polygonOffset" : MaterialParameters.polygonOffset,
						"polygonOffsetFactor" : MaterialParameters.polygonOffsetFactor,
						"polygonOffsetUnits" : MaterialParameters.polygonOffsetUnits,
						//"flipUVs" : MaterialParameters.flipUVs,
					},
					// Techniques: {
					// 	Standard: {
							//Each pass defines a THREE.JS shader
							//Passes: [
								//{

									uniforms: THREE.UniformsUtils.merge( [

										THREE.UniformsLib[ "fog" ],
										THREE.UniformsLib[ "lights" ],
										THREE.UniformsLib[ "shadowmap" ],
										{

										
										"opacity": { type: "f", value: 1.0 },
										"time": { type: "f", value: 1.0 },
										
										//"flipSided": { type: "i", value: 0 },
										"renderModeNormals": { type: "i", value: 0 },
										// "selectionColor": { type: "c", value: new THREE.Color( 0xffffff )},
										//x = max selection opacity, y = min blend value, z = max blend value
										// "selectionHighlightParams": { type: "v3", value: new THREE.Vector3( 0, 0, 0 )},

										}

									] ),
									
									vertexShader: shader_Uber_VS,
									fragmentShader: shader_Uber_PS,
									
									
									
								//}
							//]//Passes array
					// 	},
						
					// }//Techniques
				},//Transmissive

				'Skin': {

					Category: "Advanced",
					Description: ["This material has a metallic sheen with a glossy topcoat. It's ideal for glossy vehicle paint.",
					"It supports normal-mapping, emissive mapping, and reflections."
					
					].join(" "),

					
					//Cooresponds to the group and subgroup for each param
					Features: {
						"Lighting" : MaterialFeatureDefines["Lighting"],
						"Diffuse Color" : MaterialFeatureDefines["Diffuse Color"],
						"Scattering" : MaterialFeatureDefines["Local Scattering"],
						"Rim Lighting" : MaterialFeatureDefines["Rim Lighting"],
						"Normal Map" : MaterialFeatureDefines["Normal Map"],
						"Displacement" : MaterialFeatureDefines["Displacement"],
						"Specular" : MaterialFeatureDefines["Specular"],
						"Reflections" : MaterialFeatureDefines["Reflections"],
						"Emissive" : MaterialFeatureDefines["Emissive"],
					},

					//The "Parameters" are displayed for the user in the UI. Each should have a description (to be used in tool-tips, etc.)
					//a name, a type and a default value. The user shouldn't need to provide a value for any of these (e.g. if they don't 
					//specify one of the textures, it'll get set to a default) and they shouldn't care whether the parameter is needed for 
					//the first pass, second pass, fallback technique, etc.
					//The group name can be used to organize the UI to make it more readable and understandable for the user.
					Parameters: {

						"diffuseColor": MaterialParameters.diffuseColor,
						"colorOpacity": MaterialParameters.colorOpacity,
						"scatterColor": MaterialParameters.scatterColor,
						"scatterLocalScale": MaterialParameters.scatterLocalScale,
						"rimColor" : MaterialParameters.rimColor,
						"rimPower" : MaterialParameters.rimPower,
						"diffuseTexture" : MaterialParameters.diffuseTexture,
						"diffuseUVChannel" : MaterialParameters.diffuseUVChannel,
						"diffuseTextureOffset" : MaterialParameters.diffuseTextureOffset,
						"diffuseTextureScale" : MaterialParameters.diffuseTextureScale,
						"diffuseTexturePan" : MaterialParameters.diffuseTexturePan,
						"alphaBlendMode": MaterialParameters.alphaBlendMode,
						"colorBlend": MaterialParameters.colorBlend,
						"sssTexture" : MaterialParameters.sssTexture,
						"sssUVChannel" : MaterialParameters.sssUVChannel,
						"sssTextureOffset": MaterialParameters.sssTextureOffset,
						"sssTextureScale": MaterialParameters.sssTextureScale,
						"sssTexturePan": MaterialParameters.sssTexturePan,
						"aoTexture" : MaterialParameters.aoTexture,
						"aoUVChannel" : MaterialParameters.aoUVChannel,
						"aoTextureOffset" : MaterialParameters.aoTextureOffset,
						"aoTextureScale" : MaterialParameters.aoTextureScale,
						"aoTexturePan" : MaterialParameters.aoTexturePan,
						"normalTexture"	: MaterialParameters.normalTexture,
						"normalUVChannel"	: MaterialParameters.normalUVChannel,
						"normalScale": MaterialParameters.normalScale,
						"normalTextureFlipY": MaterialParameters.normalTextureFlipY,
						"normalTextureFlipX": MaterialParameters.normalTextureFlipX,
						"normalTextureOffset" : MaterialParameters.normalTextureOffset,
						"normalTextureScale" : MaterialParameters.normalTextureScale,
						"normalTexturePan" : MaterialParameters.normalTexturePan,
						"displacementBaseMag": MaterialParameters.displacementBaseMag,
						"displacementBaseBias": MaterialParameters.displacementBaseBias,
						"displacementTexture" : MaterialParameters.displacementTexture,
						"displacementUVChannel" : MaterialParameters.displacementUVChannel,
						"displacementMag": MaterialParameters.displacementMag,
						"displacementBias": MaterialParameters.displacementBias,
						"displacementTextureOffset" : MaterialParameters.displacementTextureOffset,
						"displacementTextureScale" : MaterialParameters.displacementTextureScale,
						"displacementTexturePan" : MaterialParameters.displacementTexturePan,
						"specularColor": MaterialParameters.specularColor,
						// "ks_roughness" : MaterialParameters.ks_roughness,
						// "ks_brightness" : MaterialParameters.ks_brightness,
						"specularIntensity": MaterialParameters.specularIntensity,
						"gloss": MaterialParameters.gloss,
						"specularTexture"	: MaterialParameters.specularTexture,
						"specularUVChannel" : MaterialParameters.specularUVChannel,
						"specularTextureOffset" : MaterialParameters.specularTextureOffset,
						"specularTextureScale" : MaterialParameters.specularTextureScale,
						"specularTexturePan" : MaterialParameters.specularTexturePan,
						"emissiveColor": MaterialParameters.emissiveColor,
						"emissiveIntensity": MaterialParameters.emissiveIntensity,
						"emissiveTexture"	: MaterialParameters.emissiveTexture,
						"emissiveUVChannel" : MaterialParameters.emissiveUVChannel,
						"emissiveTextureOffset" : MaterialParameters.emissiveTextureOffset,
						"emissiveTextureScale" : MaterialParameters.emissiveTextureScale,
						"emissiveTexturePan" : MaterialParameters.emissiveTexturePan,
						"environmentMappingType" : MaterialParameters.environmentMappingType,
						"environmentTexture" : MaterialParameters.environmentTexture,
						"environmentTexture2D" : MaterialParameters.environmentTexture2D,
						"reflectionFresnel": MaterialParameters.reflectionFresnel,
						"reflectionBias": MaterialParameters.reflectionBias,
						// "perPixel" : MaterialParameters.perPixel,
						// "doubleSidedLighting" : MaterialParameters.doubleSidedLighting,
						// "flipSided" : MaterialParameters.flipSided,
						"fog" : MaterialParameters.fog,
						//"lightsEnabled" : MaterialParameters.lightsEnabled,
						"depthWrite" : MaterialParameters.depthWrite,
						"depthTest" : MaterialParameters.depthTest,
						"alphaTest" : MaterialParameters.alphaTest,
						"blending" : MaterialParameters.blending,
						"side" : MaterialParameters.side,
						"polygonOffset" : MaterialParameters.polygonOffset,
						"polygonOffsetFactor" : MaterialParameters.polygonOffsetFactor,
						"polygonOffsetUnits" : MaterialParameters.polygonOffsetUnits,
						//"flipUVs" : MaterialParameters.flipUVs,
					},
					// Techniques: {
					// 	Standard: {
							//Each pass defines a THREE.JS shader
							//Passes: [
								//{
									//renderParams: {
										//blending : THREE.NormalBlending,
										//wireframe : false,
										//flipSided : false,
									//},
									uniforms: THREE.UniformsUtils.merge( [

										THREE.UniformsLib[ "fog" ],
										THREE.UniformsLib[ "lights" ],
										THREE.UniformsLib[ "shadowmap" ],
										{

										
											"opacity": { type: "f", value: 1.0 },
											"time": { type: "f", value: 1.0 },
											
											//"flipSided": { type: "i", value: 0 },
											"renderModeNormals": { type: "i", value: 0 },
											// "selectionColor": { type: "c", value: new THREE.Color( 0xffffff )},
											//x = max selection opacity, y = min blend value, z = max blend value
											// "selectionHighlightParams": { type: "v3", value: new THREE.Vector3( 0, 0, 0 )},
											"colorOpacity" : { type: "f", value: 1.0},
											"alphaBlendMode" : {type: "i", value: 1 },
											// "reflectionFresnel" : {type: "f", value: 2.0},
											// "reflectionBias" : {type: "f", value: -1.0},
											// "beckmannTexture"	   : { type: "t", value: null, default: "beckmann" },

										}

									] ),
									
									vertexShader: shader_Uber_VS,
									fragmentShader: shader_Uber_PS,	
									
								//}
							//]//Passes array
					// 	},
						
					// }//Techniques
				}//Skin
				
			}//Library
		}//VeroldMaterialTypeLibrary

		VeroldMaterialTypeLibrary.BaseMaterialRequirements = {
			"MAX_VARYING_VECTORS" : 5,
			"MAX_FRAGMENT_UNIFORM_VECTORS" : 5, //TODO - we could potentially pack a bunch of these together
			"MAX_VERTEX_UNIFORM_VECTORS" : 6 //Some of this is for skinning
		};

		VeroldMaterialTypeLibrary.BaseRequirements_DirectionalLight = {
			"MAX_FRAGMENT_UNIFORM_VECTORS" : 2, //Only for Lighting
			"MAX_VERTEX_UNIFORM_VECTORS" : 2, //Only for vertex lighting
		};

		VeroldMaterialTypeLibrary.BaseRequirements_PointLight = {
			"MAX_FRAGMENT_UNIFORM_VECTORS" : 2, //Only for Lighting
			"MAX_VERTEX_UNIFORM_VECTORS" : 2, //Only for vertex lighting
		};

		VeroldMaterialTypeLibrary.BaseRequirements_Shadow = {
			"MAX_VARYING_VECTORS" : 1,
			"MAX_VERTEX_UNIFORM_VECTORS" : 4,
			"MAX_FRAGMENT_UNIFORM_VECTORS" : 2,
		};

		return VeroldMaterialTypeLibrary;
	}

	return generate;

});

/**
 * @module VAPI
 */
define('VeroldEngine/AssetRegistry/MaterialRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/MaterialAsset'
       , 'VeroldEngine/Materials/VeroldMaterialTypeLibrary'
  ],
  function(_, THREE, MaterialAsset, veroldMaterialTypeLibraryGenerator ) {
    /**
     * Registry with manages all material assets
     * @class MaterialRegistry
     * @param {Object} [properties] Material registry properties
     * @constructor
     */
    var MaterialRegistry = function( properties ) {
      this.materialTypeLibrary = veroldMaterialTypeLibraryGenerator(properties);

      this.assets = undefined;
      this.materialObjectTypes = {
        "static" : {
          "lights": true,
          "fog": true,
          "vertexColors": THREE.VertexColors,
          "skinning" : false
        },
        "skinned" : {
          "lights": true,
          "fog": true,
          "vertexColors": THREE.VertexColors,
          "skinning" : true
        },
        "depth_static" : {
          "lights": false,
          "fog": false,
          "vertexColors": THREE.NoColors,
          "skinning" : false,
          "defines" : {
            "DEPTH_PASS" : true
          }
        },
        "depth_skinned" : {
          "lights": false,
          "fog": false,
          "vertexColors": THREE.NoColors,
          "skinning" : true,
          "defines" : {
            "DEPTH_PASS" : true
          }
        },
      };

      this.sharedUniforms = {
        "time" : { type: 'f', value: 0.0 },
        "screenDimensions": { type: 'v4', value: new THREE.Vector4( ) }
      };

      this.timeValueInUse = false;
    };

    MaterialRegistry.prototype = {
      // DOM element

      constructor: MaterialRegistry,

      initialize: function( properties ) {

        this.assets = {};
        this.veroldEngine = properties.veroldEngine;

        this.initUniformLists();

        this.sharedUniforms.screenDimensions.value = new THREE.Vector4( 0, 0, this.veroldEngine.getBaseRenderer().getCanvasWidth(), this.veroldEngine.getBaseRenderer().getCanvasHeight());

        this.veroldEngine.on("rebuildMaterials", this.rebuildAll, this );
        this.veroldEngine.on("textureUnloaded", this.onTextureUnloaded, this );
        this.veroldEngine.on("textureChanged", this.onTextureChanged, this );
        this.veroldEngine.on("resize", this.onResize, this );
      },

      uninitialize: function(  ) {
        for ( var x in this.assets ) {
          this.assets[x].uninitialize();
          delete this.assets[x];
        }

        this.assets = undefined;
        this.veroldEngine.off("rebuildMaterials", this.rebuildAll, this );
        this.veroldEngine.off("resize", this.onResize, this );
        this.veroldEngine.off("textureUnloaded", this.onTextureUnloaded, this );
        this.veroldEngine.off("textureChanged", this.onTextureChanged, this );
        this.veroldEngine = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      // _initComponents: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.loadComponents();

      //   }, this );
      // },

      initSystemAssets: function() {
        //create and load the default textures
        for ( var tex in this.materialTypeLibrary.DefaultTextures ) {
          if ( this.veroldEngine.isPrimaryEngine() ) {
            this.veroldEngine.assetRegistry.Textures.createAsset( this.materialTypeLibrary.DefaultTextures[tex] );
            var textureAsset = this.veroldEngine.assetRegistry.Textures.getAssetById( tex );
            textureAsset.load();
          }
        }
        //Cause the missing material to be loaded.
        //var mat = this.getMissingMaterial( { autoLoad: true });
      },

      //Go through the material library and mark features as supported or unsupported based on the current render device.
      // initFeatureSupport: function() {
      //   function _checkFeatures( features, requirementTotals ) {
      //     if ( !requirementTotals ) {
      //       var requirementTotals = {};
      //     }
      //     for ( var f in features ) {
      //       var supported = true;
      //       for ( var r in features[f].Requires ) {
      //         if ( requirementTotals[r] === undefined ) requirementTotals[r] = 0;
      //         requirementTotals[r] += features[f].Requires[r];
      //         //Check the requirements against the renderer capabilities.
      //         if ( that.veroldEngine.renderController.caps[r] < requirementTotals[r] ) {
      //           console.warn( f + " is not supported on the current device because " + r + " is " + that.veroldEngine.renderController.caps[r] + " and we require at least " + requirementTotals[r] );
      //           supported = false;
      //         }
      //       }
      //       features[f].supported = supported;
      //       if ( features[f].SubFeatures ) {
      //         _checkFeatures( features[f].SubFeatures, requirementTotals );
      //       }
      //     }
      //   }

      //   var that = this;

      //   for ( var matType in this.materialTypeLibrary.Library ) {
      //     var features = this.materialTypeLibrary.Library[ matType ].Features;
      //     _checkFeatures( features );
      //   }
      // },

      //Build the list of uniforms for each material type, based on the parameters for the material and the capabilities of the user's hardware.
      initUniformLists: function() {
        for ( var matType in this.materialTypeLibrary.Library ) {
          var matDef = this.materialTypeLibrary.Library[ matType ];
          var params = matDef.Parameters;
          //Go through params and add appropriate uniforms to uniform list (taking feature support into account)
          for ( var p in params ) {
            if ( !params[p].isRenderParam && !params[p].deprecated ) {
              //Check if the parameter is part of a defined feature. Then, if the feature isn't supported, skip adding the uniform.
              if ( params[p].feature ) {
                if ( !(matDef.Features && matDef.Features[ params[p].feature ] ) ) {
                  //console.warn("Skipping adding uniform " + p + " because it isn't supported.")
                  if ( params[p].subFeature ) {
                    var feature = matDef.Features[ params[p].feature ];
                    if ( !(feature.SubFeatures && feature.SubFeatures[ params[p].subFeature ] ) ) {
                      continue;
                    }
                  }
                  else {
                    continue;
                  }
                }
              }

              var uniforms = matDef.uniforms;
              if ( uniforms[p] ) continue;
              uniforms[p] = {};
              if ( params[p].type === 'dd' ) {
                uniforms[p].type = 'i';
                uniforms[p].value = params[p].value;
              }
              else if (params[p].type === 'b') {
                uniforms[p].type = 'i';
                uniforms[p].value = params[p].value ? 1 : 0;
              }
              else if (params[p].type === 'c') {
                uniforms[p].type = params[p].type;
                uniforms[p].value = new THREE.Color();
                uniforms[p].value.copy( params[p].value );
                uniforms[p].value.copyGammaToLinear( uniforms[p].value );
              }
              else {
                uniforms[p].type = params[p].type;
                uniforms[p].value = params[p].value;
              }


            }
          }
        }

        //Init shared uniforms
      },

      /**
       * Return the minimum values of device capabilities required
       * to run the shaders without any material features turned on.
       * @method getMinShaderRequirements
       * @return {Object} Object containing required capabilities and their min values.
       */
      getMinShaderRequirements: function() {
        
        function addRequirements( requirementsDef, accumulatedReqs ) {
          _.each( requirementsDef, function( value, key ) {
            if ( accumulatedReqs[ key ] === undefined ) {
              accumulatedReqs[ key ] = 0;
            }
            if ( accumulatedReqs[ key ] !== undefined ) {
              accumulatedReqs[ key ] += value;
            }
          }, this );
        }

        //Get max light and shadow settings from render controller
        //Use the shader requirements to calculate the minimum values.
        var minRequirements = {};
        
        var threeRenderer = this.veroldEngine.getBaseRenderer().threeRenderer;

        var maxDirLights = threeRenderer.maxDirLights;
        var maxPointLights = threeRenderer.maxPointLights;
        var maxShadows = threeRenderer.maxShadows;

        addRequirements( this.materialTypeLibrary.BaseMaterialRequirements, minRequirements );
        for ( var i = 0; i < maxDirLights; i++ ) {
          addRequirements( this.materialTypeLibrary.BaseRequirements_DirectionalLight, minRequirements );
        }
        for ( i = 0; i < maxPointLights; i++ ) {
          addRequirements( this.materialTypeLibrary.BaseRequirements_PointLight, minRequirements );
        }
        for ( i = 0; i < maxShadows; i++ ) {
          addRequirements( this.materialTypeLibrary.BaseRequirements_Shadow, minRequirements );
        }

        return minRequirements;
      },

      getMissingMaterial: function( options ) {
        if ( !this.assets["missingMaterial"] ) {
          console.log("Creating missing material.");
          this.createAsset( {
            name: "Missing Material",
            id: "missingMaterial",
            type: "material",
            payload: {
              materialType: "Simple",
              diffuseColor: 9671571,
              reflectionBias: -1,
              reflectionPower: 6,
              specularIntensity: 0.5,
              specularColor: 9671571,
              gloss: 0.35

            } 
          },
          {
            success: function( newMaterial ) {
              newMaterial.load( options );
            }
          });
          this.getAssetById("missingMaterial").load( options );
          this.getAssetById("missingMaterial").enableFeature( "Specular", undefined, true );
        }
        else {
          this.getAssetById("missingMaterial").load();
        }
        return this.getAssetById("missingMaterial");
      },


      getSharedUniform: function( uniformName ) {
        return this.sharedUniforms[uniformName];
      },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {
        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persistent, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model.");

        var newAsset = new MaterialAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;
      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

      update: function( delta ) {
        if ( this.timeValueInUse ) {
          this.veroldEngine.needsRender = true;
        }
        this.sharedUniforms.time.value = Date.now() % 60000 / 1000;
      },

      onResize: function() {
        var renderController = this.veroldEngine.getBaseRenderer();
        this.sharedUniforms.screenDimensions.value.x = 0;
        this.sharedUniforms.screenDimensions.value.y = 0;
        this.sharedUniforms.screenDimensions.value.z = renderController.getCanvasWidth();
        this.sharedUniforms.screenDimensions.value.w = renderController.getCanvasHeight();
      },

      onTextureUnloaded: function( textureID ) {
        _.each( this.assets, function( matAsset ) {
          var updateNeeded = false;
          var payload = matAsset.entityModel.get("payload");
          var json = { };
          for ( var p in payload) {
            if (payload[p] === textureID ) {
              updateNeeded = true;
              json["payload." + p] = null;
            }
          }
          if ( updateNeeded ) {
            matAsset.set( json );
          }
        }, this );
        
      },
      
      onTextureChanged: function( textureID, changes ) {
        _.each( this.assets, function( matAsset ) {
          var packingUpdateNeeded = false;
          var payload = matAsset.entityModel.get("payload");
          var json = { };
          for ( var p in payload) {
            if ( payload[p] === textureID ) {
              if ( changes.packing !== undefined ) {
                packingUpdateNeeded = true;
                json["payload." + p] = null;
              }
            }
          }
          if ( packingUpdateNeeded ) {
            matAsset.set( json );
            for ( var t in json ) {
              json[t] = textureID;
            }
            matAsset.set( json );
          }
        }, this );
        
      },

      rebuildAll: function() {
        _.each( this.assets, function( matAsset ) {
          if ( matAsset.threeData ) {
            for ( var y in matAsset.threeData ) {
              matAsset.threeData[y].needsUpdate = true;
            }
          }
        }, this );
      },

      getMaterialLibrary: function() {
        return this.materialTypeLibrary.Library;
      },

      getMaterialDefinition: function( veroldMaterialType ) {
        if ( !veroldMaterialType || !this.materialTypeLibrary.Library[ veroldMaterialType ] ) {
          //Error. Invalid material type specified.
          if ( veroldMaterialType === "Advanced" ) {
            veroldMaterialType = "Standard";
          }
          else if (veroldMaterialType === "Non-Textured") {
            veroldMaterialType = "Simple";
          }
          else  {
            veroldMaterialType = "Standard";
          }
        }

        return this.materialTypeLibrary.Library[ veroldMaterialType ];
      }

    };

    return MaterialRegistry;
  });

/*jslint browser: true, indent: 2, nomen: true, bitwise: true*/
/*global define, Int32Array, Uint8Array, VAPI*/


define('VeroldEngine/AssetRegistry/BaseTextureAsset',[
  'underscore',
  'three',
  'VeroldEngine/AssetRegistry/VeroldAsset',
  'VeroldEngine/Loaders/GenericLoader'
], function (_, THREE, VeroldAsset, GenericLoader) {
  var BaseTextureAsset = function () {
    VeroldAsset.call(this);
  };

  BaseTextureAsset.prototype = new VeroldAsset();

  _.extend(BaseTextureAsset.prototype, VeroldAsset.prototype, {
    initialize: function (properties) {
      VeroldAsset.prototype.initialize.call(this, properties);

      // Assign default payload values, based on the texture type.
      var json = this.entityModel.toJSON(),
        type = this.entityModel.get('type'),
        defaults = this.registry.defaultTextureSettings[type];

      _.each(defaults, function (value, key) {
        var data = {};

        if (json.payload[key] === undefined) {
          data["payload." + key] = value;
          this.set(data, { silent: true });
        }
      }, this);

      if (!this.entityModel.get('payload.mipmaps')) {
        this.set({ 'payload.mipmaps' : [] }, { silent: true });
      }

      this.loadComponents = true;

      this.trigger('load_hierarchy', this);
      this.trigger('load_hierarchy_dependencies', this);
    },

    unload: function () {
      if (this.threeData) {
        this.veroldEngine.trigger('textureUnloaded', this.id);

        console.log(this.veroldEngine.engineName + ' - Unloading texture, ' +
          this.entityModel.get('name'));

        this.threeData.dispose();
      }
    },

    applyPayloadSettings_loaded: function (changes, options) {
      var payload;

      if (this.threeData) {
        if (changes) {
          payload = this.entityModel.get('payload');

          this.threeData.wrapS = changes.uMapping !== undefined ?
              this.registry.textureUVMappingsMap[payload.uMapping] :
              this.threeData.wrapS;

          this.threeData.wrapT = changes.vMapping !== undefined ?
              this.registry.textureUVMappingsMap[payload.vMapping] :
              this.threeData.wrapT;

          this.threeData.anisotropy = changes.anisotropy !== undefined ?
              payload.anisotropy : this.threeData.anisotropy;

          this.threeData.premultiplyAlpha =
              changes.premultiplyAlpha !== undefined ?
                payload.premultiplyAlpha : this.threeData.premultiplyAlpha;

          this.threeData.flipY = false;

          this.threeData.generateMipmaps =
              changes.generateMipmaps !== undefined &&
              !this.isCompressed ? payload.generateMipmaps :
                this.threeData.generateMipmaps;

          if (changes.packingOverride !== undefined) {
            switch( changes.packingOverride ) {
            case 'rgbm':
              this.threeData.hdrPacking = THREE.HDRRGBM;
              break;
            case 'rgbd':
              this.threeData.hdrPacking = THREE.HDRRGBD;
              break;
            case 'rgbe':
              this.threeData.hdrPacking = THREE.HDRRGBE;
              break;
            case 'logluv':
              this.threeData.hdrPacking = THREE.HDRLOGLUV;
              break;  
            default:
            }
          } else if (changes.isHDR !== undefined) {
            this.threeData.hdrPacking = changes.isHDR ?
                THREE.HDRRGBM : undefined;
          }

          if (changes.filtering !== undefined) {
            var filtersMap;
            if ( this.registry.textureFiltersMap[ payload.packingOverride ] ) {
              filtersMap = this.registry.textureFiltersMap[ payload.packingOverride ];
            }
            else {
              filtersMap = this.registry.textureFiltersMap.Default;
            }
            if ( filtersMap[ payload.filtering ] ) {
              this.threeData.minFilter = filtersMap[ payload.filtering ].minFilter;
              this.threeData.magFilter = filtersMap[ payload.filtering ].magFilter;
            }
            else {
              console.warn("Unknown filter type, " + payload.filtering );
              this.threeData.minFilter = filtersMap[ "Linear" ].minFilter;
              this.threeData.magFilter = filtersMap[ "Linear" ].magFilter;
            }
          }

          this.threeData.needsUpdate = true;
        }

        if (options && options.success) {
          options.success();
        }
      }

      this.trigger('updated', this);
    },

    applyPayloadSettings_unloaded: function (changes) {
      if ( changes.preferCompression !== undefined ) {
        this.defaultResource = undefined;
        this.defaultResources = undefined;
      }
      this.veroldEngine.trigger('textureChanged', this.id, changes);
    },

    generateManualMipmaps: function() {
      if ( !this.downSampleMaterial ) {
        //create the material
      }
      if ( this.threeData ) {
        //Render the mips into render targets
        that.threeData.mipmaps.push(texture.image);
        var numMips = this.getNumMips();
        var renderer = this.veroldEngine.getThreeRenderer();
        for ( var i = 0; i < numMips; i++ ) {
          this.downSampleMaterial.uniforms.resolution.value.x = Math.pow( 2.0, numMips - i );
          this.downSampleMaterial.uniforms.resolution.value.y = Math.pow( 2.0, numMips - i );
          renderer.render( this.downSampleScene, this.downSampleCamera, this.currentLuminanceRTDownSampled[ i ], true );
          this.materialDownSample.uniforms.tDiffuse.value = this.currentLuminanceRTDownSampled[ i ];
        }

        //Copy the mips into the render texture
        // _gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );
        // _gl.texImage2D( _gl.TEXTURE_2D, ... );
        // Or, if that doesn't work, read the texture data out and shove it back in.
      }
    },

    _clampToSize: function (image, maxSize) {
      if (!this.isCompressed) {
        if (image.width <= maxSize && image.height <= maxSize) {
          return image;
        }

        // Warning: Scaling through the canvas will only work with images that
        // use premultiplied alpha.

        var maxDimension = Math.max(image.width, image.height),
          newWidth = Math.floor(image.width * maxSize / maxDimension),
          newHeight = Math.floor(image.height * maxSize / maxDimension),
          canvas = document.createElement('canvas'),
          ctx;

        canvas.width = newWidth;
        canvas.height = newHeight;

        ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, newWidth,
          newHeight);

        return canvas;
      }

      return null;
    },

    _loadCompressedTexture: function (url, mapping, onLoad) {
      var that = this,
        loader = new GenericLoader(this.veroldEngine);

      loader.loadFile(url, 'arraybuffer', function (err, buffer) {
        if (err) {
          return console.warn('Error loading texture', err);
        }

        var texture = new THREE.CompressedTexture(),
          dds = that._parseDDS(buffer, true),
          iFace,
          iMip,
          nFaces;

        if (mapping !== undefined) {
          texture.mapping = mapping;
        }

        texture.format = dds.format;
        texture.generateMipmaps = false;
        texture.needsUpdate = true;

        if (dds.isCubemap) {
          texture.flipY = false;
          texture.image = [];

          nFaces = dds.mipmaps.length / dds.mipmapCount;

          for (iFace = 0; iFace < nFaces; iFace += 1) {
            texture.image[iFace] = { mipmaps : [] };

            for (iMip = 0; iMip < dds.mipmapCount; iMip += 1) {
              texture.image[iFace].mipmaps.push(
                dds.mipmaps[iFace * dds.mipmapCount + iMip]
              );

              texture.image[iFace].format = dds.format;
              texture.image[iFace].width = dds.width;
              texture.image[iFace].height = dds.height;
            }
          }
        } else {
          texture.mipmaps = dds.mipmaps;
          texture.image.width = dds.width;
          texture.image.height = dds.height;
        }

        if (onLoad) {
          onLoad(texture);
        }
      }, function (progressObj) {
        that.loadingProgress.textures = progressObj.loaded;
        that.trigger('load_progress', that);
      });
    },

    _parseDDS: function (buffer, loadMipmaps) {
      // Adapted from @toji's DDS utils
      //  https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

      // All values and structures referenced from:
      // http://msdn.microsoft.com/en-us/library/bb943991.aspx/

      function fourCCToInt32(value) {
        return value.charCodeAt(0) +
          (value.charCodeAt(1) << 8) +
          (value.charCodeAt(2) << 16) +
          (value.charCodeAt(3) << 24);
      }

      function int32ToFourCC(value) {
        return String.fromCharCode(
          value & 0xff,
          (value >> 8) & 0xff,
          (value >> 16) & 0xff,
          (value >> 24) & 0xff
        );
      }

      function loadARGBMip(buffer, dataOffset, width, height) {
        var dataLength = width * height * 4,
          srcBuffer = new Uint8Array(buffer, dataOffset, dataLength),
          byteArray = new Uint8Array(dataLength),
          dst = 0,
          src = 0,
          x,
          y,
          r,
          g,
          b,
          a;

        for (y = 0; y < height; y += 1) {
          for (x = 0; x < width; x += 1) {
            b = srcBuffer[src];
            g = srcBuffer[src + 1];
            r = srcBuffer[src + 2];
            a = srcBuffer[src + 3];
            byteArray[dst] = r;     // r
            byteArray[dst + 1] = g; // g
            byteArray[dst + 2] = b; // b
            byteArray[dst + 3] = a; // a
            src += 4;
            dst += 4;
          }
        }

        return byteArray;
      }

      var DDS_MAGIC = 0x20534444,

        //DDSD_CAPS = 0x1,
        //DDSD_HEIGHT = 0x2,
        //DDSD_WIDTH = 0x4,
        //DDSD_PITCH = 0x8,
        //DDSD_PIXELFORMAT = 0x1000,
        DDSD_MIPMAPCOUNT = 0x20000,
        //DDSD_LINEARSIZE = 0x80000,
        //DDSD_DEPTH = 0x800000,

        //DDSCAPS_COMPLEX = 0x8,
        //DDSCAPS_MIPMAP = 0x400000,
        //DDSCAPS_TEXTURE = 0x1000,

        DDSCAPS2_CUBEMAP = 0x200,
        //DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
        //DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
        //DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
        //DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
        //DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
        //DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
        //DDSCAPS2_VOLUME = 0x200000,

        //DDPF_ALPHAPIXELS = 0x1,
        //DDPF_ALPHA = 0x2,
        DDPF_FOURCC = 0x4,
        //DDPF_RGB = 0x40,
        //DDPF_YUV = 0x200,
        //DDPF_LUMINANCE = 0x20000,

        FOURCC_DXT1 = fourCCToInt32("DXT1"),
        FOURCC_DXT3 = fourCCToInt32("DXT3"),
        FOURCC_DXT5 = fourCCToInt32("DXT5"),

        headerLengthInt = 31, // The header length in 32 bit ints

        // Offsets into the header array
        off_magic = 0,
        off_size = 1,
        off_flags = 2,
        off_height = 3,
        off_width = 4,
        off_mipmapCount = 7,
        off_pfFlags = 20,
        off_pfFourCC = 21,
        off_RGBBitCount = 22,
        off_RBitMask = 23,
        off_GBitMask = 24,
        off_BBitMask = 25,
        off_ABitMask = 26,
        //off_caps = 27,
        off_caps2 = 28,
        //off_caps3 = 29,
        //off_caps4 = 30,

        header,
        blockBytes,
        fourCC,
        isRGBAUncompressed,

        dataOffset,
        width,
        height,

        iFace,
        nFaces,
        iMip,

        byteArray,
        dataLength,

        dds = {
          mipmaps: [],
          width: 0,
          height: 0,
          format: null,
          mipmapCount: 1
        };

      header = new Int32Array(buffer, 0, headerLengthInt);

      // Parse header

      if (header[off_magic] !== DDS_MAGIC) {
        console.error('THREE.DDSLoader.parse: Invalid magic number in DDS ' +
          'header.');
        return dds;
      }

      if (!header[off_pfFlags] & DDPF_FOURCC) {
        console.error('THREE.DDSLoader.parse: Unsupported format, must ' +
          'contain a FourCC code.');
        return dds;
      }

      fourCC = header[off_pfFourCC];
      isRGBAUncompressed = false;

      switch (fourCC) {
      case FOURCC_DXT1:
        blockBytes = 8;
        dds.format = THREE.RGB_S3TC_DXT1_Format;
        break;

      case FOURCC_DXT3:
        blockBytes = 16;
        dds.format = THREE.RGBA_S3TC_DXT3_Format;
        break;

      case FOURCC_DXT5:
        blockBytes = 16;
        dds.format = THREE.RGBA_S3TC_DXT5_Format;
        break;

      default:
        if (header[off_RGBBitCount] === 32 &&
            header[off_RBitMask] & 0xff0000 &&
            header[off_GBitMask] & 0xff00 &&
            header[off_BBitMask] & 0xff &&
            header[off_ABitMask] & 0xff000000) {
          isRGBAUncompressed = true;
          blockBytes = 64;
          dds.format = THREE.RGBAFormat;
        } else {
          console.error('THREE.DDSLoader.parse: Unsupported FourCC code ',
            int32ToFourCC(fourCC));
          return dds;
        }
      }

      dds.mipmapCount = 1;

      if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
        dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
      }

      // TODO: Verify that all faces of the cubemap are present with
      // DDSCAPS2_CUBEMAP_POSITIVEX, etc.

      dds.isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;

      dds.width = header[off_width];
      dds.height = header[off_height];

      dataOffset = header[off_size] + 4;

      // Extract mipmaps buffers

      width = dds.width;
      height = dds.height;

      nFaces = dds.isCubemap ? 6 : 1;

      for (iFace = 0; iFace < nFaces; iFace += 1) {
        for (iMip = 0; iMip < dds.mipmapCount; iMip += 1) {
          if (isRGBAUncompressed) {
            byteArray = loadARGBMip(buffer, dataOffset, width, height);
            dataLength = byteArray.length;
          } else {
            dataLength = Math.max(4, width) / 4 * Math.max(4, height) /
              4 * blockBytes;
            byteArray = new Uint8Array(buffer, dataOffset, dataLength);
          }

          dds.mipmaps.push({ data: byteArray, width: width, height: height });

          dataOffset += dataLength;

          width = Math.max(width * 0.5, 1);
          height = Math.max(height * 0.5, 1);
        }

        width = dds.width;
        height = dds.height;
      }

      return dds;
    },

    /**
     * Returns the download size of this texture. Specify filters to query the
     * desired texture. If no filters are specified, the default texture for the
     * current device will be queried.
     * @method getDataSizeTextureDownload
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureDownload: function () {
      return 0;
    },

    /**
     * Returns the download size of this texture after being unzipped by the
     * browser. Specify filters to query the desired texture. If no filters are
     * specified, the default texture for the current device will be queried.
     * @method getDataSizeTextureDownload_Uncompressed
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureDownload_Uncompressed: function () {
      return 0;
    },

    /**
     * Returns the total amount of GPU memory occupied by this texture. Specify
     * filters to query the desired texture. If no filters are specified, the
     * default texture for the current device will be queried.
     * @method getDataSizeTextureInMemory
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureInMemory: function () {
      return 0;
    },

    /** Returns the maximum texture size supported by the device.
     * @return {Integer} The maximum texture size.
     */
    getMaxTextureSize: function () {
      return VAPI.isMobile() ?
          1024 : this.veroldEngine.getGPUCapability('MAX_TEXTURE_SIZE');
    },

    /**
     * Returns the pixel format of the texture. Specify filters to query the
     * desired texture. If no filters are specified, the default texture for the
     * current device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {String} The texture pixel format.
     */
    getPixelFormat: function () {
      console.error('Texture type needs to implement getPixelFormat()');
    },

    getNumMips: function() {
      var width = this.getWidth();
      var height = this.getHeight();
      var max = Math.max( width, height );
      max = Math.max( max, 1 );
      return Math.floor( Math.log2( max ) );
    },

    /**
     * Returns the preferred texture compression format for the device.
     * @return {String} 'atc', 'dxt', 'pvrtc' or 'none'
     */
    getPreferredCompression: function () {
      var compression = 'none';

      // If a compressed format is preferred, get one based on the device caps.
      if (this.getProperty('preferCompression')) {
        if (this.veroldEngine.supportsCompressedTextureS3TC()) {
          compression = 'dxt';
        } else if (this.veroldEngine.supportsCompressedTexturePVRTC()) {
          compression = 'pvrtc';
        } else if (this.veroldEngine.supportsCompressedTextureATC()) {
          compression = 'atc';
        }

        return compression;
      }
      return compression;
    },

    /**
     * Returns a resource that matches the provided filters.
     * @method getResource
     * @param  {Object} filters An object with properties to filter by
     * @param  {String} filters.compression Compression format of the texture (e.g. 'dxt'). Use 'none' for no compression.
     * @param  {Integer} filters.maxSize The maximum number of texels in the largest dimension
     * @param  {String} filters.pixelFormat e.g. 'rgb', 'rgba', 'rgbm', etc.
     * @return {Object} A resource that matches the filters
     */
    getResource: function (filters) {
      if ( !filters ) {
        filters = {};
      }
      if ( filters.bestMatch !== false) {
        filters.bestMatch = true;
      }
      var resources = this.getResources(filters);

      return resources[0];
    },

    /**
     * Returns an array of resources that match the provided filters.
     * @method getResources
     * @param  {Object} filters An object with properties to filter by
     * @param  {String} filters.compression Compression format of the texture (e.g. 'dxt'). Use 'none' for no compression.
     * @param  {Integer} filters.maxSize The maximum number of texels in the largest dimension
     * @param  {String} filters.pixelFormat e.g. 'rgb', 'rgba', 'rgbm', etc.
     * @return {Array} Array of resources that match the filters
     */
    getResources: function (filters) {
      var resources = this.entityModel.getResources();

      filters = filters || {};

      if (filters.compression !== undefined) {
        resources = _.filter(resources, function (resource) {
          return resource.properties.compression === filters.compression;
        });
      }

      if (filters.maxSize !== undefined) {
        resources = _.filter(resources, function (resource) {
          return resource.properties.width <= filters.maxSize &&
            resource.properties.height <= filters.maxSize;
        });
      }

      if (filters.pixelFormat !== undefined) {
        resources = _.filter(resources, function (resource) {
          return resource.properties.pixelFormat === filters.pixelFormat;
        });
      }

      if (filters.bestMatch) {
        var currentBest;
        if ( resources.length > 1 ) {
          _.each( resources, function( res ) {
            if ( !currentBest || res.properties.width > currentBest.properties.width ) {
              currentBest = res;
            }
          }, this );
          resources = [currentBest];
        }
      }

      return resources;
    },

    /**
     * Returns the width of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture width.
     */
    getWidth: function () {
      console.error('Texture type needs to implement getWidth()');
    },

    /**
     * Returns the height of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture height.
     */
    getHeight: function () {
      console.error('Texture type needs to implement getHeight()');
    }
  });

  window.VAPI = window.VAPI || {};
  window.VAPI.BaseTextureAsset = BaseTextureAsset;

  return BaseTextureAsset;
});


/*jslint browser: true, indent: 2, nomen: true*/
/*global define*/


define('VeroldEngine/AssetRegistry/Texture2DAsset',[
  'underscore',
  'async',
  'three',
  'VeroldEngine/AssetRegistry/BaseTextureAsset'
], function (_, async, THREE, BaseTextureAsset) {
  var Texture2DAsset = function () {
    BaseTextureAsset.call(this);
  };

  Texture2DAsset.prototype = new BaseTextureAsset();

  _.extend(Texture2DAsset.prototype, {
    initialize: function (properties) {
      BaseTextureAsset.prototype.initialize.call(this, properties);
    },

    _loadThreeData: function (changes) {
      var json,
        path,
        resource,
        that = this;

      function _loadTexture2DCallback(texture) {
        var maxTextureSize = that.getMaxTextureSize();

        if (!that.veroldEngine) {
          // Engine has shut down, exit.
          return;
        }

        if (texture.image.width > maxTextureSize ||
            texture.image.height > maxTextureSize) {
          if (that.isCompressed) {
            console.warn('Trying to load a compressed texture that is larger ' +
              'than what is supported by the hardware.');
            return;
          }

          console.warn('Trying to load a texture that is larger than what is ' +
            'supported by the hardware. Attempting to rescale.');

          texture.image = that._clampToSize(texture.image, maxTextureSize);
        }

        that.threeData = texture;
        that.threeData.name = json.name;
        that.threeData.veroldEntityId = that.id;
        changes.payload.packingOverride = resource.properties.pixelFormat;

        that.loadingProgress.textures = that.getDataSizeTextureDownload_Uncompressed();

        that.applyPayloadSettings_loaded(changes.payload, {
          success: function () {
            that.trigger('load_progress', that);
            that.trigger('load_base', that);
          }
        });
      }

      json = this.entityModel.toJSON();

      changes.payload.uMapping = true;
      changes.payload.vMapping = true;
      changes.payload.filtering = true;
      changes.payload.anisotropy = true;
      changes.payload.flipY = false;

      // If the texture hasn't been explicitly set to be uncompressed or
      // compressed and the size is greater than or less than 2048, use
      // compression.
      if (json.payload.preferCompression === undefined &&
          json.payload.tex &&
          json.payload.tex.width >= 2048) {
        this.set({ 'payload.preferCompression': true }, { 'silent': true });
      }

      resource = this._getDefaultResource();

      if (resource) {
        path = this.entityModel.getResourcePathPrefix() + resource.path;

        if (resource.properties.compression === 'dxt') {
          this.isCompressed = true;
          this._loadCompressedTexture(path, null, _loadTexture2DCallback);
        } else {
          THREE.ImageUtils.loadTexture(path, null, _loadTexture2DCallback);
        }
      } else {
        console.warn('Failed to find appropriate default texture.');
      }
    },

    applyPayloadSettings_loaded: function (changes, options) {
      var that = this;

      BaseTextureAsset.prototype.applyPayloadSettings_loaded.call(this, changes,
        {
          success: function () {
            var generateMipmaps = that.getProperty('generateMipmaps'),
              mipmaps = that.getProperty('mipmaps');

            generateMipmaps = generateMipmaps !== undefined ? generateMipmaps :
                that.registry.defaultTextureSettings.texture2D.generateMipmaps;

            if (!that.isCompressed &&
                !generateMipmaps &&
                mipmaps &&
                !_.isEmpty(mipmaps)) {
              that.loadMips(function () {
                // TODO: This is ridiculous but custom mips don't seem to work
                // until the second time they're setup. Just as a hack for now,
                // force load them again after a delay.
                setTimeout(function () {
                  that.loadMips();
                }, 0);

                that.trigger('load_progress', that);
                that.trigger('load_base', that);

                if (options && options.success) {
                  options.success();
                }
              });
            } else if (options && options.success) {
              options.success();
            }
          }
        });
    },

    _getDefaultResource: function () {
      var pixelFormat;
      var results;
      
      if (this.defaultResource === undefined) {
        pixelFormat = this.getProperty('pixelFormat');

        results = this.getResources({
          compression: this.getPreferredCompression(),
          maxSize: this.getMaxTextureSize(),
          pixelFormat: pixelFormat,
          bestMatch: true,
        });

        if (!results.length) {
          // Try again without compression.
          results = this.getResources({
            maxSize: this.getMaxTextureSize(),
            pixelFormat: pixelFormat,
            bestMatch: true,
          });
        }

        this.defaultResource = results[0];
      }

      return this.defaultResource;
    },

    /**
     * Returns the download size of this texture. Specify filters to query the
     * desired texture. If no filters are specified, the default texture for the
     * current device will be queried.
     * @method getDataSizeTextureDownload
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureDownload: function (filters) {
      var resource = filters ?
          this.getResource(filters) : this._getDefaultResource();

      if (resource) {
        return resource.contentLength;
      }

      return 0;
    },

    /**
     * Returns the download size of this texture after being unzipped by the
     * browser. Specify filters to query the desired texture. If no filters are
     * specified, the default texture for the current device will be queried.
     * @method getDataSizeTextureDownload_Uncompressed
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureDownload_Uncompressed: function (filters) {
      var resource = filters ? this.getResource(filters) :
          this._getDefaultResource();

      if (resource) {
        return resource.contentLengthIdentity || resource.contentLength;
      }

      return 0;
    },

    /**
     * Returns the total amount of GPU memory occupied by this texture. Specify
     * filters to query the desired texture. If no filters are specified, the
     * default texture for the current device will be queried.
     * @method getDataSizeTextureInMemory
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureInMemory: function (filters) {
      var pixelSize,
        resource = filters ? this.getResource(filters) :
            this._getDefaultResource();

      if (resource.properties.compression !== 'none') {
        return resource.contentLengthIdentity || resource.contentLength;
      }

      pixelSize = resource.properties.pixelFormat === 'rgb' ? 3 : 4;

      return resource.properties.width * resource.properties.height * pixelSize;
    },

    /**
     * Returns the pixel format of the texture. Specify filters to query the
     * desired texture. If no filters are specified, the default texture for the
     * current device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {String} The texture pixel format.
     */
    getPixelFormat: function (filters) {
      var resource = filters ?
          this.getResource(filters) : this._getDefaultResource();

      if (resource) {
        return resource.properties.pixelFormat;
      }

      return null;
    },

    getNumChannels: function() {
      //TODO handle single-channel textures, etc.
      var pixelSize = this._getDefaultResource().properties.pixelFormat === 'rgb' ? 3 : 4;
      return pixelSize;
    },

    /**
     * Returns the width of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture width.
     */
    getWidth: function (filters) {
      var resource = filters ?
          this.getResource(filters) : this._getDefaultResource();

      if (resource) {
        return resource.properties.width;
      }

      return 0;
    },

    /**
     * Returns the height of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture height.
     */
    getHeight: function (filters) {
      var resource = filters ?
          this.getResource(filters) : this._getDefaultResource();

      if (resource) {
        return resource.properties.height;
      }

      return 0;
    },

    loadMips: function (fn) {
      var that = this,
        failed = false,
        mipmaps = this.getProperty('mipmaps');

      this.threeData.mipmaps = [ this.threeData.image ];

      async.each(mipmaps, function (id, next) {
        var mip = that.registry.getAssetById(id),
          path,
          resource;

        if (mip) {
          resource = mip._getDefaultResource();

          if (resource) {
            path = mip.entityModel.getResourcePathPrefix() + resource.path;

            THREE.ImageUtils.loadTexture(path, null, function (texture) {
              if (texture.image) {
                that.threeData.mipmaps.push(texture.image);
              }

              next();
            });

            return;
          }
        }

        failed = true;
        next();
      }, function () {
        if (failed) {
          that.threeData.mipmaps = [];
          that.threeData.generateMipmaps = true;
        } else {
          that.trigger('load_base');
          that.threeData.needsUpdate = true;
          that.threeData.generateMipmaps = false;
        }

        if (fn) {
          fn();
        }
      });
    }
  });

  window.VAPI = window.VAPI || {};
  window.VAPI.Texture2DAsset = Texture2DAsset;

  return Texture2DAsset;
});


/*jslint browser: true, indent: 2, nomen: true*/
/*global define, VAPI*/


define('VeroldEngine/AssetRegistry/TextureCubeAsset',[
  'underscore',
  'three',
  'VeroldEngine/AssetRegistry/BaseTextureAsset'
], function (_, THREE, BaseTextureAsset) {
  var TextureCubeAsset = function () {
    BaseTextureAsset.call(this);
  };

  TextureCubeAsset.prototype = new BaseTextureAsset();

  _.extend(TextureCubeAsset.prototype, {
    _loadThreeData: function (changes, options) {
      var json = this.entityModel.toJSON(),
        paths,
        resources,
        that = this;

      changes.payload.uMapping = true;
      changes.payload.vMapping = true;
      changes.payload.filtering = true;
      changes.payload.anisotropy = true;
      changes.payload.flipY = false;

      options = options || {};

      function loadTextureCubeCallback(texture) {
        var maxTextureSize = that.getMaxTextureSize();

        if (!that.veroldEngine) {
          // Engine has shut down, exit.
          return;
        }

        if (!texture.image[0]) {
          console.warn('There was an issue loading the cubemap texture, ' +
            that.getName());

          that.state_base = 'error';

          if (options.failure) {
            return options.failure(that.id);
          }

          return;
        }

        if (texture.image[0].width > maxTextureSize ||
            texture.image[0].height > maxTextureSize) {
          if (that.isCompressed) {
            console.warn('Trying to load a compressed cubemap texture that ' +
              'is larger than what is supported by the hardware.');

            that.state_base = 'error';

            if (options.failure) {
              return options.failure(that.id);
            }

            return;
          }

          console.warn('Trying to load a cubemap texture that is larger ' +
            'than what is supported by the hardware. Attempting to rescale.');

          _.each(_.keys(texture.image), function (idx) {
            texture.image[idx] = that._clampToSize(texture.image[idx],
              maxTextureSize);
          });
        }

        that.threeData = texture;
        that.threeData.name = json.name;
        that.threeData.veroldEntityId = that.id;

        that.applyPayloadSettings_loaded(changes.payload, options);
        that.trigger('load_base', that);
      }

      resources = this._getDefaultResources();

      paths = _.map(resources, function (resource) {
        return that.entityModel.getResourcePathPrefix() + resource.path;
      });

      if (resources.length === 6) {
        this.isCompressed = false;
        THREE.ImageUtils.loadTextureCube(paths, THREE.CubeReflectionMapping,
          loadTextureCubeCallback);
      } else if (resources.length > 0) {
        this.isCompressed = true;
        this._loadCompressedTexture(paths[0], THREE.CubeReflectionMapping,
          loadTextureCubeCallback);
      } else {
        console.warn('Failed to find appropriate default texture.');
      }
    },

    _getDefaultResources: function () {
      var compression,
        pixelFormat;

      if (this.defaultResources === undefined) {
        compression = this.getPreferredCompression();
        pixelFormat = this.getProperty('pixelFormat');

        this.defaultResources = this.getResources({
          compression: compression,
          maxSize: this.getMaxTextureSize(),
          pixelFormat: pixelFormat,
          bestMatch: true,
        });

        if (this.defaultResources.length === 0) {
          compression = 'none';
          // Try again without compression.
          this.defaultResources = this.getResources({
            maxSize: this.getMaxTextureSize(),
            pixelFormat: pixelFormat,
            bestMatch: true,
          });
        }
      }

      return this.defaultResources;
    },

    /**
     * Returns the download size of this texture. Specify filters to query the
     * desired texture. If no filters are specified, the default texture for the
     * current device will be queried.
     * @method getDataSizeTextureDownload
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureDownload: function (filters) {
      var resources = filters ?
          this.getResources(filters) : this._getDefaultResources();

      var size = 0;
      _.each( resources, function( resource ) {
        size += resource.contentLength;
      }, this );

      return size;
    },

    /**
     * Returns the download size of this texture after being unzipped by the
     * browser. Specify filters to query the desired texture. If no filters are
     * specified, the default texture for the current device will be queried.
     * @method getDataSizeTextureDownload_Uncompressed
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureDownload_Uncompressed: function (filters) {
      var resources = filters ?
          this.getResources(filters) : this._getDefaultResources();

      var size = 0;
      _.each( resources, function( resource ) {
        size += resource.contentLengthIdentity || resource.contentLength;
      }, this );
      return size;
    },

    /**
     * Returns the total amount of GPU memory occupied by this texture. Specify
     * filters to query the desired texture. If no filters are specified, the
     * default texture for the current device will be queried.
     * @method getDataSizeTextureInMemory
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureInMemory: function (filters) {
      var resources = filters ?
          this.getResources(filters) : this._getDefaultResources();

      var size = 0;

      _.each( resources, function( resource ) {
        var pixelSize;

        if (resource.properties.compression === 'none') {
          pixelSize = resource.properties.pixelFormat === 'rgb' ? 3 : 4;
          size += resource.properties.width * resource.properties.height *
            pixelSize;
        } else {
          size += resource.contentLengthIdentity || resource.contentLength;
        }
      }, this );
      return size;
    },

    /** Returns the maximum texture size supported by the device.
     * @return {Integer} The maximum texture size.
     */
    getMaxTextureSize: function () {
      return VAPI.isMobile() ?
          512 : this.veroldEngine.getGPUCapability('MAX_CUBE_MAP_TEXTURE_SIZE');
    },

    /**
     * Returns the pixel format of the texture. Specify filters to query the
     * desired texture. If no filters are specified, the default texture for the
     * current device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture pixel format.
     */
    getPixelFormat: function (filters) {
      var resources = filters ? this.getResources(filters) :
          this._getDefaultResources();

      if (resources.length > 0) {
        return resources[0].properties.pixelFormat;
      }

      return null;
    },

    /**
     * Returns an array of resources that match the provided filters.
     * @method getResources
     * @param  {Object} filters An object with properties to filter by
     * @param  {String} filters.compression Compression format of the texture (e.g. 'dxt'). Use 'none' for no compression.
     * @param  {Integer} filters.cubeFace The index of the cube face [0, 5]
     * @param  {Integer} filters.group Return a single group of cube faces
     * @param  {Integer} filters.maxSize The maximum number of texels in the largest dimension
     * @param  {String} filters.pixelFormat e.g. 'rgb', 'rgba', 'rgbm', etc.
     * @return {Array} Array of resources that match the filters
     */
    getResources: function (filters) {

      filters = filters || {};
      var bestMatch = filters.bestMatch;
      filters.bestMatch = false;
      var resources = BaseTextureAsset.prototype.getResources.call(this,
        filters);
      filters.bestMatch = bestMatch;

      if (filters.cubeFace !== undefined) {
        resources = _.filter(resources, function (resource) {
          return resource.properties.cubeFace === filters.cubeFace;
        });
      }

      if ( filters.bestMatch && resources.length > 1 ) {
        //If we have multiple
        if ( filters.compression === 'none') {
          var results = new Array(6);
          
          _.each( resources, function( resource ) {
            var current = results[ resource.properties.cubeFace ];
            if ( !current || current.properties.width < resource.properties.width ) {
              results[ resource.properties.cubeFace ] = resource;
            }
          }, this );
          
          resources = results;
        }
        else {
          var largest = resources[0];
          for ( var i = 1; i < resources.length; i++ ) {
            if ( resources[i].properties.width > largest.properties.width ) {
              largest = resources[i];
            }
          }
          resources = [largest];
        }

      }

      return resources;
    },

    /**
     * Returns the width of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture width.
     */
    getWidth: function (filters) {
      var resources = filters ? this.getResources(filters) :
          this._getDefaultResources();

      if (resources.length > 0) {
        return resources[0].properties.width;
      }

      return 0;
    },

    /**
     * Returns the height of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture height.
     */
    getHeight: function (filters) {
      var resources = filters ? this.getResources(filters) :
          this._getDefaultResources();

      if (resources.length > 0) {
        return resources[0].properties.height;
      }

      return 0;
    }
  });

  window.VAPI = window.VAPI || {};
  window.VAPI.TextureCubeAsset = TextureCubeAsset;

  return TextureCubeAsset;
});


define( 'VeroldEngine/Loaders/MediaLoader',[ 'underscore' ],
  function( _ ) {

    var MediaLoader = function( ) {
      this.crossOrigin = 'anonymous';
    };

    MediaLoader.prototype = {

      constructor: MediaLoader,

      loadAudio: function( sources, onLoad, onProgress, onError ) {
        this._loadMedia( 'audio', sources, onLoad, onProgress, onError );
      },

      loadVideo: function( sources, onLoad, onProgress, onError ) {
        this._loadMedia( 'video', sources, onLoad, onProgress, onError );
      },

      _loadMedia: function( type, sources, onLoad, onProgress, onError ) {
        var that = this
          , element = document.createElement( type );

        var loadStartFn = function( event ) {
          console.log( 'Media load start' );
          element.removeEventListener( 'loadstart', loadStartFn );
        };
        
        element.addEventListener( 'loadstart', loadStartFn, false );

        var loadedMetaDataFn = function( event ) {
          console.log( 'Media loaded metadata' );
          element.removeEventListener( 'loadedmetadata', loadedMetaDataFn );
        };

        element.addEventListener( 'loadedmetadata', loadedMetaDataFn, false );

        var loadedDataFn = function( event ) {
          console.log( 'Media loaded data' );
          element.removeEventListener( 'loadeddata', loadedDataFn );
        };

        element.addEventListener( 'loadeddata', loadedDataFn, false );

        if ( onLoad ) {
          var canPlayFn = function( event ) {
            console.log( 'Media can play' );
            element.removeEventListener( 'canplay', canPlayFn );
            onLoad( element );
          };

          element.addEventListener( 'canplay', canPlayFn, false );
        }

        if ( onProgress ) {
          element.addEventListener( 'progress', function( event ) {
            onProgress( event );
          }, false );
        }

        if ( onError ) {
          element.addEventListener( 'error', function( event ) {
            console.log( 'Error loading media: ' + JSON.stringify( event.target.error ) );
            onError( event );
          }, false );
        }

        //
        // Chrome seems to require that 'crossorigin' be set via setAttribute
        // (as opposed to element.crossOrigin = ''), or the change won't be
        // picked up and the 'Origin' header won't be included in the request.
        // Even with this, Chrome seems to have problems with reading from a
        // cross origin video (e.g., assigning the video as a WebGL texture): a
        // DOM security exception is raised.  A (possibly) related bug can be
        // found here:
        //
        // https://code.google.com/p/chromium/issues/detail?id=123369#c43
        //
        if ( this.crossOrigin !== undefined ) {
          element.setAttribute( 'crossorigin', this.crossOrigin );
        }

        // Firefox seems to need this; otherwise, it may just load metadata
        // and canplay/canplaythrough won't be triggered.
        element.setAttribute( 'preload', 'auto' );

        if ( !_.isArray( sources ) ) {
          sources = [ sources ];
        }

        for ( var idx in sources ) {
          // The type string (e.g., "video/mp4", "video/webm").
          var typeStr = type + '/' + sources[ idx ].split( '.' ).pop();

          //
          // Only add sources that we think we can play.  The canPlayType()
          // function should return one of:
          //   * "probably"
          //   * "maybe"
          //   * ""
          //
          // To be safe, we also check for "no".  If the canPlayType function
          // doesn't exist, we allow all source types.
          //
          if ( element.canPlayType === undefined ||
               element.canPlayType( typeStr ).replace( /no/, '' ) ) {
            var source = document.createElement( 'source' );
            source.src = sources[ idx ];
            source.type = typeStr;
            element.appendChild( source );
          }
        }

        element.load();

        return element;
      }

    };

    window.VAPI = window.VAPI || {};
    window.VAPI.MediaLoader = MediaLoader;

    return MediaLoader;

  } );


/*jslint browser: true, indent: 2, nomen: true*/
/*global define*/


define('VeroldEngine/AssetRegistry/TextureVideoAsset',[
  'underscore',
  'three',
  'VeroldEngine/AssetRegistry/BaseTextureAsset',
  'VeroldEngine/Loaders/MediaLoader'
], function (_, THREE, BaseTextureAsset, MediaLoader) {
  var TextureVideoAsset = function () {
    BaseTextureAsset.call(this);
  };

  TextureVideoAsset.prototype = new BaseTextureAsset();

  TextureVideoAsset.prototype.events = {
    pause: { 'params': [], 'action': true, 'category': '' },
    play: {
      'params': [{
        'name': 'seek',
        'type': 'b',
        'description': '',
        'default': false
      }, {
        'name': 'seekTime',
        'type': 'f',
        'description': '',
        'default': 0
      }],
      'action': true,
      'category': ''
    },
    stop: { 'params': [], 'action': true, 'category': '' },
    toggle: { 'params': [], 'action': true, 'category': '' }
  };

  _.extend(TextureVideoAsset.prototype, {
    initialize: function (properties) {
      BaseTextureAsset.prototype.initialize.call(this, properties);
      this.veroldEngine.on('update', this.onUpdate, this);
      this.on('pause', this.pause, this);
      this.on('play', this.play, this);
      this.on('stop', this.stop, this);
      this.on('toggle', this.toggle, this);
    },

    uninitialize: function () {
      this.veroldEngine.off('update', this.onUpdate, this);
      this.off('pause', this.pause, this);
      this.off('play', this.play, this);
      this.off('stop', this.stop, this);
      this.off('toggle', this.toggle, this);

      if (this.threeData && this.threeData.image) {
        // TODO: should we be doing more here?
        this.threeData.image.pause();
      }

      BaseTextureAsset.prototype.uninitialize.call(this);
    },

    _loadThreeData: function (changes, options) {
      var that = this,
        loader = new MediaLoader(),
        name = this.getName(),
        payload = this.entityModel.get('payload'),
        paths;

      function _onVideoLoaded(video) {
        console.log('Video ready to play: ' + name);

        // Create the three.js texture.
        that.threeData = new THREE.Texture();
        that.threeData.name = name;
        that.threeData.veroldEntityId = that.id;
        that.threeData.image = video;
        that.threeData.needsUpdate = true;

        // Apply payload settings.
        changes.payload.uMapping = true;
        changes.payload.vMapping = true;
        changes.payload.filtering = true;
        changes.payload.anisotropy = true;
        changes.payload.flipY = false;
        changes.payload.generateMipmaps = true;
        changes.payload.loop = true;
        changes.payload.state = true;

        options = options || {};
        that.applyPayloadSettings_loaded(changes.payload, options);

        // Play/pause the video, based on autoPlay.
        if (payload.autoPlay) {
          that.play();
        }

        // Set the loading progress to 100%.
        that.loadingProgress.textures = that.getDataSizeTextureDownload();

        that.trigger('load_progress', that);
        that.trigger('load_base', that);
        //that.trigger('load', that);
      }

      paths = this.getResourcePaths({ quality: 'medium' });
      loader.loadVideo(paths, _onVideoLoaded);

      console.log('Loading video: ' + name);
    },

    applyPayloadSettings_loaded: function (changes, options) {
      if (this.threeData && changes) {
        var payload = this.entityModel.get('payload');

        if (changes.loop && this.threeData.image) {
          this.threeData.image.loop = payload.loop;
        }
      }

      BaseTextureAsset.prototype.applyPayloadSettings_loaded.call(this, changes,
        options);
    },

    /**
     * Returns an array of resources that match the provided filters.
     * @method getResourcePaths
     * @param  {object} filters An object with properties to filter by
     * @return {array} Array of resources that match the filters
     */
    getResources: function (filters) {
      var resources = this.entityModel.getResources();

      filters = filters || {};

      if (filters.quality !== undefined) {
        resources = _.filter(resources, function (resource) {
          return resource.properties.quality === filters.quality;
        });
      }

      return resources;
    },

    onUpdate: function () {
      if (this.threeData) {
        var video = this.threeData.image;

        if (video && video.readyState === video.HAVE_ENOUGH_DATA) {
          this.threeData.needsUpdate = true;
        }
      }
    },

    pause: function () {
      if (this.threeData) {
        this.threeData.image.pause();
      }
    },

    play: function (seek, seekTime) {
      if (this.threeData) {
        if (seek) {
          this.threeData.image.currentTime = seekTime;
        }

        this.threeData.image.play();
      }
    },

    stop: function () {
      if (this.threeData) {
        this.threeData.image.pause();
        this.threeData.image.currentTime = 0;
      }
    },

    toggle: function () {
      if (this.threeData) {
        if (this.threeData.image.paused) {
          this.play();
        } else {
          this.pause();
        }
      }
    }
  });

  window.VAPI = window.VAPI || {};
  window.VAPI.TextureVideoAsset = TextureVideoAsset;

  return TextureVideoAsset;
});

/*jslint browser: true, indent: 2, nomen: true*/
/*global define, Uint8Array*/


define('VeroldEngine/AssetRegistry/RenderTexture2DAsset',[
  'underscore',
  'three',
  'VeroldEngine/AssetRegistry/BaseTextureAsset'
], function (_, THREE, BaseTextureAsset) {
  var RenderTexture2DAsset = function () {
    BaseTextureAsset.call(this);
  };

  RenderTexture2DAsset.prototype = new BaseTextureAsset();

  _.extend(RenderTexture2DAsset.prototype, {
    initialize: function (properties) {
      this.loadComponents = true;
      BaseTextureAsset.prototype.initialize.call(this, properties);
    },

    _createRTTexture: function () {
      var payload = this.entityModel.get('payload'),
        width = this.getWidth(),
        height = this.getHeight();

      this.threeData = new THREE.WebGLRenderTarget(width, height, {
        wrapS: this.registry.textureUVMappingsMap[payload.uMapping],
        wrapT: this.registry.textureUVMappingsMap[payload.vMapping],
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: payload.format,
        type: payload.type,
        stencilBuffer: payload.stencilBuffer
      });

      this.threeData.name = this.entityModel.get('name');
      this.threeData.flipY = false;
      this.threeData.veroldEntityId = this.id;
    },

    _loadThreeData: function (changes, options) {
      this._createRTTexture();

      changes.payload.uMapping = true;
      changes.payload.vMapping = true;
      changes.payload.filtering = true;
      changes.payload.anisotropy = true;
      changes.payload.flipY = false;

      this.applyPayloadSettings_loaded(changes.payload, options);

      this.trigger('load_progress', this);
      this.trigger('load_base', this);
      this.trigger('load', this);
    },

    applyPayloadSettings_loaded: function (changes) {
      BaseTextureAsset.prototype.applyPayloadSettings_loaded.call(this,
        changes);

      var payload = this.entityModel.get('payload');

      // this.threeData.minFilter = 1006;
      // this.threeData.magFilter = 1006;

      // If something changed that necessitates the texture being recreated, do
      // so.
      if (changes.format || changes.type || changes.width || changes.height) {
        if (this.threeData.__webglFramebuffer) {
          this.threeData.dispose();
          delete this.threeData.__webglFramebuffer;
        }

        this.threeData.format = payload.format;
        this.threeData.type = payload.type;
        this.threeData.height = this.getHeight();
        this.threeData.width = this.getWidth();
      }

      if (changes.filtering) {
        if (payload.filtering === 'Trilinear') {
          this.threeData.generateMipmaps = true;
        } else {
          this.threeData.generateMipmaps = false;
        }
      }

      this.threeData.needsUpdate = false;
    },

    /**
     * Returns the total amount of GPU memory occupied by this texture.
     * @method getDataSizeTextureInMemory
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureInMemory: function () {
      var width = this.getProperty('width'),
        height = this.getProperty('height'),
        type = parseInt(this.getProperty('type'), 10),
        format = parseInt(this.getProperty('format'), 10),
        numChannels = 1,
        bytesPerChannel = 1;

      switch (type) {
      case THREE.FloatType:
      case THREE.UnsignedIntType:
      case THREE.IntType:
        bytesPerChannel = 4;
        break;

      case THREE.ShortType:
      case THREE.UnsignedShortType:
        bytesPerChannel = 2;
        break;

      case THREE.UnsignedByteType:
      case THREE.ByteType:
        bytesPerChannel = 1;
        break;

      // The following types dictate the bpp directly.
      case THREE.UnsignedShort4444Type:
      case THREE.UnsignedShort5551Type:
      case THREE.UnsignedShort565Type:
        return width * height * 2;
      }

      switch (format) {
      case THREE.RGBFormat:
        numChannels = 3;
        break;

      case THREE.RGBAFormat:
        numChannels = 4;
        break;

      case THREE.LuminanceAlphaFormat:
        numChannels = 2;
        break;

      case THREE.LuminanceFormat:
      case THREE.AlphaFormat:
        numChannels = 1;
        break;
      }

      return width * height * numChannels * bytesPerChannel;
    },

    /**
     * Returns the pixel format of the texture. Specify filters to query the
     * desired texture. If no filters are specified, the default texture for the
     * current device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {String} The texture pixel format.
     */
    getPixelFormat: function () {
      var packingOverride = this.getProperty('packingOverride');
      if ( packingOverride ) {
        return packingOverride;
      }

      var format = parseInt(this.getProperty('format'), 10);

      switch (format) {
      case THREE.RGBFormat:
        return 'rgb';

      case THREE.RGBAFormat:
        return 'rgba';

      case THREE.LuminanceAlphaFormat:
        return 'ya';

      case THREE.LuminanceFormat:
        return 'y';

      case THREE.AlphaFormat:
        return 'a';
      }

      return null;
    },

    getNumChannels: function() {
      switch ( this.getPixelFormat() ) {
      case 'rgb':
        return 3;
      case 'rgba':
        return 4;
      case 'ya':
        return 2;
      case 'y':
        return 1;
      case 'a':
        return 1;
      default:
        return 3;
      }
    },

    /**
     * Returns the width of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture width.
     */
    getWidth: function () {
      var maxTextureSize = this.veroldEngine.getGPUCapability(
          'MAX_TEXTURE_SIZE'
        ),
        width = this.getProperty('width');

      if (width > maxTextureSize) {
        width = maxTextureSize;
      }

      return width;
    },

    /**
     * Returns the height of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture height.
     */
    getHeight: function () {
      var maxTextureSize = this.veroldEngine.getGPUCapability(
          'MAX_TEXTURE_SIZE'
        ),
        height = this.getProperty('height');

      if (height > maxTextureSize) {
        height = maxTextureSize;
      }

      return height;
    },

    setUserData: function (width, height, color) {
      var size = width * height,
        textureData = new Uint8Array(3 * size),
        r = Math.floor(color.r * 255),
        g = Math.floor(color.g * 255),
        b = Math.floor(color.b * 255),
        idx;

      for (idx = 0; idx < size; idx += 1) {
        textureData[idx * 3]     = r;
        textureData[idx * 3 + 1] = g;
        textureData[idx * 3 + 2] = b;
      }

      if (this.threeData) {
        this.threeData.image = {
          data: textureData,
          width: width,
          height: height
        };

        this.threeData.needsUpdate = true;
      }
    }
  });

  window.VAPI = window.VAPI || {};
  window.VAPI.RenderTexture2DAsset = RenderTexture2DAsset;

  return RenderTexture2DAsset;
});


/*jslint browser: true, indent: 2, nomen: true*/
/*global define, Uint8Array*/


// TODO: this class and RenderTexture2D contain duplicate code that should be
// refactored.

define('VeroldEngine/AssetRegistry/RenderTextureCubeAsset',[
  'underscore',
  'three',
  'VeroldEngine/AssetRegistry/BaseTextureAsset'
], function (_, THREE, BaseTextureAsset) {
  var RenderTextureCubeAsset = function () {
    BaseTextureAsset.call(this);
  };

  RenderTextureCubeAsset.prototype = new BaseTextureAsset();

  _.extend(RenderTextureCubeAsset.prototype, {

    initialize: function (properties) {
      this.loadComponents = true;
      BaseTextureAsset.prototype.initialize.call(this, properties);
    },
    
    _createRTTexture: function () {
      var payload = this.entityModel.get('payload'),
        width = this.getWidth(),
        height = this.getHeight();

      this.threeData = new THREE.WebGLRenderTargetCube(width, height, {
        wrapS: this.registry.textureUVMappingsMap[payload.uMapping],
        wrapT: this.registry.textureUVMappingsMap[payload.vMapping],
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: payload.format,
        type: payload.type,
        stencilBuffer: payload.stencilBuffer
      });

      this.threeData.name = this.entityModel.get('name');
      this.threeData.flipY = false;
      this.threeData.veroldEntityId = this.id;
    },

    _loadThreeData: function (changes, options) {
      this._createRTTexture();

      changes.payload.uMapping = true;
      changes.payload.vMapping = true;
      changes.payload.filtering = true;
      changes.payload.anisotropy = true;
      changes.payload.flipY = false;

      this.applyPayloadSettings_loaded(changes.payload, options);

      this.trigger('load_progress', this);
      this.trigger('load_base', this);
      this.trigger('load', this);
    },

    applyPayloadSettings_loaded: function (changes) {
      BaseTextureAsset.prototype.applyPayloadSettings_loaded.call(this,
        changes);

      var payload = this.entityModel.get('payload');

      // this.threeData.minFilter = 1006;
      // this.threeData.magFilter = 1006;

      // If something changed that necessitates the texture being recreated, do
      // so.
      if (changes.format || changes.type || changes.width || changes.height) {
        if (this.threeData.__webglFramebuffer) {
          this.threeData.dispose();
          delete this.threeData.__webglFramebuffer;
        }

        this.threeData.format = payload.format;
        this.threeData.type = payload.type;
        this.threeData.width = this.getWidth();
        this.threeData.height = this.threeData.width;
      }

      if (changes.filtering) {
        if (payload.filtering === 'Trilinear') {
          this.threeData.generateMipmaps = true;
        } else {
          this.threeData.generateMipmaps = false;
        }
      }

      this.threeData.needsUpdate = false;
    },

    /**
     * Returns the total amount of GPU memory occupied by this texture.
     * @method getDataSizeTextureInMemory
     * @return {Integer} The number of bytes of data.
     */
    getDataSizeTextureInMemory: function () {
      var width = this.getProperty('width'),
        height = this.getProperty('height'),
        type = parseInt(this.getProperty('type'), 10),
        format = parseInt(this.getProperty('format'), 10),
        numChannels = 1,
        bytesPerChannel = 1;

      switch (type) {
      case THREE.FloatType:
      case THREE.UnsignedIntType:
      case THREE.IntType:
        bytesPerChannel = 4;
        break;

      case THREE.ShortType:
      case THREE.UnsignedShortType:
        bytesPerChannel = 2;
        break;

      case THREE.UnsignedByteType:
      case THREE.ByteType:
        bytesPerChannel = 1;
        break;

      // The following types dictate the bpp directly.
      case THREE.UnsignedShort4444Type:
      case THREE.UnsignedShort5551Type:
      case THREE.UnsignedShort565Type:
        return width * height * 2;
      }

      switch (format) {
      case THREE.RGBFormat:
        numChannels = 3;
        break;

      case THREE.RGBAFormat:
        numChannels = 4;
        break;

      case THREE.LuminanceAlphaFormat:
        numChannels = 2;
        break;

      case THREE.LuminanceFormat:
      case THREE.AlphaFormat:
        numChannels = 1;
        break;
      }

      return width * height * numChannels * bytesPerChannel * 6;
    },

    /**
     * Returns the pixel format of the texture. Specify filters to query the
     * desired texture. If no filters are specified, the default texture for the
     * current device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {String} The texture pixel format.
     */
    getPixelFormat: function () {
      var packingOverride = this.getProperty('packingOverride');
      if ( packingOverride ) {
        return packingOverride;
      }
      
      var format = parseInt(this.getProperty('format'), 10);

      switch (format) {
      case THREE.RGBFormat:
        return 'rgb';

      case THREE.RGBAFormat:
        return 'rgba';

      case THREE.LuminanceAlphaFormat:
        return 'ya';

      case THREE.LuminanceFormat:
        return 'y';

      case THREE.AlphaFormat:
        return 'a';
      }

      return null;
    },

    /**
     * Returns the width of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture width.
     */
    getWidth: function () {
      var maxTextureSize = this.veroldEngine.getGPUCapability(
          'MAX_CUBE_MAP_TEXTURE_SIZE'
        ),
        width = this.getProperty('width');

      if (width > maxTextureSize) {
        width = maxTextureSize;
      }

      return width;
    },

    /**
     * Returns the height of the texture. Specify filters to query the desired
     * texture. If no filters are specified, the default texture for the current
     * device will be queried.
     * @param {Object} filters Filters for selecting a texture
     * @return {Integer} The texture height.
     */
    getHeight: function () {
      var maxTextureSize = this.veroldEngine.getGPUCapability(
          'MAX_CUBE_MAP_TEXTURE_SIZE'
        ),
        height = this.getProperty('height');

      if (height > maxTextureSize) {
        height = maxTextureSize;
      }

      return height;
    },

    setUserData: function (width, height, color) {
      var size = width * height,
        textureData = new Uint8Array(3 * size),
        r = Math.floor(color.r * 255),
        g = Math.floor(color.g * 255),
        b = Math.floor(color.b * 255),
        idx;

      for (idx = 0; idx < size; idx += 1) {
        textureData[idx * 3]     = r;
        textureData[idx * 3 + 1] = g;
        textureData[idx * 3 + 2] = b;
      }

      if (this.threeData) {
        this.threeData.image = {
          data: textureData,
          width: width,
          height: height
        };

        this.threeData.needsUpdate = true;
      }
    }
  });

  window.VAPI = window.VAPI || {};
  window.VAPI.RenderTextureCubeAsset = RenderTextureCubeAsset;

  return RenderTextureCubeAsset;
});


define('VeroldEngine/AssetRegistry/TextureRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/Texture2DAsset'
       , 'VeroldEngine/AssetRegistry/TextureCubeAsset'
       , 'VeroldEngine/AssetRegistry/TextureVideoAsset'
       , 'VeroldEngine/AssetRegistry/RenderTexture2DAsset'
       , 'VeroldEngine/AssetRegistry/RenderTextureCubeAsset'
  ],
  function(_, THREE, Texture2DAsset, TextureCubeAsset, TextureVideoAsset, RenderTexture2DAsset, RenderTextureCubeAsset ) {

    var TextureRegistry = function( properties ) {
      this.assets = undefined;

      this.textureFilters = [
        "Nearest",
        "Linear",
        "Trilinear",
        //"Anisotropic"
      ];

      this.textureUVMappings = [
        "Wrap",
        "Clamp",
        "Mirror"
      ];

      this.textureUVMappingsMap = {
        "Wrap" : THREE.RepeatWrapping,
        "Clamp" : THREE.ClampToEdgeWrapping,
        "Mirror" : THREE.MirroredRepeatWrapping
      };

      this.textureFiltersMap = {
        "Default": {
          "Nearest" : {
            minFilter : THREE.NearestFilter,
            magFilter : THREE.NearestFilter,
          },
          "Linear" : {
            minFilter : THREE.LinearFilter,
            magFilter : THREE.LinearFilter,
          },
          "Trilinear" : {
            minFilter : THREE.LinearMipMapLinearFilter,
            magFilter : THREE.LinearFilter,
          },
        },
        'rgbe': {
          "Nearest" : {
            minFilter : THREE.NearestFilter,
            magFilter : THREE.NearestFilter,
          },
          "Linear" : {
            minFilter : THREE.LinearFilter,
            magFilter : THREE.LinearFilter,
          },
          "Trilinear" : {
            minFilter : THREE.LinearMipMapLinearFilter,
            magFilter : THREE.LinearFilter,
          },
        }

      };

      this.defaultTextureSettings = {
        "texture2D" : {
          //name : "Texture_With_No_Name",
          uMapping : "Wrap",
          vMapping : "Wrap",
          filtering : "Trilinear",
          anisotropy : 1,
          flipY : true,
          preferCompression : true,
          isNormalMap : false,
          generateMipmaps: true
        },
        "renderTexture2D" : {
          //name : "Texture_With_No_Name",
          format : THREE.RGBAFormat,
          type : THREE.UnsignedByteType,
          width : 256,
          height: 256,
          uMapping : "Wrap",
          vMapping : "Wrap",
          filtering : "Linear",
          anisotropy : 1,
          flipY : true,
          preferCompression : false,
          isNormalMap : false,
          stencilBuffer : false,
          depthBuffer: false,
          generateMipmaps: false
        },
        "textureCube" : {
          //name : "Texture_With_No_Name",
          uMapping : "Wrap",
          vMapping : "Wrap",
          filtering : "Trilinear",
          anisotropy : 1,
          flipY : true,
          preferCompression : false,
          isNormalMap : false,
          generateMipmaps: true
        },
        "renderTextureCube" : {
          //name : "Texture_With_No_Name",
          format : THREE.RGBAFormat,
          type : THREE.UnsignedByteType,
          width : 256,
          height: 256,
          uMapping : "Wrap",
          vMapping : "Wrap",
          filtering : "Linear",
          anisotropy : 1,
          flipY : true,
          preferCompression : false,
          isNormalMap : false,
          stencilBuffer : false,
          depthBuffer: false,
          generateMipmaps: false
        },
        "textureVideo" : {
          //name : "Texture_With_No_Name",
          uMapping : "Clamp",
          vMapping : "Clamp",
          filtering : "Linear",
          anisotropy : 1,
          flipY : true,
          preferCompression : false,
          isNormalMap : false,
          packing: THREE.HDRFull,
          generateMipmaps: false,
          autoPlay: false,
          state: "pause",
          loop: false
        }
      };
    };

    TextureRegistry.prototype = {

      constructor: TextureRegistry,

      initialize: function( properties ) {
        THREE.ImageUtils.crossOrigin = "anonymous";
        this.assets = {};
        this.veroldEngine = properties.veroldEngine;
        //Check machine capabilities and set
      },

      uninitialize: function(  ) {
        for ( var x in this.assets ) {
          this.assets[x].uninitialize();
          delete this.assets[x];
        }
        this.assets = undefined;
        this.veroldEngine = undefined;
        //this.projectId = undefined;
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      // _initComponents: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.loadComponents();
      //   }, this );
      // },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // getAllAssets: function( options ) {
      //   if ( options && options.filter ) {
      //     var newOptions = { filter: {} };
      //     _.extend( newOptions.filter, options.filter, { 'texture2D': newOptions.filter.texture2D, 
      //                                                   'textureCube': newOptions.filter.textureCube,
      //                                                   'textureVideo': newOptions.filter.textureVideo,
      //                                                   'renderTexture2D': newOptions.filter.renderTexture2D } );
      //     return this.veroldEngine.assetRegistry.getAllAssets( newOptions );
      //   }
      //   if ( options && options.autoLoad ) {
      //     for ( var x in this.assets ) {
      //       if ( this.assets[ x ].state_base == "pending" ) {
      //         this.assets[ x ].load( options );
      //       }
      //     }
      //   }
      //   return this.assets;
      // },

      //Returns the asset specified. null if invalid
      //options
        //autoLoad - boolean that's set to true to make this call automatically load the asset's data
        //success - callback on successful load of the data. Not valid if autoLoad is false
        //failure - callback on failure while loading the data. Not valid if autoLoad is false
        //progress - callback on loading progress. Not valid if autoLoad is false
      // getAsset: function( assetID, options ) {
      //   return this.veroldEngine.assetRegistry.getAsset( assetID, options );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {
        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) { console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model."); }

        var type = entityModel.get("type");
        var newAsset;
        switch ( type ) {
        case "texture2D":
          newAsset = new Texture2DAsset();
          break;
        case "textureCube":
          newAsset = new TextureCubeAsset();
          break;
        case "textureVideo":
          newAsset = new TextureVideoAsset();
          break;
        case "renderTexture2D":
          newAsset = new RenderTexture2DAsset();
          break;
        case "renderTextureCube":
          newAsset = new RenderTextureCubeAsset();
          break;
        }

        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;

      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
      },

      update: function( delta ) {

      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    };

    return TextureRegistry;
  });

/**
 * @module VAPI
 */
define('VeroldEngine/AssetRegistry/AnimationAsset',[ 'underscore'
       , 'three'
       , 'VeroldEngine/VeroldEntity'
       , 'VeroldEngine/AssetRegistry/VeroldAsset'
       , 'VeroldEngine/Loaders/GenericLoader'
  ],
  function( _, THREE, VeroldEntity, VeroldAsset, GenericLoader ) {

    /**
     * An object that holds animation data for animating models
     * @class AnimationAsset
     * @constructor
     */
    var AnimationAsset = function( ) {
      VeroldAsset.call( this );
    };

    AnimationAsset.prototype = new VeroldAsset();

    _.extend( AnimationAsset.prototype, {

      initialize: function( properties ) {
        VeroldAsset.prototype.initialize.call( this, properties );
        this.state_dependencies = "loaded";

        // Animations don't have a hierarchy so we'll mark it as already loaded.
        this.trigger( "load_hierarchy", this );
        this.trigger( "load_hierarchy_dependencies", this );
        this.trigger( "load_components", this );
      },

      getDataSizeAnimationDownload: function() {
        var resource = this.getResource();

        if (resource) {
          return resource.contentLength;
        }
      },

      getDataSizeAnimationInMemory: function() {
        var resource = this.getResource();

        if (resource) {
          return resource.contentLengthIdentity;
        }
      },

      _getCurvesForObjectsInLayer: function( objects, layer, curves ) {
        var filtered = {};

        for ( var iObject = 0; iObject < objects.length; ++iObject ) {
          var objectName = objects[ iObject ].name;
          filtered[ objectName ] = [];
        }

        for ( var iCurve = 0; iCurve < layer.curves.length; ++iCurve ) {
          var curveName = layer.curves[ iCurve ];

          if ( curves.hasOwnProperty( curveName ) ) {
            var curve = curves[ curveName ]
              , objectName = curve.object;

            if ( filtered.hasOwnProperty( objectName ) ) {
              filtered[ objectName ].push( curve );
            }
          }
        }

        return filtered;
      },

      _getKeyframes: function( objects, curves, startTime, stopTime ) {
        var keyframes = {}
          , curveTypes = {};

        // Supported channels and their corresponding THREE.js name.
        curveTypes.position = "pos";
        curveTypes.rotation = "rot";
        curveTypes.scale    = "scl";

        for ( var iObject = 0; iObject < objects.length; ++iObject ) {
          var object = objects[ iObject ]
            , objectCurves = curves[ object.name ]
            , objectKeys = []
            , mergedKeys;

          // Create a single array of keys for the object, merging all channels.
          for ( var iCurve = 0; iCurve < objectCurves.length; ++iCurve ) {
            var curve = objectCurves[ iCurve ]
              , keys = curve.keys
              , step = curve.channels + 1;

            for ( var type in curveTypes ) {
              var property = curveTypes[ type ];

              if ( curve.property === type ) {
                var idx = 0;

                // Find the first frame of the animation (time >= startTime).
                while ( idx * step < keys.length &&
                        keys[ idx * step ] < startTime ) {
                  idx++;
                }

                // If the first frame is beyond startTime, create a new frame at
                // startTime.
                if ( idx * step < keys.length ) {
                  var time = keys[ idx * step ];
                  if ( time > startTime ) {
                    var key = { "time": 0 };

                    if ( idx > 0 ) {
                      var pt0 = keys.slice( ( idx - 1 ) * step, idx * step )
                        , pt1 = keys.slice( idx * step, ( idx + 1 ) * step );

                      key[ property ] = this._interpolateKeys( pt0, pt1, startTime );
                    }
                    else {
                      // Copy the first keyframe (const interpolation).
                      key[ property ] = keys.slice( 1, step );
                    }

                    objectKeys.push( key );
                  }
                }
                else if ( keys.length > 0 ) {
                  // We did not find a keyframe with time >= startTime, so copy
                  // the last keyframe (const interpolation).
                  var key = { "time": 0 };
                  key[ property ] = keys.slice( -step + 1 );
                  objectKeys.push( key );
                }

                // Add the middle frames (startTime <= time <= stopTime).
                while ( idx * step < keys.length &&
                        keys[ idx * step ] <= stopTime ) {
                  var key = { "time": keys[ idx * step ] - startTime };
                  key[ property ] = keys.slice( ( idx * step ) + 1, ( idx + 1 ) * step );
                  objectKeys.push( key );
                  idx++;
                }

                // If the final frame is beyond stopTime, create a new frame at
                // stopTime.
                if ( idx * step < keys.length ) {
                  var time = keys[ idx * step ];
                  if ( time > stopTime ) {
                    var key = { "time": stopTime - startTime };

                    if ( idx > 0 ) {
                      var pt0 = keys.slice( ( idx - 1 ) * step, idx * step )
                        , pt1 = keys.slice( idx * step, ( idx + 1 ) * step );

                      key[ property ] = this._interpolateKeys( pt0, pt1, stopTime );
                    }
                    else {
                      // Copy the first keyframe (const interpolation).
                      key[ property ] = keys.slice( 1, step );
                    }

                    objectKeys.push( key );
                  }
                }
                else if ( keys.length > 0 ) {
                  // Copy the final keyframe (const interpolation).
                  var key = { "time": stopTime - startTime };
                  key[ property ] = keys.slice( keys.length - step + 1, keys.length );
                  objectKeys.push( key );
                }
              }
            }
          }

          // If there aren't any keys, skip the object.
          if ( objectKeys.length === 0 ) {
            continue;
          }

          // Sort the keys by time.
          objectKeys.sort( function( a, b ) {
            return a.time - b.time;
          } );

          // Merge keys with identical time values.
          mergedKeys = [ objectKeys[ 0 ] ];

          for ( var iKey = 1; iKey < objectKeys.length; ++iKey ) {
            var key = objectKeys[ iKey ]
              , lastKey = mergedKeys[ mergedKeys.length - 1 ];

            if ( key.time === lastKey.time ) {
              for ( var type in curveTypes ) {
                var property = curveTypes[ type ];
                if ( key.hasOwnProperty( property ) ) {
                  lastKey[ property ] = key[ property ];
                }
              }
            }
            else {
              mergedKeys.push( key );
            }
          }

          keyframes[ object.name ] = mergedKeys;
        }

        return keyframes;
      },

      _interpolateKeys: function( key1, key2, time ) {
        var t0 = key1[ 0 ]
          , t1 = key2[ 0 ]
          , result = []
          , alpha;

        if ( t1 - t0 === 0 ) {
          alpha = 0.5;
        }
        else {
          alpha = ( time - t0 ) / ( t1 - t0 );
        }

        for ( var idx = 1; idx < key1.length; ++idx ) {
          result.push( key1[ idx ] + ( key2[ idx ] - key1[ idx ] ) * alpha );
        }

        return result;
      },

      _loadThreeData: function( changes, options ) {
        var that = this;

        var finishedLoading = function( err, animData ) {
          if ( err ) {
            return console.warn( "Error loading animation", err );
          }

          that.threeData = animData;
          that.applyPayloadSettings_loaded( changes, options );
          that.trigger( "load_base", that );
        };

        var progressLoading = function( progressObj ) {
          that.loadingProgress.animations = progressObj.loaded;
          that.trigger( "load_progress", that );
        };

        var path = this.entityModel.getResourcePath(0);
        var loader = new GenericLoader( this.veroldEngine );
        loader.loadFile( path, 'json', finishedLoading, progressLoading );
      },

      /**
       * Add a new take to the asset.
       * @method addTake
       * @param  {Object} take The take data
       * @return {Boolean} true on success; otherwise, false
       */
      addTake: function( take ) {
        var takes = _.clone( this.entityModel.get( "payload.takes" ) )
          , json = {};

        if ( this.getTakeNames().indexOf( take.name ) !== -1 ) {
          console.warn( "Failed to add new take because its name is not unique." );
          return false;
        }

        takes.push( take );
        json[ "payload.takes" ] = takes;
        this.set( json, { save: true } );

        return true;
      },

      /**
       * Create a THREE.Animation for the object and take.
       * @method createAnimation
       * @param  {Object} root The object hierarchy
       * @param  {String} takeName The take name
       * @return {Object} The THREE.Animation object on success; otherwise false.
       */
      createAnimation: function( root, takeName ) {
        if ( !root || !root.threeData || !takeName ) {
          return null;
        }

        var take = this.getTake( takeName );

        if ( !take || !this.threeData ) {
          console.warn( "Failed to create animation because take does not exist: " + takeName );
          return null;
        }

        var layers = this.threeData.layers
          , curves = this.threeData.curves
          , uniqueName = takeName + root.id + this.id
          , objects = THREE.AnimationHandler.parse( root.threeData )
          , animation = {}
          , hierarchy = []
          , layer, keyframes;

        if ( !take.layers || take.layers.length <= 0 ) {
          return null;
        }

        if ( take.layers.length > 1 ) {
          console.warn( "Take contains multiple layers, but we only support a single layer." );
        }

        // Get curves for objects in the hierarchy.
        layer = layers[ take.layers[ 0 ] ];
        curves = this._getCurvesForObjectsInLayer( objects, layer, curves );

        // Get keyframes for each object.
        keyframes = this._getKeyframes( objects, curves, take.start, take.stop );

        // Create the THREE.js animation.
        for ( var iObject = 0; iObject < objects.length; ++iObject ) {
          var object = objects[ iObject ]
            , keys = keyframes[ object.name ];

          hierarchy.push( { "keys": keys ? keys : [] } );
        }

        animation.name = uniqueName;
        animation.length = take.stop - take.start;
        animation.fps = 25;
        animation.hierarchy = hierarchy;

        return new THREE.Animation( root.threeData, animation );
      },

      /**
       * Get take data for the specified take.
       * @method getTake
       * @param  {String} takeName The take name
       * @return {Object} The take data or null if the take does not exist.
       */
      getTake: function( takeName ) {
        var payload = this.entityModel.get( "payload" );
        for ( var idx in payload.takes ) {
          var take = payload.takes[ idx ];
          if ( take.name === takeName ) {
            return take;
          }
        }

        return null;
      },

      /**
       * Get names of all the takes.
       * @method getTakeNames
       * @return {Array} An array of take names.
       */
      getTakeNames: function() {
        var payload = this.entityModel.get( "payload" )
          , names = [];

        for ( var idx in payload.takes ) {
          names.push( payload.takes[ idx ].name );
        }

        return names;
      },

      /**
       * Get all take data.
       * @method getTakes
       * @return {Array} An array of take data.
       */
      getTakes: function() {
        var payload = this.entityModel.get( "payload" );
        return payload.takes;
      },

      /**
       * Remove the specified take.
       * @method removeTake
       * @param {Integer} idx The index of the take
       */
      removeTake: function( idx ) {
        var takes = _.clone( this.entityModel.get( "payload.takes" ) )
          , json = {};

        takes.splice( idx, 1 );
        json[ "payload.takes" ] = takes;
        this.set( json, { save: true } );
      },

      /**
       * Set the name of the specified take.
       * @method setTakeName
       * @param {Integer} takeIdx The index of the take
       * @param {String} name The new take name
       * @return {Boolean} true on success; otherwise, false.
       */
      setTakeName: function( takeIdx, name ) {
        var idx = this.getTakeNames().indexOf( name );

        if ( idx !== -1 && idx !== takeIdx ) {
          console.warn( "Failed to set take name because it is not unique." );
          return false;
        }

        var json = {};
        json[ "payload.takes." + takeIdx + ".name" ] = name;
        this.set( json, { save: true } );

        return true;
      },

      /**
       * Set the start time of the specified take.
       * @method setTakeStart
       * @param {Integer} takeIdx The index of the take
       * @param {Number} start The new take start time
       */
      setTakeStart: function( takeIdx, start ) {
        var json = {};
        json[ "payload.takes." + takeIdx + ".start" ] = Number( start );
        this.set( json, { save: true } );
      },

      /**
       * Set the stop time of the specified take.
       * @method setTakeStop
       * @param {Integer} takeIdx The index of the take
       * @param {Number} stop The new take stop time
       */
      setTakeStop: function( takeIdx, stop ) {
        var json = {};
        json[ "payload.takes." + takeIdx + ".stop" ] = Number( stop );
        this.set( json, { save: true } );
      },

      unload: function() {
        VeroldAsset.prototype.unload.call( this );
        this.veroldEngine.trigger("animationUnloaded", this.id );
      }

    } );

    window.VAPI = window.VAPI || {};
    window.VAPI.AnimationAsset = AnimationAsset;

    return AnimationAsset;
  } );


/**
 * @module VAPI
 */
define('VeroldEngine/AssetRegistry/AnimationRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/AnimationAsset'
  ],
  function(_, THREE, AnimationAsset ) {

    /**
     * All Model Animation data is managed by this
     * @class AnimationRegistry
     * @param {Object} properties Animation Registry properties
     * @constructor
     */
    var AnimationRegistry = function( properties ) {
      this.assets = undefined;
    };

    AnimationRegistry.prototype = {

      constructor: AnimationRegistry,

      initialize: function( properties ) {
        this.assets = {};
        //this.projectId = properties.projectId;
        this.veroldEngine = properties.veroldEngine;
        //Check machine capabilities and set
      },

      uninitialize: function(  ) {
        for ( var x in this.assets ) {
          this.assets[x].uninitialize();
          delete this.assets[x];
        }
        this.assets = undefined;
        this.veroldEngine = undefined;
        //this.projectId = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      // _initComponents: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.loadComponents();
      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      // getAllAssets: function( options ) {
      //   return this.veroldEngine.assetRegistry.getAllAssets.call( this, options );
        // if ( options && options.filter ) {
        //   var newOptions = { filter: {} };
        //   _.extend( newOptions.filter, options.filter, { 'animation': true } );
        //   return this.veroldEngine.assetRegistry.getAllAssets( newOptions );
        // }
        // if ( options && options.autoLoad ) {
        //   for ( var x in this.assets ) {
        //     if ( this.assets[ x ].state_base === "pending" ) {
        //       this.assets[ x ].load( options );
        //     }
        //   }
        // }
        // return this.assets;
      // },

      //Returns the asset specified. null if invalid
      //options
        //autoLoad - boolean that's set to true to make this call automatically load the asset's data
        //success - callback on successful load of the data. Not valid if autoLoad is false
        //failure - callback on failure while loading the data. Not valid if autoLoad is false
        //progress - callback on loading progress. Not valid if autoLoad is false
      // getAsset: function( assetID, options ) {
      //   return this.veroldEngine.assetRegistry.getAsset( assetID, options );
      // },

      //Creates a new asset and stores it in the registry.
        //First, this function creates the entityModel and saves it to the database, if persistent.
        //Second, this function adds the entityModel to the asset collection, triggering the 'add' event
        //The 'add' event calls this.onEntityAssetAdded which actually creates the new VeroldAsset and adds it to the registry
      //json - the definition of the asset
      //options - an object defining options for the asset
        //persistent - boolean that defines whether the object should be stored in the database (i.e. whether it's permenant or temporary)
        //alreadyInDatabase - boolean that defines whether the object is already in the database or not. This will be set to true when creating
          //assets that were just created remotely and need to be mirrored on this client.
        //success - callback on success - called when the backbone model is added to the collection
        //failure - callback on failure - called when the backbone model fails to be added to the collection
      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {
        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model.");

        var newAsset = new AnimationAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;
      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
      },

      update: function( delta ) {
        if ( this.veroldEngine.isPrimaryEngine() && THREE.AnimationHandler.animations.length ) {
          THREE.AnimationHandler.update( delta );
          this.veroldEngine.needsRender = true;
        }
      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    };

    return AnimationRegistry;
  });

define('VeroldEngine/AssetRegistry/PoseAsset',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/VeroldAsset'
       , 'VeroldEngine/Loaders/GenericLoader'
  ],
  function(_, THREE, VeroldAsset, GenericLoader ) {

    var PoseAsset = function( ) {
      VeroldAsset.call( this );

    };

    PoseAsset.prototype = new VeroldAsset();

    _.extend( PoseAsset.prototype, {

      initialize: function( properties ) {
        VeroldAsset.prototype.initialize.call( this, properties );
        //Poses don't have a hierarchy so we'll mark it as already loaded.
        this.trigger( "load_dependencies", this );
        this.trigger( "load_hierarchy", this );
        this.trigger( "load_hierarchy_dependencies", this );
        this.trigger( "load_components", this );
      },

      // uninitialize: function(  ) {
      //   VeroldAsset.prototype.uninitialize.call( this, properties );
      // },

      _loadThreeData: function( changes, options ) {

        var that = this;

        var finishedLoading = function( err, poseData ) {
          if ( err ) {
            return console.warn( "Error loading pose", err );
          }

          that.threeData = poseData;
          that.applyPayloadSettings_loaded( changes, options );
          that.trigger( "load_base", that);
        };

        var progressLoading = function() {
          that.trigger( "load_progress", that);
        };

        var path = this.entityModel.getPath( );
        var loader = new GenericLoader( this.veroldEngine );
        loader.loadFile( path, 'json', finishedLoading, progressLoading );

      },

      applyPayloadSettings_loaded: function( changes, options ) {

        // if ( this.threeData ) {
        //   var payload = this.entityModel.get("payload");
        //   if ( changes ) {
        //     this.threeData.wrapS = changes.uMapping ? this.registry.textureUVMappingsMap[ payload.uMapping ] : this.threeData.wrapS;
        //     this.threeData.needsUpdate = true;
        //   }
        // }
        this.trigger("updated", this);
      },

      unload: function( ) {
        if ( this.threeData ) {
          console.warn("TODO: Need to unload three.js animation data here")
          // console.log(this.veroldEngine.engineName + " - Unloading texture, " + this.entityModel.get("name"));
          // this.threeData.dispose();

        }
      },


    });

    window.VAPI = window.VAPI || {};
    window.VAPI.PoseAsset = PoseAsset;

    return PoseAsset;
  });

/**
 * @module VAPI
 */
define('VeroldEngine/AssetRegistry/PoseRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/PoseAsset'
  ],
  function(_, THREE, PoseAsset ) {

    /**
     * All poses are registered and managed here
     * @class PoseRegistry
     * @param {Object} [properties] PoseRegistry properties
     * @constructor
     */
    var PoseRegistry = function( properties ) {
      this.assets = undefined;

    }

    PoseRegistry.prototype = {

      constructor: PoseRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.veroldEngine = properties.veroldEngine;
        //Check machine capabilities and set
      },

      uninitialize: function(  ) {
        for ( var x in this.assets ) {
          this.assets[x].uninitialize();
          delete this.assets[x];
        }
        this.assets = undefined;
        this.veroldEngine = undefined;
        //this.projectId = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      // _initComponents: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.loadComponents();

      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      // getAllAssets: function( options ) {
      //   if ( options && options.filter ) {
      //     var newOptions = { filter: {} };
      //     _.extend( newOptions.filter, options.filter, { 'pose': true } );
      //     return this.veroldEngine.assetRegistry.getAllAssets( newOptions );
      //   }
      //   if ( options && options.autoLoad ) {
      //     for ( var x in this.assets ) {
      //       if ( this.assets[ x ].state_base == "pending" ) {
      //         this.assets[ x ].load( options );
      //       }
      //     }
      //   }
      //   return this.assets;
      // },

      //Returns the asset specified. null if invalid
      //options
        //autoLoad - boolean that's set to true to make this call automatically load the asset's data
        //success - callback on successful load of the data. Not valid if autoLoad is false
        //failure - callback on failure while loading the data. Not valid if autoLoad is false
        //progress - callback on loading progress. Not valid if autoLoad is false
      // getAsset: function( assetID, options ) {
      //   return this.veroldEngine.assetRegistry.getAsset( assetID, options );
      // },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {
        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model.");

        var newAsset = new PoseAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;

      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
        this.veroldEngine.trigger("poseDeleted", assetID );
      },

      update: function( delta ) {

      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    }

    return PoseRegistry;
  });

define('json5',[], function() {
// json5.js
// Modern JSON. See README.md for details.
//
// This file is based directly off of Douglas Crockford's json_parse.js:
// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

var JSON5 = (typeof exports === 'object' ? exports : {});

JSON5.parse = (function () {
    

// This is a function that can parse a JSON5 text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON5 parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,     // The index of the current character
        ch,     // The current character
        escapee = {
            "'":  "'",
            '"':  '"',
            '\\': '\\',
            '/':  '/',
            '\n': '',       // Replace escaped newlines in strings w/ empty string
            b:    '\b',
            f:    '\f',
            n:    '\n',
            r:    '\r',
            t:    '\t'
        },
        ws = [
            ' ',
            '\t',
            '\r',
            '\n',
            '\v',
            '\f',
            '\xA0',
            '\uFEFF'
        ],
        text,

        error = function (m) {

// Call error when something is wrong.

            var error = new SyntaxError();
            error.message = m;
            error.at = at;
            error.text = text;
            throw error;
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected '" + c + "' instead of '" + ch + "'");
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at += 1;
            return ch;
        },

        peek = function () {

// Get the next character without consuming it or
// assigning it to the ch varaible.

            return text.charAt(at);
        },

        identifier = function () {

// Parse an identifier. Normally, reserved words are disallowed here, but we
// only use this for unquoted object keys, where reserved words are allowed,
// so we don't check for those here. References:
// - http://es5.github.com/#x7.6
// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
// TODO Identifiers can have Unicode "letters" in them; add support for those.

            var key = ch;

            // Identifiers must start with a letter, _ or $.
            if ((ch !== '_' && ch !== '$') &&
                    (ch < 'a' || ch > 'z') &&
                    (ch < 'A' || ch > 'Z')) {
                error("Bad identifier");
            }

            // Subsequent characters can contain digits.
            while (next() && (
                    ch === '_' || ch === '$' ||
                    (ch >= 'a' && ch <= 'z') ||
                    (ch >= 'A' && ch <= 'Z') ||
                    (ch >= '0' && ch <= '9'))) {
                key += ch;
            }

            return key;
        },

        number = function () {

// Parse a number value.

            var number,
                sign = '',
                string = '',
                base = 10;

            if (ch === '-' || ch === '+') {
                sign = ch;
                next(ch);
            }

            // support for Infinity (could tweak to allow other words):
            if (ch === 'I') {
                number = word();
                if (typeof number !== 'number' || isNaN(number)) {
                    error('Unexpected word for number');
                }
                return (sign === '-') ? -number : number;
            }

            // support for NaN
            if (ch === 'N' ) {
              number = word();
              if (!isNaN(number)) {
                error('expected word to be NaN');
              }
              // ignore sign as -NaN also is NaN
              return number;
            }

            if (ch === '0') {
                string += ch;
                next();
                if (ch === 'x' || ch === 'X') {
                    string += ch;
                    next();
                    base = 16;
                } else if (ch >= '0' && ch <= '9') {
                    error('Octal literal');
                }
            }

            switch (base) {
            case 10:
                while (ch >= '0' && ch <= '9' ) {
                    string += ch;
                    next();
                }
                if (ch === '.') {
                    string += '.';
                    while (next() && ch >= '0' && ch <= '9') {
                        string += ch;
                    }
                }
                if (ch === 'e' || ch === 'E') {
                    string += ch;
                    next();
                    if (ch === '-' || ch === '+') {
                        string += ch;
                        next();
                    }
                    while (ch >= '0' && ch <= '9') {
                        string += ch;
                        next();
                    }
                }
                break;
            case 16:
                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
                    string += ch;
                    next();
                }
                break;
            }

            if(sign === '-') {
                number = -string;
            } else {
                number = +string;
            }
            
            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                delim,      // double quote or single quote
                uffff;

// When parsing for string values, we must look for ' or " and \ characters.

            if (ch === '"' || ch === "'") {
                delim = ch;
                while (next()) {
                    if (ch === delim) {
                        next();
                        return string;
                    } else if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (ch === '\r') {
                            if (peek() === '\n') {
                                next();
                            }
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else if (ch === '\n') {
                        // unescaped newlines are invalid; see:
                        // https://github.com/aseemk/json5/issues/24
                        // TODO this feels special-cased; are there other
                        // invalid unescaped chars?
                        break;
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        inlineComment = function () {

// Skip an inline comment, assuming this is one. The current character should
// be the second / character in the // pair that begins this inline comment.
// To finish the inline comment, we look for a newline or the end of the text.

            if (ch !== '/') {
                error("Not an inline comment");
            }

            do {
                next();
                if (ch === '\n' || ch === '\r') {
                    next();
                    return;
                }
            } while (ch);
        },

        blockComment = function () {

// Skip a block comment, assuming this is one. The current character should be
// the * character in the /* pair that begins this block comment.
// To finish the block comment, we look for an ending */ pair of characters,
// but we also watch for the end of text before the comment is terminated.

            if (ch !== '*') {
                error("Not a block comment");
            }

            do {
                next();
                while (ch === '*') {
                    next('*');
                    if (ch === '/') {
                        next('/');
                        return;
                    }
                }
            } while (ch);

            error("Unterminated block comment");
        },

        comment = function () {

// Skip a comment, whether inline or block-level, assuming this is one.
// Comments always begin with a / character.

            if (ch !== '/') {
                error("Not a comment");
            }

            next('/');

            if (ch === '/') {
                inlineComment();
            } else if (ch === '*') {
                blockComment();
            } else {
                error("Unrecognized comment");
            }
        },

        white = function () {

// Skip whitespace and comments.
// Note that we're detecting comments by only a single / character.
// This works since regular expressions are not valid JSON(5), but this will
// break if there are other valid values that begin with a / character!

            while (ch) {
                if (ch === '/') {
                    comment();
                } else if (ws.indexOf(ch) >= 0) {
                    next();
                } else {
                    return;
                }
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            case 'I':
                next('I');
                next('n');
                next('f');
                next('i');
                next('n');
                next('i');
                next('t');
                next('y');
                return Infinity;
            case 'N':
              next( 'N' );
              next( 'a' );
              next( 'N' );
              return NaN;
            }
            error("Unexpected '" + ch + "'");
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                while (ch) {
                    if (ch === ']') {
                        next(']');
                        return array;   // Potentially empty array
                    }
                    // ES5 allows omitting elements in arrays, e.g. [,] and
                    // [,null]. We don't allow this in JSON5.
                    if (ch === ',') {
                        error("Missing array element");
                    } else {
                        array.push(value());
                    }
                    white();
                    // If there's no comma after this value, this needs to
                    // be the end of the array.
                    if (ch !== ',') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                while (ch) {
                    if (ch === '}') {
                        next('}');
                        return object;   // Potentially empty object
                    }

                    // Keys can be unquoted. If they are, they need to be
                    // valid JS identifiers.
                    if (ch === '"' || ch === "'") {
                        key = string();
                    } else {
                        key = identifier();
                    }

                    white();
                    next(':');
                    object[key] = value();
                    white();
                    // If there's no comma after this pair, this needs to be
                    // the end of the object.
                    if (ch !== ',') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
        case "'":
            return string();
        case '-':
        case '+':
        case '.':
            return number();
        default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source, reviver) {
        var result;

        text = String(source);
        at = 0;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

// If there is a reviver function, we recursively walk the new structure,
// passing each name/value pair to the reviver function for possible
// transformation, starting with a temporary root object that holds the result
// in an empty key. If there is not a reviver function, we simply return the
// result.

        return typeof reviver === 'function' ? (function walk(holder, key) {
            var k, v, value = holder[key];
            if (value && typeof value === 'object') {
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = walk(value, k);
                        if (v !== undefined) {
                            value[k] = v;
                        } else {
                            delete value[k];
                        }
                    }
                }
            }
            return reviver.call(holder, key, value);
        }({'': result}, '')) : result;
    };
}());

// JSON5 stringify will not quote keys where appropriate
JSON5.stringify = function (obj, replacer, space) {
    if (replacer && (typeof(replacer) !== "function" && !isArray(replacer))) {
        throw new Error('Replacer must be a function or an array');
    }
    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {
        var value = holder[key];

        // Replace the value with its toJSON value first, if possible
        if (value && value.toJSON && typeof value.toJSON === "function") {
            value = value.toJSON();
        }

        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for
        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).
        if (typeof(replacer) === "function") {
            return replacer.call(holder, key, value);
        } else if(replacer) {
            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {
                return value;
            } else {
                return undefined;
            }
        } else {
            return value;
        }
    };

    function isWordChar(char) {
        return (char >= 'a' && char <= 'z') ||
            (char >= 'A' && char <= 'Z') ||
            (char >= '0' && char <= '9') ||
            char === '_' || char === '$';
    }

    function isWordStart(char) {
        return (char >= 'a' && char <= 'z') ||
            (char >= 'A' && char <= 'Z') ||
            char === '_' || char === '$';
    }

    function isWord(key) {
        if (typeof key !== 'string') {
            return false;
        }
        if (!isWordStart(key[0])) {
            return false;
        }
        var i = 1, length = key.length;
        while (i < length) {
            if (!isWordChar(key[i])) {
                return false;
            }
            i++;
        }
        return true;
    }

    // export for use in tests
    JSON5.isWord = isWord;

    // polyfills
    function isArray(obj) {
        if (Array.isArray) {
            return Array.isArray(obj);
        } else {
            return Object.prototype.toString.call(obj) === '[object Array]';
        }
    }

    function isDate(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    }

    isNaN = isNaN || function(val) {
        return typeof val === 'number' && val !== val;
    };

    var objStack = [];
    function checkForCircular(obj) {
        for (var i = 0; i < objStack.length; i++) {
            if (objStack[i] === obj) {
                throw new TypeError("Converting circular structure to JSON");
            }
        }
    }

    function makeIndent(str, num, noNewLine) {
        if (!str) {
            return "";
        }
        // indentation no more than 10 chars
        if (str.length > 10) {
            str = str.substring(0, 10);
        }

        var indent = noNewLine ? "" : "\n";
        for (var i = 0; i < num; i++) {
            indent += str;
        }

        return indent;
    }

    var indentStr;
    if (space) {
        if (typeof space === "string") {
            indentStr = space;
        } else if (typeof space === "number" && space >= 0) {
            indentStr = makeIndent(" ", space, true);
        } else {
            // ignore space parameter
        }
    }

    // Copied from Crokford's implementation of JSON
    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
    // Begin
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        meta = { // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    };
    function escapeString(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ?
                c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }
    // End

    function internalStringify(holder, key, isTopLevel) {
        var buffer, res;

        // Replace the value, if necessary
        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);

        if (obj_part && !isDate(obj_part)) {
            // unbox objects
            // don't unbox dates, since will turn it into number
            obj_part = obj_part.valueOf();
        }
        switch(typeof obj_part) {
            case "boolean":
                return obj_part.toString();

            case "number":
                if (isNaN(obj_part) || !isFinite(obj_part)) {
                    return "null";
                }
                return obj_part.toString();

            case "string":
                return escapeString(obj_part.toString());

            case "object":
                if (obj_part === null) {
                    return "null";
                } else if (isArray(obj_part)) {
                    checkForCircular(obj_part);
                    buffer = "[";
                    objStack.push(obj_part);

                    for (var i = 0; i < obj_part.length; i++) {
                        res = internalStringify(obj_part, i, false);
                        buffer += makeIndent(indentStr, objStack.length);
                        if (res === null || typeof res === "undefined") {
                            buffer += "null";
                        } else {
                            buffer += res;
                        }
                        if (i < obj_part.length-1) {
                            buffer += ",";
                        } else if (indentStr) {
                            buffer += "\n";
                        }
                    }
                    objStack.pop();
                    buffer += makeIndent(indentStr, objStack.length, true) + "]";
                } else {
                    checkForCircular(obj_part);
                    buffer = "{";
                    var nonEmpty = false;
                    objStack.push(obj_part);
                    for (var prop in obj_part) {
                        if (obj_part.hasOwnProperty(prop)) {
                            var value = internalStringify(obj_part, prop, false);
                            isTopLevel = false;
                            if (typeof value !== "undefined" && value !== null) {
                                buffer += makeIndent(indentStr, objStack.length);
                                nonEmpty = true;
                                var key = isWord(prop) ? prop : escapeString(prop);
                                buffer += key + ":" + (indentStr ? ' ' : '') + value + ",";
                            }
                        }
                    }
                    objStack.pop();
                    if (nonEmpty) {
                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + "}";
                    } else {
                        buffer = '{}';
                    }
                }
                return buffer;
            default:
                // functions and undefined should be ignored
                return undefined;
        }
    }

    // special case...when undefined is used inside of
    // a compound object/array, return null.
    // but when top-level, return undefined
    var topLevelHolder = {"":obj};
    if (obj === undefined) {
        return getReplacedValueOrUndefined(topLevelHolder, '', true);
    }
    return internalStringify(topLevelHolder, '', true);
};
return JSON5;
});

/*
  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint bitwise:true plusplus:true */
/*global esprima:true, define:true, exports:true, window: true,
throwErrorTolerant: true,
throwError: true, generateStatement: true, peek: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true, parseParams: true, validateParam: true,
parseUnaryExpression: true,
parseStatement: true, parseSourceElement: true */

(function (root, factory) {
    

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // Rhino, and plain browser loading.

    /* istanbul ignore next */
    if (typeof define === 'function' && define.amd) {
        define('VeroldEngine/libs/esprima/esprima',['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.esprima = {}));
    }
}(this, function (exports) {
    

    var Token,
        TokenName,
        FnExprTokens,
        Syntax,
        PlaceHolders,
        PropertyKind,
        Messages,
        Regex,
        source,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        lookahead,
        state,
        extra;

    Token = {
        BooleanLiteral: 1,
        EOF: 2,
        Identifier: 3,
        Keyword: 4,
        NullLiteral: 5,
        NumericLiteral: 6,
        Punctuator: 7,
        StringLiteral: 8,
        RegularExpression: 9
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = 'Boolean';
    TokenName[Token.EOF] = '<end>';
    TokenName[Token.Identifier] = 'Identifier';
    TokenName[Token.Keyword] = 'Keyword';
    TokenName[Token.NullLiteral] = 'Null';
    TokenName[Token.NumericLiteral] = 'Numeric';
    TokenName[Token.Punctuator] = 'Punctuator';
    TokenName[Token.StringLiteral] = 'String';
    TokenName[Token.RegularExpression] = 'RegularExpression';

    // A function following one of those tokens is an expression.
    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                    'return', 'case', 'delete', 'throw', 'void',
                    // assignment operators
                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                    '&=', '|=', '^=', ',',
                    // binary/unary operators
                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                    '<=', '<', '>', '!=', '!=='];

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement'
    };

    PlaceHolders = {
        ArrowParameterPlaceHolder: {
            type: 'ArrowParameterPlaceHolder'
        }
    };

    PropertyKind = {
        Data: 1,
        Get: 2,
        Set: 4
    };

    // Error messages should be identical to V8.
    Messages = {
        UnexpectedToken:  'Unexpected token %0',
        UnexpectedNumber:  'Unexpected number',
        UnexpectedString:  'Unexpected string',
        UnexpectedIdentifier:  'Unexpected identifier',
        UnexpectedReserved:  'Unexpected reserved word',
        UnexpectedEOS:  'Unexpected end of input',
        NewlineAfterThrow:  'Illegal newline after throw',
        InvalidRegExp: 'Invalid regular expression',
        UnterminatedRegExp:  'Invalid regular expression: missing /',
        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',
        InvalidLHSInForIn:  'Invalid left-hand side in for-in',
        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
        NoCatchOrFinally:  'Missing catch or finally after try',
        UnknownLabel: 'Undefined label \'%0\'',
        Redeclaration: '%0 \'%1\' has already been declared',
        IllegalContinue: 'Illegal continue statement',
        IllegalBreak: 'Illegal break statement',
        IllegalReturn: 'Illegal return statement',
        StrictModeWith:  'Strict mode code may not include a with statement',
        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',
        StrictVarName:  'Variable name may not be eval or arguments in strict mode',
        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',
        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',
        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',
        StrictDelete:  'Delete of an unqualified identifier in strict mode.',
        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',
        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',
        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',
        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',
        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',
        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',
        StrictReservedWord:  'Use of future reserved word in strict mode'
    };

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    // Ensure the condition is true, otherwise throw an error.
    // This is only to have a better contract semantic, i.e. another safety net
    // to catch a logic error. The condition shall be fulfilled in normal case.
    // Do NOT use this to enforce a certain condition on any user input.

    function assert(condition, message) {
        /* istanbul ignore if */
        if (!condition) {
            throw new Error('ASSERT: ' + message);
        }
    }

    function isDecimalDigit(ch) {
        return (ch >= 0x30 && ch <= 0x39);   // 0..9
    }

    function isHexDigit(ch) {
        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
    }

    function isOctalDigit(ch) {
        return '01234567'.indexOf(ch) >= 0;
    }


    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
            (ch === 0x5C) ||                      // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    // 7.6.1.2 Future Reserved Words

    function isFutureReservedWord(id) {
        switch (id) {
        case 'class':
        case 'enum':
        case 'export':
        case 'extends':
        case 'import':
        case 'super':
            return true;
        default:
            return false;
        }
    }

    function isStrictModeReservedWord(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'yield':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    // 7.6.1.1 Keywords

    function isKeyword(id) {
        if (strict && isStrictModeReservedWord(id)) {
            return true;
        }

        // 'const' is specialized as Keyword in V8.
        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.
        // Some others are from future reserved words.

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') ||
                (id === 'try') || (id === 'let');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    // 7.4 Comments

    function addComment(type, value, start, end, loc) {
        var comment;

        assert(typeof start === 'number', 'Comment must have valid position');

        // Because the way the actual token is scanned, often the comments
        // (if any) are skipped twice during the lexical analysis.
        // Thus, we need to skip adding a comment if the comment array already
        // handled it.
        if (state.lastCommentStart >= start) {
            return;
        }
        state.lastCommentStart = start;

        comment = {
            type: type,
            value: value
        };
        if (extra.range) {
            comment.range = [start, end];
        }
        if (extra.loc) {
            comment.loc = loc;
        }
        extra.comments.push(comment);
        if (extra.attachComment) {
            extra.leadingComments.push(comment);
            extra.trailingComments.push(comment);
        }
    }

    function skipSingleLineComment(offset) {
        var start, loc, ch, comment;

        start = index - offset;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart - offset
            }
        };

        while (index < length) {
            ch = source.charCodeAt(index);
            ++index;
            if (isLineTerminator(ch)) {
                if (extra.comments) {
                    comment = source.slice(start + offset, index - 1);
                    loc.end = {
                        line: lineNumber,
                        column: index - lineStart - 1
                    };
                    addComment('Line', comment, start, index - 1, loc);
                }
                if (ch === 13 && source.charCodeAt(index) === 10) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                return;
            }
        }

        if (extra.comments) {
            comment = source.slice(start + offset, index);
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
            addComment('Line', comment, start, index, loc);
        }
    }

    function skipMultiLineComment() {
        var start, loc, ch, comment;

        if (extra.comments) {
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (isLineTerminator(ch)) {
                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                ++index;
                lineStart = index;
                if (index >= length) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else if (ch === 0x2A) {
                // Block comment ends with '*/'.
                if (source.charCodeAt(index + 1) === 0x2F) {
                    ++index;
                    ++index;
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 2);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        addComment('Block', comment, start, index, loc);
                    }
                    return;
                }
                ++index;
            } else {
                ++index;
            }
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    function skipComment() {
        var ch, start;

        start = (index === 0);
        while (index < length) {
            ch = source.charCodeAt(index);

            if (isWhiteSpace(ch)) {
                ++index;
            } else if (isLineTerminator(ch)) {
                ++index;
                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
                start = true;
            } else if (ch === 0x2F) { // U+002F is '/'
                ch = source.charCodeAt(index + 1);
                if (ch === 0x2F) {
                    ++index;
                    ++index;
                    skipSingleLineComment(2);
                    start = true;
                } else if (ch === 0x2A) {  // U+002A is '*'
                    ++index;
                    ++index;
                    skipMultiLineComment();
                } else {
                    break;
                }
            } else if (start && ch === 0x2D) { // U+002D is '-'
                // U+003E is '>'
                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
                    // '-->' is a single-line comment
                    index += 3;
                    skipSingleLineComment(3);
                } else {
                    break;
                }
            } else if (ch === 0x3C) { // U+003C is '<'
                if (source.slice(index + 1, index + 4) === '!--') {
                    ++index; // `<`
                    ++index; // `!`
                    ++index; // `-`
                    ++index; // `-`
                    skipSingleLineComment(4);
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    function scanHexEscape(prefix) {
        var i, len, ch, code = 0;

        len = (prefix === 'u') ? 4 : 2;
        for (i = 0; i < len; ++i) {
            if (index < length && isHexDigit(source[index])) {
                ch = source[index++];
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            } else {
                return '';
            }
        }
        return String.fromCharCode(code);
    }

    function scanUnicodeCodePointEscape() {
        var ch, code, cu1, cu2;

        ch = source[index];
        code = 0;

        // At least, one hex digit is required.
        if (ch === '}') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        while (index < length) {
            ch = source[index++];
            if (!isHexDigit(ch)) {
                break;
            }
            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
        }

        if (code > 0x10FFFF || ch !== '}') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        // UTF-16 Encoding
        if (code <= 0xFFFF) {
            return String.fromCharCode(code);
        }
        cu1 = ((code - 0x10000) >> 10) + 0xD800;
        cu2 = ((code - 0x10000) & 1023) + 0xDC00;
        return String.fromCharCode(cu1, cu2);
    }

    function getEscapedIdentifier() {
        var ch, id;

        ch = source.charCodeAt(index++);
        id = String.fromCharCode(ch);

        // '\u' (U+005C, U+0075) denotes an escaped character.
        if (ch === 0x5C) {
            if (source.charCodeAt(index) !== 0x75) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            ++index;
            ch = scanHexEscape('u');
            if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
            id = ch;
        }

        while (index < length) {
            ch = source.charCodeAt(index);
            if (!isIdentifierPart(ch)) {
                break;
            }
            ++index;
            id += String.fromCharCode(ch);

            // '\u' (U+005C, U+0075) denotes an escaped character.
            if (ch === 0x5C) {
                id = id.substr(0, id.length - 1);
                if (source.charCodeAt(index) !== 0x75) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id += ch;
            }
        }

        return id;
    }

    function getIdentifier() {
        var start, ch;

        start = index++;
        while (index < length) {
            ch = source.charCodeAt(index);
            if (ch === 0x5C) {
                // Blackslash (U+005C) marks Unicode escape sequence.
                index = start;
                return getEscapedIdentifier();
            }
            if (isIdentifierPart(ch)) {
                ++index;
            } else {
                break;
            }
        }

        return source.slice(start, index);
    }

    function scanIdentifier() {
        var start, id, type;

        start = index;

        // Backslash (U+005C) starts an escaped character.
        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();

        // There is no keyword or literal with only one character.
        // Thus, it must be an identifier.
        if (id.length === 1) {
            type = Token.Identifier;
        } else if (isKeyword(id)) {
            type = Token.Keyword;
        } else if (id === 'null') {
            type = Token.NullLiteral;
        } else if (id === 'true' || id === 'false') {
            type = Token.BooleanLiteral;
        } else {
            type = Token.Identifier;
        }

        return {
            type: type,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }


    // 7.7 Punctuators

    function scanPunctuator() {
        var start = index,
            code = source.charCodeAt(index),
            code2,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        switch (code) {

        // Check for most common single-character punctuators.
        case 0x2E:  // . dot
        case 0x28:  // ( open bracket
        case 0x29:  // ) close bracket
        case 0x3B:  // ; semicolon
        case 0x2C:  // , comma
        case 0x7B:  // { open curly brace
        case 0x7D:  // } close curly brace
        case 0x5B:  // [
        case 0x5D:  // ]
        case 0x3A:  // :
        case 0x3F:  // ?
        case 0x7E:  // ~
            ++index;
            if (extra.tokenize) {
                if (code === 0x28) {
                    extra.openParenToken = extra.tokens.length;
                } else if (code === 0x7B) {
                    extra.openCurlyToken = extra.tokens.length;
                }
            }
            return {
                type: Token.Punctuator,
                value: String.fromCharCode(code),
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };

        default:
            code2 = source.charCodeAt(index + 1);

            // '=' (U+003D) marks an assignment or comparison operator.
            if (code2 === 0x3D) {
                switch (code) {
                case 0x2B:  // +
                case 0x2D:  // -
                case 0x2F:  // /
                case 0x3C:  // <
                case 0x3E:  // >
                case 0x5E:  // ^
                case 0x7C:  // |
                case 0x25:  // %
                case 0x26:  // &
                case 0x2A:  // *
                    index += 2;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code) + String.fromCharCode(code2),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };

                case 0x21: // !
                case 0x3D: // =
                    index += 2;

                    // !== and ===
                    if (source.charCodeAt(index) === 0x3D) {
                        ++index;
                    }
                    return {
                        type: Token.Punctuator,
                        value: source.slice(start, index),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        start: start,
                        end: index
                    };
                }
            }
        }

        // 4-character punctuator: >>>=

        ch4 = source.substr(index, 4);

        if (ch4 === '>>>=') {
            index += 4;
            return {
                type: Token.Punctuator,
                value: ch4,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 3-character punctuators: === !== >>> <<= >>=

        ch3 = ch4.substr(0, 3);

        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
            index += 3;
            return {
                type: Token.Punctuator,
                value: ch3,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // Other 2-character punctuators: ++ -- << >> && ||
        ch2 = ch3.substr(0, 2);

        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {
            index += 2;
            return {
                type: Token.Punctuator,
                value: ch2,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        // 1-character punctuators: < > = ! + - * % & | ^ /

        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
            ++index;
            return {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
    }

    // 7.8.3 Numeric Literals

    function scanHexLiteral(start) {
        var number = '';

        while (index < length) {
            if (!isHexDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (number.length === 0) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt('0x' + number, 16),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanOctalLiteral(start) {
        var number = '0' + source[index++];
        while (index < length) {
            if (!isOctalDigit(source[index])) {
                break;
            }
            number += source[index++];
        }

        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseInt(number, 8),
            octal: true,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function scanNumericLiteral() {
        var number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
            'Numeric literal must start with a decimal digit or a decimal point');

        start = index;
        number = '';
        if (ch !== '.') {
            number = source[index++];
            ch = source[index];

            // Hex number starts with '0x'.
            // Octal number starts with '0'.
            if (number === '0') {
                if (ch === 'x' || ch === 'X') {
                    ++index;
                    return scanHexLiteral(start);
                }
                if (isOctalDigit(ch)) {
                    return scanOctalLiteral(start);
                }

                // decimal number starts with '0' such as '09' is illegal.
                if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }

            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === '.') {
            number += source[index++];
            while (isDecimalDigit(source.charCodeAt(index))) {
                number += source[index++];
            }
            ch = source[index];
        }

        if (ch === 'e' || ch === 'E') {
            number += source[index++];

            ch = source[index];
            if (ch === '+' || ch === '-') {
                number += source[index++];
            }
            if (isDecimalDigit(source.charCodeAt(index))) {
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
            } else {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
        }

        if (isIdentifierStart(source.charCodeAt(index))) {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    // 7.8.4 String Literals

    function scanStringLiteral() {
        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;
        startLineNumber = lineNumber;
        startLineStart = lineStart;

        quote = source[index];
        assert((quote === '\'' || quote === '"'),
            'String literal must starts with a quote');

        start = index;
        ++index;

        while (index < length) {
            ch = source[index++];

            if (ch === quote) {
                quote = '';
                break;
            } else if (ch === '\\') {
                ch = source[index++];
                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                    case 'u':
                    case 'x':
                        if (source[index] === '{') {
                            ++index;
                            str += scanUnicodeCodePointEscape();
                        } else {
                            restore = index;
                            unescaped = scanHexEscape(ch);
                            if (unescaped) {
                                str += unescaped;
                            } else {
                                index = restore;
                                str += ch;
                            }
                        }
                        break;
                    case 'n':
                        str += '\n';
                        break;
                    case 'r':
                        str += '\r';
                        break;
                    case 't':
                        str += '\t';
                        break;
                    case 'b':
                        str += '\b';
                        break;
                    case 'f':
                        str += '\f';
                        break;
                    case 'v':
                        str += '\x0B';
                        break;

                    default:
                        if (isOctalDigit(ch)) {
                            code = '01234567'.indexOf(ch);

                            // \0 is not octal escape sequence
                            if (code !== 0) {
                                octal = true;
                            }

                            if (index < length && isOctalDigit(source[index])) {
                                octal = true;
                                code = code * 8 + '01234567'.indexOf(source[index++]);

                                // 3 digits are only allowed when string starts
                                // with 0, 1, 2, 3
                                if ('0123'.indexOf(ch) >= 0 &&
                                        index < length &&
                                        isOctalDigit(source[index])) {
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
                                }
                            }
                            str += String.fromCharCode(code);
                        } else {
                            str += ch;
                        }
                        break;
                    }
                } else {
                    ++lineNumber;
                    if (ch ===  '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                }
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                break;
            } else {
                str += ch;
            }
        }

        if (quote !== '') {
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }

        return {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            startLineNumber: startLineNumber,
            startLineStart: startLineStart,
            lineNumber: lineNumber,
            lineStart: lineStart,
            start: start,
            end: index
        };
    }

    function testRegExp(pattern, flags) {
        var tmp = pattern,
            value;

        if (flags.indexOf('u') >= 0) {
            // Replace each astral symbol and every Unicode code point
            // escape sequence that represents such a symbol with a single
            // ASCII symbol to avoid throwing on regular expressions that
            // are only valid in combination with the `/u` flag.
            tmp = tmp
                .replace(/\\u\{([0-9a-fA-F]{5,6})\}/g, 'x')
                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
        }

        // First, detect invalid regular expressions.
        try {
            value = new RegExp(tmp);
        } catch (e) {
            throwError({}, Messages.InvalidRegExp);
        }

        // Return a regular expression object for this pattern-flag pair, or
        // `null` in case the current environment doesn't support the flags it
        // uses.
        try {
            return new RegExp(pattern, flags);
        } catch (exception) {
            return null;
        }
    }

    function scanRegExpBody() {
        var ch, str, classMarker, terminated, body;

        ch = source[index];
        assert(ch === '/', 'Regular expression literal must start with a slash');
        str = source[index++];

        classMarker = false;
        terminated = false;
        while (index < length) {
            ch = source[index++];
            str += ch;
            if (ch === '\\') {
                ch = source[index++];
                // ECMA-262 7.8.5
                if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
                str += ch;
            } else if (isLineTerminator(ch.charCodeAt(0))) {
                throwError({}, Messages.UnterminatedRegExp);
            } else if (classMarker) {
                if (ch === ']') {
                    classMarker = false;
                }
            } else {
                if (ch === '/') {
                    terminated = true;
                    break;
                } else if (ch === '[') {
                    classMarker = true;
                }
            }
        }

        if (!terminated) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        // Exclude leading and trailing slash.
        body = str.substr(1, str.length - 2);
        return {
            value: body,
            literal: str
        };
    }

    function scanRegExpFlags() {
        var ch, str, flags, restore;

        str = '';
        flags = '';
        while (index < length) {
            ch = source[index];
            if (!isIdentifierPart(ch.charCodeAt(0))) {
                break;
            }

            ++index;
            if (ch === '\\' && index < length) {
                ch = source[index];
                if (ch === 'u') {
                    ++index;
                    restore = index;
                    ch = scanHexEscape('u');
                    if (ch) {
                        flags += ch;
                        for (str += '\\u'; restore < index; ++restore) {
                            str += source[restore];
                        }
                    } else {
                        index = restore;
                        flags += 'u';
                        str += '\\u';
                    }
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                } else {
                    str += '\\';
                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            } else {
                flags += ch;
                str += ch;
            }
        }

        return {
            value: flags,
            literal: str
        };
    }

    function scanRegExp() {
        var start, body, flags, value;

        lookahead = null;
        skipComment();
        start = index;

        body = scanRegExpBody();
        flags = scanRegExpFlags();
        value = testRegExp(body.value, flags.value);

        if (extra.tokenize) {
            return {
                type: Token.RegularExpression,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: start,
                end: index
            };
        }

        return {
            literal: body.literal + flags.literal,
            value: value,
            regex: {
                pattern: body.value,
                flags: flags.value
            },
            start: start,
            end: index
        };
    }

    function collectRegex() {
        var pos, loc, regex, token;

        skipComment();

        pos = index;
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        regex = scanRegExp();

        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        /* istanbul ignore next */
        if (!extra.tokenize) {
            // Pop the previous token, which is likely '/' or '/='
            if (extra.tokens.length > 0) {
                token = extra.tokens[extra.tokens.length - 1];
                if (token.range[0] === pos && token.type === 'Punctuator') {
                    if (token.value === '/' || token.value === '/=') {
                        extra.tokens.pop();
                    }
                }
            }

            extra.tokens.push({
                type: 'RegularExpression',
                value: regex.literal,
                regex: regex.regex,
                range: [pos, index],
                loc: loc
            });
        }

        return regex;
    }

    function isIdentifierName(token) {
        return token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    function advanceSlash() {
        var prevToken,
            checkToken;
        // Using the following algorithm:
        // https://github.com/mozilla/sweet.js/wiki/design
        prevToken = extra.tokens[extra.tokens.length - 1];
        if (!prevToken) {
            // Nothing before that: it cannot be a division.
            return collectRegex();
        }
        if (prevToken.type === 'Punctuator') {
            if (prevToken.value === ']') {
                return scanPunctuator();
            }
            if (prevToken.value === ')') {
                checkToken = extra.tokens[extra.openParenToken - 1];
                if (checkToken &&
                        checkToken.type === 'Keyword' &&
                        (checkToken.value === 'if' ||
                         checkToken.value === 'while' ||
                         checkToken.value === 'for' ||
                         checkToken.value === 'with')) {
                    return collectRegex();
                }
                return scanPunctuator();
            }
            if (prevToken.value === '}') {
                // Dividing a function by anything makes little sense,
                // but we have to check for that.
                if (extra.tokens[extra.openCurlyToken - 3] &&
                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                    // Anonymous function.
                    checkToken = extra.tokens[extra.openCurlyToken - 4];
                    if (!checkToken) {
                        return scanPunctuator();
                    }
                } else if (extra.tokens[extra.openCurlyToken - 4] &&
                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                    // Named function.
                    checkToken = extra.tokens[extra.openCurlyToken - 5];
                    if (!checkToken) {
                        return collectRegex();
                    }
                } else {
                    return scanPunctuator();
                }
                // checkToken determines whether the function is
                // a declaration or an expression.
                if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                    // It is an expression.
                    return scanPunctuator();
                }
                // It is a declaration.
                return collectRegex();
            }
            return collectRegex();
        }
        if (prevToken.type === 'Keyword') {
            return collectRegex();
        }
        return scanPunctuator();
    }

    function advance() {
        var ch;

        skipComment();

        if (index >= length) {
            return {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                start: index,
                end: index
            };
        }

        ch = source.charCodeAt(index);

        if (isIdentifierStart(ch)) {
            return scanIdentifier();
        }

        // Very common: ( and ) and ;
        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
            return scanPunctuator();
        }

        // String literal starts with single quote (U+0027) or double quote (U+0022).
        if (ch === 0x27 || ch === 0x22) {
            return scanStringLiteral();
        }


        // Dot (.) U+002E can also start a floating-point number, hence the need
        // to check the next character.
        if (ch === 0x2E) {
            if (isDecimalDigit(source.charCodeAt(index + 1))) {
                return scanNumericLiteral();
            }
            return scanPunctuator();
        }

        if (isDecimalDigit(ch)) {
            return scanNumericLiteral();
        }

        // Slash (/) U+002F can also start a regex.
        if (extra.tokenize && ch === 0x2F) {
            return advanceSlash();
        }

        return scanPunctuator();
    }

    function collectToken() {
        var loc, token, value, entry;

        skipComment();
        loc = {
            start: {
                line: lineNumber,
                column: index - lineStart
            }
        };

        token = advance();
        loc.end = {
            line: lineNumber,
            column: index - lineStart
        };

        if (token.type !== Token.EOF) {
            value = source.slice(token.start, token.end);
            entry = {
                type: TokenName[token.type],
                value: value,
                range: [token.start, token.end],
                loc: loc
            };
            if (token.regex) {
                entry.regex = {
                    pattern: token.regex.pattern,
                    flags: token.regex.flags
                };
            }
            extra.tokens.push(entry);
        }

        return token;
    }

    function lex() {
        var token;

        token = lookahead;
        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();

        index = token.end;
        lineNumber = token.lineNumber;
        lineStart = token.lineStart;

        return token;
    }

    function peek() {
        var pos, line, start;

        pos = index;
        line = lineNumber;
        start = lineStart;
        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
        index = pos;
        lineNumber = line;
        lineStart = start;
    }

    function Position() {
        this.line = lineNumber;
        this.column = index - lineStart;
    }

    function SourceLocation() {
        this.start = new Position();
        this.end = null;
    }

    function WrappingSourceLocation(startToken) {
        if (startToken.type === Token.StringLiteral) {
            this.start = {
                line: startToken.startLineNumber,
                column: startToken.start - startToken.startLineStart
            };
        } else {
            this.start = {
                line: startToken.lineNumber,
                column: startToken.start - startToken.lineStart
            };
        }
        this.end = null;
    }

    function Node() {
        // Skip comment.
        index = lookahead.start;
        if (lookahead.type === Token.StringLiteral) {
            lineNumber = lookahead.startLineNumber;
            lineStart = lookahead.startLineStart;
        } else {
            lineNumber = lookahead.lineNumber;
            lineStart = lookahead.lineStart;
        }
        if (extra.range) {
            this.range = [index, 0];
        }
        if (extra.loc) {
            this.loc = new SourceLocation();
        }
    }

    function WrappingNode(startToken) {
        if (extra.range) {
            this.range = [startToken.start, 0];
        }
        if (extra.loc) {
            this.loc = new WrappingSourceLocation(startToken);
        }
    }

    WrappingNode.prototype = Node.prototype = {

        processComment: function () {
            var lastChild,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                last = bottomRight[bottomRight.length - 1];

            if (this.type === Syntax.Program) {
                if (this.body.length > 0) {
                    return;
                }
            }

            if (extra.trailingComments.length > 0) {
                if (extra.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = extra.trailingComments;
                    extra.trailingComments = [];
                } else {
                    extra.trailingComments.length = 0;
                }
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }

            // Eating the stack.
            if (last) {
                while (last && last.range[0] >= this.range[0]) {
                    lastChild = last;
                    last = bottomRight.pop();
                }
            }

            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {
                    this.leadingComments = lastChild.leadingComments;
                    lastChild.leadingComments = undefined;
                }
            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= this.range[0]) {
                this.leadingComments = extra.leadingComments;
                extra.leadingComments = [];
            }


            if (trailingComments) {
                this.trailingComments = trailingComments;
            }

            bottomRight.push(this);
        },

        finish: function () {
            if (extra.range) {
                this.range[1] = index;
            }
            if (extra.loc) {
                this.loc.end = new Position();
                if (extra.source) {
                    this.loc.source = extra.source;
                }
            }

            if (extra.attachComment) {
                this.processComment();
            }
        },

        finishArrayExpression: function (elements) {
            this.type = Syntax.ArrayExpression;
            this.elements = elements;
            this.finish();
            return this;
        },

        finishArrowFunctionExpression: function (params, defaults, body, expression) {
            this.type = Syntax.ArrowFunctionExpression;
            this.id = null;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishAssignmentExpression: function (operator, left, right) {
            this.type = Syntax.AssignmentExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBinaryExpression: function (operator, left, right) {
            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
            this.operator = operator;
            this.left = left;
            this.right = right;
            this.finish();
            return this;
        },

        finishBlockStatement: function (body) {
            this.type = Syntax.BlockStatement;
            this.body = body;
            this.finish();
            return this;
        },

        finishBreakStatement: function (label) {
            this.type = Syntax.BreakStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishCallExpression: function (callee, args) {
            this.type = Syntax.CallExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishCatchClause: function (param, body) {
            this.type = Syntax.CatchClause;
            this.param = param;
            this.body = body;
            this.finish();
            return this;
        },

        finishConditionalExpression: function (test, consequent, alternate) {
            this.type = Syntax.ConditionalExpression;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishContinueStatement: function (label) {
            this.type = Syntax.ContinueStatement;
            this.label = label;
            this.finish();
            return this;
        },

        finishDebuggerStatement: function () {
            this.type = Syntax.DebuggerStatement;
            this.finish();
            return this;
        },

        finishDoWhileStatement: function (body, test) {
            this.type = Syntax.DoWhileStatement;
            this.body = body;
            this.test = test;
            this.finish();
            return this;
        },

        finishEmptyStatement: function () {
            this.type = Syntax.EmptyStatement;
            this.finish();
            return this;
        },

        finishExpressionStatement: function (expression) {
            this.type = Syntax.ExpressionStatement;
            this.expression = expression;
            this.finish();
            return this;
        },

        finishForStatement: function (init, test, update, body) {
            this.type = Syntax.ForStatement;
            this.init = init;
            this.test = test;
            this.update = update;
            this.body = body;
            this.finish();
            return this;
        },

        finishForInStatement: function (left, right, body) {
            this.type = Syntax.ForInStatement;
            this.left = left;
            this.right = right;
            this.body = body;
            this.each = false;
            this.finish();
            return this;
        },

        finishFunctionDeclaration: function (id, params, defaults, body) {
            this.type = Syntax.FunctionDeclaration;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishFunctionExpression: function (id, params, defaults, body) {
            this.type = Syntax.FunctionExpression;
            this.id = id;
            this.params = params;
            this.defaults = defaults;
            this.body = body;
            this.rest = null;
            this.generator = false;
            this.expression = false;
            this.finish();
            return this;
        },

        finishIdentifier: function (name) {
            this.type = Syntax.Identifier;
            this.name = name;
            this.finish();
            return this;
        },

        finishIfStatement: function (test, consequent, alternate) {
            this.type = Syntax.IfStatement;
            this.test = test;
            this.consequent = consequent;
            this.alternate = alternate;
            this.finish();
            return this;
        },

        finishLabeledStatement: function (label, body) {
            this.type = Syntax.LabeledStatement;
            this.label = label;
            this.body = body;
            this.finish();
            return this;
        },

        finishLiteral: function (token) {
            this.type = Syntax.Literal;
            this.value = token.value;
            this.raw = source.slice(token.start, token.end);
            if (token.regex) {
                this.regex = token.regex;
            }
            this.finish();
            return this;
        },

        finishMemberExpression: function (accessor, object, property) {
            this.type = Syntax.MemberExpression;
            this.computed = accessor === '[';
            this.object = object;
            this.property = property;
            this.finish();
            return this;
        },

        finishNewExpression: function (callee, args) {
            this.type = Syntax.NewExpression;
            this.callee = callee;
            this.arguments = args;
            this.finish();
            return this;
        },

        finishObjectExpression: function (properties) {
            this.type = Syntax.ObjectExpression;
            this.properties = properties;
            this.finish();
            return this;
        },

        finishPostfixExpression: function (operator, argument) {
            this.type = Syntax.UpdateExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = false;
            this.finish();
            return this;
        },

        finishProgram: function (body) {
            this.type = Syntax.Program;
            this.body = body;
            this.finish();
            return this;
        },

        finishProperty: function (kind, key, value) {
            this.type = Syntax.Property;
            this.key = key;
            this.value = value;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishReturnStatement: function (argument) {
            this.type = Syntax.ReturnStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishSequenceExpression: function (expressions) {
            this.type = Syntax.SequenceExpression;
            this.expressions = expressions;
            this.finish();
            return this;
        },

        finishSwitchCase: function (test, consequent) {
            this.type = Syntax.SwitchCase;
            this.test = test;
            this.consequent = consequent;
            this.finish();
            return this;
        },

        finishSwitchStatement: function (discriminant, cases) {
            this.type = Syntax.SwitchStatement;
            this.discriminant = discriminant;
            this.cases = cases;
            this.finish();
            return this;
        },

        finishThisExpression: function () {
            this.type = Syntax.ThisExpression;
            this.finish();
            return this;
        },

        finishThrowStatement: function (argument) {
            this.type = Syntax.ThrowStatement;
            this.argument = argument;
            this.finish();
            return this;
        },

        finishTryStatement: function (block, guardedHandlers, handlers, finalizer) {
            this.type = Syntax.TryStatement;
            this.block = block;
            this.guardedHandlers = guardedHandlers;
            this.handlers = handlers;
            this.finalizer = finalizer;
            this.finish();
            return this;
        },

        finishUnaryExpression: function (operator, argument) {
            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
            this.operator = operator;
            this.argument = argument;
            this.prefix = true;
            this.finish();
            return this;
        },

        finishVariableDeclaration: function (declarations, kind) {
            this.type = Syntax.VariableDeclaration;
            this.declarations = declarations;
            this.kind = kind;
            this.finish();
            return this;
        },

        finishVariableDeclarator: function (id, init) {
            this.type = Syntax.VariableDeclarator;
            this.id = id;
            this.init = init;
            this.finish();
            return this;
        },

        finishWhileStatement: function (test, body) {
            this.type = Syntax.WhileStatement;
            this.test = test;
            this.body = body;
            this.finish();
            return this;
        },

        finishWithStatement: function (object, body) {
            this.type = Syntax.WithStatement;
            this.object = object;
            this.body = body;
            this.finish();
            return this;
        }
    };

    // Return true if there is a line terminator before the next token.

    function peekLineTerminator() {
        var pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        return found;
    }

    // Throw an exception

    function throwError(token, messageFormat) {
        var error,
            args = Array.prototype.slice.call(arguments, 2),
            msg = messageFormat.replace(
                /%(\d)/g,
                function (whole, index) {
                    assert(index < args.length, 'Message reference must be in range');
                    return args[index];
                }
            );

        if (typeof token.lineNumber === 'number') {
            error = new Error('Line ' + token.lineNumber + ': ' + msg);
            error.index = token.start;
            error.lineNumber = token.lineNumber;
            error.column = token.start - lineStart + 1;
        } else {
            error = new Error('Line ' + lineNumber + ': ' + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + 1;
        }

        error.description = msg;
        throw error;
    }

    function throwErrorTolerant() {
        try {
            throwError.apply(null, arguments);
        } catch (e) {
            if (extra.errors) {
                extra.errors.push(e);
            } else {
                throw e;
            }
        }
    }


    // Throw an exception because of the token.

    function throwUnexpected(token) {
        if (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        if (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        if (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        if (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        if (token.type === Token.Keyword) {
            if (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } else if (strict && isStrictModeReservedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictReservedWord);
                return;
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        // BooleanLiteral, NullLiteral, or Punctuator.
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    // Expect the next token to match the specified punctuator.
    // If not, an exception will be thrown.

    function expect(value) {
        var token = lex();
        if (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    /**
     * @name expectTolerant
     * @description Quietly expect the given token value when in tolerant mode, otherwise delegates
     * to <code>expect(value)</code>
     * @param {String} value The value we are expecting the lookahead token to have
     * @since 2.0
     */
    function expectTolerant(value) {
        if (extra.errors) {
            var token = lookahead;
            if (token.type !== Token.Punctuator && token.value !== value) {
                throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
            } else {
                lex();
            }
        } else {
            expect(value);
        }
    }

    // Expect the next token to match the specified keyword.
    // If not, an exception will be thrown.

    function expectKeyword(keyword) {
        var token = lex();
        if (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    // Return true if the next token matches the specified punctuator.

    function match(value) {
        return lookahead.type === Token.Punctuator && lookahead.value === value;
    }

    // Return true if the next token matches the specified keyword

    function matchKeyword(keyword) {
        return lookahead.type === Token.Keyword && lookahead.value === keyword;
    }

    // Return true if the next token is an assignment operator

    function matchAssign() {
        var op;

        if (lookahead.type !== Token.Punctuator) {
            return false;
        }
        op = lookahead.value;
        return op === '=' ||
            op === '*=' ||
            op === '/=' ||
            op === '%=' ||
            op === '+=' ||
            op === '-=' ||
            op === '<<=' ||
            op === '>>=' ||
            op === '>>>=' ||
            op === '&=' ||
            op === '^=' ||
            op === '|=';
    }

    function consumeSemicolon() {
        var line;

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B || match(';')) {
            lex();
            return;
        }

        line = lineNumber;
        skipComment();
        if (lineNumber !== line) {
            return;
        }

        if (lookahead.type !== Token.EOF && !match('}')) {
            throwUnexpected(lookahead);
        }
    }

    // Return true if provided expression is LeftHandSideExpression

    function isLeftHandSide(expr) {
        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
    }

    // 11.1.4 Array Initialiser

    function parseArrayInitialiser() {
        var elements = [], node = new Node();

        expect('[');

        while (!match(']')) {
            if (match(',')) {
                lex();
                elements.push(null);
            } else {
                elements.push(parseAssignmentExpression());

                if (!match(']')) {
                    expect(',');
                }
            }
        }

        lex();

        return node.finishArrayExpression(elements);
    }

    // 11.1.5 Object Initialiser

    function parsePropertyFunction(param, first) {
        var previousStrict, body, node = new Node();

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (first && strict && isRestrictedWord(param[0].name)) {
            throwErrorTolerant(first, Messages.StrictParamName);
        }
        strict = previousStrict;
        return node.finishFunctionExpression(null, param, [], body);
    }

    function parseObjectPropertyKey() {
        var token, node = new Node();

        token = lex();

        // Note: This function is called only from parseObjectProperty(), where
        // EOF and Punctuator tokens are already filtered out.

        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
            if (strict && token.octal) {
                throwErrorTolerant(token, Messages.StrictOctalLiteral);
            }
            return node.finishLiteral(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseObjectProperty() {
        var token, key, id, value, param, node = new Node();

        token = lookahead;

        if (token.type === Token.Identifier) {

            id = parseObjectPropertyKey();

            // Property Assignment: Getter and Setter.

            if (token.value === 'get' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                expect(')');
                value = parsePropertyFunction([]);
                return node.finishProperty('get', key, value);
            }
            if (token.value === 'set' && !match(':')) {
                key = parseObjectPropertyKey();
                expect('(');
                token = lookahead;
                if (token.type !== Token.Identifier) {
                    expect(')');
                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);
                    value = parsePropertyFunction([]);
                } else {
                    param = [ parseVariableIdentifier() ];
                    expect(')');
                    value = parsePropertyFunction(param, token);
                }
                return node.finishProperty('set', key, value);
            }
            expect(':');
            value = parseAssignmentExpression();
            return node.finishProperty('init', id, value);
        }
        if (token.type === Token.EOF || token.type === Token.Punctuator) {
            throwUnexpected(token);
        } else {
            key = parseObjectPropertyKey();
            expect(':');
            value = parseAssignmentExpression();
            return node.finishProperty('init', key, value);
        }
    }

    function parseObjectInitialiser() {
        var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();

        expect('{');

        while (!match('}')) {
            property = parseObjectProperty();

            if (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } else {
                name = toString(property.key.value);
            }
            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;

            key = '$' + name;
            if (Object.prototype.hasOwnProperty.call(map, key)) {
                if (map[key] === PropertyKind.Data) {
                    if (strict && kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                    } else if (kind !== PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    }
                } else {
                    if (kind === PropertyKind.Data) {
                        throwErrorTolerant({}, Messages.AccessorDataProperty);
                    } else if (map[key] & kind) {
                        throwErrorTolerant({}, Messages.AccessorGetSet);
                    }
                }
                map[key] |= kind;
            } else {
                map[key] = kind;
            }

            properties.push(property);

            if (!match('}')) {
                expectTolerant(',');
            }
        }

        expect('}');

        return node.finishObjectExpression(properties);
    }

    // 11.1.6 The Grouping Operator

    function parseGroupExpression() {
        var expr;

        expect('(');

        if (match(')')) {
            lex();
            return PlaceHolders.ArrowParameterPlaceHolder;
        }

        ++state.parenthesisCount;

        expr = parseExpression();

        expect(')');

        return expr;
    }


    // 11.1 Primary Expressions

    function parsePrimaryExpression() {
        var type, token, expr, node;

        if (match('(')) {
            return parseGroupExpression();
        }

        if (match('[')) {
            return parseArrayInitialiser();
        }

        if (match('{')) {
            return parseObjectInitialiser();
        }

        type = lookahead.type;
        node = new Node();

        if (type === Token.Identifier) {
            expr =  node.finishIdentifier(lex().value);
        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
            if (strict && lookahead.octal) {
                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
            }
            expr = node.finishLiteral(lex());
        } else if (type === Token.Keyword) {
            if (matchKeyword('function')) {
                return parseFunctionExpression();
            }
            if (matchKeyword('this')) {
                lex();
                expr = node.finishThisExpression();
            } else {
                throwUnexpected(lex());
            }
        } else if (type === Token.BooleanLiteral) {
            token = lex();
            token.value = (token.value === 'true');
            expr = node.finishLiteral(token);
        } else if (type === Token.NullLiteral) {
            token = lex();
            token.value = null;
            expr = node.finishLiteral(token);
        } else if (match('/') || match('/=')) {
            if (typeof extra.tokens !== 'undefined') {
                expr = node.finishLiteral(collectRegex());
            } else {
                expr = node.finishLiteral(scanRegExp());
            }
            peek();
        } else {
            throwUnexpected(lex());
        }

        return expr;
    }

    // 11.2 Left-Hand-Side Expressions

    function parseArguments() {
        var args = [];

        expect('(');

        if (!match(')')) {
            while (index < length) {
                args.push(parseAssignmentExpression());
                if (match(')')) {
                    break;
                }
                expectTolerant(',');
            }
        }

        expect(')');

        return args;
    }

    function parseNonComputedProperty() {
        var token, node = new Node();

        token = lex();

        if (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseNonComputedMember() {
        expect('.');

        return parseNonComputedProperty();
    }

    function parseComputedMember() {
        var expr;

        expect('[');

        expr = parseExpression();

        expect(']');

        return expr;
    }

    function parseNewExpression() {
        var callee, args, node = new Node();

        expectKeyword('new');
        callee = parseLeftHandSideExpression();
        args = match('(') ? parseArguments() : [];

        return node.finishNewExpression(callee, args);
    }

    function parseLeftHandSideExpressionAllowCall() {
        var expr, args, property, startToken, previousAllowIn = state.allowIn;

        startToken = lookahead;
        state.allowIn = true;
        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        for (;;) {
            if (match('.')) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else if (match('(')) {
                args = parseArguments();
                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
            } else if (match('[')) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else {
                break;
            }
        }
        state.allowIn = previousAllowIn;

        return expr;
    }

    function parseLeftHandSideExpression() {
        var expr, property, startToken;
        assert(state.allowIn, 'callee of new expression always allow in keyword.');

        startToken = lookahead;

        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();

        for (;;) {
            if (match('[')) {
                property = parseComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
            } else if (match('.')) {
                property = parseNonComputedMember();
                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
            } else {
                break;
            }
        }
        return expr;
    }

    // 11.3 Postfix Expressions

    function parsePostfixExpression() {
        var expr, token, startToken = lookahead;

        expr = parseLeftHandSideExpressionAllowCall();

        if (lookahead.type === Token.Punctuator) {
            if ((match('++') || match('--')) && !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPostfix);
                }

                if (!isLeftHandSide(expr)) {
                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
                }

                token = lex();
                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
            }
        }

        return expr;
    }

    // 11.4 Unary Operators

    function parseUnaryExpression() {
        var token, expr, startToken;

        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
            expr = parsePostfixExpression();
        } else if (match('++') || match('--')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            // 11.4.4, 11.4.5
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant({}, Messages.StrictLHSPrefix);
            }

            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (match('+') || match('-') || match('~') || match('!')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
            startToken = lookahead;
            token = lex();
            expr = parseUnaryExpression();
            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                throwErrorTolerant({}, Messages.StrictDelete);
            }
        } else {
            expr = parsePostfixExpression();
        }

        return expr;
    }

    function binaryPrecedence(token, allowIn) {
        var prec = 0;

        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
            return 0;
        }

        switch (token.value) {
        case '||':
            prec = 1;
            break;

        case '&&':
            prec = 2;
            break;

        case '|':
            prec = 3;
            break;

        case '^':
            prec = 4;
            break;

        case '&':
            prec = 5;
            break;

        case '==':
        case '!=':
        case '===':
        case '!==':
            prec = 6;
            break;

        case '<':
        case '>':
        case '<=':
        case '>=':
        case 'instanceof':
            prec = 7;
            break;

        case 'in':
            prec = allowIn ? 7 : 0;
            break;

        case '<<':
        case '>>':
        case '>>>':
            prec = 8;
            break;

        case '+':
        case '-':
            prec = 9;
            break;

        case '*':
        case '/':
        case '%':
            prec = 11;
            break;

        default:
            break;
        }

        return prec;
    }

    // 11.5 Multiplicative Operators
    // 11.6 Additive Operators
    // 11.7 Bitwise Shift Operators
    // 11.8 Relational Operators
    // 11.9 Equality Operators
    // 11.10 Binary Bitwise Operators
    // 11.11 Binary Logical Operators

    function parseBinaryExpression() {
        var marker, markers, expr, token, prec, stack, right, operator, left, i;

        marker = lookahead;
        left = parseUnaryExpression();
        if (left === PlaceHolders.ArrowParameterPlaceHolder) {
            return left;
        }

        token = lookahead;
        prec = binaryPrecedence(token, state.allowIn);
        if (prec === 0) {
            return left;
        }
        token.prec = prec;
        lex();

        markers = [marker, lookahead];
        right = parseUnaryExpression();

        stack = [left, token, right];

        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

            // Reduce: make a binary expression from the three topmost entries.
            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                right = stack.pop();
                operator = stack.pop().value;
                left = stack.pop();
                markers.pop();
                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
                stack.push(expr);
            }

            // Shift.
            token = lex();
            token.prec = prec;
            stack.push(token);
            markers.push(lookahead);
            expr = parseUnaryExpression();
            stack.push(expr);
        }

        // Final reduce to clean-up the stack.
        i = stack.length - 1;
        expr = stack[i];
        markers.pop();
        while (i > 1) {
            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
            i -= 2;
        }

        return expr;
    }


    // 11.12 Conditional Operator

    function parseConditionalExpression() {
        var expr, previousAllowIn, consequent, alternate, startToken;

        startToken = lookahead;

        expr = parseBinaryExpression();
        if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
            return expr;
        }
        if (match('?')) {
            lex();
            previousAllowIn = state.allowIn;
            state.allowIn = true;
            consequent = parseAssignmentExpression();
            state.allowIn = previousAllowIn;
            expect(':');
            alternate = parseAssignmentExpression();

            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
        }

        return expr;
    }

    // [ES6] 14.2 Arrow Function

    function parseConciseBody() {
        if (match('{')) {
            return parseFunctionSourceElements();
        }
        return parseAssignmentExpression();
    }

    function reinterpretAsCoverFormalsList(expressions) {
        var i, len, param, params, defaults, defaultCount, options, rest;

        params = [];
        defaults = [];
        defaultCount = 0;
        rest = null;
        options = {
            paramSet: {}
        };

        for (i = 0, len = expressions.length; i < len; i += 1) {
            param = expressions[i];
            if (param.type === Syntax.Identifier) {
                params.push(param);
                defaults.push(null);
                validateParam(options, param, param.name);
            } else if (param.type === Syntax.AssignmentExpression) {
                params.push(param.left);
                defaults.push(param.right);
                ++defaultCount;
                validateParam(options, param.left, param.left.name);
            } else {
                return null;
            }
        }

        if (options.message === Messages.StrictParamDupe) {
            throwError(
                strict ? options.stricted : options.firstRestricted,
                options.message
            );
        }

        if (defaultCount === 0) {
            defaults = [];
        }

        return {
            params: params,
            defaults: defaults,
            rest: rest,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseArrowFunctionExpression(options, node) {
        var previousStrict, body;

        expect('=>');
        previousStrict = strict;

        body = parseConciseBody();

        if (strict && options.firstRestricted) {
            throwError(options.firstRestricted, options.message);
        }
        if (strict && options.stricted) {
            throwErrorTolerant(options.stricted, options.message);
        }

        strict = previousStrict;

        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
    }

    // 11.13 Assignment Operators

    function parseAssignmentExpression() {
        var oldParenthesisCount, token, expr, right, list, startToken;

        oldParenthesisCount = state.parenthesisCount;

        startToken = lookahead;
        token = lookahead;

        expr = parseConditionalExpression();

        if (expr === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
            if (state.parenthesisCount === oldParenthesisCount ||
                    state.parenthesisCount === (oldParenthesisCount + 1)) {
                if (expr.type === Syntax.Identifier) {
                    list = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.AssignmentExpression) {
                    list = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.SequenceExpression) {
                    list = reinterpretAsCoverFormalsList(expr.expressions);
                } else if (expr === PlaceHolders.ArrowParameterPlaceHolder) {
                    list = reinterpretAsCoverFormalsList([]);
                }
                if (list) {
                    return parseArrowFunctionExpression(list, new WrappingNode(startToken));
                }
            }
        }

        if (matchAssign()) {
            // LeftHandSideExpression
            if (!isLeftHandSide(expr)) {
                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);
            }

            // 11.13.1
            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                throwErrorTolerant(token, Messages.StrictLHSAssignment);
            }

            token = lex();
            right = parseAssignmentExpression();
            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
        }

        return expr;
    }

    // 11.14 Comma Operator

    function parseExpression() {
        var expr, startToken = lookahead, expressions;

        expr = parseAssignmentExpression();

        if (match(',')) {
            expressions = [expr];

            while (index < length) {
                if (!match(',')) {
                    break;
                }
                lex();
                expressions.push(parseAssignmentExpression());
            }

            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
        }

        return expr;
    }

    // 12.1 Block

    function parseStatementList() {
        var list = [],
            statement;

        while (index < length) {
            if (match('}')) {
                break;
            }
            statement = parseSourceElement();
            if (typeof statement === 'undefined') {
                break;
            }
            list.push(statement);
        }

        return list;
    }

    function parseBlock() {
        var block, node = new Node();

        expect('{');

        block = parseStatementList();

        expect('}');

        return node.finishBlockStatement(block);
    }

    // 12.2 Variable Statement

    function parseVariableIdentifier() {
        var token, node = new Node();

        token = lex();

        if (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        return node.finishIdentifier(token.value);
    }

    function parseVariableDeclaration(kind) {
        var init = null, id, node = new Node();

        id = parseVariableIdentifier();

        // 12.2.1
        if (strict && isRestrictedWord(id.name)) {
            throwErrorTolerant({}, Messages.StrictVarName);
        }

        if (kind === 'const') {
            expect('=');
            init = parseAssignmentExpression();
        } else if (match('=')) {
            lex();
            init = parseAssignmentExpression();
        }

        return node.finishVariableDeclarator(id, init);
    }

    function parseVariableDeclarationList(kind) {
        var list = [];

        do {
            list.push(parseVariableDeclaration(kind));
            if (!match(',')) {
                break;
            }
            lex();
        } while (index < length);

        return list;
    }

    function parseVariableStatement(node) {
        var declarations;

        expectKeyword('var');

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations, 'var');
    }

    // kind may be `const` or `let`
    // Both are experimental and not in the specification yet.
    // see http://wiki.ecmascript.org/doku.php?id=harmony:const
    // and http://wiki.ecmascript.org/doku.php?id=harmony:let
    function parseConstLetDeclaration(kind) {
        var declarations, node = new Node();

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        return node.finishVariableDeclaration(declarations, kind);
    }

    // 12.3 Empty Statement

    function parseEmptyStatement() {
        var node = new Node();
        expect(';');
        return node.finishEmptyStatement();
    }

    // 12.4 Expression Statement

    function parseExpressionStatement(node) {
        var expr = parseExpression();
        consumeSemicolon();
        return node.finishExpressionStatement(expr);
    }

    // 12.5 If statement

    function parseIfStatement(node) {
        var test, consequent, alternate;

        expectKeyword('if');

        expect('(');

        test = parseExpression();

        expect(')');

        consequent = parseStatement();

        if (matchKeyword('else')) {
            lex();
            alternate = parseStatement();
        } else {
            alternate = null;
        }

        return node.finishIfStatement(test, consequent, alternate);
    }

    // 12.6 Iteration Statements

    function parseDoWhileStatement(node) {
        var body, test, oldInIteration;

        expectKeyword('do');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        if (match(';')) {
            lex();
        }

        return node.finishDoWhileStatement(body, test);
    }

    function parseWhileStatement(node) {
        var test, body, oldInIteration;

        expectKeyword('while');

        expect('(');

        test = parseExpression();

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return node.finishWhileStatement(test, body);
    }

    function parseForVariableDeclaration() {
        var token, declarations, node = new Node();

        token = lex();
        declarations = parseVariableDeclarationList();

        return node.finishVariableDeclaration(declarations, token.value);
    }

    function parseForStatement(node) {
        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;

        init = test = update = null;

        expectKeyword('for');

        expect('(');

        if (match(';')) {
            lex();
        } else {
            if (matchKeyword('var') || matchKeyword('let')) {
                state.allowIn = false;
                init = parseForVariableDeclaration();
                state.allowIn = previousAllowIn;

                if (init.declarations.length === 1 && matchKeyword('in')) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            } else {
                state.allowIn = false;
                init = parseExpression();
                state.allowIn = previousAllowIn;

                if (matchKeyword('in')) {
                    // LeftHandSideExpression
                    if (!isLeftHandSide(init)) {
                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);
                    }

                    lex();
                    left = init;
                    right = parseExpression();
                    init = null;
                }
            }

            if (typeof left === 'undefined') {
                expect(';');
            }
        }

        if (typeof left === 'undefined') {

            if (!match(';')) {
                test = parseExpression();
            }
            expect(';');

            if (!match(')')) {
                update = parseExpression();
            }
        }

        expect(')');

        oldInIteration = state.inIteration;
        state.inIteration = true;

        body = parseStatement();

        state.inIteration = oldInIteration;

        return (typeof left === 'undefined') ?
                node.finishForStatement(init, test, update, body) :
                node.finishForInStatement(left, right, body);
    }

    // 12.7 The continue statement

    function parseContinueStatement(node) {
        var label = null, key;

        expectKeyword('continue');

        // Optimize the most common form: 'continue;'.
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (peekLineTerminator()) {
            if (!state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            return node.finishContinueStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !state.inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        return node.finishContinueStatement(label);
    }

    // 12.8 The break statement

    function parseBreakStatement(node) {
        var label = null, key;

        expectKeyword('break');

        // Catch the very common case first: immediately a semicolon (U+003B).
        if (source.charCodeAt(index) === 0x3B) {
            lex();

            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (peekLineTerminator()) {
            if (!(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            return node.finishBreakStatement(null);
        }

        if (lookahead.type === Token.Identifier) {
            label = parseVariableIdentifier();

            key = '$' + label.name;
            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        if (label === null && !(state.inIteration || state.inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        return node.finishBreakStatement(label);
    }

    // 12.9 The return statement

    function parseReturnStatement(node) {
        var argument = null;

        expectKeyword('return');

        if (!state.inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        // 'return' followed by a space and an identifier is very common.
        if (source.charCodeAt(index) === 0x20) {
            if (isIdentifierStart(source.charCodeAt(index + 1))) {
                argument = parseExpression();
                consumeSemicolon();
                return node.finishReturnStatement(argument);
            }
        }

        if (peekLineTerminator()) {
            return node.finishReturnStatement(null);
        }

        if (!match(';')) {
            if (!match('}') && lookahead.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        return node.finishReturnStatement(argument);
    }

    // 12.10 The with statement

    function parseWithStatement(node) {
        var object, body;

        if (strict) {
            // TODO(ikarienator): Should we update the test cases instead?
            skipComment();
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword('with');

        expect('(');

        object = parseExpression();

        expect(')');

        body = parseStatement();

        return node.finishWithStatement(object, body);
    }

    // 12.10 The swith statement

    function parseSwitchCase() {
        var test, consequent = [], statement, node = new Node();

        if (matchKeyword('default')) {
            lex();
            test = null;
        } else {
            expectKeyword('case');
            test = parseExpression();
        }
        expect(':');

        while (index < length) {
            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                break;
            }
            statement = parseStatement();
            consequent.push(statement);
        }

        return node.finishSwitchCase(test, consequent);
    }

    function parseSwitchStatement(node) {
        var discriminant, cases, clause, oldInSwitch, defaultFound;

        expectKeyword('switch');

        expect('(');

        discriminant = parseExpression();

        expect(')');

        expect('{');

        cases = [];

        if (match('}')) {
            lex();
            return node.finishSwitchStatement(discriminant, cases);
        }

        oldInSwitch = state.inSwitch;
        state.inSwitch = true;
        defaultFound = false;

        while (index < length) {
            if (match('}')) {
                break;
            }
            clause = parseSwitchCase();
            if (clause.test === null) {
                if (defaultFound) {
                    throwError({}, Messages.MultipleDefaultsInSwitch);
                }
                defaultFound = true;
            }
            cases.push(clause);
        }

        state.inSwitch = oldInSwitch;

        expect('}');

        return node.finishSwitchStatement(discriminant, cases);
    }

    // 12.13 The throw statement

    function parseThrowStatement(node) {
        var argument;

        expectKeyword('throw');

        if (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        return node.finishThrowStatement(argument);
    }

    // 12.14 The try statement

    function parseCatchClause() {
        var param, body, node = new Node();

        expectKeyword('catch');

        expect('(');
        if (match(')')) {
            throwUnexpected(lookahead);
        }

        param = parseVariableIdentifier();
        // 12.14.1
        if (strict && isRestrictedWord(param.name)) {
            throwErrorTolerant({}, Messages.StrictCatchVariable);
        }

        expect(')');
        body = parseBlock();
        return node.finishCatchClause(param, body);
    }

    function parseTryStatement(node) {
        var block, handlers = [], finalizer = null;

        expectKeyword('try');

        block = parseBlock();

        if (matchKeyword('catch')) {
            handlers.push(parseCatchClause());
        }

        if (matchKeyword('finally')) {
            lex();
            finalizer = parseBlock();
        }

        if (handlers.length === 0 && !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        return node.finishTryStatement(block, [], handlers, finalizer);
    }

    // 12.15 The debugger statement

    function parseDebuggerStatement(node) {
        expectKeyword('debugger');

        consumeSemicolon();

        return node.finishDebuggerStatement();
    }

    // 12 Statements

    function parseStatement() {
        var type = lookahead.type,
            expr,
            labeledBody,
            key,
            node;

        if (type === Token.EOF) {
            throwUnexpected(lookahead);
        }

        if (type === Token.Punctuator && lookahead.value === '{') {
            return parseBlock();
        }

        node = new Node();

        if (type === Token.Punctuator) {
            switch (lookahead.value) {
            case ';':
                return parseEmptyStatement(node);
            case '(':
                return parseExpressionStatement(node);
            default:
                break;
            }
        } else if (type === Token.Keyword) {
            switch (lookahead.value) {
            case 'break':
                return parseBreakStatement(node);
            case 'continue':
                return parseContinueStatement(node);
            case 'debugger':
                return parseDebuggerStatement(node);
            case 'do':
                return parseDoWhileStatement(node);
            case 'for':
                return parseForStatement(node);
            case 'function':
                return parseFunctionDeclaration(node);
            case 'if':
                return parseIfStatement(node);
            case 'return':
                return parseReturnStatement(node);
            case 'switch':
                return parseSwitchStatement(node);
            case 'throw':
                return parseThrowStatement(node);
            case 'try':
                return parseTryStatement(node);
            case 'var':
                return parseVariableStatement(node);
            case 'while':
                return parseWhileStatement(node);
            case 'with':
                return parseWithStatement(node);
            default:
                break;
            }
        }

        expr = parseExpression();

        // 12.12 Labelled Statements
        if ((expr.type === Syntax.Identifier) && match(':')) {
            lex();

            key = '$' + expr.name;
            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
                throwError({}, Messages.Redeclaration, 'Label', expr.name);
            }

            state.labelSet[key] = true;
            labeledBody = parseStatement();
            delete state.labelSet[key];
            return node.finishLabeledStatement(expr, labeledBody);
        }

        consumeSemicolon();

        return node.finishExpressionStatement(expr);
    }

    // 13 Function Definition

    function parseFunctionSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted,
            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
            node = new Node();

        expect('{');

        while (index < length) {
            if (lookahead.type !== Token.StringLiteral) {
                break;
            }
            token = lookahead;

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = state.labelSet;
        oldInIteration = state.inIteration;
        oldInSwitch = state.inSwitch;
        oldInFunctionBody = state.inFunctionBody;
        oldParenthesisCount = state.parenthesizedCount;

        state.labelSet = {};
        state.inIteration = false;
        state.inSwitch = false;
        state.inFunctionBody = true;
        state.parenthesizedCount = 0;

        while (index < length) {
            if (match('}')) {
                break;
            }
            sourceElement = parseSourceElement();
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }

        expect('}');

        state.labelSet = oldLabelSet;
        state.inIteration = oldInIteration;
        state.inSwitch = oldInSwitch;
        state.inFunctionBody = oldInFunctionBody;
        state.parenthesizedCount = oldParenthesisCount;

        return node.finishBlockStatement(sourceElements);
    }

    function validateParam(options, param, name) {
        var key = '$' + name;
        if (strict) {
            if (isRestrictedWord(name)) {
                options.stricted = param;
                options.message = Messages.StrictParamName;
            }
            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.stricted = param;
                options.message = Messages.StrictParamDupe;
            }
        } else if (!options.firstRestricted) {
            if (isRestrictedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamName;
            } else if (isStrictModeReservedWord(name)) {
                options.firstRestricted = param;
                options.message = Messages.StrictReservedWord;
            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                options.firstRestricted = param;
                options.message = Messages.StrictParamDupe;
            }
        }
        options.paramSet[key] = true;
    }

    function parseParam(options) {
        var token, param, def;

        token = lookahead;
        param = parseVariableIdentifier();
        validateParam(options, token, token.value);
        if (match('=')) {
            lex();
            def = parseAssignmentExpression();
            ++options.defaultCount;
        }

        options.params.push(param);
        options.defaults.push(def);

        return !match(')');
    }

    function parseParams(firstRestricted) {
        var options;

        options = {
            params: [],
            defaultCount: 0,
            defaults: [],
            firstRestricted: firstRestricted
        };

        expect('(');

        if (!match(')')) {
            options.paramSet = {};
            while (index < length) {
                if (!parseParam(options)) {
                    break;
                }
                expect(',');
            }
        }

        expect(')');

        if (options.defaultCount === 0) {
            options.defaults = [];
        }

        return {
            params: options.params,
            defaults: options.defaults,
            stricted: options.stricted,
            firstRestricted: options.firstRestricted,
            message: options.message
        };
    }

    function parseFunctionDeclaration() {
        var id, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, node = new Node();

        expectKeyword('function');
        token = lookahead;
        id = parseVariableIdentifier();
        if (strict) {
            if (isRestrictedWord(token.value)) {
                throwErrorTolerant(token, Messages.StrictFunctionName);
            }
        } else {
            if (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } else if (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionDeclaration(id, params, defaults, body);
    }

    function parseFunctionExpression() {
        var token, id = null, stricted, firstRestricted, message, tmp,
            params = [], defaults = [], body, previousStrict, node = new Node();

        expectKeyword('function');

        if (!match('(')) {
            token = lookahead;
            id = parseVariableIdentifier();
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        tmp = parseParams(firstRestricted);
        params = tmp.params;
        defaults = tmp.defaults;
        stricted = tmp.stricted;
        firstRestricted = tmp.firstRestricted;
        if (tmp.message) {
            message = tmp.message;
        }

        previousStrict = strict;
        body = parseFunctionSourceElements();
        if (strict && firstRestricted) {
            throwError(firstRestricted, message);
        }
        if (strict && stricted) {
            throwErrorTolerant(stricted, message);
        }
        strict = previousStrict;

        return node.finishFunctionExpression(id, params, defaults, body);
    }

    // 14 Program

    function parseSourceElement() {
        if (lookahead.type === Token.Keyword) {
            switch (lookahead.value) {
            case 'const':
            case 'let':
                return parseConstLetDeclaration(lookahead.value);
            case 'function':
                return parseFunctionDeclaration();
            default:
                return parseStatement();
            }
        }

        if (lookahead.type !== Token.EOF) {
            return parseStatement();
        }
    }

    function parseSourceElements() {
        var sourceElement, sourceElements = [], token, directive, firstRestricted;

        while (index < length) {
            token = lookahead;
            if (token.type !== Token.StringLiteral) {
                break;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            if (sourceElement.expression.type !== Syntax.Literal) {
                // this is not directive
                break;
            }
            directive = source.slice(token.start + 1, token.end - 1);
            if (directive === 'use strict') {
                strict = true;
                if (firstRestricted) {
                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                }
            } else {
                if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                }
            }
        }

        while (index < length) {
            sourceElement = parseSourceElement();
            /* istanbul ignore if */
            if (typeof sourceElement === 'undefined') {
                break;
            }
            sourceElements.push(sourceElement);
        }
        return sourceElements;
    }

    function parseProgram() {
        var body, node;

        skipComment();
        peek();
        node = new Node();
        strict = false;

        body = parseSourceElements();
        return node.finishProgram(body);
    }

    function filterTokenLocation() {
        var i, entry, token, tokens = [];

        for (i = 0; i < extra.tokens.length; ++i) {
            entry = extra.tokens[i];
            token = {
                type: entry.type,
                value: entry.value
            };
            if (entry.regex) {
                token.regex = {
                    pattern: entry.regex.pattern,
                    flags: entry.regex.flags
                };
            }
            if (extra.range) {
                token.range = entry.range;
            }
            if (extra.loc) {
                token.loc = entry.loc;
            }
            tokens.push(token);
        }

        extra.tokens = tokens;
    }

    function tokenize(code, options) {
        var toString,
            tokens;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};

        // Options matching.
        options = options || {};

        // Of course we collect tokens here.
        options.tokens = true;
        extra.tokens = [];
        extra.tokenize = true;
        // The following two fields are necessary to compute the Regex tokens.
        extra.openParenToken = -1;
        extra.openCurlyToken = -1;

        extra.range = (typeof options.range === 'boolean') && options.range;
        extra.loc = (typeof options.loc === 'boolean') && options.loc;

        if (typeof options.comment === 'boolean' && options.comment) {
            extra.comments = [];
        }
        if (typeof options.tolerant === 'boolean' && options.tolerant) {
            extra.errors = [];
        }

        try {
            peek();
            if (lookahead.type === Token.EOF) {
                return extra.tokens;
            }

            lex();
            while (lookahead.type !== Token.EOF) {
                try {
                    lex();
                } catch (lexError) {
                    if (extra.errors) {
                        extra.errors.push(lexError);
                        // We have to break on the first error
                        // to avoid infinite loops.
                        break;
                    } else {
                        throw lexError;
                    }
                }
            }

            filterTokenLocation();
            tokens = extra.tokens;
            if (typeof extra.comments !== 'undefined') {
                tokens.comments = extra.comments;
            }
            if (typeof extra.errors !== 'undefined') {
                tokens.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }
        return tokens;
    }

    function parse(code, options) {
        var program, toString;

        toString = String;
        if (typeof code !== 'string' && !(code instanceof String)) {
            code = toString(code);
        }

        source = code;
        index = 0;
        lineNumber = (source.length > 0) ? 1 : 0;
        lineStart = 0;
        length = source.length;
        lookahead = null;
        state = {
            allowIn: true,
            labelSet: {},
            parenthesisCount: 0,
            inFunctionBody: false,
            inIteration: false,
            inSwitch: false,
            lastCommentStart: -1
        };

        extra = {};
        if (typeof options !== 'undefined') {
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

            if (extra.loc && options.source !== null && options.source !== undefined) {
                extra.source = toString(options.source);
            }

            if (typeof options.tokens === 'boolean' && options.tokens) {
                extra.tokens = [];
            }
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
            if (extra.attachComment) {
                extra.range = true;
                extra.comments = [];
                extra.bottomRightStack = [];
                extra.trailingComments = [];
                extra.leadingComments = [];
            }
        }

        try {
            program = parseProgram();
            if (typeof extra.comments !== 'undefined') {
                program.comments = extra.comments;
            }
            if (typeof extra.tokens !== 'undefined') {
                filterTokenLocation();
                program.tokens = extra.tokens;
            }
            if (typeof extra.errors !== 'undefined') {
                program.errors = extra.errors;
            }
        } catch (e) {
            throw e;
        } finally {
            extra = {};
        }

        return program;
    }

    // Sync with *.json manifests.
    exports.version = '2.0.0-dev';

    exports.tokenize = tokenize;

    exports.parse = parse;

    // Deep copy.
   /* istanbul ignore next */
    exports.Syntax = (function () {
        var name, types = {};

        if (typeof Object.create === 'function') {
            types = Object.create(null);
        }

        for (name in Syntax) {
            if (Syntax.hasOwnProperty(name)) {
                types[name] = Syntax[name];
            }
        }

        if (typeof Object.freeze === 'function') {
            Object.freeze(types);
        }

        return types;
    }());

}));
/* vim: set sw=4 ts=4 et tw=80 : */
;
/*
  unwrapComment and dependencies from doctrine and esutils

  https://github.com/Constellation/doctrine
  https://github.com/estools/esutils/blob/master/lib/code.js

  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
define('VeroldEngine/libs/unwrap_comment',[], function() {
  var Regex, NON_ASCII_WHITESPACES;

  // See `tools/generate-identifier-regex.js`.
  Regex = {
    NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
    NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
  };

  // 7.2 White Space

  NON_ASCII_WHITESPACES = [
    0x1680, 0x180E,
    0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
    0x202F, 0x205F,
    0x3000,
    0xFEFF
  ];

  function isWhiteSpace(ch) {
    return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
        (ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0);
  }

  // 7.3 Line Terminators

  function isLineTerminator(ch) {
    return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
  }

  function unwrapComment(doc) {
    // JSDoc comment is following form
    //   /**
    //    * .......
    //    */
    // remove /**, */ and *
    var BEFORE_STAR = 0,
        STAR = 1,
        AFTER_STAR = 2,
        index,
        len,
        mode,
        result,
        ch;

    doc = doc.replace(/^\/\*\*?/, '').replace(/\*\/$/, '');
    index = 0;
    len = doc.length;
    mode = BEFORE_STAR;
    result = '';

    while (index < len) {
      ch = doc.charCodeAt(index);
      switch (mode) {
      case BEFORE_STAR:
        if (isLineTerminator(ch)) {
          result += String.fromCharCode(ch);
        } else if (ch === 0x2A  /* '*' */) {
          mode = STAR;
        } else if (!isWhiteSpace(ch)) {
          result += String.fromCharCode(ch);
          mode = AFTER_STAR;
        }
        break;

      case STAR:
        if (!isWhiteSpace(ch)) {
          result += String.fromCharCode(ch);
        }
        mode = isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
        break;

      case AFTER_STAR:
        result += String.fromCharCode(ch);
        if (isLineTerminator(ch)) {
          mode = BEFORE_STAR;
        }
        break;
      }
      index += 1;
    }

    return result;
  }

  return unwrapComment;
});

define('VeroldEngine/Util/APIUtilities',[ 'underscore', 'async' ], function(_, async) {
  var VAPI = window.VAPI = window.VAPI || {};
  var define = window.define;

  var extensions = {};
  var nLoading = 0;

  VAPI.loadExtensions = function(paths, fn) {
    if (!_.isArray(paths) || !_.size(paths)) {
      return fn();
    }

    async.forEach(paths, VAPI.loadExtension, fn);
  };

  VAPI.loadExtension = function(path, fn) {
    var script;

    if (extensions[path] && extensions[path].state === 'loaded') {
      return fn();
    } else if (extensions[path] && extensions[path].state !== 'loaded') {
      script = extensions[path].script;

      if (typeof fn === 'function') {
        script.addEventListener('load', function() {
          setTimeout(fn, 0);
        });
      }
    } else {
      // backup define
      window.define = undefined;
      var body= document.getElementsByTagName('body')[0];
      script =  document.createElement('script');
      script.type= 'text/javascript';
      script.src= path;
      script.async = false;
      body.appendChild(script);
      extensions[path] = {
        script: script,
        state: 'loading'
      };

      nLoading ++;

      script.addEventListener('load', function() {
        extensions[path].state = 'loaded';
        nLoading--;
        if (nLoading === 0) {
          window.define = define;
        }
        if (typeof fn === 'function') {
          fn();
        }
      });
    }
  };

  return VAPI;
});

/* jshint -W061 */
define('VeroldEngine/AssetRegistry/ScriptAsset',[ 'backbone' 
       , 'underscore'
       , 'three'
       , 'json5'
       , 'VeroldEngine/libs/esprima/esprima'
       , 'VeroldEngine/libs/unwrap_comment'
       , 'VeroldEngine/AssetRegistry/VeroldAsset'
       , 'VeroldEngine/Util/APIUtilities'
  ],
  function(Backbone, _, THREE, JSON5, esprima, unwrapComment, VeroldAsset, VAPI ) {
    function getType(type) {
      switch (type.toLowerCase()) {
        case 'v4':
        case 'vector4':
          return 'v4';

        case 'v3':
        case 'vector3':
          return 'v3';

        case 'v2':
        case 'vector2':
          return 'v2';

        case 'f':
        case 'float':
          return 'f';

        case 'i':
        case 'int':
        case 'integer':
          return 'i';

        case 'b':
        case 'bool':
        case 'boolean':
          return 'b';

        case 's':
        case 'string':
          return 's';

        case 'dd':
        case 'dropdown':
          return 'dd';

        case 'c':
        case 'color':
          return 'c';

        case 'a':
        case 'array':
          return 'a';

        case 'custom':
          return 'custom';

        case 'json':
          return 'json';

        default:
          return type;
      }
    }

    function grabToken(arr) {
      var token;
      if (arr && arr.length) {
        // skip @vname
        while (arr.length && !(token = arr.shift())) {}
      }
      return token;
    }

    function parseVName(comment) {
      var name,
          parts = comment.split(/[\n\s]/);

      grabToken(parts);

      name = parts.join(' ').trim();

      return name;
    }

    function parseVDescription(comment) {
      var description,
          parts = comment.split(/[\n\s]/);

      grabToken(parts);

      description = parts.join(' ').trim();

      return description;
    }

    function parseVInclude(comment) {
      var url, 
          parts = comment.split(/[\n\s]/);

      grabToken(parts);

      url = parts.join(' ').trim();

      return url;
    }

    function recursiveBuildAttribute(vattr, knownTypes) {
      var customType = knownTypes[vattr.type];

      if (customType) {
        vattr.attributes = _.extend({}, knownTypes[vattr.type].attributes);
        vattr.type = 'custom';
      } else {
        vattr.type = getType(vattr.type);
      }

      // for arrays
      if (vattr.subType) {
        recursiveBuildAttribute(vattr.subType, knownTypes);
      }

      // for custom objects
      if (vattr.attributes) {
        _.each(vattr.attributes, function(attr) {
          recursiveBuildAttribute(attr, knownTypes);
        });
      }
    }

    var arrayRegex = /\[\s*\]$/;

    function parseVAttr(comment, knownTypes) {
      var vattr = {},
          parts = comment.split(/[\n\s]/),
          json,
          type,
          testForArray;

      grabToken(parts);

      type = grabToken(parts);

      testForArray = type.match(arrayRegex);
      
      vattr.name = grabToken(parts);

      if (testForArray) {
        type = type.substr(0, testForArray.index).trim();
        vattr.type = 'a';
        vattr.subType = {
          type: getType(type)
        };
      } else {
        vattr.type = getType(type);
      }

      json = parts.join(' ').trim();
      if (json.length) {
        vattr = _.extend(vattr, JSON5.parse(json));
      }

      recursiveBuildAttribute(vattr, knownTypes);  

      return vattr;
    }

    function parseVType(comment, knownTypes) {
      var vtype = {},
          parts = comment.split(/[\n\s]/),
          json;

      grabToken(parts);

      vtype.name = grabToken(parts);
      vtype.type = 'custom';

      json = parts.join(' ').trim();
      if (json.length) {
        vtype = _.extend(vtype, JSON5.parse(json));
      }

      return vtype;      
    }

    function parseVEvent(comment) {
      var vevent = {}, 
          parts = comment.split(/[\n\s]/),
          json;

      grabToken(parts);

      vevent.scope = grabToken(parts);
      vevent.name = grabToken(parts);

      json = parts.join(' ').trim();

      if (json.length) {
        vevent = _.extend(vevent, JSON5.parse(json));
      }

      return vevent;
    }

    function parseVFilter(comment) {
      var parts = comment.split(/[\n\s]/);

      grabToken(parts);

      return grabToken(parts).split('|');
    }

    function parseVCategory(comment) {
      var parts = comment.split(/[\n\s]/);

      grabToken(parts);

      return grabToken(parts).trim();
    }

    var ScriptAsset = function( properties ) {
      VeroldAsset.call( this );

      this.scriptData = {
        description: null,
        klass: null
      };
    };

    ScriptAsset.prototype = new VeroldAsset();

    ScriptAsset.prototype.initialize = function( properties ) {
      VeroldAsset.prototype.initialize.call( this, properties);
      this.processComments(this.getProperty('script'));
      this.entityModel.on('change:payload.script', this.scriptChanged, this);
      this.entityModel.on('change:payload.attributes', this.attributesChanged, this);
      var payload = this.entityModel.get("payload");
      if ( !payload.category ) {
        payload.category = "User Defined";
      }
    };

    ScriptAsset.prototype.uninitialize = function() {
      this.entityModel.off('change:payload.script', this.scriptChanged, this);
      VeroldAsset.prototype.uninitialize.apply( this, arguments );
    };

    ScriptAsset.prototype.initializeComponents = function() {
      return;
    };

    ScriptAsset.prototype.update = function() {
    };

    ScriptAsset.prototype.getDefaultComponentData = function() {
      return ScriptAsset.getDefaultComponentData(this.entityModel.get('payload.attributes'));
    };

    ScriptAsset.prototype.isRunnable = function() {
      if (this.veroldEngine.componentSettings.enabled && (
          (this.entityModel.isPersistent && this.veroldEngine.componentSettings.persistent) ||
          (!this.entityModel.isPersistent && this.veroldEngine.componentSettings.nonPersistent)
        )
      ) {
        return true;
      }

      return false;
    };

    ScriptAsset.prototype.load_base = function( options ) {
      // VeroldAsset.prototype.load_base.call( this, options );

      if (this.isRunnable() && this.state_base !== "loaded" ) {
        var externalDependencies = [];

        _.each(this.entityModel.get('payload.externalDependencies'), function(dependency) {
          externalDependencies.push(dependency);
        }, this);

        VAPI.loadExtensions(externalDependencies, _.bind(function() {
          this.createScriptData(_.bind(function() {
            this.trigger("load_progress", this);
            this.trigger("load_base", this);
            this.trigger("load", this);
          }, this));
        }, this));
      } else if ( this.state_base === "loaded") {
        this.trigger("load_progress", this);
        this.trigger("load_base", this);
        this.trigger("load", this);
      }
    };

    ScriptAsset.prototype.createScriptData = function(fn) {
      if (this.entityModel.get('payload.scriptUrl')) {
        this.createScriptFromUrl(fn);
      } else if (this.entityModel.get('payload.script')) {
        this.createScript(fn);
      } else {
        this.createScriptFromMinified(fn);
      }
    };

    ScriptAsset.prototype.processComments = function(script) {
      try {
        var ast = esprima.parse(script, { attachComment: true, tolerant: true }),
            processedComments = 0,
            name, 
            description, 
            category,
            attributes = {}, 
            attributesOrder = [], 
            externalDependencies = [],
            knownTypes = {},
            events = {},
            filter = [];

        var parseComment = function(comment) {
          var unwrapped = unwrapComment(comment.value).trim(),
              blocks,
              value;

          blocks = unwrapped.split(/^\@v|\n\s*\@v/g);

          blocks.shift();

          blocks.forEach(function(block) {
            if (block.indexOf('name') === 0) {
              if ((value = parseVName(block))) {
                name = value;
                processedComments ++;
              }
            } else if (block.indexOf('description') === 0) {
              if ((value = parseVDescription(block))) {
                description = value;
                processedComments ++;
              }
            } else if (block.indexOf('include') === 0) {
              if ((value = parseVInclude(block))) {
                externalDependencies.push(value);
                processedComments ++;
              }
            } else if (block.indexOf('type') === 0) {
              if ((value = parseVType(block, knownTypes))) {
                knownTypes[value.name] = value;
                processedComments ++;
              }           
            } else if (block.indexOf('attr') === 0 || block.indexOf('attribute') === 0) {
              if ((value = parseVAttr(block, knownTypes))) {
                attributes[value.name] = value;
                attributesOrder.push(value.name);
                processedComments ++;
              }
            } else if (block.indexOf('event') === 0) {
              if ((value = parseVEvent(block))) {
                events[value.name] = value; 
                processedComments ++;
              }
            } else if (block.indexOf('filter') === 0) {
              if((value = parseVFilter(block))) {
                value.forEach(function(type) {
                  filter.push(type.trim());
                });
                processedComments ++;
              }  
            } else if (block.indexOf('category') === 0) {
              if((value = parseVCategory(block))) {
                category = value;
                processedComments ++;
              }
            } 
          });
        };

        ast.comments.forEach(parseComment);

        this.scriptData.invalid = false;

        var recursiveUndefined = function(original, current) {
          _.each(original, function(value, key) {
            if (!current[key]) {
              original[key] = undefined;
            } else if (_.isObject(original[key])) {
              recursiveUndefined(original[key], current[key]);
            }
          });
        };

        if (processedComments > 0) {
          var originalAttributes = this.entityModel.get('payload.attributes'),
              originalEvents = this.entityModel.get('payload.events');

          recursiveUndefined(originalAttributes, attributes);
          recursiveUndefined(originalEvents, events);

          this.entityModel.set({
            name: name || this.entityModel.get('name'),
            payload: {
              description: description || this.getProperty('description'),
              attributes: attributes,
              attributesOrder: attributesOrder,
              events: events,
              externalDependencies: externalDependencies,
              filter: filter.length ? _.uniq(filter) : undefined,
              category: category || "User Defined",
              parsedComments: true
            }
          }, { processComments: true });

        } else {
          this.entityModel.set({
            name: name || this.entityModel.get('name'),
            payload: {
              parsedComments: false
            }
          }, { processComments: true });
        }
      } catch(e) {
        this.scriptData.invalid = true;
        console.error('Failed to process comments for ' + this.entityModel.get('name') + " with error: " + e);
      }
    };
    
    ScriptAsset.prototype.createScript = function(fn) {
      var scriptName = encodeURIComponent(this.entityModel.get('name')),
          script = this.entityModel.get('payload.script');

      if (!scriptName.match(/\.js$/i)) {
        scriptName += '.js';
      }

      this.processComments(script);

      if (this.scriptData.invalid) {
        return console.error('Invalid script data, not executing!');
      }
      
      //try {
        this.scriptData.klass = eval('(function(require, _, VAPI, THREE, console, Math) {\n' +
          (script || '') +
          '});\n' +
          '\/\/# sourceURL=' + this.veroldEngine.paths.apiBaseUrl + '/entities/' + this.id + '/script/' + scriptName + '\n')
          (require, _, window.VAPI, THREE, window.console, window.Math);
          
        fn();
      // } catch(e) {
      //   console.error('Failed to create component class for ' + this.entityModel.get('name') + " with error: " + e );
      // }
    };

    ScriptAsset.prototype.createScriptFromUrl = function(fn) {
      var scriptUrl = this.entityModel.get('payload.scriptUrl');
      console.warn('createScriptFromUrl');
      Backbone.$.ajax({
        url: scriptUrl,
        method: 'POST',
        dataType: 'html'
      }).
      done(_.bind(function(script) {
        try {
          this.scriptData.klass = eval('(function(require, _, VAPI, THREE, console, Math) {\n' +
            (script || '') +
            '});\n' +
            '\/\/# sourceURL=' + scriptUrl + '\n')
            (require, _, window.VAPI, THREE, window.console, window.Math);

          fn();
        } catch(e) {
          console.error('Failed to create component class for ' + this.entityModel.get('name') + " with error: " + e );
        }
      }, this));
    };


    ScriptAsset.prototype.createScriptFromMinified = function(fn) {
      var script = this.entityModel.get('payload.minified');
      console.warn('createScriptFromMinified');

      if(script) {
        try {
          this.scriptData.klass = eval(script)(require, _, window.VAPI, THREE, window.console, window.Math);
          fn();
        } catch(e) {
          console.error('Failed to create component class for ' + this.entityModel.get('name') + " with error: " + e );
        }
      } else {
        throw new Error('Failed to evaluate custom script!');
      }
    };


    ScriptAsset.prototype._loadThreeData = function() {
      // do nothing
    };


    ScriptAsset.prototype.applyPayloadSettings_loaded = function() {
      // do nothing
    };


    ScriptAsset.prototype.scriptChanged = function() {
      this.trigger('script_changed');

      this.processComments(this.getProperty('script'));
    };

    ScriptAsset.prototype.attributesChanged = function(model, changes, options) {
      if (!options.processComments) {
        this.processComments(this.getProperty('script'));
      }
    };
    
    ScriptAsset.getDefaultComponentData = function(attrs) {
      var attributes = {};

      if (attrs) {
        _.each(attrs, function(attr, idx) {
          if (typeof attr.default !== 'undefined') {
            attributes[idx] = attr.default;
          } else if (attr.type === 'custom')  {
            attributes[idx] = ScriptAsset.getDefaultComponentData(attr.attributes);
          } else if (attr.type === 'a') {
            attributes[idx] = [];
          }
        }, this);
      }

      return _.deepClone(attributes);
    };

    window.VAPI = window.VAPI || {};
    window.VAPI.ScriptAsset = ScriptAsset;

    return ScriptAsset;
  });


define('text!VeroldEngine/Components/BuiltIn/Animation.js',[],function () { return '/**\r\n * A custom component class.\r\n *\r\n * @class Animation\r\n */\r\nfunction Animation() {\r\n  this.state = \'stopped\';\r\n}\r\n\r\nAnimation.prototype = new VAPI.VeroldComponent();\r\n\r\nAnimation.prototype.attributesChanged = function(changes, previous) {\r\n  if (previous && previous.asset) {\r\n    this.getScene().unregisterAnimation(previous.asset);\r\n  }\r\n\r\n  if (this.asset) {\r\n    this.getScene().registerAnimation(this.asset.id);\r\n  }\r\n\r\n  // Reload the animation while resetting the play state and current time.\r\n  this.reload(true);\r\n};\r\n\r\nAnimation.prototype.editorInit = function() {\r\n  this.init();\r\n\r\n  if (this.getEntity().isHierarchyLoaded()) {\r\n    this.objectLoaded();\r\n  }\r\n  else {\r\n    this.getEntity().once("load_hierarchy", this.objectLoaded, this);\r\n  }\r\n\r\n  this.getEngine().on("update", this.update, this);\r\n};\r\n\r\nAnimation.prototype.editorShutdown = function() {\r\n  this.getEngine().off("update", this.update, this);\r\n  this.shutdown();\r\n};\r\n\r\n/**\r\n * Returns the currently assigned animation asset.\r\n * @method getAsset\r\n * @return {Object} The currently assigned animation asset.\r\n */\r\nAnimation.prototype.getAsset = function() {\r\n  return this.asset;\r\n};\r\n\r\n/**\r\n * Returns the animation speed.\r\n * @method getSpeed\r\n * @return {Number} The animation speed.\r\n */\r\nAnimation.prototype.getSpeed = function() {\r\n  return this.speed;\r\n};\r\n\r\n/**\r\n * Returns the currently assigned animation take.\r\n * @method getTake\r\n * @return {String} The animation take.\r\n */\r\nAnimation.prototype.getTake = function() {\r\n  return this.take;\r\n};\r\n\r\n/**\r\n * Returns a dictionary of all take names.\r\n * @method getTakes\r\n * @return {Object} The take dictionary.\r\n */\r\nAnimation.prototype.getTakes = function() {\r\n  var takeDict = {};\r\n\r\n  if (this.asset) {\r\n    var takeNames = this.asset.getTakeNames();\r\n\r\n    for (var idx in takeNames) {\r\n      var takeName = takeNames[idx];\r\n      takeDict[takeName] = takeName;\r\n    }\r\n  }\r\n\r\n  return takeDict;\r\n};\r\n\r\n/**\r\n * Returns the animation time.\r\n * @method getTime\r\n * @return {Number} The animation time.\r\n */\r\nAnimation.prototype.getTime = function() {\r\n  if (this.animation) {\r\n    return this.animation.currentTime;\r\n  }\r\n\r\n  return 0.0;\r\n};\r\n\r\n/**\r\n * Returns the animation weight.\r\n * @method getWeight\r\n * @return {Number} The animation weight.\r\n */\r\nAnimation.prototype.getWeight = function() {\r\n  return this.weight;\r\n};\r\n\r\n/**\r\n * Called as soon as the VeroldEntity begins to load.\r\n */\r\nAnimation.prototype.init = function() {\r\n  // Listen to changes on the animation asset.\r\n  this.onAssetChanged = function() {\r\n    this.reload();\r\n  }.bind(this);\r\n\r\n  if (this.asset) {\r\n    this.asset.entityModel.on("change:payload.*", this.onAssetChanged);\r\n    this.getScene().registerAnimation(this.asset.id);\r\n  }\r\n\r\n  // this.veroldEntity is available here but the Three.JS data isn\'t loaded yet\r\n  this.getEntity().on(\'playKeyframeAnimation\', this.playKeyframeAnimation, this);\r\n  this.getEntity().on(\'pauseKeyframeAnimation\', this.pause, this);\r\n  this.getEntity().on(\'stopKeyframeAnimation\', this.stop, this);\r\n  this.getEntity().on(\'toggleKeyframeAnimation\', this.toggle, this);\r\n};\r\n\r\n/**\r\n * Returns true if the animation is enabled; otherwise, returns false. When\r\n * disabled, an animation does not have any effect on the scene. In contrast, a\r\n * paused or stopped (but enabled) animation may still be blended with other\r\n * animations. Animations are initially disabled, until the first call to\r\n * `play`. Use `stop` to disable an animation. Disabling unneeded animations\r\n * may have performance benefits.\r\n * @method isEnabled\r\n * @return {Boolean} true if looping is enabled; otherwise, false.\r\n */\r\nAnimation.prototype.isEnabled = function() {\r\n  return this.animation && this.animation.isPlaying;\r\n};\r\n\r\n/**\r\n * Returns true if looping is enabled; otherwise, returns false.\r\n * @method isLoop\r\n * @return {Boolean} true if looping is enabled; otherwise, false.\r\n */\r\nAnimation.prototype.isLoop = function() {\r\n  return this.loop;\r\n};\r\n\r\n/**\r\n * Returns true if the animation is paused; otherwise, returns false.\r\n * @method isPaused\r\n * @return {Boolean} true if the animation is paused; otherwise, false.\r\n */\r\nAnimation.prototype.isPaused = function() {\r\n  return this.state === \'paused\';\r\n};\r\n\r\n/**\r\n * Returns true if the animation is playing; otherwise, returns false.\r\n * @method isPlaying\r\n * @return {Boolean} true if the animation is playing; otherwise, false.\r\n */\r\nAnimation.prototype.isPlaying = function() {\r\n  return this.state === \'playing\';\r\n};\r\n\r\n/**\r\n * Returns true if the animation is stopped; otherwise, returns false.\r\n * @method isStopped\r\n * @return {Boolean} true if the animation is stopped; otherwise, false.\r\n */\r\nAnimation.prototype.isStopped = function() {\r\n  return this.state === \'stopped\';\r\n};\r\n\r\n/**\r\n * Called once the hierarchy is loaded.\r\n */\r\nAnimation.prototype.objectLoaded = function() {\r\n  this.reload(true);\r\n};\r\n\r\n/**\r\n * Play the currently assigned animation asset and take.\r\n * @method play\r\n * @param {Function} fn Callback function that is triggered when the take finishes playing\r\n */\r\nAnimation.prototype.play = function(fn) {\r\n  if (this.animation) {\r\n    if (this.state !== \'playing\') {\r\n      this.animation.timeScale = this.speed;\r\n      this.animation.play(this.animation.currentTime, this.animation.weight);\r\n      this.state = \'playing\';\r\n    }\r\n\r\n    this.onAnimationEnd = fn;\r\n  }\r\n};\r\n\r\n/**\r\n * Play the specified animation, with the given playback settings.\r\n * @method playKeyframeAnimation\r\n * @param {String} assetId The ID of the animation asset\r\n * @param {String} take The name of the take\r\n * @param {Boolean} loop Whether or not to loop the animation\r\n * @param {Number} speed The playback speed\r\n * @param {Number} startTime The time offset to start the animation at\r\n */\r\nAnimation.prototype.playKeyframeAnimation = function(assetId, take, loop, speed, startTime) {\r\n  var playAnimation = function(animation) {\r\n    if (animation) {\r\n      loop = loop !== undefined ? loop : this.isLoop();\r\n      speed = speed !== undefined ? speed : this.getSpeed();\r\n      startTime = startTime !== undefined ? startTime : this.getTime();\r\n\r\n      this.setLoop(loop);\r\n      this.setSpeed(speed);\r\n      this.setTime(startTime);\r\n\r\n      this.play();\r\n    }\r\n  }.bind(this);\r\n\r\n  if (assetId !== undefined || take !== undefined) {\r\n    var asset = assetId ? this.getEngine().getEntityById(assetId) : this.asset,\r\n        take = take ? take : this.take;\r\n\r\n    this.setAsset(asset, false);\r\n    this.setTake(take, false);\r\n\r\n    this.reload(false, function(err, animation) {\r\n      playAnimation(animation);\r\n    });\r\n  }\r\n  else {\r\n    playAnimation(this.animation);\r\n  }\r\n};\r\n\r\n/**\r\n * Pause the animation, without resetting the playhead.\r\n * @method pause\r\n */\r\nAnimation.prototype.pause = function() {\r\n  if (this.animation && this.state === \'playing\') {\r\n    this.animation.timeScale = 0;\r\n    this.state = \'paused\';\r\n  }\r\n};\r\n\r\n/**\r\n * Stop and release the current animation.\r\n * @method release\r\n */\r\nAnimation.prototype.release = function() {\r\n  this.stop();\r\n\r\n  if (this.animation) {\r\n    this.animation.stop();\r\n    this.animation = undefined;\r\n  }\r\n};\r\n\r\n/**\r\n * Reload the currently assigned animation asset and take. This should be called\r\n * when changes are made to the asset or take, for example.\r\n * @method reload\r\n * @param {Boolean} reset Reset the playhead and play state\r\n * @param {Function} fn Callback function when asset loading completes\r\n */\r\nAnimation.prototype.reload = function(reset, fn) {\r\n  var time = reset ? this.startTime : this.getTime(),\r\n      isPlaying = reset ? this.autoPlay : this.isPlaying();\r\n\r\n  // Release the current animation (if there is one).\r\n  this.release();\r\n\r\n  // Load and create a new animation.\r\n  if (this.asset && this.take) {\r\n    this.asset.load({\r\n      load: function() {\r\n        this.animation = this.asset.createAnimation(this.veroldEntity, this.take);\r\n\r\n        if (this.animation) {\r\n          this.animation.loop = this.loop;\r\n          this.animation.timeScale = this.speed;\r\n          this.animation.currentTime = time;\r\n          this.animation.weight = this.weight;\r\n\r\n          if (isPlaying) {\r\n            this.play();\r\n          }\r\n        }\r\n\r\n        if (fn) {\r\n          fn(null, this.animation);\r\n        }\r\n      }.bind(this)\r\n    });\r\n  }\r\n  else if (fn) {\r\n    fn(null, null);\r\n  }\r\n};\r\n\r\n/**\r\n * Set the current animation asset.\r\n * @method setAsset\r\n * @param {Object} asset The animation asset or null to unset the asset\r\n * @param {Boolean} reload Whether or not to reload the animation\r\n * @param {Function} fn Callback function when asset loading completes\r\n */\r\nAnimation.prototype.setAsset = function(asset, reload, fn) {\r\n  // Remove old change listener from the animation asset.\r\n  if (this.asset) {\r\n    this.asset.entityModel.off("change:payload.*", this.onAssetChanged);\r\n  }\r\n\r\n  this.asset = asset;\r\n\r\n  // Add new change listener to the animation asset.\r\n  if (this.asset) {\r\n    this.asset.entityModel.on("change:payload.*", this.onAssetChanged);\r\n  }\r\n\r\n  if (reload === undefined || reload) {\r\n    this.reload(false, fn);\r\n  }\r\n};\r\n\r\n/**\r\n * Enable or disable looping.\r\n * @method setLoop\r\n * @param {Boolean} loop The loop state\r\n */\r\nAnimation.prototype.setLoop = function(loop) {\r\n  this.loop = loop;\r\n\r\n  if (this.animation) {\r\n    this.animation.loop = this.loop;\r\n  }\r\n};\r\n\r\n/**\r\n * Set the animation speed.\r\n * @method setSpeed\r\n * @param {Number} speed The animation speed\r\n */\r\nAnimation.prototype.setSpeed = function(speed) {\r\n  this.speed = speed;\r\n\r\n  // Only update the animation\'s timeScale when the animation is playing since\r\n  // the timeScale is also used to pause and stop the animation. In those cases,\r\n  // the timeScale will be updated on the next call to `play`.\r\n  if (this.isPlaying()) {\r\n    this.animation.timeScale = this.speed;\r\n  }\r\n};\r\n\r\n/**\r\n * Set the current animation take.\r\n * @method setTake\r\n * @param {String} take The take name\r\n * @param {Boolean} reload Whether or not to reload the animation\r\n * @param {Function} fn Callback function when asset loading completes\r\n */\r\nAnimation.prototype.setTake = function(take, reload, fn) {\r\n  this.take = take;\r\n\r\n  if (reload === undefined || reload) {\r\n    this.reload(false, fn);\r\n  }\r\n};\r\n\r\n/**\r\n * Set the animation time.\r\n * @method setTime\r\n * @param {Number} time The animation time\r\n */\r\nAnimation.prototype.setTime = function(time) {\r\n  if (this.animation) {\r\n    this.animation.currentTime = time;\r\n    this.animation.reset();\r\n  }\r\n};\r\n\r\n/**\r\n * Set the animation weight.\r\n * @method setWeight\r\n * @param {Number} weight The animation weight\r\n */\r\nAnimation.prototype.setWeight = function(weight) {\r\n  this.weight = weight;\r\n\r\n  if (this.animation) {\r\n    this.animation.weight = this.weight;\r\n  }\r\n};\r\n\r\n/**\r\n * Called when the VeroldEntity is unloaded or this component is removed.\r\n * @method shutdown\r\n */\r\nAnimation.prototype.shutdown = function() {\r\n  // Remove the change listener from the animation asset.\r\n  if (this.asset) {\r\n    this.asset.entityModel.off("change:payload.*", this.onAssetChanged);\r\n  }\r\n\r\n  // Release the animation.\r\n  this.release();\r\n\r\n  this.getEntity().off(\'playKeyframeAnimation\', this.playKeyframeAnimation, this);\r\n  this.getEntity().off(\'pauseKeyframeAnimation\', this.pause, this);\r\n  this.getEntity().off(\'stopKeyframeAnimation\', this.stop, this);\r\n  this.getEntity().off(\'toggleKeyframeAnimation\', this.toggle, this);\r\n};\r\n\r\n/**\r\n * Stop the animation, resetting the playhead to 0, and optionally disable it.\r\n * When disabled, an animation has no effect on the scene, whereas a stopped\r\n * (but enabled) animation could still be blended with another animation. Before\r\n * the first call to `play`, an animation is disabled. Once disabled, an\r\n * animation remains disabled until `play` is called again. Disabling unneeded\r\n * animations may have performance benefits.\r\n * @method stop\r\n * @param disable {Boolean} disable Cease updating the animation\r\n */\r\nAnimation.prototype.stop = function(disable) {\r\n  if (this.animation) {\r\n    if (this.state !== \'stopped\') {\r\n      this.animation.timeScale = 0;\r\n      this.state = \'stopped\';\r\n    }\r\n\r\n    this.setTime(0);\r\n\r\n    if (disable) {\r\n      this.animation.stop();\r\n    }\r\n  }\r\n};\r\n\r\nAnimation.prototype.toggle = function() {\r\n  if (this.animation) {\r\n    if (this.state === \'playing\') { \r\n      this.pause();\r\n    } \r\n    else {\r\n      this.play();\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Called per VeroldEngine update (once per frame).\r\n * @method update\r\n * @param {Number} delta The number of seconds since the last call to `update`\r\n */\r\nAnimation.prototype.update = function(delta) {\r\n  if (!this.loop &&\r\n      this.animation &&\r\n      this.animation.currentTime >= this.animation.data.length) {\r\n\r\n    this.stop(true);\r\n\r\n    if (this.onAnimationEnd) {\r\n      // Store the callback, then clear it so that it\'s not called twice.\r\n      var fn = this.onAnimationEnd;\r\n      this.onAnimationEnd = undefined;\r\n\r\n      // Invoke the callback.\r\n      fn(this);\r\n    }\r\n\r\n    this.getEntity().trigger(\'endKeyframeAnimation\');\r\n  }\r\n};\r\n\r\nreturn Animation;\r\n\r\n';});


define('text!VeroldEngine/Components/BuiltIn/AudioListener.js',[],function () { return 'function AudioListener() {\n  this.context = null;\n}\n\nAudioListener.prototype = new VAPI.VeroldComponent();\n\nAudioListener.prototype.init = function() {\n  this.context = this.getEntity().veroldEngine.getAudioContext();\n\n  if (!this.context) {\n    console.warn("Failed to create Web Audio context.");\n    return;\n  }\n};\n\nAudioListener.prototype.update = function(delta) {\n  if (this.hasThreeData() && this.context) {\n    var xform = this.getThreeData().matrixWorld\n      , objPos = new THREE.Vector3(0, 0, 0).applyMatrix4(xform)\n      , objDir = new THREE.Vector3(0, 0,-1).applyMatrix4(xform).sub(objPos).normalize()\n      , objUp  = new THREE.Vector3(0, 1, 0).applyMatrix4(xform).sub(objPos).normalize();\n    \n    this.context.listener.setPosition(objPos.x, objPos.y, objPos.z);\n    this.context.listener.setOrientation(objDir.x, objDir.y, objDir.z, objUp.x, objUp.y, objUp.z);\n  }\n};\n\nreturn AudioListener;\n\n';});


define('text!VeroldEngine/Components/BuiltIn/AudioSource.js',[],function () { return 'function AudioSource() {\n  this.gainNode = null;\n  this.sourceNode = null;\n  this.pannerNode = null;\n  this.context = null;\n  this.buffer = null;\n  this.startTime = 0;\n  this.playOffset = 0;\n  this.state = "stopped";\n  this.element = null;\n  this.isVideo = false;\n}\n\nAudioSource.prototype = new VAPI.VeroldComponent();\n\nAudioSource.prototype.freeAudioGraph = function() {\n  if (this.element) {\n    this.element.pause();\n    this.element.currentTime = 0;\n  }\n\n  if (this.sourceNode) {\n    // If sourceNode is an AudioBufferSourceNode, stop it first.\n    if (!this.stream) {\n      this.sourceNode.stop(0);\n    }\n\n    this.sourceNode.disconnect();\n    this.sourceNode = null;\n  }\n\n  if (this.gainNode) {\n    this.gainNode.disconnect();\n  }\n\n  if (this.pannerNode) {\n    this.pannerNode.disconnect();\n  }\n};\n\nAudioSource.prototype.getCurrentTime = function() {\n  if (this.state === "playing") {\n    if (this.element) {\n      return this.element.currentTime;\n    }\n    else if (this.context) {\n      return this.context.currentTime - this.startTime;\n    }\n  }\n\n  return this.playOffset;\n};\n\nAudioSource.prototype.getGain = function() {\n  return this.gain;\n};\n\nAudioSource.prototype.getState = function() {\n  return this.state;\n};\n\nAudioSource.prototype.init = function() {\n  this.context = this.getEntity().veroldEngine.getAudioContext();\n\n  if (this.context) {\n    this.gainNode = this.context.createGain();\n    this.pannerNode = this.context.createPanner();\n  }\n  else {\n    console.warn("No audio context, using fallback.");\n    this.stream = true; // Must stream via an audio element.\n    this.positional = false; // Positional audio not supported.\n  }\n\n  // Always stream video assets.\n  this.isVideo = this.asset instanceof VAPI.TextureVideoAsset;\n  if (this.isVideo) {\n    this.stream = true;\n  }\n\n  if (this.autoPlay) {\n    this.play();\n  }\n  else if (this.preload) {\n    this.load(function(err) {\n      if (err) {\n        console.warn(err);\n      }\n    });\n  }\n\n  this.listenTo(this.getEntity(), \'playAudio\', this.play);\n  this.listenTo(this.getEntity(), \'pauseAudio\', this.pause);\n  this.listenTo(this.getEntity(), \'stopAudio\', this.stop);\n  this.listenTo(this.getEntity(), \'toggleAudio\', this.toggle);\n};\n\nAudioSource.prototype.initAudioGraph = function(fn) {\n  var that = this;\n\n  this.load(function(err, source) {\n    if (err) {\n      return fn(err);\n    }\n    else if (!that.context) {\n      return fn(null, null);\n    }\n\n    var nodes = [];\n\n    if (that.stream) {\n      that.sourceNode = that.context.createMediaElementSource(source);\n    }\n    else {\n      that.sourceNode = that.context.createBufferSource();\n      that.sourceNode.buffer = source;\n    }\n\n    nodes.push(that.sourceNode);\n    nodes.push(that.gainNode);\n\n    if (that.positional) {\n      nodes.push(that.pannerNode);\n    }\n\n    nodes.push(that.context.destination);\n\n    for (var iNode = 1; iNode < nodes.length; ++iNode) {\n      nodes[iNode - 1].connect(nodes[iNode]);\n    }\n\n    fn(null, that.sourceNode);\n  });\n};\n\nAudioSource.prototype.isLoop = function() {\n  return this.loop;\n};\n\nAudioSource.prototype.isPaused = function() {\n  return this.state === "paused";\n};\n\nAudioSource.prototype.isPlaying = function() {\n  return this.state === "playing";\n};\n\nAudioSource.prototype.isStopped = function() {\n  return this.state === "stopped";\n};\n\nAudioSource.prototype.load = function(fn) {\n  var that = this;\n\n  // Return the element or buffer, if they have already been created.\n  if (this.stream && this.element) {\n    return fn(null, this.element);\n  }\n  else if (!this.stream && this.buffer) {\n    return fn(null, this.buffer);\n  }\n\n  if (!this.asset) {\n    return fn(new Error("No audio asset"));\n  }\n\n  // If we are streaming, load the audio asset and reference the audio or video\n  // element. If we aren\'t streaming, load the entire file into an audio buffer.\n  if (this.stream) {\n    this.asset.load({\n      load: function(asset) {\n        if (!asset) {\n          return fn(new Error("Error loading audio/video file"));\n        }\n\n        if (that.isVideo) {\n          that.element = asset.threeData.image;\n        }\n        else {\n          that.element = asset.threeData;\n        }\n\n        fn(null, that.element);\n    }});\n  }\n  else {\n    if (!this.context) {\n      return fn(new Error("No Web Audio context"));\n    }\n\n    var xhr = new XMLHttpRequest();\n\n    xhr.open(\'GET\', this.asset.getResourcePaths({ sampleRate: 44100 })[0]);\n    xhr.responseType = \'arraybuffer\';\n\n    xhr.onreadystatechange = function(evt) {\n      if (xhr.readyState === 4) {\n        if (that.buffer) {\n          return fn(null, that.buffer);\n        }\n\n        if (xhr.status === 200) {\n          that.context.decodeAudioData(this.response, function(buffer) {\n            that.buffer = buffer;\n            fn(null, that.buffer);\n          },\n          function(err) {\n            fn(err);\n          });\n        }\n        else {\n          fn(new Error("Error loading audio file"));\n        }\n      }\n    };\n\n    xhr.send();\n  }\n};\n\nAudioSource.prototype.pause = function() {\n  if (this.state === "playing") {\n    // The order of these function calls is important: getCurrentTime() must be\n    // called while state is "playing" and before freeAudioGraph().\n    this.playOffset = this.getCurrentTime();\n    this.state = "paused";\n    this.freeAudioGraph();\n  }\n};\n\nAudioSource.prototype.play = function(offset) {\n  if (this.state === "paused" || this.state === "stopped") {\n    var that = this;\n\n    // Add the specified offset to the current play offset.\n    offset = offset !== undefined ? offset : 0;\n    this.playOffset += offset;\n\n    this.initAudioGraph(function(err, sourceNode) {\n      if (err) {\n        console.warn("Error playing audio: " + err);\n        return;\n      }\n\n      // Update the gain and loop settings.\n      that.setGain(that.gain);\n      that.setLoop(that.loop);\n\n      // If we are streaming, play the audio/video element; otherwise, play the\n      // buffer source node.\n      if (that.stream) {\n        that.element.currentTime = that.playOffset;\n        that.element.play();\n      }\n      else if (that.context) {\n        that.startTime = that.context.currentTime;\n        that.sourceNode.start(0, that.playOffset);\n      }\n      else {\n        console.warn("No Web Audio context.");\n      }\n\n      that.state = "playing";\n    });\n  }\n};\n\nAudioSource.prototype.setGain = function(gain) {\n  this.gain = gain;\n\n  // If we have a gain node, set the gain on it; otherwise, set the gain on the\n  // audio/video element.\n  if (this.gainNode) {\n    this.gainNode.gain.value = this.gain;\n  }\n  else if (this.element) {\n    this.element.volume = this.gain;\n  }\n};\n\nAudioSource.prototype.setLoop = function(loop) {\n  this.loop = loop;\n\n  if (this.element) {\n    this.element.loop = this.loop;\n  }\n  else if (this.sourceNode) {\n    this.sourceNode.loop = this.loop;\n  }\n};\n\nAudioSource.prototype.stop = function() {\n  if (this.state === "playing" || this.state === "paused") {\n    this.playOffset = 0;\n    this.state = "stopped";\n    this.freeAudioGraph();\n  }\n};\n\nAudioSource.prototype.toggle = function() {\n  if (this.state === "playing") {\n    this.pause();\n  }\n  else {\n    this.play();\n  }\n};\n\nAudioSource.prototype.update = function(delta) {\n  if (this.hasThreeData() && this.positional) {\n    var xform = this.getThreeData().matrixWorld\n      , objPos = new THREE.Vector3(0, 0, 0).applyMatrix4(xform)\n      , objDir = new THREE.Vector3(0, 0, 1).applyMatrix4(xform).sub(objPos).normalize();\n\n    this.pannerNode.setPosition(objPos.x, objPos.y, objPos.z);\n    this.pannerNode.setOrientation(objDir.x, objDir.y, objDir.z);\n  }\n};\n\nreturn AudioSource;\n\n';});


define('text!VeroldEngine/Components/BuiltIn/FreeCameraController.js',[],function () { return '/**\n *\n * FreeCamera\n *\n * All scripts will have access to the following variables in their scope:\n *\n *   VAPI - the Verold API\n *   require - requirejs\n *   THREE - THREE.JS\n *\n * All objects will have the following properties assigned to them:\n *\n *   this.veroldEntity - the verold object which this component is attached to\n *   this.events - global event system\n *\n * All of your component attributes will automatically be bound to your object,\n * you can access them via this.[attribute name].\n *\n * If you wish to have access to common javascript libraries such as jQuery or\n * Underscore, you can use the ones we provide via:\n *\n * var _ = require(\'underscore\');\n * var $ = require(\'jquery\');\n *\n * Alternatively, you can load in your own versions of these dependencies by\n * adding them as external dependencies on your developers tab.\n *\n * Additional information regarding the Verold API can be found in our API docs:\n *\n *  http://dev.verold.com/doc/\n */\n\nvar _ = require(\'underscore\');\n\n/* global VAPI */\n\n/**\n * A custom component class.\n *\n * @class FreeCamera\n */\nfunction FreeCamera() {\n  this._moveVector = new THREE.Vector3();\n  this._tempVector = new THREE.Vector3();\n  this._tempVector2 = new THREE.Vector3();\n  \n  this.tempCamera = new THREE.PerspectiveCamera();\n  this.tempEuler = new THREE.Euler();\n  this.tempQuaternion = new THREE.Quaternion();\n  \n  this._currentMoveSpeed = new THREE.Vector3();\n\n  this.ellapsedTimeSinceInput = 0;\n  this.enablePan = undefined;\n  this.enableZoom = undefined;\n\n  this.invertX = false;\n  this.invertY = false;\n  this.invertZoom = false;\n  this.touchState = "none";\n  this.touchLast = new THREE.Vector2();\n  this.touchLastPinchDist = 0.0;\n  this.touchYStart = 0.0;\n  this.lookDelta = new THREE.Vector2();\n  this.moveDelta = new THREE.Vector3();\n  this.zoomDelta = 0.0;\n  this.currentLookSpeed = new THREE.Vector2();\n  this.currentMoveSpeed = new THREE.Vector3();\n  this.currentZoomSpeed = 0.0;\n  this.lookDeltaLength = 0.0;\n  this.moveDeltaLength = 0.0;\n\n  this.pitchAngleBoundsRadians = { max: 0.0, min: 0.0 };\n\n  this.onMouseDown_PointerLock = this.onMouseDown_PointerLock.bind(this);\n  this.onMouseUp_PointerLock = this.onMouseUp_PointerLock.bind(this);\n}\n\nFreeCamera.prototype = new VAPI.VeroldComponent();\n\n/**\n * Called immediately after after component creation\n */\nFreeCamera.prototype.init = function() {\n  \n  if ( this.usePointerLock ) {\n    this.togglePointerLock( true );\n  }\n  var engine = this.getEngine();\n  \n  this.pitchAngleBoundsRadians.max = Math.PI * this.pitchAngleBounds.max / 180.0;\n  this.pitchAngleBoundsRadians.min = Math.PI * this.pitchAngleBounds.min / 180.0;\n\n  if ( window.VAPI.isMobile() ) {\n    engine.on( \'touchStart\', this.onTouchStart, this );\n    engine.on( \'touchMove\', this.onTouchMove, this );\n    engine.on( \'touchEnd\', this.onTouchEnd, this );\n  }\n  else {\n    engine.on( \'mouseMove\', this.onMouseMove, this );\n    engine.on( \'mouseScroll\', this.onMouseScroll, this );\n  }\n\n  this.getEntity().on(\'enableFreeCameraController\', this.freeCameraEnable, this);\n  this.getEntity().on(\'disableFreeCameraController\', this.freeCameraDisable, this);\n  this.getEntity().on(\'toggleFreeCameraController\', this.freeCameraToggle, this);\n};\n\n/**\n * Called when a verold object is destroyed or this component is removed\n * from a verold object.\n */\nFreeCamera.prototype.shutdown = function() {\n  // make sure to clean up any events or other bindings that you have created\n  // to avoid memory leaks\n  var engine = this.getEngine();\n\n  if ( window.VAPI.isMobile() ) {\n    engine.off( \'touchStart\', this.onTouchStart, this );\n    engine.off( \'touchMove\', this.onTouchMove, this );\n    engine.off( \'touchEnd\', this.onTouchEnd, this );\n  }\n  else {\n    engine.off( \'mouseMove\', this.onMouseMove, this );\n    engine.off( \'mouseScroll\', this.onMouseScroll, this );\n  }\n  this.getEntity().off(\'enableFreeCameraController\', this.freeCameraEnable, this);\n  this.getEntity().off(\'disableFreeCameraController\', this.freeCameraDisable, this);\n  this.getEntity().off(\'toggleFreeCameraController\', this.freeCameraToggle, this);\n  \n  this.togglePointerLock( false );\n};\n\nFreeCamera.prototype.setTargetByID = function( targetID, interpTime ) {\n  var targetObj = this.getEntity().getParentAsset().getObjectById( targetID );\n  this.setTarget( targetObj, interpTime );\n};\n\nFreeCamera.prototype.setTarget = function( targetObj ) {\n  if ( targetObj ) {\n    var that = this;\n    var targetPos = new THREE.Vector3();\n    if ( targetObj.isVeroldEntity ) {\n      this.getScene().once(\'load_hierarchy\', function() {\n        targetObj.getCenterInWorldSpace( targetPos );\n        var dist;\n        var bb = targetObj.getProperty("boundingbox");\n        if ( bb ) {\n          dist = this.adjustDistanceForObject( targetObj );\n        }\n        else {\n          targetObj.traverse( function( obj ) {\n            bb = obj.getProperty("boundingbox");\n            if ( bb ) {\n              dist = that.adjustDistanceForObject( obj );\n              return true;\n            }\n          });\n        }\n        var threeData = this.getThreeData();\n        threeData.lookAt( targetPos );\n        var distanceVector = new THREE.Vector3(0, 0, dist);\n        distanceVector.applyQuaternion( threeData.quaternion );\n        targetPos.add( distanceVector );\n        threeData.position.copy( targetPos );\n        \n      }, this );\n      this.getScene().load_hierarchy();\n    }\n  }\n};\n\nFreeCamera.prototype.adjustDistanceForObject = function( targetObj ) {\n  var bb = targetObj.getProperty("boundingbox");\n  if ( bb ) {\n    var dist = new THREE.Vector3();\n    dist.set( bb.max.x - bb.min.x, bb.max.y - bb.min.y, bb.max.z - bb.min.z);\n    var scale = new THREE.Vector3();\n    scale.setFromMatrixScale( targetObj.threeData.matrixWorld );\n    dist.multiply( scale );\n    var size = dist.length();\n    var newDist = Math.abs( size / (2.0 * Math.tan( this.getThreeData().fov * Math.PI / 360.0 )) );\n    //newDist = Math.max( Math.min( newDist, this.orbitDistanceMax ), this.orbitDistanceMin );\n    return newDist;\n  }\n};\n\n/**\n * Called per VeroldEngine update (per frame)\n * @param  {float} delta The number of seconds since the last call to `update`\n */\nFreeCamera.prototype.preUpdate = function( delta ) {\n  \n  if (this.hasThreeData() && this.isEnabled() ) {\n    //Check WASD state and move camera appropriately\n    //Also check for modifier keys like ctrl and cmd. If these are pressed,\n    //don\'t move the camera.\n    var input = this.getInput();\n    var modKey = input.keyDown("ctrl") || input.keyDown("cmd");\n    var forwardKey = input.keyDown("upArrow") || input.keyDown("W");\n    var backwardKey = input.keyDown("downArrow") || input.keyDown("S");\n    var leftKey = input.keyDown("leftArrow") || input.keyDown("A");\n    var rightKey = input.keyDown("rightArrow") || input.keyDown("D");\n\n    if ( !modKey && ( forwardKey || backwardKey || leftKey || rightKey ) ) {\n      \n      if ( this.enableZoom ) {\n        if ( forwardKey ) {\n          this.moveDelta.z = -delta;\n        }\n        else if ( backwardKey ) {\n          this.moveDelta.z = delta;\n        }\n      }\n      if ( this.enablePan ) {\n        if ( rightKey ) {\n          this.moveDelta.x = -delta;\n        }\n        else if ( leftKey ) {\n          this.moveDelta.x = delta;\n        }\n      }\n    }\n    this.updateCamera( delta );\n\n  }\n};\n\nFreeCamera.prototype.postUpdate = function() {\n  this.hasChanged = false;\n};\n\nFreeCamera.prototype.updateCamera = function( delta ) {\n\n  //Handle inverting the controls\n  if ( this.invertX ) {\n    this.lookDelta.x *= -1.0;\n    this.moveDelta.x *= -1.0;\n  }\n  if ( this.invertY ) {\n    this.lookDelta.y *= -1.0;\n    this.moveDelta.y *= -1.0;\n  }\n  if ( this.invertZoom ) {\n    this.zoomDelta *= -1.0;\n  }\n\n  //Handle speed modifier keys\n  var speedMod = 1.0;\n  if ( this.getInput().keyDown( "shift" ) ) {\n    speedMod = 5.0;\n  }\n  // else if ( this.getInput().keyDown( "ctrl" ) ) {\n  //   speedMod = 0.25;\n  // }\n\n  var damping = Math.min((delta - 0.017) * 33.3 + this.inertialDamping, 1.0);\n  var oneMinusDamping = 1.0 - damping;\n\n  this.currentLookSpeed.x = oneMinusDamping * this.currentLookSpeed.x + damping * 6.0 * speedMod * this.lookSpeed * this.lookDelta.x;\n  this.currentLookSpeed.y = oneMinusDamping * this.currentLookSpeed.y + damping * 6.0 * speedMod * this.lookSpeed * this.lookDelta.y;\n  \n  //If the movement controls have been used, update the movement speed.\n  this.currentMoveSpeed.x = oneMinusDamping * this.currentMoveSpeed.x + damping * speedMod * this.movementSpeed * this.moveDelta.x;\n  this.currentMoveSpeed.y = oneMinusDamping * this.currentMoveSpeed.y + damping * speedMod * this.movementSpeed * this.moveDelta.y;\n  this.currentMoveSpeed.z = oneMinusDamping * this.currentMoveSpeed.z + damping * speedMod * this.movementSpeed * this.moveDelta.z;\n  \n  //Handle zoom\n  this.currentMoveSpeed.z += oneMinusDamping * this.currentZoomSpeed + damping * speedMod * this.movementSpeed * this.zoomDelta;\n  \n  //Update the three camera based on the current movement speed.\n  var threeData = this.getThreeData();\n\n  //Using current x,y rotation speed, determine the new quaternion for the camera\n  //New position is based on the distance and direction to target\n  \n  this.tempEuler.set( this.currentLookSpeed.y, this.currentLookSpeed.x, 0.0 );\n  this.tempQuaternion.setFromEuler( this.tempEuler );\n  threeData.quaternion.multiply( this.tempQuaternion );\n\n  //Set bounds on the pitch angle\n  this.tempEuler.setFromQuaternion( threeData.quaternion, \'YXZ\' );\n  if ( -this.tempEuler.x > this.pitchAngleBoundsRadians.max ) {\n    this.tempEuler.x = -this.pitchAngleBoundsRadians.max;\n    threeData.quaternion.setFromEuler( this.tempEuler );\n    this.currentLookSpeed.y = 0.0;\n  }\n  else if ( -this.tempEuler.x < this.pitchAngleBoundsRadians.min ) {\n    this.tempEuler.x = -this.pitchAngleBoundsRadians.min;\n    threeData.quaternion.setFromEuler( this.tempEuler );\n    this.currentLookSpeed.y = 0.0;\n  }\n\n  //Handle linear movement of the camera\n  this._tempVector.copy( this.currentMoveSpeed );\n  this._tempVector.x *= -1.0;\n  this._tempVector.applyQuaternion( threeData.quaternion );\n  threeData.position.add( this._tempVector );\n  \n  //Set the camera\'s position using the orientation and \n  this._tempVector.set( 0.0, 0.0, -10.0 );\n  this._tempVector.applyQuaternion( threeData.quaternion );\n  this._tempVector.add( threeData.position );\n\n  threeData.lookAt( this._tempVector );\n\n  if ( this.currentZoomSpeed || this.currentLookSpeed.x || this.currentLookSpeed.y || this.currentMoveSpeed.x || this.currentMoveSpeed.y || this.currentMoveSpeed.z ) {\n    this.getEngine().needsRender = true;\n    this.hasChanged = true;\n  }\n\n  this.lookDelta.set( 0.0, 0.0 );\n  this.moveDelta.set( 0.0, 0.0, 0.0 );\n  this.zoomDelta = 0.0;\n};\n\n\nFreeCamera.prototype.freeCameraEnable = function( blendTime ) {\n  this.enable();\n};\n\nFreeCamera.prototype.freeCameraDisable = function( ) {\n  this.disable();\n};\n\nFreeCamera.prototype.freeCameraToggle = function( ) {\n  if ( this.isEnabled() ) {\n    this.disable();\n  }\n  else {\n    this.enable();\n  }\n  if ( this.usePointerLock && !this.isEnabled() ) {\n    document.exitPointerLock();\n  }\n};\n\nFreeCamera.prototype.getEulerAngles = function( outEuler ) {\n  var returnVector = outEuler;\n  if ( !outEuler ) {\n    returnVector = new THREE.Euler();\n  }\n  returnVector.setFromQuaternion( this.getThreeData().quaternion, \'YXZ\' );\n  \n  return returnVector;\n};\n\nFreeCamera.prototype.setEulerAngles = function( euler ) {\n  this.getThreeData().quaternion.setFromEuler( euler );\n};\n\nFreeCamera.prototype.togglePointerLock = function( on ) {\n  this.usePointerLock = on;\n  \n  if ( this.usePointerLock ) {\n    this.getThreeRenderer().domElement.addEventListener( \'mousedown\', this.onMouseDown_PointerLock);\n  }\n  else {\n    this.getThreeRenderer().domElement.removeEventListener( \'mousedown\', this.onMouseDown_PointerLock);\n  }\n};\n\nFreeCamera.prototype.onMouseDown_PointerLock = function( event ) {\n  if ( this.isEnabled() && event.button === 0 || event.button === 2 ) {\n    this.getThreeRenderer().domElement.requestPointerLock();\n    \n    this.getThreeRenderer().domElement.addEventListener( \'mouseup\', this.onMouseUp_PointerLock);\n  }\n};\n\nFreeCamera.prototype.onMouseUp_PointerLock = function( event ) {\n  if ( this.veroldEntity ) {\n    if ( event.button === 2 && this.getInput().mouseButtonUp( "left" ) || event.button === 0 && that.getInput().mouseButtonUp( "right" ) ) {\n      this.getThreeRenderer().domElement.removeEventListener( \'mouseup\', this.onMouseUp_PointerLock );\n      document.exitPointerLock();\n    }\n  }\n};\n  \n\nFreeCamera.prototype.onMouseMove = function( event ) {\n  if ( this.isEnabled() ) {\n    var input = this.getInput();\n    var rightButton = input.mouseButtonDown("right");\n    var leftButton = input.mouseButtonDown("left");\n    // var middleButton = input.mouseButtonDown("middle");\n\n  \n    if ( ( rightButton ) && this.enablePan ) {\n\n      this.moveDelta.x = event.scenePercentDeltaX;\n      this.moveDelta.y = event.scenePercentDeltaY;\n    }\n    else if ( leftButton ) {\n\n      this.lookDelta.x = -event.scenePercentDeltaX;\n      this.lookDelta.y = -event.scenePercentDeltaY;\n    }\n\n  }\n};\n      \nFreeCamera.prototype.onMouseScroll = function( delta ) {\n  if ( this.isEnabled() && _.isNumber( delta ) && this.enableZoom ) {\n    \n    this.zoomDelta = -delta * 0.1;\n  }\n};\n\nFreeCamera.prototype.onTouchStart = function( event ) {\n\n  if ( this.isEnabled() ) {\n    \n    var touches = event.touches;\n    if ( !touches ) return;\n\n    switch ( touches.length ) {\n\n    case 1: // one-fingered touch: rotate\n      this.touchState = "rotate";\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\n      \n      break;\n\n    case 2: // two-fingered touch: dolly\n      this.touchState = "zoom";\n\n      var dx = touches[ 0 ].scenePercentX - touches[ 1 ].scenePercentX;\n      var dy = touches[ 0 ].scenePercentY - touches[ 1 ].scenePercentY;\n      var distance = Math.sqrt( dx * dx + dy * dy );\n\n      this.touchLastPinchDist = distance;\n      this.touchYStart = touches[ 0 ].scenePercentY;\n      break;\n\n    case 3: // three-fingered touch: pan\n      this.touchState = "pan";\n\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\n      break;\n\n    default:\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\n      this.touchLastPinchDist = -1;\n    }\n\n  }\n};\n\nFreeCamera.prototype.onTouchMove = function( event ) {\n\n  var touches = event.touches;\n  if ( !touches ) return;\n  // var speedMod = 0.3;\n  var dx, dy;\n  switch ( touches.length ) {\n\n  case 1: // one-fingered touch: rotate\n    if ( this.touchLast.x >= 0 ) {\n      dx = -0.5 * ( this.touchLast.x - touches[ 0 ].scenePercentX );\n      dy = -0.5 * ( this.touchLast.y - touches[ 0 ].scenePercentY );\n    }\n    else {\n      dx = 0.0;\n      dy = 0.0;\n    }\n\n    this.touchLast.x = touches[ 0 ].scenePercentX;\n    this.touchLast.y = touches[ 0 ].scenePercentY;\n    \n    this.ellapsedTimeSinceInput = 0;\n    \n    this.lookDelta.set( dx, dy );\n\n    break;\n\n  case 2: // two-fingered touch: dolly\n    \n    dx = touches[ 0 ].scenePercentX - touches[ 1 ].scenePercentX;\n    dy = touches[ 0 ].scenePercentY - touches[ 1 ].scenePercentY;\n    var distance = Math.sqrt( dx * dx + dy * dy );\n\n    if ( this.touchLast.x >= 0.0 ) {\n      var pinchChange = this.touchLastPinchDist - distance;\n      var scrollChange = this.touchLast.y - touches[ 0 ].scenePercentY;\n      if ( Math.abs( pinchChange ) > Math.abs( scrollChange ) ) {\n        this.zoomDelta = 20.0 * pinchChange;\n      }\n      else {\n        this.zoomDelta = 20.0 * scrollChange;\n      }\n    }\n\n    this.touchLastPinchDist = distance;\n    this.touchLast.x = touches[ 0 ].scenePercentX;\n    this.touchLast.y = touches[ 0 ].scenePercentY;\n\n    break;\n\n  case 3: // three-fingered touch: pan\n    dx = touches[ 0 ].scenePercentX - this.touchLast.x;\n    dy = touches[ 0 ].scenePercentY - this.touchLast.y;\n\n    if ( this.touchLast.x >= 0.0 ) {\n      this.moveDelta.set( dx, dy, 0.0 );\n    }\n\n    this.touchLast.x = touches[ 0 ].scenePercentX;\n    this.touchLast.y = touches[ 0 ].scenePercentY;\n    break;\n  }\n  \n};\n\nFreeCamera.prototype.onTouchEnd = function( /* event */ ) {\n\n  this.touchLast.set( -1.0, -1.0 );\n  this.touchLastPinchDist = -1;\n  this.touchState = "none";\n};\n\n\nreturn FreeCamera;\n';});


define('text!VeroldEngine/Components/BuiltIn/OrbitCameraController.js',[],function () { return '/*\r\n@vname Orbit Camera Controller\r\n@vdescription A controller that allows a camera to easily orbit a target object.\r\n@vfilter camera\r\n@vcategory \'Camera Controllers\'\r\n@vattr object targetObject { \r\n  default : null, \r\n  description : \'The object that the camera orbit point will be relative to.\',\r\n}\r\n@vattr v3 targetOffset {\r\n  \'default\' : {"x": 0.0, "y": 0.0, \'z\': 0.0 },\r\n  \'description\' : \'An offset relative to the target object. This will allow you to target a specific point on an object.\',\r\n}\r\n@vattr float inertialDamping {\r\n  \'default\': 0.40,\r\n  \'description\': \'How quickly the camera stops moving when input stops.\',\r\n  "min" : 0.0,\r\n  "max" : 1.0\r\n}\r\n@vattr bool invertX {\r\n  \'default\': false,\r\n  \'description\': \'Reverse the default direction that the camera moves horizontally.\'\r\n}\r\n@vattr bool invertY {\r\n  \'default\': false,\r\n  \'description\': \'Reverse the default direction that the camera moves vertically.\'\r\n}\r\n@vattr bool invertZoom {\r\n  \'default\': false,\r\n  \'description\': \'Reverse the default direction that the camera moves when zooming.\'\r\n}\r\n@vattr float lookSpeed {\r\n  \'description\' : \'The speed that the camera orbits the target\',\r\n  \'default\' : 1.0,\r\n  \'max\' : 1000,\r\n  \'min\' : 0.0001\r\n}\r\n@vattr float movementSpeed {\r\n  \'description\' : \'The speed that the camera moves when panning\',\r\n  \'default\' : 8.0,\r\n  \'max\' : 2000,\r\n  \'min\' : 0.001\r\n}\r\n@vattr bool autoOrbit {\r\n  \'default\': false,\r\n  \'description\': \'Automatically orbit the camera when the user is not controlling it.\'\r\n}\r\n@vattr float autoOrbitSpeed {\r\n  \'description\' : \'The speed of the automatic orbit.\',\r\n  \'default\' : 1.0,\r\n  \'max\' : 1000,\r\n  \'min\' : -1000\r\n}\r\n@vattr float autoOrbitDelay {\r\n  \'description\' : \'The period of time with no mouse input before the auto-orbit starts (in seconds).\',\r\n  \'default\' : 1.0,\r\n  \'max\' : 1000,\r\n  \'min\' : 0.0001\r\n}\r\n@vattr float orbitDistanceMin {\r\n  \'description\' : \'The closest that the camera is allowed to get to the target.\',\r\n  \'default\' : 0.1,\r\n  \'max\' : 1000,\r\n  \'min\' : 0.001\r\n}\r\n@vattr float orbitDistanceMax {\r\n  \'description\' : \'The furthest that the camera is allowed to get from the target.\',\r\n  \'default\' : 5.0,\r\n  \'max\' : 10000,\r\n  \'min\' : 1.0\r\n}\r\n@vattr Vector2 pitchAngleBounds {\r\n  \'description\' : \'Allows you to set how far the camera can pitch (tilt) from horizontal. Defined in degrees with horizontal being 0.\',\r\n  \'default\': {"max": 75.0, "min": -75.0 },\r\n  "max": { "max": 90.0, "min": 90.0 },\r\n  "min": { "max": -90.0, "min": -90.001 } \r\n}\r\n@vattr bool enablePan {\r\n  \'default\': true,\r\n  \'description\': \'Allow the user to pan side-to-side and up and down with the camera.\'\r\n}\r\n@vattr bool enableZoom {\r\n  \'default\': true,\r\n  \'description\': \'Allow the user to zoom in and out with the camera.\'\r\n}\r\n@vattr bool interpolation {\r\n  \'default\': true,\r\n  \'description\': \'When enabled, the camera will smoothly interpolate toward its desired state. e.g. If something else moves the camera, interpolation will cause the camera to smoothly focus on the target again. Otherwise, it will snap back.\'\r\n}\r\n@vattr float interpSpeed {\r\n  \'description\' : \'The speed at which the orbiting camera locks on to its target, if set to point away from it.\',\r\n  \'default\' : 0.5,\r\n  \'max\' : 10.0,\r\n  \'min\' : 0.01\r\n}\r\n@vattr bool usePointerLock {\r\n  \'default\': false,\r\n  \'description\': \'The mouse cursor will be hidden during camera control and won\\\'t move. Requires the user to accept pointer lock message in web browser.\'\r\n}\r\n\r\n@vevent local enableOrbitCameraController {\'scope\' : \'local\', \'action\':true, \'category\':\'Orbit Camera\', \'parameters\' : []}\r\n@vevent local disableOrbitCameraController {\'scope\' : \'local\', \'action\':true, \'category\':\'Orbit Camera\', \'parameters\' : []}\r\n@vevent local toggleOrbitCameraController {\'scope\' : \'local\', \'action\':true, \'category\':\'Orbit Camera\', \'parameters\' : []}\r\n@vevent local setOrbitDistance {\'scope\' : \'local\', \'action\':true, \'category\':\'Orbit Camera\', \'parameters\' : [\r\n  {\'name\': \'newDistance\', \'type\': \'f\', \'description\': \'The new distance that the camera will orbit at.\', \'default\': 1.0},\r\n]}\r\n@vevent local setTarget {\'scope\' : \'local\', \'description\': \'Sets the camera to orbit the given object\', \'action\':true, \'category\':\'Orbit Camera\', \'parameters\' : [\r\n  {\'name\': \'newTarget\', \'type\': \'object\', \'description\': \'The new target that the camera will orbit.\', \'default\': null},\r\n  {\'name\': \'center\', \'type\': \'b\', \'description\': \'Whether or not to target the center of the object. If false, the camera will orbit the origin of the object.\', \'default\': true},\r\n]}\r\n@vevent local focusOnTarget {\'scope\' : \'local\', \'description\': \'Look at the center of the current target and zoom so that the object nicely fills the field of view.\', \'action\':true, \'category\':\'Orbit Camera\', \'parameters\' : []}\r\n\r\n*/\r\n\r\nvar _ = require(\'underscore\');\r\n\r\n/* global VAPI */\r\n\r\n/**\r\n * A custom component class.\r\n *\r\n * @class OrbitCamera\r\n */\r\nfunction OrbitCamera() {\r\n  this.isEditor = false;\r\n  this._moveVector = new THREE.Vector3();\r\n  this._tempVector = new THREE.Vector3();\r\n  this._tempVector2 = new THREE.Vector3();\r\n  this._tempVector4 = new THREE.Vector4();\r\n  this._pivotWorldPos = new THREE.Vector3();\r\n  this._tempMatrix4 = new THREE.Matrix4();\r\n  //The point that the camera will orbit (using the targetObject and targetOffset)\r\n  this.pivotPoint = new THREE.Object3D();\r\n  this.targetObject = undefined;\r\n  this.targetOffset = new THREE.Vector3();\r\n  this.tempCamera = new THREE.PerspectiveCamera();\r\n  this.tempEuler = new THREE.Euler(0,0,0, \'YXZ\');\r\n  this.tempQuaternion = new THREE.Quaternion();\r\n  this.tempQuaternion2 = new THREE.Quaternion();\r\n  this.currentOrbitDistance = 2.50;\r\n  this.newOrbitDistance = 0.0;\r\n  this.targetMoved = true;\r\n  \r\n  this.ellapsedTimeSinceInput = 0;\r\n  this.enablePan = undefined;\r\n  this.enableZoom = undefined;\r\n\r\n  this.invertX = false;\r\n  this.invertY = false;\r\n  this.invertZoom = false;\r\n  this.touchLast = new THREE.Vector2();\r\n  this.touchLastPinchDist = 0.0;\r\n  // this.touchYStart = 0.0;\r\n  this.orbitMovement = new THREE.Vector2();\r\n  this.linearMovementDelta = new THREE.Vector3();\r\n  this.zoomDelta = 0.0;\r\n  this.currentOrbitSpeed = new THREE.Vector2();\r\n  this.currentMoveSpeed = new THREE.Vector2();\r\n  this.currentZoomSpeed = 0.0;\r\n  this.orbitMovementLength = 0.0;\r\n  this.linearMovementDeltaLength = 0.0;\r\n\r\n  this.moveStart = new THREE.Vector2();\r\n  this.pan = false;\r\n  this.look = false;\r\n  this.zoom = false;\r\n  this.isMouseDragging = false;\r\n  this.isTouchDragging = false;\r\n  this.autoOrbitOn = false;\r\n    \r\n  // this.positionStart = new THREE.Vector3();\r\n  this.quaternionStart = new THREE.Quaternion();\r\n  this.eulerStart = new THREE.Euler(0,0,0, \'YXZ\');\r\n  this.currentMousePosition = new THREE.Vector2();\r\n\r\n  this.pitchAngleBoundsRadians = { max: 0.0, min: 0.0 };\r\n  this.onMouseDown_PointerLock = this.onMouseDown_PointerLock.bind(this);\r\n  this.onMouseUp_PointerLock = this.onMouseUp_PointerLock.bind(this);\r\n}\r\n\r\nOrbitCamera.prototype = new VAPI.VeroldComponent();\r\n\r\nOrbitCamera.prototype.editorInit = function() {\r\n  // var that = this;\r\n  this.isEditor = true;\r\n  this.init();\r\n  this.pivotPoint.add( \r\n    new THREE.Mesh( \r\n      new THREE.SphereGeometry( 0.025, 12, 12 ), \r\n      new THREE.MeshBasicMaterial({wireframe: true})\r\n    ));\r\n  this.pivotPoint.visible = false;\r\n  this.getEngine().on( "update", this.editorUpdate, this );\r\n  this.getEntity().on( "editorSelected", this.onSelected, this );\r\n  this.getEntity().on( "editorUnselected", this.onUnselected, this );\r\n  var that = this;\r\n  VAPI.globalEvents.trigger(\'studioApp::isSelected\', this.getEntity(), function( selected ) {\r\n    if ( selected ) {\r\n      that.onSelected();\r\n    }\r\n  });\r\n};\r\n\r\nOrbitCamera.prototype.editorShutdown = function() {\r\n  this.shutdown();\r\n  this.getEngine().off( "update", this.editorUpdate, this );\r\n  this.getEntity().off( "editorSelected", this.onSelected, this );\r\n  this.getEntity().off( "editorUnselected", this.onUnselected, this );\r\n  this.getEntity().reset();\r\n  if ( this.transformControls ) {\r\n    this.transformControls.detach( this.pivotPoint );\r\n    if ( this.transformControls.parent ) {\r\n      this.transformControls.parent.remove( this.transformControls );\r\n    }\r\n    this.transformControls.destroy();\r\n  }\r\n  this.pivotPoint.visible = false;\r\n};\r\n\r\nOrbitCamera.prototype.onSelected = function() {\r\n  var that = this;\r\n  if ( !this.transformControls ) {\r\n    var editorCamera;\r\n    VAPI.globalEvents.trigger(\'studioApp::getCurrentCamera\', function( camera ) {\r\n      editorCamera = camera.threeData;\r\n    });\r\n    this.transformControls = new THREE.TransformControls( editorCamera, this.getEngine().canvas );\r\n    this.transformControls.size = 0.75;\r\n    // this.transformControls.addEventListener( \'change\', function( gizmo ) {\r\n    // });\r\n    this.transformControls.addEventListener( \'change_final\', function( gizmo ) {\r\n      that.setAttribute(\'targetOffset\', that.pivotPoint.position, { save: true } );\r\n    });\r\n    this.initTarget();\r\n  }\r\n  if ( this.isEnabled() ) {\r\n    this.transformControls.attach( this.pivotPoint );\r\n    this.pivotPoint.visible = true;\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onUnselected = function() {\r\n  if ( this.isEnabled() ) {\r\n    this.pivotPoint.visible = false;\r\n    if ( this.transformControls ) {\r\n      this.transformControls.detach( this.pivotPoint );\r\n    }\r\n    this.getEntity().reset();\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.editorUpdate = function( delta ) {\r\n  if ( this.isEnabled() && this.transformControls && this.pivotPoint.visible ) {\r\n    this.transformControls.update();\r\n    this.updateCamera( delta );\r\n\r\n    var editorCamera;\r\n    VAPI.globalEvents.trigger(\'studioApp::getCurrentCamera\', function( camera ) {\r\n      editorCamera = camera.threeData;\r\n    });\r\n    if ( this.pivotPoint.parent ) {\r\n      this._tempVector.subVectors( this.pivotPoint.getWorldPosition(), editorCamera.getWorldPosition() );\r\n      var distance = this._tempVector.length();\r\n      this.pivotPoint.scale.copy( this.pivotPoint.parent.getWorldScale() );\r\n      this.pivotPoint.scale.x = distance / this.pivotPoint.scale.x;\r\n      this.pivotPoint.scale.y = distance / this.pivotPoint.scale.y;\r\n      this.pivotPoint.scale.z = distance / this.pivotPoint.scale.z;\r\n      \r\n    }\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onEnable = function() {\r\n  if ( this.isEditor ) {\r\n    this.onSelected();\r\n  }\r\n  else {\r\n    this.getEntity().reset();\r\n    this.targetOffset = this.getAttribute( \'targetOffset\' );\r\n    this.attributesChanged( { targetOffset: this.targetOffset });\r\n    this.currentMoveSpeed.set( 0, 0 );\r\n    this.moveStart.copy( this.currentMousePosition );\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onDisable = function() {\r\n  if ( this.isEditor ) {\r\n    this.pivotPoint.visible = false;\r\n    this.transformControls.detach( this.pivotPoint );\r\n    this.getEntity().reset();\r\n  }\r\n  else {\r\n    this.getEntity().reset();\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.attributesChanged = function( changes ) {\r\n  if ( changes.targetObject !== undefined ) {\r\n    this.targetMoved = true;\r\n    // if ( !(changes.targetOffset && changes.targetOffset.x !== undefined) ) {\r\n    //   var that = this;\r\n    //   var offset = { x: 0, y: 0, z: 0};\r\n    //   that.setAttribute(\'targetOffset\', offset, { save: true } );\r\n    // }\r\n    this.initTarget();\r\n    \r\n    if ( this.isEditor ) {\r\n      this.pivotPoint.scale.copy( this.pivotPoint.parent.getWorldScale() );\r\n      this.pivotPoint.scale.x = 1.0 / this.pivotPoint.scale.x;\r\n      this.pivotPoint.scale.y = 1.0 / this.pivotPoint.scale.y;\r\n      this.pivotPoint.scale.z = 1.0 / this.pivotPoint.scale.z;\r\n    }\r\n  }\r\n  else if ( changes.targetOffset && changes.targetOffset.x !== undefined ) {\r\n    this.setTargetOffset( changes.targetOffset );\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.init = function() {\r\n  \r\n  var engine = this.getEngine();\r\n  \r\n  if ( this.usePointerLock ) {\r\n    this.togglePointerLock( true );\r\n  }\r\n  this.pitchAngleBoundsRadians.max = Math.PI * this.pitchAngleBounds.max / 180.0;\r\n  this.pitchAngleBoundsRadians.min = Math.PI * this.pitchAngleBounds.min / 180.0;\r\n\r\n  this.getEntity().when(\'load_base\', this.initTarget, this );\r\n  this.on( \'enable\', this.onEnable, this );\r\n  this.on( \'disable\', this.onDisable, this );\r\n  \r\n  if ( !this.isEditor ) {\r\n    if ( window.VAPI.isMobile() ) {\r\n      engine.on( \'touchStart\', this.onTouchStart, this );\r\n      engine.on( \'touchMove\', this.onTouchMove, this );\r\n      engine.on( \'touchEnd\', this.onTouchEnd, this );\r\n    }\r\n    else {\r\n      engine.on( \'mouseUp\', this.onMouseUp, this );\r\n      engine.on( \'mouseDown\', this.onMouseDown, this );\r\n      engine.on( \'mouseMove\', this.onMouseMove, this );\r\n      engine.on( \'mouseScroll\', this.onMouseScroll, this );\r\n    }\r\n  }\r\n\r\n  this.getEntity().on(\'enableOrbitCameraController\', this.orbitCameraEnable, this);\r\n  this.getEntity().on(\'disableOrbitCameraController\', this.orbitCameraDisable, this);\r\n  this.getEntity().on(\'toggleOrbitCameraController\', this.orbitCameraToggle, this);\r\n  this.getEntity().on(\'setOrbitDistance\', this.setOrbitDistance, this);\r\n  this.getEntity().on(\'setTarget\', this.setTarget, this);\r\n  this.getEntity().on(\'focusOnTarget\', this.focusOnTarget, this);\r\n};\r\n\r\nOrbitCamera.prototype.shutdown = function() {\r\n  // make sure to clean up any events or other bindings that you have created\r\n  // to avoid memory leaks\r\n  var engine = this.getEngine();\r\n  this.off( \'enable\', this.onEnable, this );\r\n  this.off( \'disable\', this.onDisable, this );\r\n\r\n  if ( window.VAPI.isMobile() ) {\r\n    engine.off( \'touchStart\', this.onTouchStart, this );\r\n    engine.off( \'touchMove\', this.onTouchMove, this );\r\n    engine.off( \'touchEnd\', this.onTouchEnd, this );\r\n  }\r\n  else {\r\n    engine.off( \'mouseUp\', this.onMouseUp, this );\r\n    engine.off( \'mouseDown\', this.onMouseDown, this );\r\n    engine.off( \'mouseMove\', this.onMouseMove, this );\r\n    engine.off( \'mouseScroll\', this.onMouseScroll, this );\r\n  }\r\n  \r\n  this.togglePointerLock( false );\r\n\r\n  this.getEntity().off(\'enableOrbitCameraController\', this.orbitCameraEnable, this);\r\n  this.getEntity().off(\'disableOrbitCameraController\', this.orbitCameraDisable, this);\r\n  this.getEntity().off(\'toggleOrbitCameraController\', this.orbitCameraToggle, this);\r\n  this.getEntity().off(\'setOrbitDistance\', this.setOrbitDistance, this);\r\n  this.getEntity().off(\'setTarget\', this.setTarget, this);\r\n  this.getEntity().off(\'focusOnTarget\', this.focusOnTarget, this);\r\n};\r\n\r\nOrbitCamera.prototype.objectCreated = function() {\r\n  this.quaternionStart.copy( this.getThreeData().quaternion );\r\n  this.eulerStart.setFromQuaternion( this.quaternionStart, \'YXZ\' );\r\n};\r\n\r\n//Sets the orbit point to that defined by targetObject and targetOffset.\r\nOrbitCamera.prototype.initTarget = function() {\r\n  var that = this;\r\n\r\n  // that._tempVector.set(0,0,0);\r\n    \r\n  this.getScene().when(\'load_hierarchy\', function() {\r\n    if ( that.targetObject && that.targetObject !== that.getEntity() && that.targetObject.threeData ) {\r\n      that.targetObject.threeData.add( that.pivotPoint );\r\n      that.pivotPoint.position.copy( that.targetOffset );\r\n    }\r\n    else {\r\n      that.getThreeScene().add( that.pivotPoint );\r\n      that.pivotPoint.position.copy( that.targetOffset );\r\n    }\r\n    if ( that.isEditor && that.transformControls ) {\r\n      that.getThreeScene().add( that.transformControls );\r\n    }\r\n\r\n  }, this );\r\n\r\n};\r\n\r\nOrbitCamera.prototype.setTargetOffset = function( newOffset, options ) {\r\n  this.targetMoved = true;\r\n  this.pivotPoint.position.copy( newOffset );\r\n  var json = { x: newOffset.x, y: newOffset.y, z: newOffset.z };\r\n  this.setAttribute(\'targetOffset\', json, options );\r\n};\r\n\r\nOrbitCamera.prototype.setOrbitDistance = function( newDistance ) {\r\n  this.newOrbitDistance = newDistance;\r\n};\r\n\r\nOrbitCamera.prototype.setTarget = function( newObjectId, center, options ) {\r\n  if ( _.isString( newObjectId ) || !newObjectId ) {\r\n    this.setAttribute(\'targetObject\', newObjectId );\r\n  }\r\n  else if ( _.isObject( newObjectId ) && newObjectId.id ) {\r\n    this.setAttribute(\'targetObject\', newObjectId.id );\r\n  }\r\n  if ( center ) {\r\n    this.lookAtCenter( options );\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.lookAtCenter = function( options ) {\r\n  this.targetMoved = true;\r\n  var json = { x: 0, y: 0, z: 0 };\r\n  if ( this.targetObject ) {\r\n    var center = this.targetObject.getCenter();\r\n    this.pivotPoint.position.copy( center );\r\n    json = { x: center.x, y: center.y, z: center.z };\r\n  }\r\n  this.setAttribute(\'targetOffset\', json, options );\r\n};\r\n\r\nOrbitCamera.prototype.focusOnTarget = function() {\r\n  //adjust target offset to point to centre of object\r\n  //call setOrbitDistance to cause the target to fill the field of view\r\n  if ( this.targetObject ) {\r\n    \r\n    this.lookAtCenter();\r\n    var newDistance;\r\n    var bb = this.targetObject.getProperty("boundingbox");\r\n    if ( bb ) {\r\n      var dist = new THREE.Vector3();\r\n      dist.set( bb.max.x - bb.min.x, bb.max.y - bb.min.y, bb.max.z - bb.min.z);\r\n      var scale;\r\n      if ( this.targetObject.threeData ) {\r\n        this.targetObject.threeData.updateMatrixWorld();\r\n        scale = new THREE.Vector3();\r\n        scale.setFromMatrixScale( this.targetObject.threeData.matrixWorld );\r\n      }\r\n      else {\r\n        scale = this.targetObject.getScale();\r\n      }\r\n      dist.multiply( scale );\r\n      var size = dist.length();\r\n      if ( this.getEntity().getProperty("type") === "PerspectiveCamera") {\r\n        newDistance = Math.abs( size / (2.0 * Math.tan( this.getEntity().getProperty("fov") * Math.PI / 360.0 )) );\r\n      }\r\n      else {\r\n        newDistance = 0.5 * (this.getEntity().getProperty("near") + this.getEntity().getProperty("far"));\r\n      }\r\n      \r\n      newDistance = Math.max( Math.min( newDistance, this.orbitDistanceMax ), this.orbitDistanceMin );\r\n    }\r\n    else {\r\n      this._tempVector.subVectors( this.getEntity().getPosition(), this.targetObject.getProperty("position") );\r\n      newDistance = Math.max( Math.min( this._tempVector.length(), this.orbitDistanceMax ), this.orbitDistanceMin );\r\n    }\r\n    this.setOrbitDistance( newDistance );\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Called per VeroldEngine update (per frame)\r\n * @param  {float} delta The number of seconds since the last call to `update`\r\n */\r\nOrbitCamera.prototype.preUpdate = function( delta ) {\r\n\r\n  if (this.hasThreeData() && this.isEnabled() ) {\r\n\r\n    //Check WASD state and move camera appropriately\r\n    //Also check for modifier keys like ctrl and cmd. If these are pressed,\r\n    //don\'t move the camera.\r\n    var input = this.getInput();\r\n    var modKey = input.keyDown("ctrl") || input.keyDown("cmd");\r\n    var forwardKey = input.keyDown("upArrow") || input.keyDown("W");\r\n    var backwardKey = input.keyDown("downArrow") || input.keyDown("S");\r\n    var leftKey = input.keyDown("leftArrow") || input.keyDown("A");\r\n    var rightKey = input.keyDown("rightArrow") || input.keyDown("D");\r\n\r\n    if ( !modKey && ( forwardKey || backwardKey || leftKey || rightKey ) ) {\r\n\r\n      if ( this.enableZoom ) {\r\n        if ( forwardKey ) {\r\n          this.zoomDelta = -delta;\r\n        }\r\n        else if ( backwardKey ) {\r\n          this.zoomDelta = delta;\r\n        }\r\n        // this.linearMovementDeltaLength = this.linearMovementDelta.length();\r\n      }\r\n      if ( this.enablePan ) {\r\n        if ( rightKey ) {\r\n          this.linearMovementDelta.x = -delta;\r\n        }\r\n        else if ( leftKey ) {\r\n          this.linearMovementDelta.x = delta;\r\n        }\r\n        // this.linearMovementDeltaLength = this.linearMovementDelta.length();\r\n      }\r\n    }\r\n    this.updateCamera( delta );\r\n\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.postUpdate = function() {\r\n  this.hasChanged = false;\r\n};\r\n\r\nOrbitCamera.prototype.updateCamera = function( delta ) {\r\n\r\n  var input = this.getInput();\r\n  \r\n  //Handle speed modifier keys\r\n  var speedMod = 1.0;\r\n  if ( input.keyDown( "shift" ) ) {\r\n    speedMod = 5.0;\r\n  }\r\n  // else if ( this.getInput().keyDown( "ctrl" ) ) {\r\n  //   speedMod = 0.25;\r\n  // }\r\n\r\n  //If there is any user control, reset the ellapsed time.\r\n  if ( this.isMouseDragging || this.zoomDelta ) {\r\n    this.ellapsedTimeSinceInput = 0.0;\r\n  }\r\n  else {\r\n    this.ellapsedTimeSinceInput += delta;\r\n  }\r\n  \r\n  this.orbitMovement.copy( this.currentMousePosition );\r\n  this.orbitMovement.sub( this.moveStart );\r\n  this.orbitMovement.multiplyScalar( 6.0 * speedMod * this.lookSpeed );\r\n  \r\n  var threeData = this.getThreeData();\r\n  var damping = Math.max( 0.0, Math.min( delta * 33.3 * this.inertialDamping, 1.0) );\r\n  var oneMinusDamping = 1.0 - damping;\r\n  var interpDistance = 0.0;\r\n  \r\n  //Handle inverting the controls\r\n  if ( this.invertX ) {\r\n    this.orbitMovement.x *= -1.0;\r\n    this.linearMovementDelta.x *= -1.0;\r\n  }\r\n  if ( this.invertY ) {\r\n    this.orbitMovement.y *= -1.0;\r\n    this.linearMovementDelta.y *= -1.0;\r\n  }\r\n  if ( this.invertZoom ) {\r\n    this.zoomDelta *= -1.0;\r\n  }\r\n\r\n  //Look at current angular movement since the start of control and clamp the min/max pitch.\r\n  this.tempEuler.copy( this.eulerStart );\r\n  this.tempEuler.x -= this.orbitMovement.y;\r\n  this.tempEuler.y -= this.orbitMovement.x;\r\n  if ( this.tempEuler.x > this.pitchAngleBoundsRadians.max ) {\r\n    this.tempEuler.x = this.pitchAngleBoundsRadians.max;\r\n  }\r\n  else if ( this.tempEuler.x < this.pitchAngleBoundsRadians.min ) {\r\n    this.tempEuler.x = this.pitchAngleBoundsRadians.min;\r\n  }\r\n\r\n  //Handle automatic orbiting when there has been to user input for a given amount of time.\r\n  if ( this.autoOrbit && !this.isEditor && this.ellapsedTimeSinceInput > this.autoOrbitDelay ) {\r\n    //update cursor position so that when we zoom/move the camera, it won\'t attempt to force itself to where it began rotating from(the jitter)\r\n    this.currentMousePosition.x -= ((this.autoOrbitSpeed * 0.1 * Math.min(1.0, this.ellapsedTimeSinceInput - this.autoOrbitDelay)) % (2.0 * Math.PI)) * delta;\r\n    this.autoOrbitOn = true;\r\n  }\r\n  \r\n  // Handle panning of the camera\r\n  this.linearMovementDelta.multiplyScalar( speedMod * this.movementSpeed );\r\n  this.currentMoveSpeed.x = oneMinusDamping * this.currentMoveSpeed.x + damping * this.linearMovementDelta.x;\r\n  this.currentMoveSpeed.y = oneMinusDamping * this.currentMoveSpeed.y + damping * this.linearMovementDelta.y;\r\n  if ( Math.abs( this.currentMoveSpeed.y ) < 0.0001 && Math.abs( this.currentMoveSpeed.x ) < 0.0001 ) {\r\n    this.currentMoveSpeed.set( 0, 0 );\r\n  }\r\n  \r\n  if ( this.currentMoveSpeed.x || this.currentMoveSpeed.y ) {\r\n    //If there is panning movement, shift the location of the pivot point.\r\n    this._tempVector.set( -this.currentMoveSpeed.x, this.currentMoveSpeed.y, 0.0 );\r\n    // this._tempVector.x *= -1.0;\r\n    this._tempVector.applyQuaternion( threeData.quaternion );\r\n    this._tempMatrix4.getInverse( this.pivotPoint.matrixWorld );\r\n    this._tempVector4.set( this._tempVector.x, this._tempVector.y, this._tempVector.z, 0.0 );\r\n    this._tempVector4.applyMatrix4( this._tempMatrix4 );\r\n    \r\n    this._tempVector.set( this._tempVector4.x, this._tempVector4.y, this._tempVector4.z );\r\n    \r\n    this.pivotPoint.position.add( this._tempVector );\r\n    //Get the world-space position of the pivot point.\r\n    this.pivotPoint.getWorldPosition( this._pivotWorldPos );\r\n  }\r\n  else {\r\n    //Otherwise, just update the world-space position of the pivot point.\r\n    this._pivotWorldPos.setFromMatrixPosition( this.pivotPoint.matrixWorld );\r\n  }\r\n\r\n  //Handle zoom\r\n  //Calculate the distance to orbit at.\r\n  this._tempVector.subVectors( this._pivotWorldPos, threeData.position );\r\n  var currentDistance = this._tempVector.length();\r\n  var targetDistance;\r\n  //If the user is actively zooming or if no new target distance is set and the inertia of the camera is still moving it.\r\n  if ( this.zoomDelta || !this.newOrbitDistance ) {\r\n    this.newOrbitDistance = 0.0;\r\n    this.currentZoomSpeed = oneMinusDamping * this.currentZoomSpeed + damping * speedMod * 0.1 * this.movementSpeed * this.zoomDelta;\r\n    if ( Math.abs( this.currentZoomSpeed ) < 0.0001 ) {\r\n      this.currentZoomSpeed = 0.0;\r\n    }\r\n    var newDistance = currentDistance + this.currentZoomSpeed * this.currentOrbitDistance;\r\n    targetDistance = Math.min( this.orbitDistanceMax, Math.max( this.orbitDistanceMin, newDistance ));\r\n    interpDistance = (targetDistance - currentDistance);\r\n    this.currentOrbitDistance = targetDistance;\r\n  }\r\n  //If we still have a new orbit distance defined, we\'ll try to move to that.\r\n  else {\r\n    targetDistance = Math.min( this.orbitDistanceMax, Math.max( this.orbitDistanceMin, this.newOrbitDistance ));\r\n    if ( this.interpolation ) {\r\n      interpDistance = (targetDistance - currentDistance);\r\n      this.currentOrbitDistance = interpDistance * 10.0 * this.interpSpeed * delta + currentDistance;\r\n    }\r\n    else {\r\n      this.currentOrbitDistance = targetDistance;\r\n    }\r\n    if ( Math.abs( this.currentOrbitDistance - this.newOrbitDistance ) < 0.0001 ) {\r\n      this.newOrbitDistance = 0.0;\r\n    }\r\n  }\r\n  \r\n  //If the camera is being controlled, use the current x,y rotation speed\r\n  //to determine the new quaternion for the camera\r\n  if ( this.isMouseDragging || this.zoomDelta || !this.targetMoved || this.autoOrbitOn ) {\r\n    this.targetMoved = false;\r\n    this.tempQuaternion.setFromEuler( this.tempEuler );\r\n    threeData.quaternion.slerp( this.tempQuaternion, this.inertialDamping );\r\n    threeData.position.set( 0, 0, this.currentOrbitDistance );\r\n    threeData.position.applyQuaternion( threeData.quaternion );\r\n    threeData.position.add( this._pivotWorldPos );\r\n    threeData.lookAt( this._pivotWorldPos );\r\n  }\r\n  else {\r\n    \r\n    // //If the camera isn\'t being controlled by the user, continue interpolating to the desired position/orientation\r\n    if ( this.interpolation ) {\r\n      // lerp the current orientation towards the assigned pivot.\r\n      this.tempCamera.position.copy( threeData.position );\r\n      this.tempCamera.lookAt( this._pivotWorldPos );\r\n      \r\n      threeData.quaternion.slerp( this.tempCamera.quaternion, 0.1 * this.interpSpeed );\r\n\r\n      //Set the camera\'s position using the orientation and orbit distance\r\n      if ( interpDistance ) {\r\n        this._tempVector.set( 0, 0, 1 );\r\n        // this._tempVector.set( 0, 0, this.currentOrbitDistance );\r\n        this._tempVector.applyQuaternion( this.tempCamera.quaternion );\r\n        this._tempVector.multiplyScalar( interpDistance * 10.0 * this.interpSpeed * delta );\r\n\r\n        threeData.position.add( this._tempVector );\r\n      }\r\n    }\r\n    else {\r\n      threeData.lookAt( this._pivotWorldPos );\r\n      threeData.position.set( 0, 0, this.currentOrbitDistance );\r\n      threeData.position.applyQuaternion( threeData.quaternion );\r\n      threeData.position.add( this._pivotWorldPos );\r\n    }\r\n  }\r\n\r\n  this.getEngine().needsRender = true;\r\n  this.hasChanged = true;\r\n\r\n  this.orbitMovement.set( 0.0, 0.0 );\r\n  this.linearMovementDelta.set( 0.0, 0.0, 0.0 );\r\n  this.zoomDelta = 0.0;\r\n\r\n};\r\n\r\n\r\nOrbitCamera.prototype.orbitCameraEnable = function( blendTime ) {\r\n  this.enable();\r\n};\r\n\r\nOrbitCamera.prototype.orbitCameraDisable = function( ) {\r\n  this.disable();\r\n};\r\n\r\nOrbitCamera.prototype.orbitCameraToggle = function( ) {\r\n  if ( this.isEnabled() ) {\r\n    this.disable();\r\n  }\r\n  else {\r\n    this.enable();\r\n  }\r\n  if ( this.usePointerLock && !this.isEnabled() ) {\r\n    document.exitPointerLock();\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.getEulerAngles = function( outEuler ) {\r\n  var returnVector = outEuler;\r\n  if ( !outEuler ) {\r\n    returnVector = new THREE.Euler();\r\n  }\r\n  returnVector.setFromQuaternion( this.getThreeData().quaternion, \'YXZ\' );\r\n\r\n  return returnVector;\r\n};\r\n\r\nOrbitCamera.prototype.setEulerAngles = function( euler ) {\r\n  this.getThreeData().quaternion.setFromEuler( euler );\r\n};\r\n\r\nOrbitCamera.prototype.togglePointerLock = function( on ) {\r\n  this.usePointerLock = on;\r\n\r\n  if ( this.usePointerLock ) {\r\n    this.getThreeRenderer().domElement.addEventListener( \'mousedown\', this.onMouseDown_PointerLock );\r\n   }\r\n  else {\r\n    this.getThreeRenderer().domElement.removeEventListener( \'mousedown\', this.onMouseDown_PointerLock );\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onMouseDown = function( event ) {\r\n  if ( this.isEnabled() ) {\r\n    var input = this.getInput();\r\n    var rightButton = input.mouseButtonDown("right");\r\n    var leftButton = input.mouseButtonDown("left");\r\n    this.pan = false;\r\n    this.look = false;\r\n    if ( ( rightButton ) && this.enablePan ) {\r\n      this.pan = true;\r\n    }\r\n    else if ( leftButton ) {\r\n      this.look = true;\r\n    }\r\n\r\n    this.moveStart.x = event.scenePercentX;\r\n    this.moveStart.y = event.scenePercentY;\r\n    this.currentMousePosition.copy( this.moveStart );\r\n    // this.positionStart.copy( this.getThreeData().position );\r\n    this.quaternionStart.copy( this.getThreeData().quaternion );\r\n    this.eulerStart.setFromQuaternion( this.quaternionStart, \'YXZ\' );\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onMouseUp = function( event ) {\r\n  if ( this.isEnabled() ) {\r\n    var input = this.getInput();\r\n    var rightButton = input.mouseButtonDown("right");\r\n    var leftButton = input.mouseButtonDown("left");\r\n    this.pan = false;\r\n    this.look = false;\r\n    \r\n    if ( ( rightButton ) && this.enablePan ) {\r\n      this.pan = true;\r\n    }\r\n    else if ( leftButton ) {\r\n      this.look = true;\r\n    }\r\n    else {\r\n      this.isMouseDragging = false;\r\n    }\r\n    // this.moveStart.x = event.scenePercentX;\r\n    // this.moveStart.y = event.scenePercentY;\r\n    // this.positionStart.set( 0.0, 0.0, 0.0 );\r\n    // this.quaternionStart.set( 0.0, 0.0, 0.0, 1.0 );\r\n    // console.log("Mode is " + this.mode );\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onMouseDown_PointerLock = function( event ) {\r\n  if ( this.isEnabled() && event.button === 0 || event.button === 2 ) {\r\n    this.getThreeRenderer().domElement.requestPointerLock();\r\n\r\n    this.getThreeRenderer().domElement.addEventListener( \'mouseup\', this.onMouseUp_PointerLock );\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onMouseUp_PointerLock = function( event ) {\r\n  if ( this.veroldEntity ) {\r\n    if ( event.button === 2 && this.getInput().mouseButtonUp( "left" ) || event.button === 0 && this.getInput().mouseButtonUp( "right" ) ) {\r\n      this.getThreeRenderer().domElement.removeEventListener( \'mouseup\', this.onMouseUp_PointerLock );\r\n      document.exitPointerLock();\r\n    }\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onMouseMove = function( event ) {\r\n  if ( this.isEnabled() ) {\r\n    var input = this.getInput();\r\n    var rightButton = input.mouseButtonDown("right");\r\n    var leftButton = input.mouseButtonDown("left");\r\n\r\n    if ( ( rightButton ) && this.enablePan ) {\r\n\r\n      this.isMouseDragging = true;\r\n      this.linearMovementDelta.x = event.scenePercentDeltaX;\r\n      this.linearMovementDelta.y = event.scenePercentDeltaY;\r\n    }\r\n    else if ( leftButton ) {\r\n      this.isMouseDragging = true;\r\n      this.currentMousePosition.x = event.scenePercentX;\r\n      this.currentMousePosition.y = event.scenePercentY;\r\n    }\r\n    // this.eulerEllapsed.add( event.scenePercentDeltaX, event.scenePercentDeltaY );\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onMouseScroll = function( delta ) {\r\n  if ( this.isEnabled() && _.isNumber( delta ) && this.enableZoom ) {\r\n    this.zoomDelta = -delta * 0.1;\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onTouchStart = function( event ) {\r\n\r\n  if ( this.isEnabled() ) {\r\n\r\n    var touches = event.touches;\r\n    if ( !touches ) {\r\n      return;\r\n    }\r\n\r\n    switch ( touches.length ) {\r\n\r\n    case 1: // one-fingered touch: rotate\r\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\r\n\r\n      this.look = true;\r\n      this.pan = false;\r\n      this.zoom = false;\r\n      \r\n      break;\r\n\r\n    case 2: // two-fingered touch: dolly\r\n      \r\n      this.look = false;\r\n      this.pan = false;\r\n      this.zoom = false;\r\n      if ( this.enableZoom ) {\r\n        this.zoom = true;\r\n        var dx = touches[ 0 ].scenePercentX - touches[ 1 ].scenePercentX;\r\n        var dy = touches[ 0 ].scenePercentY - touches[ 1 ].scenePercentY;\r\n        var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n        this.touchLastPinchDist = distance;\r\n        // this.touchYStart = touches[ 0 ].scenePercentY;\r\n      }\r\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\r\n      break;\r\n\r\n    case 3: // three-fingered touch: pan\r\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\r\n      this.look = false;\r\n      this.pan = false;\r\n      if ( this.enablePan ) {\r\n        this.pan = true;\r\n      }\r\n      this.zoom = false;\r\n      break;\r\n\r\n    default:\r\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\r\n      this.touchLastPinchDist = -1;\r\n    }\r\n\r\n    this.moveStart.x = touches[ 0 ].scenePercentX;\r\n    this.moveStart.y = touches[ 0 ].scenePercentY;\r\n    this.currentMousePosition.copy( this.moveStart );\r\n    // this.positionStart.copy( this.getThreeData().position );\r\n    this.quaternionStart.copy( this.getThreeData().quaternion );\r\n    this.eulerStart.setFromQuaternion( this.quaternionStart, \'YXZ\' );\r\n\r\n  }\r\n\r\n  this.isTouchDragging = false;\r\n};\r\n\r\nOrbitCamera.prototype.onTouchMove = function( event ) {\r\n\r\n  if ( this.isEnabled() ) {\r\n    // this.touchInProgress = true;\r\n    var touches = event.touches;\r\n    if ( !touches ) {\r\n      return;\r\n    }\r\n    // var speedMod = 0.3;\r\n    var dx, dy;\r\n    switch ( touches.length ) {\r\n\r\n    case 1: // one-fingered touch: rotate\r\n      this.look = true;\r\n      this.pan = false;\r\n      this.zoom = false;\r\n\r\n      this.touchLast.x = touches[ 0 ].scenePercentX;\r\n      this.touchLast.y = touches[ 0 ].scenePercentY;\r\n      this.isMouseDragging = true;\r\n      // this.ellapsedTimeSinceInput = 0;\r\n\r\n      if(!this.isTouchDragging){\r\n        if(this.moveStart.distanceTo(this.touchLast) > 0.01){\r\n          this.isTouchDragging = true;\r\n        }\r\n      }\r\n      else {\r\n        this.currentMousePosition.x = touches[ 0 ].scenePercentX;\r\n        this.currentMousePosition.y = touches[ 0 ].scenePercentY;\r\n      }\r\n\r\n      break;\r\n\r\n    case 2: // two-fingered touch: dolly\r\n\r\n      this.look = false;\r\n      this.pan = false;\r\n      this.zoom = false;\r\n      if ( this.enableZoom ) {\r\n        // this.isMouseDragging = true;\r\n        this.zoom = true;\r\n        dx = touches[ 0 ].scenePercentX - touches[ 1 ].scenePercentX;\r\n        dy = touches[ 0 ].scenePercentY - touches[ 1 ].scenePercentY;\r\n        var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n        var pinchChange = this.touchLastPinchDist - distance;\r\n        var scrollChange = this.touchLast.y - touches[ 0 ].scenePercentY;\r\n        // var scrollChange = 0;\r\n        if ( Math.abs( pinchChange ) > Math.abs( scrollChange ) ) {\r\n          this.zoomDelta = 20.0 * pinchChange;\r\n        }\r\n        else {\r\n          this.zoomDelta = 20.0 * scrollChange;\r\n        }\r\n      \r\n        this.touchLastPinchDist = distance;\r\n      }\r\n      this.touchLast.x = touches[ 0 ].scenePercentX;\r\n      this.touchLast.y = touches[ 0 ].scenePercentY;\r\n\r\n      break;\r\n\r\n    case 3: // three-fingered touch: pan\r\n      this.look = false;\r\n      this.pan = false;\r\n      this.zoom = false;\r\n      if ( this.enablePan ) {\r\n        this.isMouseDragging = true;\r\n        this.pan = true;\r\n        dx = touches[ 0 ].scenePercentX - this.touchLast.x;\r\n        dy = touches[ 0 ].scenePercentY - this.touchLast.y;\r\n\r\n        this.linearMovementDelta.x = dx;\r\n        this.linearMovementDelta.y = dy;\r\n      }\r\n\r\n      this.touchLast.x = touches[ 0 ].scenePercentX;\r\n      this.touchLast.y = touches[ 0 ].scenePercentY;\r\n\r\n      break;\r\n    }\r\n\r\n  }\r\n};\r\n\r\nOrbitCamera.prototype.onTouchEnd = function( event ) {\r\n\r\n  if ( this.isEnabled() ) {\r\n    this.touchLast.set( -1.0, -1.0 );\r\n    this.touchLastPinchDist = -1;\r\n    var touches = event.touches;\r\n    \r\n    switch ( touches.length ) {\r\n\r\n    case 0:\r\n      this.isMouseDragging = false;\r\n      this.look = false;\r\n      this.pan = false;\r\n      this.zoom = false;\r\n      break;\r\n    case 1: // one-fingered touch: rotate\r\n      this.look = true;\r\n      this.pan = false;\r\n      this.zoom = false;\r\n      \r\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\r\n      this.moveStart.x = touches[ 0 ].scenePercentX;\r\n      this.moveStart.y = touches[ 0 ].scenePercentY;\r\n      this.currentMousePosition.copy( this.moveStart );\r\n      // this.positionStart.copy( this.getThreeData().position );\r\n      this.quaternionStart.copy( this.getThreeData().quaternion );\r\n      this.eulerStart.setFromQuaternion( this.quaternionStart, \'YXZ\' );\r\n      break;\r\n\r\n    case 2: // two-fingered touch: dolly\r\n\r\n      this.look = false;\r\n      this.pan = false;\r\n      this.zoom = false;\r\n      if ( this.enableZoom ) {\r\n        this.zoom = true;\r\n        var dx = touches[ 0 ].scenePercentX - touches[ 1 ].scenePercentX;\r\n        var dy = touches[ 0 ].scenePercentY - touches[ 1 ].scenePercentY;\r\n        var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n        this.touchLastPinchDist = distance;\r\n      }\r\n      // this.touchYStart = touches[ 0 ].scenePercentY;\r\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\r\n      break;\r\n\r\n    case 3: // three-fingered touch: pan\r\n      this.look = false;\r\n      this.pan = false;\r\n      if ( this.enablePan ) {\r\n        this.pan = true;\r\n      }\r\n      this.zoom = false;\r\n\r\n      this.touchLast.set( touches[ 0 ].scenePercentX, touches[ 0 ].scenePercentY );\r\n      break;\r\n\r\n    default:\r\n\r\n    }\r\n\r\n    this.isTouchDragging = false;\r\n  }\r\n};\r\n\r\nreturn OrbitCamera;\r\n';});


define('text!VeroldEngine/Components/BuiltIn/SkyboxRenderer.js',[],function () { return '/**\n * A skybox component class.\n *\n * @class Component\n */\nfunction SkyboxRenderer() {\n  this.skyboxScene = null;\n  this.skyboxMesh = null;\n  this.skyboxGeometry = null;\n  this.skyboxMaterialCube = null;\n  this.skyboxMaterial2D = null;\n  this.skyboxUniforms = null;\n  this.skyboxVShader = null;\n  this.skyboxPShader = null;\n  this.renderer = null;\n\n  this.skyboxTexture = null;\n  this.size = 10000.0;\n  this.isEditor = false;\n}\n\nSkyboxRenderer.prototype = new VAPI.VeroldComponent();\n\nSkyboxRenderer.prototype.editorInit = function() {\n  this.isEditor = true;\n  this.init();\n  this.getEntity().when(\'load\', this.objectLoaded, this );\n};\n\nSkyboxRenderer.prototype.init = function() {\n\n  this.renderer = this.getThreeRenderer();\n  \n  this.createGeometry();\n  this.createScene();\n\n  this.skyboxRenderPass = new THREE.RenderPass( this.skyboxScene );\n  this.skyboxRenderPass.clear = true;\n  this.skyboxRenderPass.enabled = false;\n\n  this.createMaterial();\n  this.initTexture();\n  this.createMesh();\n  \n  this.mainScene = this.getEntity().getParentAsset();\n  \n  this.on(\'enable\', this.enable, this );\n  this.on(\'disable\', this.disable, this );\n  this.getEntity().on(\'setSkyboxTexture\', this.setSkyboxTexture, this );\n  this.getEngine().on(\'rebuildMaterials\', this.rebuildMaterials, this );\n};\n\nSkyboxRenderer.prototype.editorShutdown = function() {\n\n  this.shutdown();\n};\n\nSkyboxRenderer.prototype.shutdown = function() {\n  this.off(\'enable\', this.enable, this );\n  this.off(\'disable\', this.disable, this );\n  this.getEngine().off(\'rebuildMaterials\', this.rebuildMaterials, this );\n  this.getEntity().off(\'setSkyboxTexture\', this.setSkyboxTexture, this );\n  if ( this.skyboxScene ) {\n    this.skyboxScene.remove( this.skyboxMesh );\n  }\n  this.skyboxGeometry.dispose();\n  this.skyboxMaterialCube.dispose();\n  this.skyboxMaterial2D.dispose();\n  this.skyboxScene = null;\n  this.skyboxMesh = null;\n  this.skyboxGeometry = null;\n  this.skyboxMaterialCube = null;\n  this.skyboxMaterial2D = null;\n  this.skyboxUniforms = null;\n  this.skyboxTexture = null;\n};\n\nSkyboxRenderer.prototype.createScene = function() {\n  this.skyboxScene = new THREE.Scene();\n};\n\nSkyboxRenderer.prototype.attributesChanged = function( changed ) {\n  if ( changed.skyboxTexture !== undefined ) {\n    this.initTexture();\n    this.skyboxMesh.material = this.currentMaterial;\n  }\n  if ( changed.color ) {\n    this.skyboxUniforms.color.value = this.color;\n  }\n  if ( changed.skyboxFogScale !== undefined ) {\n    this.skyboxMaterialCube.uniforms.skyboxFogScale.value = this.skyboxFogScale;\n    this.skyboxMaterial2D.uniforms.skyboxFogScale.value = this.skyboxFogScale;\n  }\n  if ( changed.skyboxFogPower !== undefined ) {\n    this.skyboxMaterialCube.uniforms.skyboxFogPower.value = this.skyboxFogPower;\n    this.skyboxMaterial2D.uniforms.skyboxFogPower.value = this.skyboxFogPower;\n  }\n  if ( this.skyboxScene && this.mainScene.threeData ) {\n    this.skyboxUniforms.fogColor.value = this.mainScene.threeData.fog.color;\n  }\n};\n\nSkyboxRenderer.prototype.enable = function() {\n  if ( this.skyboxScene ) {\n    this.skyboxScene.add( this.skyboxMesh );\n    if ( !this.skyboxTexture.isLoaded() ) {\n      this.skyboxTexture.load();\n    }\n  }\n};\n\nSkyboxRenderer.prototype.disable = function() {\n  if ( this.skyboxScene ) {\n    this.skyboxScene.remove( this.skyboxMesh );\n  }\n};\n\nSkyboxRenderer.prototype.objectLoaded = function() {\n  // if ( this.isEnabled() ) {\n    this.getRenderer().addRenderPass( this.skyboxRenderPass, -1 );\n    this.skyboxUniforms.fogColor.value = this.mainScene.threeData.fog.color;\n    this.rebuildMaterials();\n  // }\n};\n\nSkyboxRenderer.prototype.createGeometry = function() {\n  this.skyboxGeometry = new THREE.BoxGeometry( this.size, this.size, this.size, 1, 1, 1 );\n  //this.skyboxGeometry.computeTangents();\n  this.skyboxGeometry.dynamic = false;\n};\n\nSkyboxRenderer.prototype.createMesh = function() {\n  this.skyboxMesh = new THREE.Mesh( this.skyboxGeometry, this.currentMaterial );\n  this.skyboxMesh.frustumCulled = false;\n  this.skyboxMesh.castShadow = false;\n  this.skyboxMesh.receiveShadow = false;\n  this.skyboxMesh.name = "Skybox";\n  if ( this.isEnabled() ) {\n    this.skyboxScene.add( this.skyboxMesh );\n  }\n};\n\nSkyboxRenderer.prototype.initTexture = function() {\n  if ( !this.skyboxTexture ) {\n    this.skyboxTexture = this.getAssetRegistry().Textures.getAssetById(\'white_cube\');\n    this.currentMaterial = this.skyboxMaterialCube;\n  }\n  if ( this.skyboxTexture.type === "textureCube" || this.skyboxTexture.type === "renderTextureCube" ) {\n    this.currentMaterial = this.skyboxMaterialCube;\n  }\n  else {\n    this.currentMaterial = this.skyboxMaterial2D;\n  }\n  if ( this.skyboxTexture.getPixelFormat() === \'rgbm\' ) {\n    this.currentMaterial.defines[\'HDR_INPUT\'] = "";\n    this.currentMaterial.defines[\'ENVMAP_HDR_INPUT\'] = THREE.HDRRGBM;\n  }\n  else if ( this.skyboxTexture.getPixelFormat() === \'rgbd\' ) {\n    this.currentMaterial.defines[\'HDR_INPUT\'] = "";\n    this.currentMaterial.defines[\'ENVMAP_HDR_INPUT\'] = THREE.HDRRGBD;\n  }\n  else if ( this.skyboxTexture.getPixelFormat() === \'rgbe\' ) {\n    this.currentMaterial.defines[\'HDR_INPUT\'] = "";\n    this.currentMaterial.defines[\'ENVMAP_HDR_INPUT\'] = THREE.HDRRGBE;\n  }\n  else {\n    delete this.currentMaterial.defines[\'HDR_INPUT\'];\n    delete this.currentMaterial.defines[\'ENVMAP_HDR_INPUT\'];\n  }\n\n  this.skyboxTexture.when( "load", function() {\n    this.skyboxUniforms.environmentTexture.value = this.skyboxTexture.threeData;\n    this.currentMaterial.needsUpdate = true;\n    this.skyboxRenderPass.enabled = true;\n  }, this );\n  \n  if ( this.isEnabled() ) {\n    this.skyboxTexture.load();\n  }\n};\n\nSkyboxRenderer.prototype.setSkyboxTexture = function( textureId ) {\n  this.skyboxTexture = this.getAssetRegistry().Textures.getAssetById( textureId );\n  this.initTexture();\n};\n\nSkyboxRenderer.prototype.rebuildMaterials = function() {\n  if ( this.skyboxMaterialCube ) {\n    this.skyboxMaterialCube.needsUpdate = true;\n  }\n  if ( this.skyboxMaterial2D ) {\n    this.skyboxMaterial2D.needsUpdate = true;\n  }\n};\n\nSkyboxRenderer.prototype.createMaterial = function() {\n\n  this.skyboxUniforms = THREE.UniformsUtils.merge( [\n    { fogColor: { type: "c", value: new THREE.Color() } },\n    { skyboxFogPower: { type: "f", value: this.skyboxFogPower } },\n    { skyboxFogScale: { type: "f", value: this.skyboxFogScale } },\n    { environmentTexture: { type: "t", value: null } }\n  ]),\n\n  this.skyboxVShader = [\n\n   "varying vec3 vCameraVector;",\n   "void main() {",\n      "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",\n      "vCameraVector = worldPosition.xyz - cameraPosition;",\n      "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",\n    "}"\n\n  ].join("\\n");\n\n  this.skyboxPShader = [\n\n    //THREE.ShaderChunk["fog_pars_fragment"],\n\n    "uniform vec3 fogColor;",\n    "uniform float skyboxFogPower;",\n    "uniform float skyboxFogScale;",\n    "#ifdef USE_CUBEMAP",\n      "uniform samplerCube environmentTexture;",\n    "#else",\n      "uniform sampler2D environmentTexture;",\n    "#endif",\n\n    THREE.ShaderChunk[ \'hdr_decode_pars_fragment\'],\n\n    "varying vec3 vCameraVector;",\n\n    "void main() {",\n      //"float power = clamp( 0.1 + 0.9 * (1.0 - vNormal.z * vNormal.z ), 0.0, 1.0);",\n      "vec3 cameraVectorN = normalize( vCameraVector );",\n      "#ifdef USE_CUBEMAP",\n        "vec4 environmentColor = textureCube( environmentTexture, vec3( vCameraVector.x, vCameraVector.yz )  );",\n      "#else",\n        "vec2 sampleUV;",\n        "sampleUV.y = clamp( cameraVectorN.y * -0.5 + 0.5, 0.0, 1.0);",\n        "sampleUV.x = atan( cameraVectorN.z, cameraVectorN.x ) * 0.15915494309189533576888376337251 + 0.5;",\n        "vec4 environmentColor = texture2D( environmentTexture, sampleUV );",\n      "#endif",\n\n      "#if defined( HDR_INPUT ) && defined( ENVMAP_HDR_INPUT )",\n        "#if ENVMAP_HDR_INPUT == HDR_TYPE_RGBM",\n          "environmentColor.xyz = HDRDecodeRGBM( environmentColor );",\n        "#elif ENVMAP_HDR_INPUT == HDR_TYPE_RGBD",\n          "environmentColor.xyz = HDRDecodeRGBD( environmentColor );",\n        "#elif ENVMAP_HDR_INPUT == HDR_TYPE_RGBE",\n          "environmentColor.xyz = HDRDecodeRGBE( environmentColor );",\n        "#elif ENVMAP_HDR_INPUT == HDR_TYPE_LOGLUV",\n          "environmentColor.xyz = HDRDecodeLOGLUV( environmentColor );",\n        "#endif",\n        "#if defined( GAMMA_OUTPUT )",\n          "environmentColor.xyz = sqrt( environmentColor.xyz );",\n        "#endif",\n      "#else",\n        "#if !defined( GAMMA_OUTPUT )",\n          "environmentColor.xyz *= environmentColor.xyz;",\n        "#endif",\n      "#endif",\n\n      \n\n      "gl_FragColor = vec4( environmentColor.xyz, 1.0 );",\n\n      //"#ifdef USE_FOG",\n        "float fogFactor = clamp( abs(pow( (1.0 - cameraVectorN.y), ( skyboxFogPower) * 12.0 )) + (skyboxFogScale * 2.0 - 1.0), 0.0, 1.0);",\n        "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",\n      //"#endif",\n    "}"\n\n  ].join("\\n");\n\n  this.skyboxMaterialCube = new THREE.ShaderMaterial( {\n    vertexShader: this.skyboxVShader,\n    fragmentShader: this.skyboxPShader,\n    uniforms: this.skyboxUniforms,\n    useFog: true,\n    //fog: true,\n    fogExp: true,\n    side: THREE.BackSide,\n    depthTest: false,\n    depthWrite: false,\n    defines: { USE_CUBEMAP: "" }\n  } );\n\n  this.skyboxMaterial2D = new THREE.ShaderMaterial( {\n    vertexShader: this.skyboxVShader,\n    fragmentShader: this.skyboxPShader,\n    uniforms: this.skyboxUniforms,\n    useFog: true,\n    //fog: true,\n    fogExp: true,\n    side: THREE.BackSide,\n    depthTest: false,\n    depthWrite: false,\n  } );\n};\n\n\nreturn SkyboxRenderer;\n';});


define('text!VeroldEngine/Components/BuiltIn/DefaultRenderer.js',[],function () { return '/**\r\n * A skybox component class.\r\n *\r\n * @class Component\r\n */\r\nfunction DefaultRenderer() {\r\n\r\n  this.threeRenderer = null;\r\n  this.caps = {};\r\n\r\n  //Attributes\r\n  this.antialias = false;\r\n  this.preserveDrawingBuffer = true;\r\n  this.precision = "mediump";\r\n  this.devicePixelRatio = 1.0;\r\n\r\n  this.shadowMapEnabled = true;\r\n  this.shadowMapEnabledMobile = false;\r\n  this.shadowMapType = THREE.PCFSoftShadowMap;\r\n  this.shadowMapCascade = false;\r\n  this.shadowMapDebug = false;\r\n  this.maxShadows = -1;\r\n  this.maxPointLights = -1;\r\n  this.maxDirLights = -1;\r\n  this.maxSpotLights = -1;\r\n  this.maxHemiLights = -1;\r\n\r\n  this.clearColor = new THREE.Color();\r\n  this.clearAlpha = 0.0;\r\n  this.autoClear = false;\r\n  this.autoClearColor = true;\r\n  this.autoClearDepth = true;\r\n  this.autoClearStencil = true;\r\n\r\n  this.sortObjects = true;\r\n  this.autoUpdateObjects = true;\r\n\r\n  // this.gammaInput = true;\r\n  // this.gammaOutput = false;\r\n\r\n  this.preRenderFns = {};\r\n  this.postRenderFns = {};\r\n  this.renderPasses = [];\r\n\r\n  this.renderOnDemand = false;\r\n}\r\n\r\nDefaultRenderer.prototype = new VAPI.VeroldComponent();\r\n\r\nDefaultRenderer.prototype.editorInit = function() {\r\n  this.preInit();\r\n  this.objectCreated();\r\n  this.applyRenderSettings();\r\n  this.getEngine().on(\'postRender\', this.postRender, this );\r\n};\r\n\r\nDefaultRenderer.prototype.preInit = function() {\r\n  this.canvas = this.getEngine().canvas;\r\n  this.initDefaultRenderer();\r\n\r\n  this.getEngine().on( \'resize\', this.resize, this );\r\n\r\n  this.caps = this.getEngine().getBaseRenderer().caps;\r\n\r\n  this.getEngine().setBaseRenderer( this );\r\n\r\n  //Init scene sceneComposer\r\n  // var pars = { format: THREE.RGBAFormat, minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter };\r\n  var renderer = this.getThreeRenderer();\r\n  renderer.hdrOutputEnabled = true;\r\n  renderer.gammaInput = true;\r\n  renderer.gammaOutput = true;\r\n  \r\n  var extensions = new THREE.WebGLExtensions( renderer.getContext() );\r\n  if ( (extensions.get(\'OES_texture_half_float_linear\') || extensions.get(\'OES_texture_float_linear\')) && !VAPI.isMobile() ) {\r\n    // pars.type = THREE.FloatType;\r\n    renderer.hdrOutputType = THREE.HDRFull;\r\n  }\r\n  else {\r\n    renderer.hdrOutputEnabled = false;\r\n  }\r\n  \r\n  // var renderTarget = new THREE.WebGLRenderTarget( this.getRenderer().getCanvasWidth(), this.getRenderer().getCanvasHeight(), pars );\r\n  // renderTarget.name = "Main Render Target";\r\n  // this.sceneComposer = new THREE.EffectComposer( this.getThreeRenderer(), renderTarget );\r\n  // this.sceneComposer.enabled = false;\r\n\r\n  // this.sceneComposer.setSize( this.getRenderer().getCanvasWidth(), this.getRenderer().getCanvasHeight() );\r\n};\r\n\r\nDefaultRenderer.prototype.init = function() {\r\n  if ( this.renderOnDemand ) {\r\n    this.getEngine().renderOnDemand = true;\r\n  }\r\n  if ( !this.shadowMapEnabledMobile ) {\r\n    this.shadowMapEnabled = VAPI.isMobile() ? this.shadowMapEnabledMobile && this.shadowMapEnabled : this.shadowMapEnabled;\r\n  }\r\n  this.applyRenderSettings();\r\n};\r\n/**\r\n * Called when a verold object is destroyed or this component is removed\r\n * from a verold object.\r\n */\r\nDefaultRenderer.prototype.shutdown = DefaultRenderer.prototype.editorShutdown = function() {\r\n\r\n  this.getEngine().off( \'resize\', this.resize, this );\r\n  this.getEngine().off(\'postRender\', this.postRender, this );\r\n\r\n  for ( var i = 0; i < this.renderPasses.length; i++ ) {\r\n    this.renderPasses[ i ].pass = null;\r\n    this.renderPasses[ i ].scene = null;\r\n    this.renderPasses[ i ].camera = null;\r\n  }\r\n  // this.sceneComposer.dispose();\r\n\r\n  this.threeRenderer.context = null;\r\n  this.threeRenderer = null;\r\n  this.canvas = undefined;\r\n  //this.flags = undefined;\r\n};\r\n\r\nDefaultRenderer.prototype.objectCreated = function() {\r\n  this.getEngine().trigger(\'resize\');\r\n};\r\n\r\nDefaultRenderer.prototype.attributesChanged = function( changes ) {\r\n  var rebuildMaterials = false;\r\n  if ( changes.shadowMapEnabledMobile !== undefined ) {\r\n    // this.shadowMapEnabledMobile = changes.shadowMapEnabledMobile;\r\n    rebuildMaterials = true;\r\n  }\r\n  this.shadowMapEnabled = VAPI.isMobile() ? this.shadowMapEnabledMobile && this.shadowMapEnabled : this.shadowMapEnabled;\r\n  this.applyRenderSettings();\r\n\r\n  if ( changes.renderOnDemand ) {\r\n    this.getEngine().renderOnDemand = true;\r\n  }\r\n  if ( changes.clearAlpha !== undefined ) {\r\n    this.threeRenderer.setClearColor( this.clearColor, changes.clearAlpha );\r\n  }\r\n  if ( changes.clearColor !== undefined ) {\r\n    this.threeRenderer.setClearColor( changes.clearColor, this.clearAlpha );\r\n  }\r\n\r\n  if ( changes.gammaOutput !== undefined ) {\r\n    // this.gammaOutput = changes.gammaOutput;\r\n    rebuildMaterials = true;\r\n  }\r\n  if ( changes.gammaInput !== undefined ) {\r\n    // this.gammaInput = changes.gammaInput;\r\n    rebuildMaterials = true;\r\n  }\r\n  if ( changes.shadowMapEnabled !== undefined ) {\r\n    // this.shadowMapEnabled = changes.shadowMapEnabled;\r\n    rebuildMaterials = true;\r\n  }\r\n  if ( changes.shadowMapDebug !== undefined ) {\r\n    // this.shadowMapDebug = changes.shadowMapDebug;\r\n    rebuildMaterials = true;\r\n  }\r\n  if ( changes.shadowMapCascade !== undefined ) {\r\n    // this.shadowMapCascade = changes.shadowMapCascade;\r\n    rebuildMaterials = true;\r\n  }\r\n  if ( changes.shadowMapType !== undefined ) {\r\n    this.shadowMapType = parseInt( changes.shadowMapType, 10 );\r\n    console.warn("TODO - need to recreate the shadow maps if the shadow filtering has changed because PCFSoftShadowMap reuires the shadowmap to be rendered with no filtering.");\r\n    rebuildMaterials = true;\r\n  }\r\n  if ( changes.devicePixelRatio !== undefined ) {\r\n    this.getEngine().trigger("resize");\r\n  }\r\n\r\n  if ( rebuildMaterials ) {\r\n    //rebuild materials\r\n    console.log("Rebuilding materials!!!");\r\n    this.getEngine().trigger(\'rebuildMaterials\');\r\n  }\r\n};\r\n\r\nDefaultRenderer.prototype.initDefaultRenderer = function() {\r\n\r\n  //TODO - fix devicePixelRatio on iOS.\r\n  if ( VAPI.isIOS() ) {\r\n    this.devicePixelRatio = 1.0;\r\n  }\r\n  // var context = this.getEngine().getBaseRenderer().threeRenderer.getContext();\r\n  if( VAPI.browserCaps.isWebGLEnabled() ){\r\n    this.threeRenderer = new THREE.WebGLRenderer({\r\n      // context: context,\r\n      canvas: this.canvas,\r\n      antialias    : this.antialias,\r\n      preserveDrawingBuffer  : this.preserveDrawingBuffer,\r\n      alpha: true,\r\n      precision : this.precision,\r\n      logarithmicDepthBuffer: this.logarithmicDepthBuffer\r\n    });\r\n    this.threeRenderer.setPixelRatio( this.devicePixelRatio !== 0 ? this.devicePixelRatio : window.devicePixelRatio );\r\n  }\r\n  else{\r\n    console.warn("WebGL not supported so falling back to canvas renderer.");\r\n    this.threeRenderer = new THREE.CanvasRenderer();\r\n  }\r\n};\r\n\r\n// DefaultRenderer.prototype.registerPreRenderFn = function( name, fn, context ) {\r\n//   this.preRenderFns[ name ] = { renderFn: fn, context: context };\r\n// };\r\n\r\n// DefaultRenderer.prototype.unregisterPreRenderFn = function( name ) {\r\n//   if ( this.preRenderFns[ name ] ) {\r\n//     delete this.preRenderFns[ name ];\r\n//   }\r\n// };\r\n\r\n// DefaultRenderer.prototype.registerPostRenderFn = function( name, fn, context ) {\r\n//   this.postRenderFns[ name ] = { renderFn: fn, context: context };\r\n// };\r\n\r\n// DefaultRenderer.prototype.unregisterPostRenderFn = function( name ) {\r\n//   if ( this.postRenderFns[ name ] ) {\r\n//     delete this.postRenderFns[ name ];\r\n//   }\r\n// };\r\n\r\nDefaultRenderer.prototype.addRenderPass = function( pass, priority ) {\r\n  if ( priority < 0 ) {\r\n    this.renderPasses.splice( 0, 0, { pass : pass, scene : pass.scene, camera: pass.camera } );\r\n  }\r\n  else {\r\n    this.renderPasses.push( { pass : pass, scene : pass.scene, camera: pass.camera } );\r\n  }\r\n  // if ( priority < 0 ) {\r\n  //   if ( this.sceneComposer && this.sceneComposer.passes.length >= this.renderPasses.length - 1 ) {\r\n  //     this.sceneComposer.passes.splice( 0, 0, pass );\r\n  //   }\r\n  // }\r\n  // else {\r\n  //   if ( this.sceneComposer && this.sceneComposer.passes.length >= this.renderPasses.length - 1 ) {\r\n  //     this.sceneComposer.passes.splice( this.renderPasses.length - 1, 0, pass );\r\n  //   }\r\n  // }\r\n  for ( var i in this.renderPasses ) {\r\n    this.renderPasses[i].pass.clear = false;\r\n    // this.renderPasses[i].pass.clearColor = this.clearColor;\r\n  }\r\n  this.renderPasses[0].pass.clear = true;\r\n  this.renderPasses[0].pass.clearColor = this.clearColor;\r\n  this.renderPasses[0].pass.clearAlpha = this.clearAlpha;\r\n  this.renderPassesNeedUpdate = true;\r\n};\r\n\r\nDefaultRenderer.prototype.removeRenderPass = function( pass ) {\r\n  var i, foundIndex = -1;\r\n  for ( i = 0; i < this.renderPasses.length; i++ ) {\r\n    if ( this.renderPasses[ i ].pass === pass ) {\r\n      foundIndex = i;\r\n      break;\r\n    }\r\n  }\r\n  if ( foundIndex >= 0 ) {\r\n    this.renderPasses.splice( foundIndex, 1 );\r\n    // if ( this.sceneComposer && this.sceneComposer.passes.length >= this.renderPasses.length - 1 ) {\r\n    //   this.sceneComposer.passes.splice( foundIndex, 1 );\r\n    // }\r\n  }\r\n  this.renderPassesNeedUpdate = true;\r\n};\r\n\r\n// DefaultRenderer.prototype.getComposer = function() {\r\n//   return this.sceneComposer;\r\n// };\r\n\r\nDefaultRenderer.prototype.initRenderPasses = function() {\r\n  // this.sceneComposer.passes = [];\r\n  for ( var i = 0; i < this.renderPasses.length; i++ ) {\r\n    this.renderPasses[i].pass.scene = this.renderPasses[i].scene;\r\n    this.renderPasses[i].pass.camera = this.renderPasses[i].camera;\r\n    // this.sceneComposer.addPass( this.renderPasses[i].pass );\r\n  }\r\n};\r\n\r\nDefaultRenderer.prototype.applyRenderSettings = function() {\r\n  if ( this.threeRenderer ) {\r\n    _.each( this, function( value, key ) {\r\n      if ( this.threeRenderer[ key ] !== undefined ) {\r\n        this.threeRenderer[ key ] = value;\r\n      }\r\n    }, this );\r\n\r\n    if ( this.devicePixelRatio === 0.0 ) {\r\n      this.devicePixelRatio = window.devicePixelRatio;\r\n      this.threeRenderer.setPixelRatio( window.devicePixelRatio );\r\n    }\r\n    else {\r\n      this.threeRenderer.setPixelRatio( this.devicePixelRatio );\r\n    }\r\n    \r\n    this.threeRenderer.setClearColor( this.clearColor, this.clearAlpha );\r\n\r\n    //This is a temporary check to force a maximum number of lights if the hardware supports a very low number of uniforms\r\n    if ( this.getGPUCapability("MAX_FRAGMENT_UNIFORM_VECTORS") < 29 || VAPI.isMobile() ) {\r\n      this.threeRenderer.maxDirLights = Math.min( this.maxDirLights, 1 );\r\n      this.threeRenderer.maxPointLights = Math.min( this.maxPointLights, 1 );\r\n      this.threeRenderer.maxShadows = Math.min( this.maxShadows, 1 );\r\n    }\r\n  }\r\n\r\n};\r\n\r\n/**\r\n * Given the name of a GPU device capability (e.g. MAX_VERTEX_TEXTURE_IMAGE_UNITS ), return the current system\'s\r\n * value for this capability.\r\n * @param  {String} cap The capability name\r\n * @return {Integer}     The value of the capability\r\n */\r\nDefaultRenderer.prototype.getGPUCapability = function( cap ) {\r\n  return this.caps[ cap ];\r\n};\r\n\r\nDefaultRenderer.prototype.supportsCompressedTextureS3TC = function() {\r\n  return this.caps.compressedTextureFormats["S3TC"];\r\n};\r\n\r\nDefaultRenderer.prototype.supportsCompressedTexturePVRTC = function() {\r\n  return this.caps.compressedTextureFormats["PVRTC"];\r\n};\r\n\r\nDefaultRenderer.prototype.supportsCompressedTextureATC = function() {\r\n  return this.caps.compressedTextureFormats["ATC"];\r\n};\r\n\r\nDefaultRenderer.prototype.preRender = function() {\r\n  // this.newRenderStarted = true;\r\n  this.threeRenderer.setRenderTarget( null );\r\n  this.threeRenderer.clear( true, true, true );\r\n};\r\n\r\nDefaultRenderer.prototype.postRender = function() {\r\n  this.renderPassesNeedUpdate = false;\r\n};\r\n\r\nDefaultRenderer.prototype.renderView = function( scene, camera, options ) {\r\n  if ( !options ) {\r\n    options = {};\r\n  }\r\n  var i = 0;\r\n  if ( scene && camera ) {\r\n    // if ( this.newRenderStarted ) {\r\n    //   // this.threeRenderer.shadowMapAutoUpdate = true;\r\n    //   options.clearColor = true;\r\n    //   // this.threeRenderer.clear( options.clearColor, options.clearDepth, options.clearStencil );\r\n    //   this.newRenderStarted = false;\r\n    // }\r\n    // else {\r\n    //   // this.threeRenderer.shadowMapAutoUpdate = false;\r\n    //   options.clearColor = false;\r\n    // }\r\n    if ( options.enablePreRenderFunctions ) {\r\n      // _.each( this.preRenderFns, function( pass ) {\r\n      //   pass.renderFn.call( pass.context, scene, camera, options );\r\n      // }, this );\r\n      this.getEngine().trigger("preRenderView", scene, camera, options );\r\n    }\r\n    for ( i = 0; i < this.renderPasses.length; i++ ) {\r\n      this.renderPasses[i].pass.scene = this.renderPasses[i].scene ? this.renderPasses[i].scene : scene;\r\n      this.renderPasses[i].pass.camera = this.renderPasses[i].camera ? this.renderPasses[i].camera : camera;\r\n    }\r\n\r\n    var viewPort = this.threeRenderer.getViewport();\r\n\r\n    if ( options.composer && options.composer.passes.length ) {\r\n      if ( options.composer.renderPassesNeedUpdate || this.renderPassesNeedUpdate ) {\r\n        var renderPasses = [];\r\n        for ( i = 0; i < this.renderPasses.length; i++ ) {\r\n          renderPasses[i] = this.renderPasses[i].pass;\r\n        }\r\n        options.composer.passes = renderPasses.concat( options.composer.passes );\r\n        options.composer.renderPassesNeedUpdate = false;\r\n      }\r\n      //TODO - move this viewport stuff into RenderView?\r\n      var lastPass = options.composer.passes[ options.composer.passes.length - 1 ];\r\n      lastPass.viewPort = options.viewPort;\r\n      if ( lastPass.uniforms && lastPass.uniforms.opacity ) {\r\n        lastPass.uniforms.opacity.value = options.opacity !== undefined ? options.opacity : 1.0;\r\n      }\r\n      this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.x = 0.0;\r\n      this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.y = 0.0;\r\n      this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.z = this.getCanvasWidth();\r\n      this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.w = this.getCanvasHeight();\r\n\r\n      lastPass.renderToScreen = options.renderToScreen !== undefined ? options.renderToScreen : true;\r\n      if ( options.renderTarget ) {\r\n        lastPass.renderToTexture = options.renderTarget;\r\n        lastPass.renderToScreen = false;\r\n      }\r\n      // this.sceneComposer.passes[ 0 ].needsSwap = options.needsSwap !== undefined ? options.needsSwap : false;\r\n      // this.sceneComposer.passes[ 0 ].clearColor = options.clearColor ? ;\r\n      // lastPass.clearDepth = options.clearDepth;\r\n      options.composer.render( options.delta !== undefined ? options.delta : 0.0167 );\r\n    }\r\n    else {\r\n\r\n      if ( options.opacity !== undefined && (!options.viewPort || options.viewPort.width === this.getWidth() && options.viewPort.height === this.getHeight() )) {\r\n        if ( this.getCanvas().style.opacity != options.opacity ) {\r\n          this.getCanvas().style.opacity = options.opacity;\r\n        }\r\n      }\r\n      else if ( this.getCanvas().style.opacity != 1 ) {\r\n        this.getCanvas().style.opacity = 1.0;\r\n      }\r\n\r\n      if ( !options.renderTarget ) {\r\n        // var prevRenderTarget = this.threeRenderer.getRenderTarget();\r\n        this.threeRenderer.setRenderTarget( null );\r\n        this.threeRenderer.clear( options.clearColor, options.clearDepth, options.clearStencil );\r\n      }\r\n      else {\r\n        this.threeRenderer.setRenderTarget( options.renderTarget );\r\n        this.threeRenderer.clear( options.clearColor, options.clearDepth, options.clearStencil );\r\n      }\r\n\r\n      if ( options.viewPort ) {\r\n\r\n        this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.x = options.viewPort.x;\r\n        this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.y = options.viewPort.y;\r\n\r\n        this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.z = options.viewPort.width * this.devicePixelRatio;\r\n        this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.w = options.viewPort.height * this.devicePixelRatio;\r\n\r\n        this.threeRenderer.setViewport( options.viewPort.x, options.viewPort.y, options.viewPort.width, options.viewPort.height );\r\n      }\r\n\r\n      var renderer = options.effect ? options.effect : this.threeRenderer;\r\n\r\n      for ( i = 0; i < this.renderPasses.length; i++ ) {\r\n        var prevOverrideMat = this.renderPasses[ i ].pass.scene.overrideMaterial;\r\n        if ( this.renderPasses[ i ].pass.overrideMaterial ) {\r\n          this.renderPasses[ i ].pass.scene.overrideMaterial = this.renderPasses[ i ].pass.overrideMaterial;\r\n        }\r\n        \r\n        if ( options.renderTarget ) {\r\n          // if ( i === 0 ) {\r\n          //   renderer.clear( options.clearColor, options.clearDepth );\r\n          // }\r\n          renderer.render( this.renderPasses[ i ].pass.scene, this.renderPasses[ i ].pass.camera, options.renderTarget, false );\r\n        }\r\n        else {\r\n          renderer.render( this.renderPasses[ i ].pass.scene, this.renderPasses[ i ].pass.camera );\r\n        }\r\n\r\n        if ( this.renderPasses[ i ].pass.overrideMaterial ) {\r\n          this.renderPasses[ i ].pass.scene.overrideMaterial = prevOverrideMat;\r\n        }\r\n      }\r\n\r\n      // this.threeRenderer.setRenderTarget( prevRenderTarget );\r\n      if ( options.viewPort ) {\r\n        this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.x = viewPort.x;\r\n        this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.y = viewPort.y;\r\n        this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.z = viewPort.width * this.devicePixelRatio;\r\n        this.getAssetRegistry().Materials.sharedUniforms.screenDimensions.value.w = viewPort.height * this.devicePixelRatio;\r\n\r\n        this.threeRenderer.setViewport( viewPort.x, viewPort.y, viewPort.width, viewPort.height );\r\n      }\r\n    }\r\n\r\n    // if ( options.includePostRender ) {\r\n      // _.each( this.postRenderFns, function( pass ) {\r\n      //   pass.renderFn.call( pass.context, scene, camera );\r\n      // }, this );\r\n      this.getEngine().trigger("postRenderView", scene, camera, options );\r\n    // }\r\n  }\r\n};\r\n\r\n/**\r\n * Returns the size of the render target in device-independent pixels (dips)\r\n * @method getWidth\r\n * @return {Int} The width of the render target.\r\n */\r\nDefaultRenderer.prototype.getWidth = function() {\r\n  return this.canvas.clientWidth;\r\n};\r\n\r\n/**\r\n * Returns the size of the render target in device-independent pixels (dips)\r\n * @method getHeight\r\n * @return {Int} The height of the render target.\r\n */\r\nDefaultRenderer.prototype.getHeight = function() {\r\n  return this.canvas.clientHeight;\r\n};\r\n\r\nDefaultRenderer.prototype.getCanvasWidth = function() {\r\n  return this.canvas.width;\r\n};\r\n\r\nDefaultRenderer.prototype.getCanvasHeight = function() {\r\n  return this.canvas.height;\r\n};\r\n\r\nDefaultRenderer.prototype.getCanvas = function() {\r\n  return this.threeRenderer.domElement;\r\n};\r\n\r\nDefaultRenderer.prototype.resize = function( ) {\r\n\r\n  var w = this.canvas.parentElement.clientWidth;\r\n  var h = this.canvas.parentElement.clientHeight;\r\n\r\n  this.threeRenderer.setSize(w, h, true);\r\n\r\n  // if ( this.sceneComposer ) {\r\n  //   this.sceneComposer.setSize( this.getRenderer().getCanvasWidth(), this.getRenderer().getCanvasHeight() );\r\n  // }\r\n};\r\n\r\nreturn DefaultRenderer;';});


define('text!VeroldEngine/Components/BuiltIn/DefaultFilters.js',[],function () { return '/*\n@vname Default Filters\n@vdescription Stores the default filter settings that cameras will use when rendering.\n@vfilter application\n@vcategory Rendering\n@vtype bloom {\n  "attributes": {\n    "enabled": { type: \'b\', default: false },\n    "strength": { type: \'f\', default: 1.0, min: 0.1, max: 4.0, step: 0.001 },\n    "sigma": { type: \'f\', default: 4, min: 1, max: 8, step: 0.001, advanced: true },\n    "resolution": { type: \'i\', default: 256, min: 64, max: 1024, step: 1, advanced: true },\n  }\n}\n@vtype toneMapping {\n  "attributes": {\n    "enabled": { type: \'b\', default: false, description: \'Enable tone-mapping.\' },\n    "adaptive": { type: "b", "description": "Automatically adjusts the tone-mapping every frame based on the average luminance of the scene.",default: true },\n    "adaptSpeed": { type: "f", "description": "The speed at which adaptive tone-mapping works. Higher number is faster.", default: 0.5, min: 0.1, max: 20.0 },\n    "exposureBias":     { type: "f", "description": "Adjusts the overall brightness of the image. Use this to tweak the final result of tone-mapping.", default: 1.0, min: 0.0001, max: 5.0 },\n    "maxLuminance":  { type: "f", "description": "Sets the maximum brightness reached before pixels become white after tone-mapping.", default: 16, min: 0.01, max: 25.0 },\n    "luminance":  { type: "f", "description": "When the \'Adaptive\' feature is turned off, this will set the scene luminance to be used by tone-mapping.", default: 1.0, min: 0.0001, max: 16.0 },\n  },\n}\n@vtype fxaa {\n  "attributes": {\n    "enabled": { type: \'b\', default: false },\n  }\n}\n@vtype vignette {\n  "attributes": {\n    "enabled": { type: \'b\', default: false },\n    "offset": { type: \'f\', default: 1.0, min: 0.0, max: 1.0, step: 0.001 },\n    "darkness": { type: \'f\', default: 1.0, min: 0.0, max: 5.0, step: 0.001 }\n  }\n}\n@vtype ssao {\n  "attributes": {\n    "enabled": { type: \'b\', default: false },\n    "fogEnabled": { type: \'i\', default: 1, advanced: true },\n    "depthScale": { type: \'f\', default: 100000.0, min: 100.0, max: 50000.0, step: 0.001, advanced: true },\n    "onlyAO":       { type: "i", default: 0 },\n    "aoClamp":      { type: "f", default: 0.75, advanced: true },\n    "lumInfluence": { type: "f", default: 0.75, advanced: true },\n    "noiseAmount": { type: "f", default: 0.0002 },\n    "radius": { type: "f", default: 8.0 },\n    "diffArea": { type: "f", default: 0.4, advanced: true },\n    "gDisplace": { type: "f", default: 0.4, advanced: true }\n  }\n}\n@vtype dof {\n  "attributes": {\n    "enabled": { type: \'b\', default: false },\n    "aspect": { type: \'f\', default: 1.0, min: 0.0, max: 1.0, step: 0.001, advanced: true },\n    "aperture": { type: \'f\', default: 0.4, min: 0.0, max: 1.0, step: 0.001 },\n    "focus": { type: \'f\', default: 0.980, min: 0.0, max: 1.0, step: 0.001 },\n  }\n}\n@vtype sepia {\n  "attributes": {\n    "enabled": { type: \'b\', default: false },\n    "amount": { type: \'f\', default: 0.9, min: 0.0, max: 1.0, step: 0.001 }\n  }\n}\n@vtype video {\n  "attributes": {\n    "enabled": { type: \'b\', default: false },\n    "nIntensity": { type: "f", default: 0.15 },\n    "sIntensity": { type: "f", default: 0.05 },\n    "sCount":     { type: "f", default: 512 },\n    "grayscale":  { type: "b", default: false }\n  },\n}\n@vattr bloom bloom { description: "" }\n@vattr toneMapping toneMapping { description: "" }\n@vattr fxaa fxaa { description: "" }\n@vattr vignette vignette { description: "" }\n@vattr ssao ssao { description: "" }\n@vattr dof dof { description: "" }\n@vattr sepia sepia { description: "" }\n@vattr video video { description: "" }\n\n*/\nfunction DefaultFilters() {\n\n}\n\nDefaultFilters.prototype = new VAPI.VeroldComponent();\n\nDefaultFilters.prototype.editorInit = function() {\n  this.init();\n  // this.getEngine().on( "preRenderView", this.preRenderView, this );\n};\n\nDefaultFilters.prototype.init = function() {\n  // this.on( \'enable\', this.onEnable, this );\n  // this.on( \'disable\', this.onDisable, this );\n  // this.initComposer();\n  // this.getEngine().on( \'resize\', this.resize, this );\n  this.getEngine().on( \'getDefaultFilters\', this.getDefaultFilters, this );\n  this.updateFilters();\n};\n\nDefaultFilters.prototype.editorShutdown = function() {\n  // this.off( \'enable\', this.onEnable, this );\n  // this.off( \'disable\', this.onDisable, this );\n  this.shutdown();\n  // this.getEngine().off( "preRenderView", this.preRenderView, this );\n};\n\nDefaultFilters.prototype.shutdown = function() {\n  this.getEngine().off( \'getDefaultFilters\', this.getDefaultFilters, this );\n\n};\n\nDefaultFilters.prototype.getDefaultFilters = function( callback ) {\n  if ( _.isFunction( callback ) ) {\n    return callback( this );\n  }\n};\n\nDefaultFilters.prototype.onEnable = function() {\n  this.composer.enabled = true;\n  this.updateFilters();\n};\n\nDefaultFilters.prototype.onDisable = function() {\n  this.updateFilters();\n};\n\nDefaultFilters.prototype.attributesChanged = function( changes ) {\n\n  this.updateFilters( changes );\n};\n\n\nDefaultFilters.prototype.updateFilters = function( changes ) {\n\n  var that = this;\n\n  var toneMapping = this.toneMapping;\n  if ( toneMapping && toneMapping.enabled && this.isEnabled() ) {\n\n    setTimeout( function() {\n      var renderer = that.getEntity().getComponentByScriptId("verold_renderer");\n      if ( renderer ) {\n        renderer.setAttribute( "gammaOutput", false );\n      }\n    }, 0 );\n  }\n  else {\n    setTimeout( function() {\n      var renderer = that.getEntity().getComponentByScriptId("verold_renderer");\n      if ( renderer ) {\n        renderer.setAttribute( "gammaOutput", true );\n      }\n    }, 0 );\n  }\n\n  this.getEngine().trigger(\'defaultFiltersChanged\');\n\n};\n\n\nreturn DefaultFilters;\n';});


define('text!VeroldEngine/Components/BuiltIn/RenderFilters.js',[],function () { return '/*\n@vname Render Filters\n@vdescription Overrides the filter settings that cameras will use when rendering.\n@vfilter object\n@vcategory Rendering\n@vtype bloom {\n  "attributes": {\n    "override": { type: \'b\', default: false, description: \'Override the default behaviour of this filter.\' },\n    "enabled": { type: \'b\', default: false },\n    "strength": { type: \'f\', default: 1.0, min: 0.1, max: 4.0, step: 0.001 },\n    "sigma": { type: \'f\', default: 4, min: 1, max: 8, step: 0.001, advanced: true },\n    "resolution": { type: \'i\', default: 256, min: 64, max: 1024, step: 1, advanced: true },\n  }\n}\n@vtype toneMapping {\n  "attributes": {\n    "override": { type: \'b\', default: false, description: \'Override the default behaviour of this filter.\' },\n    "adaptive": { type: "b", "description": "Automatically adjusts the tone-mapping every frame based on the average luminance of the scene.",default: true },\n    "adaptSpeed": { type: "f", "description": "The speed at which adaptive tone-mapping works. Higher number is faster.", default: 0.5, min: 0.1, max: 20.0 },\n    "exposureBias":     { type: "f", "description": "Adjusts the overall brightness of the image. Use this to tweak the final result of tone-mapping.", default: 1.0, min: 0.0001, max: 5.0 },\n    "maxLuminance":  { type: "f", "description": "Sets the maximum brightness reached before pixels become white after tone-mapping.", default: 16, min: 0.01, max: 25.0 },\n    "luminance":  { type: "f", "description": "When the \'Adaptive\' feature is turned off, this will set the scene luminance to be used by tone-mapping.", default: 1.0, min: 0.0001, max: 16.0 },\n  },\n}\n@vtype fxaa {\n  "attributes": {\n    "override": { type: \'b\', default: false, description: \'Override the default behaviour of this filter.\' },\n    "enabled": { type: \'b\', default: false },\n  }\n}\n@vtype vignette {\n  "attributes": {\n    "override": { type: \'b\', default: false, description: \'Override the default behaviour of this filter.\' },\n    "enabled": { type: \'b\', default: false },\n    "offset": { type: \'f\', default: 1.0, min: 0.0, max: 1.0, step: 0.001 },\n    "darkness": { type: \'f\', default: 1.0, min: 0.0, max: 5.0, step: 0.001 }\n  }\n}\n@vtype ssao {\n  "attributes": {\n    "override": { type: \'b\', default: false, description: \'Override the default behaviour of this filter.\' },\n    "enabled": { type: \'b\', default: false },\n    "fogEnabled": { type: \'i\', default: 1, advanced: true },\n    "depthScale": { type: \'f\', default: 100000.0, min: 100.0, max: 50000.0, step: 0.001, advanced: true },\n    "onlyAO":       { type: "i", default: 0 },\n    "aoClamp":      { type: "f", default: 0.75, advanced: true },\n    "lumInfluence": { type: "f", default: 0.75, advanced: true },\n    "noiseAmount": { type: "f", default: 0.0002 },\n    "radius": { type: "f", default: 8.0 },\n    "diffArea": { type: "f", default: 0.4, advanced: true },\n    "gDisplace": { type: "f", default: 0.4, advanced: true }\n  }\n}\n@vtype dof {\n  "attributes": {\n    "override": { type: \'b\', default: false, description: \'Override the default behaviour of this filter.\' },\n    "enabled": { type: \'b\', default: false },\n    "aspect": { type: \'f\', default: 1.0, min: 0.0, max: 1.0, step: 0.001, advanced: true },\n    "aperture": { type: \'f\', default: 0.4, min: 0.0, max: 1.0, step: 0.001 },\n    "focus": { type: \'f\', default: 0.980, min: 0.0, max: 1.0, step: 0.001 },\n  }\n}\n@vtype sepia {\n  "attributes": {\n    "override": { type: \'b\', default: false, description: \'Override the default behaviour of this filter.\' },\n    "enabled": { type: \'b\', default: false },\n    "amount": { type: \'f\', default: 0.9, min: 0.0, max: 1.0, step: 0.001 }\n  }\n}\n@vtype video {\n  "attributes": {\n    "override": { type: \'b\', default: false, description: \'Override the default behaviour of this filter.\' },\n    "enabled": { type: \'b\', default: false },\n    "nIntensity": { type: "f", default: 0.15 },\n    "sIntensity": { type: "f", default: 0.05 },\n    "sCount":     { type: "f", default: 512 },\n    "grayscale":  { type: "b", default: false }\n  },\n}\n@vattr bloom bloom { description: "" }\n@vattr toneMapping toneMapping { description: "" }\n@vattr fxaa fxaa { description: "" }\n@vattr vignette vignette { description: "" }\n@vattr ssao ssao { description: "" }\n@vattr dof dof { description: "" }\n@vattr sepia sepia { description: "" }\n@vattr video video { description: "" }\n\n*/\nfunction RenderFilters() {\n\n  this.shaderDefs = {\n    "video" : { shader: THREE.FilmShader, textureID: "tDiffuse" },\n    "sepia" : { shader: THREE.SepiaShader, textureID: "tDiffuse" },\n    "vignette" : { shader: THREE.VignetteShader, textureID: "tDiffuse" },\n    "bokeh" : { shader: THREE.BokehShader, textureID: "tColor" },\n    "bokeh2" : { shader: THREE.BokehShader2, textureID: "tColor" },\n    "edge" : { shader: THREE.EdgeShader, textureID: "tDiffuse" },\n    "edge2" : { shader: THREE.EdgeShader2, textureID: "tDiffuse" },\n    "fxaa" : { shader: THREE.FXAAShader, textureID: "tDiffuse" },\n    "copy" : { shader: THREE.CopyShader, textureID: "tDiffuse" },\n    "ssao" : { shader: THREE.SSAOShader, textureID: "tDiffuse" },\n  };\n  this.composer = undefined;\n  this.defaultFilters = undefined;\n  this.needsDepthPass = false;\n}\n\nRenderFilters.prototype = new VAPI.VeroldComponent();\n\nRenderFilters.prototype.editorInit = function() {\n  this.init();\n  this.getEngine().on( "preRenderView", this.preRenderView, this );\n};\n\nRenderFilters.prototype.init = function() {\n  var that = this;\n  this.on( \'enable\', this.onEnable, this );\n  this.on( \'disable\', this.onDisable, this );\n  this.getEngine().trigger(\'getDefaultFilters\', function( filters ) {\n    that.defaultFilters = filters;\n  }, this );\n  this.initComposer();\n  this.getEngine().on( \'resize\', this.resize, this );\n  this.getEngine().on( \'defaultFiltersChanged\', this.updateFilters, this );\n};\n\nRenderFilters.prototype.editorShutdown = function() {\n  \n  this.shutdown();\n  this.getEngine().off( "preRenderView", this.preRenderView, this );\n  this.getEngine().off( \'defaultFiltersChanged\', this.updateFilters, this );\n};\n\nRenderFilters.prototype.shutdown = function() {\n  this.off( \'enable\', this.onEnable, this );\n  this.off( \'disable\', this.onDisable, this );\n  this.getEngine().off( \'resize\', this.resize, this );\n  if ( this.toneMappingPass ) {\n    this.toneMappingPass.dispose();\n  }\n  if ( this.copyPass ) {\n    this.copyPass.dispose();\n  }\n  if ( this.bloomPass ) {\n    this.bloomPass.dispose();\n  }\n  if ( this.fxaaPass ) {\n    this.fxaaPass.dispose();\n  }\n  if ( this.filmPass ) {\n    this.filmPass.dispose();\n  }\n  if ( this.vignettePass ) {\n    this.vignettePass.dispose();\n  }\n  if ( this.sepiaPass ) {\n    this.sepiaPass.dispose();\n  }\n  if ( this.dofPass ) {\n    this.dofPass.dispose();\n  }\n  if ( this.ssaoPass ) {\n    this.ssaoPass.dispose();\n  }\n\n  this.rtTextureDepth.dispose();\n  this.depthMaterial.static.dispose();\n  this.depthMaterial.skinned.dispose();\n};\n\nRenderFilters.prototype.onEnable = function() {\n  this.composer.enabled = true;\n  this.updateFilters();\n  // _.each( this.composer.passes, function( pass ) {\n  //   pass.enabled = true;\n  // }, this );\n};\n\nRenderFilters.prototype.onDisable = function() {\n  this.composer.enabled = false;\n  this.updateFilters();\n  // _.each( this.composer.passes, function( pass ) {\n  //   pass.enabled = false;\n  // }, this );\n};\n\nRenderFilters.prototype.attributesChanged = function( changes ) {\n\n  // if ( changes ) {\n    this.updateFilters( changes );\n  // }\n};\n\nRenderFilters.prototype.initComposer = function() {\n\n  var pars = { format: THREE.RGBAFormat, minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter };\n  var renderer = this.getThreeRenderer();\n  if ( renderer.hdrOutputType === THREE.HDRFull && renderer.hdrOutputEnabled ) {\n    pars.type = THREE.FloatType;\n  }\n  var renderTarget = new THREE.WebGLRenderTarget( this.getRenderer().getCanvasWidth(), this.getRenderer().getCanvasHeight(), pars );\n  renderTarget.name = this.getEntity().getName() + ": Main Render Buffer";\n  this.composer = new THREE.EffectComposer( this.getThreeRenderer(), renderTarget );\n  this.composer.enabled = this.isEnabled();\n  // this.scenePass = new THREE.RenderPass();\n  // this.scenePass.clear = false;\n  // this.getRenderer().addRenderPass( this.scenePass );\n  this.composer.renderPassesNeedUpdate = true;\n\n  this.copyPass = new THREE.ShaderPass( this.shaderDefs[\'copy\'].shader );\n\n  var toneMapping = this.toneMapping;\n  if ( toneMapping ) {\n    this.toneMappingPass = new THREE.AdaptiveToneMappingPass( this.toneMapping.adaptive, 256 );\n  }\n\n  var bloom = this.bloom;\n  if ( bloom ) {\n    var resolution = bloom.resolution !== undefined ? bloom.resolution : 256;\n    var aspect = this.getRenderer().getWidth() / this.getRenderer().getHeight();\n    this.bloomPass = new THREE.BloomPass( bloom.strength, bloom.kernelSize, bloom.sigma, resolution * aspect, resolution );\n  }\n\n  if ( this.fxaa ) {\n    this.fxaaPass = new THREE.ShaderPass( this.shaderDefs[\'fxaa\'].shader );\n  }\n\n  if ( this.video ) {\n    this.filmPass = new THREE.FilmPass();\n  }\n\n  if ( this.vignette ) {\n    this.vignettePass = new THREE.ShaderPass( this.shaderDefs[\'vignette\'].shader );\n  }\n\n  if ( this.sepia ) {\n    this.sepiaPass = new THREE.ShaderPass( this.shaderDefs[\'sepia\'].shader );\n  }\n\n  if ( this.dof ) {\n    this.dofPass = new THREE.ShaderPass( this.shaderDefs[\'bokeh\'].shader );\n  }\n\n  if ( this.ssao ) {\n    this.ssaoPass = new THREE.ShaderPass( this.shaderDefs[\'ssao\'].shader );\n    //this.ssaoPass.material.fog = true;\n  }\n\n  this.rtTextureDepth = new THREE.WebGLRenderTarget( this.getRenderer().getCanvasWidth(), this.getRenderer().getCanvasHeight(), { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );\n  this.rtTextureDepth.name = this.getEntity().getName() + ": Depth Texture";\n  var depthShader = THREE.ShaderLib[ "depthRGBA" ];\n  var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\n  this.depthMaterial = {};\n  this.depthMaterial.static = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n  this.depthMaterial.static.depthTest = true;\n  this.depthMaterial.static.blending = THREE.NoBlending;\n\n  depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n  this.depthMaterial.skinned = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n  this.depthMaterial.skinned.depthTest = true;\n  this.depthMaterial.skinned.blending = THREE.NoBlending;\n  this.depthMaterial.skinned.skinning = true;\n\n  this.updateFilters( this );\n\n  // this.getEngine().getBaseRenderer().threeComposer = this.composer;\n};\n\nRenderFilters.prototype.updateFilters = function( changes ) {\n\n  this.needsDepthPass = false;\n  var needsCopyPass = false;\n  var that = this;\n  \n  this.composer.passes = [];\n  this.composer.renderPassesNeedUpdate = true;\n  \n  // this.getRenderer().initRenderPasses();\n  if ( !this.defaultFilters.isEnabled() || !this.isEnabled()) {\n    return;\n  }\n\n  if ( this.defaultFilters.toneMapping.enabled ) {\n    this.toneMappingPass.seedTargets( this.getThreeRenderer() );\n    this.composer.addPass( this.toneMappingPass );\n    this.toneMappingPass.renderToScreen = false;\n    needsCopyPass = true;\n  }\n\n  if ( !VAPI.isMobile() ) {\n    if ( this.ssao.override && this.ssao.enabled ||\n        !this.ssao.override && this.defaultFilters.ssao.enabled ) {\n      this.composer.addPass( this.ssaoPass );\n      this.ssaoPass.renderToScreen = false;\n  // this.ssaoPass.needsSwap = true;\n      this.needsDepthPass = true;\n      needsCopyPass = false;\n    }\n\n    if ( this.dof.override && this.dof.enabled ||\n        !this.dof.override && this.defaultFilters.dof.enabled ) {\n      this.composer.addPass( this.dofPass );\n      this.dofPass.renderToScreen = false;\n      // this.dofPass.needsSwap = true;\n      this.needsDepthPass = true;\n      needsCopyPass = false;\n    }\n  \n    if ( this.bloom.override && this.bloom.enabled ||\n        !this.bloom.override && this.defaultFilters.bloom.enabled ) {\n      this.composer.addPass( this.bloomPass );\n      this.bloomPass.renderToScreen = false;\n      needsCopyPass = true;\n    }\n\n    if ( this.fxaa.override && this.fxaa.enabled ||\n          !this.fxaa.override && this.defaultFilters.fxaa.enabled ) {\n      this.composer.addPass( this.fxaaPass );\n      this.fxaaPass.renderToScreen = false;\n      needsCopyPass = true;\n    }\n\n    if ( this.video.override && this.video.enabled ||\n          !this.video.override && this.defaultFilters.video.enabled ) {\n      this.composer.addPass( this.filmPass );\n      this.filmPass.renderToScreen = false;\n      needsCopyPass = true;\n    }\n  }\n  \n  if ( this.vignette.override && this.vignette.enabled ||\n        !this.vignette.override && this.defaultFilters.vignette.enabled ) {\n    this.composer.addPass( this.vignettePass );\n    this.vignettePass.renderToScreen = false;\n    needsCopyPass = false;\n  }\n\n  if ( this.sepia.override && this.sepia.enabled ||\n        !this.sepia.override && this.defaultFilters.sepia.enabled ) {\n    this.composer.addPass( this.sepiaPass );\n    this.sepiaPass.renderToScreen = false;\n    needsCopyPass = false;\n  }\n\n  if ( needsCopyPass ) {\n    this.composer.addPass( this.copyPass );\n  }\n\n  if ( this.composer.passes.length > 1 ) {\n    var lastPass = this.composer.passes[ this.composer.passes.length - 1 ];\n    lastPass.renderToScreen = true;\n  }\n\n  //Tone-mapping\n  var toneMapping = this.toneMapping.override ? this.toneMapping : this.defaultFilters.toneMapping;\n  this.toneMappingPass.setAdaptive( toneMapping.adaptive );\n  this.toneMappingPass.setAdaptiveWhiteLevel( false );//this.toneMapping.adaptiveWhiteLevel );\n  this.toneMappingPass.setAdaptionRate( toneMapping.adaptSpeed );\n  this.toneMappingPass.setMaxLuminance( toneMapping.maxLuminance );\n  this.toneMappingPass.setExposure( toneMapping.exposureBias );\n  this.toneMappingPass.setAverageLuminance( toneMapping.luminance );\n\n  //Film\n  var video = this.video.override ? this.video : this.defaultFilters.video;\n  this.filmPass.uniforms.nIntensity.value = video.nIntensity !== undefined ? video.nIntensity : 0.5;\n  this.filmPass.uniforms.sIntensity.value = video.sIntensity !== undefined ? video.sIntensity : 0.05;\n  this.filmPass.uniforms.sCount.value = video.sCount !== undefined ? video.sCount : 4096;\n  this.filmPass.uniforms.grayscale.value = video.grayscale !== undefined ? video.grayscale : 1;\n\n  //Bloom\n  var bloom = this.bloom.override ? this.bloom : this.defaultFilters.bloom;\n  this.bloomPass.copyUniforms.opacity.value = bloom.strength !== undefined ? bloom.strength : 1;\n  if ( changes && changes.bloom ) {\n    if ( changes.bloom.resolution ) {\n      var resolution = bloom.resolution !== undefined ? bloom.resolution : 256;\n      var aspect = this.getRenderer().getWidth() / this.getRenderer().getHeight();\n\n      this.bloomPass.setSize( resolution * aspect, resolution );\n    }\n  }\n  THREE.BloomPass.blurX.x = 1.0 / this.bloomPass.resolutionX;\n  THREE.BloomPass.blurY.y = 1.0 / this.bloomPass.resolutionY;\n  var sigma = this.bloom.sigma !== undefined ? this.bloom.sigma : 4;\n  this.bloomPass.setSigma( sigma );\n  \n  //Sepia\n  var sepia = this.sepia.override ? this.sepia : this.defaultFilters.sepia;\n  this.sepiaPass.uniforms.amount.value = sepia.amount !== undefined ? sepia.amount : 1;\n\n  //Vignette\n  var vignette = this.vignette.override ? this.vignette : this.defaultFilters.vignette;\n  this.vignettePass.uniforms.offset.value = vignette.offset !== undefined ? vignette.offset : 1;\n  this.vignettePass.uniforms.darkness.value = vignette.darkness !== undefined ? vignette.darkness : 1;\n\n  //SSAO\n  var ssao = this.ssao.override ? this.ssao : this.defaultFilters.ssao;\n  this.ssaoPass.uniforms.tDepth.value = this.rtTextureDepth;\n  this.ssaoPass.uniforms.onlyAO.value = ssao.onlyAO !== undefined ? ssao.onlyAO : 0;\n  this.ssaoPass.uniforms.aoClamp.value = ssao.aoClamp !== undefined ? ssao.aoClamp : 0.5;\n  this.ssaoPass.uniforms.lumInfluence.value = ssao.lumInfluence !== undefined ? ssao.lumInfluence : 0.5;\n  this.ssaoPass.uniforms.noiseAmount.value = ssao.noiseAmount !== undefined ? ssao.noiseAmount : 0.0003;\n  this.ssaoPass.uniforms.radius.value = ssao.radius !== undefined ? ssao.radius * this.getRenderer().devicePixelRatio : 5;\n  this.ssaoPass.uniforms.diffArea.value = ssao.diffArea !== undefined ? ssao.diffArea : 0.4;\n  this.ssaoPass.uniforms.gDisplace.value = ssao.gDisplace !== undefined ? ssao.gDisplace : 0.4;\n  this.ssaoPass.uniforms.fogEnabled.value = ssao.fogEnabled !== undefined ? ssao.fogEnabled : 1;\n  this.ssaoPass.uniforms.depthScale.value = ssao.depthScale !== undefined ? ssao.depthScale : 1000;\n\n  //DOF\n  var dof = this.dof.override ? this.dof : this.defaultFilters.dof;\n  this.dofPass.uniforms.tDepth.value = this.rtTextureDepth;\n  this.dofPass.uniforms.focus.value = dof.focus !== undefined ? dof.focus : 1;\n  this.dofPass.uniforms.aspect.value = dof.aspect !== undefined ? dof.aspect : 1;\n  this.dofPass.uniforms.aperture.value = dof.aperture !== undefined ? dof.aperture : 0.025;\n  this.dofPass.uniforms.maxblur.value = dof.maxblur !== undefined ? dof.maxblur : 1;\n};\n\nRenderFilters.prototype.preRenderView = function( scene, camera ) {\n  if ( camera === this.getThreeData() && scene && this.needsDepthPass && this.isEnabled() ) {\n    var threeRenderer = this.getThreeRenderer();\n    var oldOverride = scene.overrideMaterial;\n    var clearColour = threeRenderer.getClearColor();\n    var clearAlpha = threeRenderer.getClearAlpha();\n    // var viewPort = threeRenderer.getViewport();\n    scene.overrideMaterial = this.depthMaterial;\n    threeRenderer.setViewport( 0, 0, this.rtTextureDepth.width, this.rtTextureDepth.height );\n    //threeRenderer.setClearColor( 0xffffff );\n    threeRenderer.render( scene, camera, this.rtTextureDepth, true );\n    threeRenderer.setClearColor( clearColour, clearAlpha );\n    // threeRenderer.setViewport( viewPort.x, viewPort.y, viewPort.width, viewPort.height );\n    scene.overrideMaterial = oldOverride;\n    this.ssaoPass.uniforms.cameraNear.value = camera.near;\n    this.ssaoPass.uniforms.cameraFar.value = camera.far;\n    this.ssaoPass.uniforms.fogDensity.value = scene.fog.density;\n    // this.ssaoPass.uniforms.logDepthBufFC.value = 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 );\n\n    // this.fxaaPass.uniforms.resolution.value.x = 1.0 / viewPort.width;\n    // this.fxaaPass.uniforms.resolution.value.y = 1.0 / viewPort.height;\n  }\n};\n\nRenderFilters.prototype.resize = function( ) {\n\n  if ( this.composer ) {\n    var canvasWidth = this.getRenderer().getCanvasWidth();\n    var canvasHeight = this.getRenderer().getCanvasHeight();\n    this.composer.setSize( canvasWidth, canvasHeight );\n    if ( this.needsDepthPass ) {\n      this.rtTextureDepth.dispose();\n      this.rtTextureDepth = new THREE.WebGLRenderTarget( canvasWidth, canvasHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat } );\n      this.rtTextureDepth.name = "Depth Texture";\n    }\n\n    this.dofPass.uniforms.tDepth.value = this.rtTextureDepth;\n\n    this.fxaaPass.uniforms.resolution.value.x = 1.0 / canvasWidth;\n    this.fxaaPass.uniforms.resolution.value.y = 1.0 / canvasHeight;\n\n    this.bloomPass.setSize( canvasWidth, canvasHeight );\n    // this.bloomPass.bloom2Material.uniforms.resolution.value.x = 10.0 / canvasWidth;\n    // this.bloomPass.bloom2Material.uniforms.resolution.value.y = 10.0 / canvasHeight;\n\n    this.ssaoPass.uniforms.tDepth.value = this.rtTextureDepth;\n    this.ssaoPass.uniforms.size.value.x = canvasWidth;\n    this.ssaoPass.uniforms.size.value.y = canvasHeight;\n  }\n};\n\nreturn RenderFilters;\n';});


define('text!VeroldEngine/Components/BuiltIn/RenderView.js',[],function () { return '/**\n *\n * @class RenderView\n */\nfunction RenderView() {\n  this.renderEventName = "render";\n  this.enablePostProcess = true;\n  this.enableShadows = true;\n  this.enablePreRenderFunctions = true;\n  this.opacity = 1.0;\n  this.currentRenderContext = this;\n  this.renderTarget;\n}\n\n/*global VAPI*/\nRenderView.prototype = new VAPI.VeroldComponent();\n\nRenderView.prototype.init = function() {\n  \n  var renderEvent = parseInt( this.renderGroup, 10 );\n  if ( renderEvent ) {\n    this.renderEventName += "Group" + renderEvent;\n  }\n  this.getEngine().on( this.renderEventName, this.renderView, this );\n  this.getEngine().on( "resize", this.resize, this );\n  this.resize();\n\n  this.listenTo( this.getEntity(), \'enableRenderView\', this.enableRenderView );\n  this.listenTo( this.getEntity(), \'disableRenderView\', this.disableRenderView );\n  this.listenTo( this.getEntity(), \'toggleRenderView\', this.toggleRenderView );\n  this.listenTo( this.getEntity(), \'setViewport\', this.setViewport );\n};\n\nRenderView.prototype.shutdown = function() {\n  this.getEngine().off( this.renderEventName, this.renderView, this );\n  this.getEngine().off( "resize", this.resize, this );\n};\n\nRenderView.prototype.componentsLoaded = function() {\n  this.filters = this.getEntity().getComponentByScriptId(\'camera_filters_script\');\n};\n\nRenderView.prototype.enableRenderView = function( fade ) {\n  this.enable();\n  if ( fade ) {\n    this.fadeOutTime = 0.0\n    this.fadeInTime = fade;\n    this.opacityTime = 0.0;\n    this.opacity = 0.0;\n  }\n  else {\n    this.opacity = 1.0;\n  }\n};\n\nRenderView.prototype.disableRenderView = function( fade ) {\n  if ( fade ) {\n    this.fadeInTime = 0.0;\n    this.opacityTime = fade;\n    this.fadeOutTime = fade;\n    this.opacity = 1.0;\n  }\n  else {\n    this.disable();\n    this.opacity = 0.0;\n  }\n};\n\nRenderView.prototype.toggleRenderView = function( fade ) {\n  if ( this.isEnabled() ) {\n    this.disableRenderView( fade );\n  }\n  else {\n    this.enableRenderView( fade );\n  }\n};\n\nRenderView.prototype.setViewport = function( x, y, width, height, animationTime ) {\n  this.viewportLeft = x;\n  this.viewportBottom = y;\n  this.viewportWidth = width;\n  this.viewportHeight = height;\n  \n  if ( !animationTime ) {\n    this.resize();\n    this.animationTotalTime = 0;\n  }\n  else {\n    this.animationTotalTime = animationTime;\n    this.animationTime = 0;\n    this.oldX = this._x;\n    this.oldY = this._y;\n    this.oldWidth = this._width;\n    this.oldHeight = this._height;\n\n    this.updateViewport();\n\n    this.targetX = this._x;\n    this.targetY = this._y;\n    this.targetWidth = this._width;\n    this.targetHeight = this._height;\n\n    this._x = this.oldX;\n    this._y = this.oldY;\n    this._width = this.oldWidth;\n    this._height = this.oldHeight;\n  }\n};\n\nRenderView.prototype.updateViewport = function() {\n  var cWidth, cHeight, percent;\n  cWidth = this.getEngine().getBaseRenderer().getWidth();\n  cHeight = this.getEngine().getBaseRenderer().getHeight();\n\n  if ( this.viewportBottom.slice( -1 ) === "%" ) {\n    percent = parseFloat(this.viewportBottom.slice( 0, -1)) * 0.01;\n    this._y = parseInt(percent * cHeight, 10);\n  }\n  else {\n    this._y = parseInt(this.viewportBottom);\n  }\n  if ( this.viewportLeft.slice( -1 ) === "%" ) {\n    percent = parseFloat(this.viewportLeft.slice( 0, -1)) * 0.01;\n    this._x = parseInt(percent * cWidth, 10);\n  }\n  else {\n    this._x = parseInt(this.viewportLeft);\n  }\n  if ( this.viewportWidth.slice( -1 ) === "%" ) {\n    percent = parseFloat(this.viewportWidth.slice( 0, -1)) * 0.01;\n    this._width = parseInt(percent * cWidth, 10);\n  }\n  else {\n    this._width = parseInt(this.viewportWidth);\n  }\n  this._width = Math.min( this._width, cWidth - this._x );\n\n  if ( this.viewportHeight.slice( -1 ) === "%" ) {\n    percent = parseFloat(this.viewportHeight.slice( 0, -1)) * 0.01;\n    this._height = parseInt(percent * cHeight, 10);\n  }\n  else {\n    this._height = parseInt(this.viewportHeight);\n  }\n  this._height = Math.min( this._height, cHeight - this._y );\n\n  if ( this._x < 0 ) {\n    this._x += cWidth;\n  }\n  if ( this._y < 0 ) {\n    this._y += cHeight;\n  }\n};\n\nRenderView.prototype.updateCameraProjection = function() {\n  var camera = this.getThreeData();\n  if ( camera ) {\n    camera.aspect = this._width / this._height;\n    camera.updateProjectionMatrix();\n  }\n};\n\nRenderView.prototype.resize = function() {\n  this.updateViewport();\n  this.updateCameraProjection();\n};\n\nRenderView.prototype.setRenderOverride = function( fn, context ) {\n\n  this.getEngine().off( this.renderEventName, this.renderView, this.currentRenderContext );\n  if ( fn ) {\n    this.getEngine().on( this.renderEventName, fn, context );\n    this.currentRenderContext = context;\n  }\n  else {\n    this.getEngine().on( this.renderEventName, this.renderView, this );\n  }\n};\n\nRenderView.prototype.renderView = function(delta) {\n  if ( this.isEnabled() ) {\n    var scene = this.getScene();\n    var renderTarget = null;\n    if ( this.renderTarget ) {\n      if ( !this.renderTarget.threeData ) {\n        return;\n      }\n      else {\n        renderTarget = this.renderTarget.threeData;\n      }\n    }\n    if (this.hasThreeData() && scene && scene.threeData ) {\n      if ( this.fadeInTime ) {\n        this.getEngine().needsRender = true;\n        this.opacityTime += delta;\n        this.opacity = this.opacityTime * this.opacityTime / this.fadeInTime;\n        if ( this.opacity > 1.0 ) {\n          this.opacity = 1.0;\n          this.fadeInTime = 0.0;\n          this.opacityTime = 0.0;\n        }\n      }\n      else if ( this.fadeOutTime ) {\n        this.getEngine().needsRender = true;\n        if ( this.opacityTime === -1.0 ) {\n          this.disable();\n          this.opacity = 0;\n          this.fadeOutTime = 0.0;\n          this.opacityTime = 0.0;\n          this.disable();\n        }\n        else {\n          this.opacityTime -= delta;\n          if ( this.opacityTime <= 0.0 ) {\n            this.opacity = 0.0001;\n            this.opacityTime = -1.0;\n          }\n          else {\n            this.opacity = this.opacityTime / this.fadeOutTime;\n            // this.opacity = Math.min( this.opacity, 1.0 );\n          }\n        }\n      }\n      if ( this.animationTotalTime > 0 ) {\n        this.getEngine().needsRender = true;\n        this.animationTime += delta;\n        var animationProgress = this.animationTime / this.animationTotalTime;\n        if ( animationProgress >= 1.0 ) {\n          this.animationTotalTime = 0;\n          animationProgress = 1.0;\n        }\n\n        this._x = (1.0 - animationProgress) * this.oldX + animationProgress * this.targetX;\n        this._y = (1.0 - animationProgress) * this.oldY + animationProgress * this.targetY;\n        this._width = (1.0 - animationProgress) * this.oldWidth + animationProgress * this.targetWidth;\n        this._height = (1.0 - animationProgress) * this.oldHeight + animationProgress * this.targetHeight;\n\n        this.updateCameraProjection();\n      }\n\n      // this.getThreeRenderer().clear( this.clearColor, this.clearDepth, true );\n      // this.getThreeRenderer().setViewport( this._x, this._y, this._width, this._height );\n      this.getRenderer().renderView( scene.threeData, this.getThreeData(), {\n        viewPort: { x: this._x, y: this._y, width: this._width, height: this._height},\n        enablePreRenderFunctions: this.enablePreRenderFunctions,\n        composer: this.filters ? this.filters.composer : null,\n        enableShadows: this.enableShadows,\n        clearColor: this.clearColor,\n        clearDepth: this.clearDepth,\n        delta: delta,\n        opacity: this.opacity,\n        renderTarget: renderTarget } );\n    }\n  } \n};\n\nreturn RenderView;\n';});


define('text!VeroldEngine/Components/BuiltIn/HMDRenderEffect.js',[],function () { return '// The MIT License\n\n// Copyright  2010-2015 three.js authors\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/**\n * This effect is heavily, heavily based on THREE.OculusRiftEffect by troffmo5 / http://github.com/troffmo5\n *\n * It has been modified to work with the Verold renderer.\n *\n */\nfunction HMDRenderEffect() {\n  // this.hmdEffect = null;\n\n  // Parameters from the Oculus Rift DK1\n  this.hScreenSize = 0.14976;\n  this.vScreenSize = 0.0936;\n  this.interpupillaryDistance = 0.064;\n  this.lensSeparationDistance = 0.064;\n  this.eyeToScreenDistance = 0.041;\n  this.distortionK = [1.0, 0.22, 0.24, 0.0];\n  this.chromaAbParameter = [ 0.996, -0.004, 1.014, 0.0];\n  this.vResolution = 1080;\n  this.hResolution = 1920;\n}\n\nHMDRenderEffect.prototype = new VAPI.VeroldComponent();\n\nHMDRenderEffect.prototype.init = function() {\n  this.getEngine().on(\'resize\', this.resize, this );\n  this.on( \'enable\', this.onEnabled, this );\n  this.on( \'disable\', this.onDisabled, this );\n};\n\nHMDRenderEffect.prototype.shutdown = function() {\n  this.getEngine().off(\'resize\', this.resize, this );\n  this.off( \'enable\', this.onEnabled, this );\n  this.off( \'disable\', this.onDisabled, this );\n  if ( this.hmdRenderTarget ) {\n    this.hmdRenderTarget.dispose();\n  }\n};\n\nHMDRenderEffect.prototype.componentsLoaded = function(delta) {\n  this.renderViewComp = this.getEntity().getComponentByScriptId( \'render_view_component\');\n  this.renderFiltersComp = this.getEntity().getComponentByScriptId( \'camera_filters_script\');\n  if ( this.isEnabled() ) {\n    this.initHMDEffect();\n    this.onEnabled();\n  }\n};\n\nHMDRenderEffect.prototype.resize = function() {\n\n  if ( this.isEnabled() ) {\n    this.RTParams = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n    this.left = {};\n    this.right = {};\n    var distScale = 1.0;\n    this.hResolution = this.getRenderer().getWidth();\n    this.vResolution = this.getRenderer().getHeight();\n    \n    // Compute aspect ratio and FOV\n    var aspect = this.hResolution / (2*this.vResolution);\n\n    // Fov is normally computed with:\n    //   THREE.Math.radToDeg( 2*Math.atan2(this.vScreenSize,2*this.eyeToScreenDistance) );\n    // But with lens distortion it is increased (see Oculus SDK Documentation)\n    var r = -1.0 - (4 * (this.hScreenSize/4 - this.lensSeparationDistance/2) / this.hScreenSize);\n    distScale = (this.distortionK[0] + this.distortionK[1] * Math.pow(r,2) + this.distortionK[2] * Math.pow(r,4) + this.distortionK[3] * Math.pow(r,6));\n    var fov = THREE.Math.radToDeg(2*Math.atan2(this.vScreenSize*distScale, 2*this.eyeToScreenDistance));\n\n    // Compute camera projection matrices\n    var proj = (new THREE.Matrix4()).makePerspective( fov, aspect, 0.01, 10000 );\n    var h = 4 * (this.hScreenSize/4 - this.interpupillaryDistance/2) / this.hScreenSize;\n    this.left.proj = ((new THREE.Matrix4()).makeTranslation( h, 0.0, 0.0 )).multiply(proj);\n    this.right.proj = ((new THREE.Matrix4()).makeTranslation( -h, 0.0, 0.0 )).multiply(proj);\n\n    // Compute camera transformation matrices\n    this.left.tranform = (new THREE.Matrix4()).makeTranslation( -this.interpupillaryDistance/2, 0.0, 0.0 );\n    this.right.tranform = (new THREE.Matrix4()).makeTranslation( this.interpupillaryDistance/2, 0.0, 0.0 );\n\n    // Compute Viewport\n    this.left.viewport = [0, 0, this.hResolution/2, this.vResolution];\n    this.right.viewport = [this.hResolution/2, 0, this.hResolution/2, this.vResolution];\n\n    // Distortion shader parameters\n    var lensShift = 4 * (this.hScreenSize/4 - this.lensSeparationDistance/2) / this.hScreenSize;\n    this.left.lensCenter = new THREE.Vector2( lensShift, 0.0);\n    this.right.lensCenter = new THREE.Vector2( -lensShift, 0.0);\n\n    this.RTMaterial.uniforms.hmdWarpParam.value = new THREE.Vector4(this.distortionK[0], this.distortionK[1], this.distortionK[2], this.distortionK[3]);\n    this.RTMaterial.uniforms.chromAbParam.value = new THREE.Vector4(this.chromaAbParameter[0], this.chromaAbParameter[1], this.chromaAbParameter[2], this.chromaAbParameter[3]);\n    this.RTMaterial.uniforms.scaleIn.value = new THREE.Vector2(1.0,1.0/aspect);\n    this.RTMaterial.uniforms.scale.value = new THREE.Vector2(1.0/distScale, 1.0*aspect/distScale);\n\n    // Create render target\n    if ( this.hmdRenderTarget ) {\n      this.hmdRenderTarget.dispose();\n    }\n    this.hmdRenderTarget = new THREE.WebGLRenderTarget( Math.floor(this.hResolution*distScale/2), Math.floor(this.vResolution*distScale), this.RTParams );\n    this.RTMaterial.uniforms.texid.value = this.hmdRenderTarget;\n  }\n};\n\nHMDRenderEffect.prototype.onEnabled = function() {\n  \n  if ( this.renderViewComp ) {\n    this.renderViewComp.setRenderOverride( this.renderView, this );\n    this.resize();\n  }\n};\n\nHMDRenderEffect.prototype.onDisabled = function() {\n  if ( this.renderViewComp ) {\n    this.renderViewComp.setRenderOverride( null );\n  }\n};\n\nHMDRenderEffect.prototype.renderView = function( delta ) {\n\n  if ( this.isEnabled() ) {\n\n    var scene = this.getThreeScene();\n\n    if ( this.hasThreeData() && scene ) {\n\n      var camera = this.getThreeData();\n      if (camera.matrixAutoUpdate) camera.updateMatrix();\n\n      // Render left\n      this.pCamera.projectionMatrix.copy( this.left.proj );\n\n      this.pCamera.matrix.copy(camera.matrix).multiply( this.left.tranform);\n      this.pCamera.matrixWorldNeedsUpdate = true;\n      this.RTMaterial.uniforms.lensCenter.value = this.left.lensCenter;\n\n      this.getRenderer().renderView( scene, this.pCamera, {\n        enablePreRenderFunctions: this.renderViewComp.enablePreRenderFunctions,\n        composer: this.renderFiltersComp ? this.renderFiltersComp.composer : null,\n        enableShadows: this.renderViewComp.enableShadows,\n        clearColor: true,\n        clearDepth: true,\n        renderTarget: this.hmdRenderTarget,\n        delta: delta,\n        opacity: 1.0 } );\n\n      this.getThreeRenderer().setRenderTarget( null );\n      this.getThreeRenderer().setViewport( this.left.viewport[0], this.left.viewport[1], this.left.viewport[2], this.left.viewport[3] );\n      this.getThreeRenderer().render( this.finalScene, this.oCamera );\n\n      // Render right\n      this.pCamera.projectionMatrix.copy( this.right.proj );\n\n      this.pCamera.matrix.copy(camera.matrix).multiply( this.right.tranform);\n      this.pCamera.matrixWorldNeedsUpdate = true;\n\n      // renderer.setViewport( this.right.viewport[0], this.right.viewport[1], this.right.viewport[2], this.right.viewport[3]);\n\n      this.RTMaterial.uniforms.lensCenter.value = this.right.lensCenter;\n\n      // renderer.render( scene, this.pCamera, this.hmdRenderTarget, this.clearFlag );\n      // this.clearFlag = false;\n\n      this.getRenderer().renderView( scene, this.pCamera, {\n        // viewPort: { x: this.right.viewport[0], y: this.right.viewport[1], width: this.right.viewport[2], height: this.right.viewport[3]},\n        // viewPort: { x: this.renderViewComp._x, y: this.renderViewComp._y, width: this.renderViewComp._width, height: this.renderViewComp._height},\n        enablePreRenderFunctions: this.renderViewComp.enablePreRenderFunctions,\n        composer: this.renderFiltersComp ? this.renderFiltersComp.composer : null,\n        enableShadows: this.renderViewComp.enableShadows,\n        clearColor: this.renderViewComp.clearColor,\n        clearDepth: this.renderViewComp.clearDepth,\n        renderTarget: this.hmdRenderTarget,\n        delta: delta,\n        opacity: 1.0 } );\n\n      this.getThreeRenderer().setRenderTarget( null );\n      this.getThreeRenderer().setViewport( this.right.viewport[0], this.right.viewport[1], this.right.viewport[2], this.right.viewport[3] );\n      this.getThreeRenderer().render( this.finalScene, this.oCamera );\n    }\n  }\n};\n\n/**\n *\n * This effect is heavily, heavily based on THREE.OculusRiftEffect by troffmo5 / http://github.com/troffmo5\n *\n */\nHMDRenderEffect.prototype.initHMDEffect = function() {\n\n  // Perspective camera\n  this.pCamera = new THREE.PerspectiveCamera();\n  this.pCamera.matrixAutoUpdate = false;\n  this.pCamera.target = new THREE.Vector3();\n\n  // Orthographic camera\n  this.oCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, 1, 1000 );\n  this.oCamera.position.z = 1;\n\n  this.hResolution = this.getRenderer().getCanvasWidth();\n  this.vResolution = this.getRenderer().getCanvasHeight();\n\n  \n  this.RTMaterial = new THREE.ShaderMaterial( {\n    uniforms: {\n      "texid": { type: "t", value: null },\n      "scale": { type: "v2", value: new THREE.Vector2(1.0,1.0) },\n      "scaleIn": { type: "v2", value: new THREE.Vector2(1.0,1.0) },\n      "lensCenter": { type: "v2", value: new THREE.Vector2(0.0,0.0) },\n      "hmdWarpParam": { type: "v4", value: new THREE.Vector4(1.0,0.0,0.0,0.0) },\n      "chromAbParam": { type: "v4", value: new THREE.Vector4(1.0,0.0,0.0,0.0) }\n    },\n    vertexShader: [\n      "varying vec2 vUv;",\n      "void main() {",\n      " vUv = uv;",\n      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",\n      "}"\n    ].join("\\n"),\n\n    fragmentShader: [\n      "uniform vec2 scale;",\n      "uniform vec2 scaleIn;",\n      "uniform vec2 lensCenter;",\n      "uniform vec4 hmdWarpParam;",\n      \'uniform vec4 chromAbParam;\',\n      "uniform sampler2D texid;",\n      "varying vec2 vUv;",\n      "void main()",\n      "{",\n      "  vec2 uv = (vUv*2.0)-1.0;", // range from [0,1] to [-1,1]\n      "  vec2 theta = (uv-lensCenter)*scaleIn;",\n      "  float rSq = theta.x*theta.x + theta.y*theta.y;",\n      "  vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);",\n      \'  vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);\',\n      "  vec2 tcBlue = (lensCenter + scale * rBlue);",\n      "  tcBlue = (tcBlue+1.0)/2.0;", // range from [-1,1] to [0,1]\n      "  if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue))) {",\n      "    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);",\n      "    return;}",\n      "  vec2 tcGreen = lensCenter + scale * rvector;",\n      "  tcGreen = (tcGreen+1.0)/2.0;", // range from [-1,1] to [0,1]\n      "  vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);",\n      "  vec2 tcRed = lensCenter + scale * rRed;",\n      "  tcRed = (tcRed+1.0)/2.0;", // range from [-1,1] to [0,1]\n      "  gl_FragColor = vec4(texture2D(texid, tcRed).r, texture2D(texid, tcGreen).g, texture2D(texid, tcBlue).b, 1);",\n      "}"\n    ].join("\\n")\n  } );\n\n  this.mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), this.RTMaterial );\n\n  // Final scene\n  this.finalScene = new THREE.Scene();\n  this.finalScene.add( this.oCamera );\n  this.finalScene.add( this.mesh );\n\n  this.resize();\n\n\n};\nreturn HMDRenderEffect;\n\n';});


define('text!VeroldEngine/Components/BuiltIn/DebugTextureRender.js',[],function () { return '/**\n *\n * @class DebugTextureRender\n */\nfunction DebugTextureRender() {\n  this.renderEventName = "render";\n  this.currentRenderContext = this;\n  // this.texture2D = null;\n}\n\n/*global VAPI*/\nDebugTextureRender.prototype = new VAPI.VeroldComponent();\n\nDebugTextureRender.prototype.init = function() {\n\n  this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\n  this.scene  = new THREE.Scene();\n\n  this.material = new THREE.ShaderMaterial( THREE.CopyShader );\n\n  this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), this.material );\n  this.scene.add( this.quad );\n\n  this.getEntity().when(\'load\', this.objectLoaded, this );\n  \n  var renderEvent = parseInt( this.renderGroup, 10 );\n  if ( renderEvent ) {\n    this.renderEventName += "Group" + renderEvent;\n  }\n  this.getEngine().on( this.renderEventName, this.renderView, this );\n  this.getEngine().on( "resize", this.resize, this );\n  this.resize();\n};\n\nDebugTextureRender.prototype.shutdown = function() {\n  this.getEngine().off( this.renderEventName, this.renderView, this );\n  this.getEngine().off( "resize", this.resize, this );\n};\n\nDebugTextureRender.prototype.objectLoaded = function() {\n  this.material.uniforms.tDiffuse.value = this.getThreeData();\n};\n\nDebugTextureRender.prototype.setViewport = function( x, y, width, height ) {\n  this.viewportLeft = x;\n  this.viewportBottom = y;\n  this.viewportWidth = width;\n  this.viewportHeight = height;\n      \n  this.oldX = this._x;\n  this.oldY = this._y;\n  this.oldWidth = this._width;\n  this.oldHeight = this._height;\n\n  this.updateViewport();\n\n  this.targetX = this._x;\n  this.targetY = this._y;\n  this.targetWidth = this._width;\n  this.targetHeight = this._height;\n\n  this._x = this.oldX;\n  this._y = this.oldY;\n  this._width = this.oldWidth;\n  this._height = this.oldHeight;\n\n};\n\nDebugTextureRender.prototype.updateViewport = function() {\n  var cWidth, cHeight, percent;\n  cWidth = this.getEngine().getBaseRenderer().getWidth();\n  cHeight = this.getEngine().getBaseRenderer().getHeight();\n\n  if ( this.viewportBottom.slice( -1 ) === "%" ) {\n    percent = parseFloat(this.viewportBottom.slice( 0, -1)) * 0.01;\n    this._y = parseInt(percent * cHeight, 10);\n  }\n  else {\n    this._y = parseInt(this.viewportBottom);\n  }\n  if ( this.viewportLeft.slice( -1 ) === "%" ) {\n    percent = parseFloat(this.viewportLeft.slice( 0, -1)) * 0.01;\n    this._x = parseInt(percent * cWidth, 10);\n  }\n  else {\n    this._x = parseInt(this.viewportLeft);\n  }\n  if ( this.viewportWidth.slice( -1 ) === "%" ) {\n    percent = parseFloat(this.viewportWidth.slice( 0, -1)) * 0.01;\n    this._width = parseInt(percent * cWidth, 10);\n  }\n  else {\n    this._width = parseInt(this.viewportWidth);\n  }\n  if ( this.viewportHeight.slice( -1 ) === "%" ) {\n    percent = parseFloat(this.viewportHeight.slice( 0, -1)) * 0.01;\n    this._height = parseInt(percent * cHeight, 10);\n  }\n  else {\n    this._height = parseInt(this.viewportHeight);\n  }\n\n  if ( this._x < 0 ) {\n    this._x += cWidth;\n  }\n  if ( this._y < 0 ) {\n    this._y += cHeight;\n  }\n};\n\nDebugTextureRender.prototype.updateCameraProjection = function() {\n  var camera = this.getThreeData();\n  if ( camera ) {\n    camera.aspect = this._width / this._height;\n    // camera.updateProjectionMatrix();\n  }\n};\n\nDebugTextureRender.prototype.resize = function() {\n  this.updateViewport();\n  this.updateCameraProjection();\n};\n\nDebugTextureRender.prototype.renderView = function(delta) {\n  if ( this.isEnabled() ) {\n    // var scene = this.getScene();\n    if (this.hasThreeData() ) {\n      \n      // this.getThreeRenderer().clear( this.clearColor, this.clearDepth, true );\n      var oldViewport = this.getThreeRenderer().getViewport();\n      this.getThreeRenderer().setRenderTarget(null);\n      this.getThreeRenderer().setViewport( this._x, this._y, this._width, this._height );\n      this.getThreeRenderer().render( this.scene, this.camera );\n      this.getThreeRenderer().setViewport( oldViewport._x, oldViewport._y, oldViewport._width, oldViewport._height );\n    }\n  } \n};\n\nreturn DebugTextureRender;\n';});


define('text!VeroldEngine/Components/BuiltIn/RenderTargetViewer.js',[],function () { return '/**\r\n *\r\n * @class RenderTargetViewer\r\n */\r\nfunction RenderTargetViewer() {\r\n  this.renderEventName = "render";\r\n  this.currentRenderContext = this;\r\n  this.textureRegistryById = {};\r\n  // this.textureRegistryByName = {};\r\n}\r\n\r\nRenderTargetViewer.EL_CSS = {\r\n  \'position\': \'absolute\',\r\n  \'left\': 0,\r\n  \'top\': 0,\r\n  \'padding\': \'8px\',\r\n  \'border-radius\': \'5px\',\r\n  \'font-family\': \'"proxima_nova_regular",Helvetica,Arial,sans-serif\',\r\n  \'max-width\' : \'25%\',\r\n  \'min-width\' : \'25px\',\r\n  \'transition\': \'opacity 0.1s ease-in-out, background 0.1s ease-in-out\',\r\n  \'cursor\' : \'pointer\',\r\n  // \'display\' : \'none\'\r\n};\r\n\r\nRenderTargetViewer.TEXT_CSS = {\r\n  \'color\': \'#fff\',\r\n  \'font-family\': \'"proxima_nova_regular",Helvetica,Arial,sans-serif\',\r\n  \'word-wrap\':\'break-word\',\r\n  \'-webkit-touch-callout\': \'none\',\r\n  \'-webkit-user-select\': \'none\',\r\n  \'-khtml-user-select\': \'none\',\r\n  \'-moz-user-select\': \'none\',\r\n  \'-ms-user-select\': \'none\',\r\n  \'user-select\': \'none\',\r\n  \'pointer-events\' : \'none\',\r\n  \'line-height\' : \'115%\',\r\n  \'font-size\' : \'1.8vmin\'  //1.8vmax for mobile, 1.8vmin for desktop\r\n};\r\n\r\nfunction css (el, styles) {\r\n  // if args length is 3, then el, property, value\r\n\r\n  if (!el || !el.style) {\r\n    return;\r\n  }\r\n\r\n  if (typeof styles === \'string\') {\r\n    if (arguments.length === 2) {\r\n      return el.style[arguments[1]];\r\n    } else {\r\n      el.style[arguments[1]] = arguments[2];\r\n    }\r\n  }\r\n  for (var i in styles) {\r\n    if (styles.hasOwnProperty(i)) {\r\n      el.style[i] = styles[i];\r\n    }\r\n  }\r\n}\r\n\r\nfunction addClass(el, className) {\r\n  if (el.classList) {\r\n    el.classList.add(className);\r\n  } else {\r\n    el.className += \' \' + className;\r\n  }\r\n}\r\n\r\n/*global VAPI*/\r\nRenderTargetViewer.prototype = new VAPI.VeroldComponent();\r\n\r\nRenderTargetViewer.prototype.preInit = RenderTargetViewer.prototype.preInitEditor = function() {\r\n  VAPI.globalEvents.on( "veroldEngine:textureDebugger:registerTexture", this.registerTexture, this );\r\n  VAPI.globalEvents.on( "veroldEngine:textureDebugger:unregisterTexture", this.unregisterTexture, this );\r\n};\r\n\r\nRenderTargetViewer.prototype.init = RenderTargetViewer.prototype.editorInit = function() {\r\n\r\n  this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\r\n  this.scene  = new THREE.Scene();\r\n\r\n  this.material = new THREE.ShaderMaterial( THREE.CopyShader );\r\n\r\n  this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), this.material );\r\n  this.scene.add( this.quad );\r\n\r\n  // this.getEntity().when(\'load\', this.objectLoaded, this );\r\n  \r\n  var renderEvent = parseInt( this.renderGroup, 10 );\r\n  if ( renderEvent ) {\r\n    this.renderEventName += "Group" + renderEvent;\r\n  }\r\n  this.getEngine().on( this.renderEventName, this.renderView, this );\r\n  this.getEngine().on( "resize", this.resize, this );\r\n  this.resize();\r\n};\r\n\r\nRenderTargetViewer.prototype.shutdown = RenderTargetViewer.prototype.editorShutdown = function() {\r\n  VAPI.globalEvents.off( "veroldEngine:textureDebugger:registerTexture", this.registerTexture, this );\r\n  VAPI.globalEvents.off( "veroldEngine:textureDebugger:unregisterTexture", this.unregisterTexture, this );\r\n  this.getEngine().off( this.renderEventName, this.renderView, this );\r\n  this.getEngine().off( "resize", this.resize, this );\r\n};\r\n\r\nRenderTargetViewer.prototype.registerTexture = function( texture ) {\r\n  this.textureRegistryById[ texture.uuid ] = texture;\r\n};\r\n\r\nRenderTargetViewer.prototype.unregisterTexture = function( texture ) {\r\n  if ( !this.textureRegistryById[ texture.uuid ] ) {\r\n    console.warn( "Unregistering render target that isn\'t registered");\r\n  }\r\n  else {\r\n    delete this.textureRegistryById[ texture.uuid ];\r\n  }\r\n};\r\n\r\n// RenderTargetViewer.prototype.updateNameRegistry = function( ) {\r\n//   _.each( this.textureRegistryById, function( tex ) {\r\n//     if ( tex.name && tex.name !== \'\' ) {\r\n//       if ( this.textureRegistryByName[ tex.name ] && this.textureRegistryByName[ tex.name ].uuid !== tex.uuid ) {\r\n//         console.warn("RenderTargetViewer: More than one texture registered with the name, " + tex.name );\r\n//       }\r\n//       this.textureRegistryByName[ tex.name ] = tex;\r\n//     }\r\n//   }, this );\r\n  \r\n// };\r\n\r\nRenderTargetViewer.prototype.setTexture = function( textureId ) {\r\n  this.threeTexture = null;\r\n  \r\n  if ( textureId ) {\r\n    this.threeTexture = this.textureRegistryById[ textureId ];\r\n    this.material.uniforms.tDiffuse.value = this.threeTexture;\r\n    this.quad.visible = true;\r\n  }\r\n  else {\r\n    this.quad.visible = false;\r\n  }\r\n};\r\n\r\nRenderTargetViewer.prototype.setViewport = function( x, y, width, height ) {\r\n  this.viewportLeft = x;\r\n  this.viewportBottom = y;\r\n  this.viewportWidth = width;\r\n  this.viewportHeight = height;\r\n      \r\n  this.oldX = this._x;\r\n  this.oldY = this._y;\r\n  this.oldWidth = this._width;\r\n  this.oldHeight = this._height;\r\n\r\n  this.updateViewport();\r\n\r\n  this.targetX = this._x;\r\n  this.targetY = this._y;\r\n  this.targetWidth = this._width;\r\n  this.targetHeight = this._height;\r\n\r\n  this._x = this.oldX;\r\n  this._y = this.oldY;\r\n  this._width = this.oldWidth;\r\n  this._height = this.oldHeight;\r\n\r\n};\r\n\r\nRenderTargetViewer.prototype.updateViewport = function() {\r\n  var cWidth, cHeight, percent;\r\n  cWidth = this.getEngine().getBaseRenderer().getWidth();\r\n  cHeight = this.getEngine().getBaseRenderer().getHeight();\r\n\r\n  if ( this.viewportBottom.slice( -1 ) === "%" ) {\r\n    percent = parseFloat(this.viewportBottom.slice( 0, -1)) * 0.01;\r\n    this._y = parseInt(percent * cHeight, 10);\r\n  }\r\n  else {\r\n    this._y = parseInt(this.viewportBottom);\r\n  }\r\n  if ( this.viewportLeft.slice( -1 ) === "%" ) {\r\n    percent = parseFloat(this.viewportLeft.slice( 0, -1)) * 0.01;\r\n    this._x = parseInt(percent * cWidth, 10);\r\n  }\r\n  else {\r\n    this._x = parseInt(this.viewportLeft);\r\n  }\r\n  if ( this.viewportWidth.slice( -1 ) === "%" ) {\r\n    percent = parseFloat(this.viewportWidth.slice( 0, -1)) * 0.01;\r\n    this._width = parseInt(percent * cWidth, 10);\r\n  }\r\n  else {\r\n    this._width = parseInt(this.viewportWidth);\r\n  }\r\n  if ( this.viewportHeight.slice( -1 ) === "%" ) {\r\n    percent = parseFloat(this.viewportHeight.slice( 0, -1)) * 0.01;\r\n    this._height = parseInt(percent * cHeight, 10);\r\n  }\r\n  else {\r\n    this._height = parseInt(this.viewportHeight);\r\n  }\r\n\r\n  if ( this._x < 0 ) {\r\n    this._x += cWidth;\r\n  }\r\n  if ( this._y < 0 ) {\r\n    this._y += cHeight;\r\n  }\r\n};\r\n\r\n// RenderTargetViewer.prototype.updateCameraProjection = function() {\r\n//   var camera = this.getThreeData();\r\n//   if ( camera ) {\r\n//     camera.aspect = this._width / this._height;\r\n//     // camera.updateProjectionMatrix();\r\n//   }\r\n// };\r\n\r\nRenderTargetViewer.prototype.updateTextureDropdown = function() {\r\n  if ( this.isEnabled() ) {\r\n    var that = this;\r\n    setTimeout( function() {\r\n      var newOption;\r\n      \r\n      if ( !that.textureDropDown ) {\r\n        that.textureDropDown = document.createElement(\'select\');\r\n        that.textureDropDown.name = "Poop";\r\n        that.textureDropDown.id = "Poop";\r\n        addClass(that.textureDropDown, \'debugger-dropdown\');\r\n        css(that.textureDropDown, RenderTargetViewer.EL_CSS);\r\n        var canvas = that.getThreeRenderer().domElement;\r\n        if ( canvas.parentElement ) {\r\n          canvas.parentElement.appendChild( that.textureDropDown );\r\n        }\r\n        else {\r\n          canvas.appendChild( that.textureDropDown );\r\n        }\r\n        that.textureDropDown.onchange = function( event, thing ) {\r\n          that.setTexture( that.textureDropDown.value );\r\n        };\r\n      }\r\n\r\n      that.textureDropDown.options.length = 0;\r\n      newOption = document.createElement(\'option\');\r\n      newOption.value = 0;\r\n      newOption.text = "None";\r\n      that.textureDropDown.appendChild( newOption );\r\n\r\n      _.each( that.textureRegistryById, function( tex, id ) {\r\n        newOption = document.createElement(\'option\');\r\n        newOption.value = id;\r\n        newOption.text = tex.name !== \'\' ? tex.name : id;\r\n        if ( tex.__webglTexture ) {\r\n          that.textureDropDown.appendChild( newOption );\r\n        }\r\n      }, that );\r\n      that.textureDropDown.style.top = (that.getEngine().getBaseRenderer().getHeight() - that._y - that._height) + \'px\';\r\n      that.textureDropDown.style.left = that._x + \'px\';\r\n      that.textureDropDown.style.zIndex = 200;\r\n    }, 0);\r\n  }\r\n};\r\n\r\nRenderTargetViewer.prototype.resize = function() {\r\n  if ( this.isEnabled() ) {\r\n    this.updateTextureDropdown();\r\n    this.updateViewport();\r\n    // this.updateCameraProjection();\r\n  }\r\n};\r\n\r\nRenderTargetViewer.prototype.renderView = function(delta) {\r\n  if ( this.isEnabled() ) {\r\n    // var scene = this.getScene();\r\n    if (this.threeTexture ) {\r\n      \r\n      // this.getThreeRenderer().clear( this.clearColor, this.clearDepth, true );\r\n      var oldViewport = this.getThreeRenderer().getViewport();\r\n      this.getThreeRenderer().setRenderTarget(null);\r\n      this.getThreeRenderer().setViewport( this._x, this._y, this._width, this._height );\r\n      this.getThreeRenderer().render( this.scene, this.camera );\r\n      this.getThreeRenderer().setViewport( oldViewport._x, oldViewport._y, oldViewport._width, oldViewport._height );\r\n      \r\n    }\r\n  } \r\n};\r\n\r\nreturn RenderTargetViewer;\r\n';});


define('text!VeroldEngine/Components/BuiltIn/RenderModes.js',[],function () { return 'var _ = require(\'underscore\');\n\n/* global VAPI */\nvar EngineMaterials = require(\'VeroldEngine/Materials/EngineMaterials\');\n\n/**\n * A custom RenderModes class.\n *\n * @class RenderModes\n */\nfunction RenderModes() {\n  this.wireframeCache = {};\n  this.currentRenderMode = "Lit";\n  this.skinWeightsMatDef = {\n    side : THREE.DoubleSide,\n    vertexShader: [\n      THREE.ShaderChunk[ "skinning_pars_vertex" ],\n      "varying vec3 vColor;",\n\n      "void main() {",\n        THREE.ShaderChunk[ "skinbase_vertex" ],\n        THREE.ShaderChunk[ "skinning_vertex" ],\n        THREE.ShaderChunk[ "default_vertex" ],\n\n        "#ifdef USE_SKINNING",\n        "vColor = vec3( skinWeight.x, skinWeight.y, skinWeight.z);",\n        "#else",\n        "vColor = vec3( 0.0, 0.0, 0);",\n        "#endif",\n      "}"\n\n    ].join("\\n"),\n\n    fragmentShader: [\n      "varying vec3 vColor;",\n      "void main() {",\n        "gl_FragColor = vec4( vColor, 1.0 );",\n      "}"\n    ].join("\\n")\n  };\n\n  this.skinIndicesMatDef = {\n    side : THREE.DoubleSide,\n    vertexShader: [\n      THREE.ShaderChunk[ "skinning_pars_vertex" ],\n      "varying vec3 vColor;",\n\n      "void main() {",\n        THREE.ShaderChunk[ "skinbase_vertex" ],\n        THREE.ShaderChunk[ "skinning_vertex" ],\n        THREE.ShaderChunk[ "default_vertex" ],\n\n        "#ifdef USE_SKINNING",\n        "vColor = vec3( pow(skinIndex.x * 0.0025, 0.125), pow(skinIndex.y * 0.0025, 0.125), pow(skinIndex.z * 0.0025, 0.125));",\n        "#else",\n        "vColor = vec3( 0.0, 0.0, 0);",\n        "#endif",\n      "}"\n    ].join("\\n"),\n\n    fragmentShader: [\n      "varying vec3 vColor;",\n      "void main() {",\n        "gl_FragColor = vec4( vColor, 1.0 );",\n      "}"\n    ].join("\\n")\n\n  };\n\n  this.renderModes = {\n    "Lit" : {\n      "overrideMaterial" : null,\n      // "overlayEnable" : false,\n      "overrideUniforms" : [\n        { name : "renderModeNormals", value: 0 },\n      ],\n      "wireframeEnable" : false,\n    },\n    "Unlit" : {\n      "overrideMaterial" : null,\n      "disableLights" : true,\n      // "overlayEnable" : false,\n      "overrideUniforms" : [\n        { name : "renderModeNormals", value: 0 },\n      ],\n      "wireframeEnable" : false,\n    },\n    "Normals" : {\n      "overrideMaterial" : null,\n      "overrideUniforms" : [\n        { name : "renderModeNormals", value: 1},\n      ],\n      // "overlayEnable" : false,\n      "wireframeEnable" : false,\n    },\n    "Wireframe" : {\n      "overrideMaterial" : null,\n      // "overlayEnable" : true,\n      "overrideUniforms" : [\n        { name : "renderModeNormals", value: 0},\n      ],\n      "wireframeEnable" : true,\n      // "overlayMaterial" : { \n      //   "skinned" : new THREE.ShaderMaterial( EngineMaterials.wireframe ), \n      //   "static" : new THREE.ShaderMaterial( EngineMaterials.wireframe )\n      // }\n    },\n    "Flat-shaded Wireframe" : {\n      "overrideMaterial" : "flatShaded",\n      "overlayEnable" : true,\n      "wireframeEnable" : true,\n      // "overlayMaterial" : { \n      //   "skinned" : new THREE.ShaderMaterial( EngineMaterials.wireframe ), \n      //   "static" : new THREE.ShaderMaterial( EngineMaterials.wireframe )\n      // },\n      "overrideUniforms" : [\n        { name : "renderModeNormals", value: 0 },\n      ],\n      "disableSkybox" : false\n    },\n    "UV Overlay" : {\n      "overrideMaterial" : "uvMaterial",\n      // "overlayEnable" : false,\n      "disableSkybox" : false,\n      "overrideUniforms" : [\n        { name : "renderModeNormals", value: 0, previousValue: null },\n      ],\n      "wireframeEnable" : false,\n    },\n    "Skin Weights" : {\n      "overrideMaterial" : { \n        "skinned" : new THREE.ShaderMaterial( this.skinWeightsMatDef ), \n        "static" : new THREE.ShaderMaterial( this.skinWeightsMatDef )\n      },\n      // "overlayEnable" : false,\n      "wireframeEnable" : false,\n    },\n    "Skin Indices" : {\n      "overrideMaterial" : { \n        "skinned" : new THREE.ShaderMaterial( this.skinIndicesMatDef ),\n        "static" : new THREE.ShaderMaterial( this.skinIndicesMatDef ) },\n      // "overlayEnable" : false,\n      "wireframeEnable" : false,\n    },\n  };\n}\n\nRenderModes.prototype = new VAPI.VeroldComponent();\n\nRenderModes.prototype.editorInit = function() {\n  this.getEngine().on(\'preRenderView\', this.preRenderView, this );\n  this.getEngine().on(\'postRenderView\', this.postRenderView, this );\n  this.init();\n};\n\nRenderModes.prototype.editorShutdown = function() {\n  this.getEngine().off(\'preRenderView\', this.preRenderView, this );\n  this.getEngine().off(\'postRenderView\', this.postRenderView, this );\n  this.shutdown();\n};\n\n/**\n * Called immediately after after RenderModes creation\n */\nRenderModes.prototype.init = function() {\n  \n  this.uvTextureJSON = { name: "uvTexture", id: "uvTexture", type: "texture2D", payload: {\n      isLocal: true,\n      filtering: "Trilinear",\n      anisotropy: 8\n    },\n    resources: [{\n      path: this.getEngine().paths.glAssetsBaseUrl + "/textures/Materials/uvgrid.jpg",\n      contentType: "image/jpeg",\n      contentEncoding: "identity",\n      contentLength: 569756,\n      contentLengthIdentity: 569756,\n      properties: {\n        // type: "tex_low",\n        width: 1024,\n        height: 1024,\n        compression: \'none\',\n        pixelFormat: \'rgb\',\n      }\n    }, {\n      path: this.getEngine().paths.glAssetsBaseUrl + "/textures/Materials/uvgrid.dds",\n      contentType: "image/x-dds",\n      contentEncoding: "identity",\n      contentLength: 699192,\n      contentLengthIdentity: 699192,\n      properties: {\n        // type: "tex_dxt_low",\n        width: 1024,\n        height: 1024,\n        compression: \'dxt\',\n        pixelFormat: \'rgb\',\n      }\n    }]\n  };\n  this.uvMaterialJSON = { name: "uvMaterial", id: "uvMaterial", type: "material", payload: { materialType: "Standard", diffuseTexture: "uvTexture", Features: { "Lighting" : {enabled : false }}, side: THREE.DoubleSide }};\n  this.flatShadedMaterialJSON = { name: "flatShaded", id: "flatShaded", type: "material", payload: { materialType: "Simple", diffuseColor: 0xeee5dd, specularColor: 0x000000, reflectionBias: -1.0, Features: { "Lighting" : {enabled : false }}, side: THREE.DoubleSide }};\n\n  VAPI.globalEvents.on(\'setRenderMode\', this.setRenderMode, this );\n\n  this.sceneAsset = this.veroldEntity.getParentAsset();\n  this.threeRenderer = this.getThreeRenderer();\n  this.assetRegistry = this.veroldEntity.veroldEngine.assetRegistry;\n  this.wireframeScene = new THREE.Scene();\n  \n  if ( !this.assetRegistry.assets[ this.uvTextureJSON.id ]) {\n    this.assetRegistry.createAsset( this.uvTextureJSON, {\n      success: function( texAsset ) {\n      }\n    } );\n  }\n  if ( !this.assetRegistry.assets[ this.uvMaterialJSON.id ]) {\n    this.assetRegistry.createAsset( this.uvMaterialJSON, {\n      success: function( matAsset ) {\n      }\n    } );\n  }\n  if ( !this.assetRegistry.assets[ this.flatShadedMaterialJSON.id ]) {\n    this.assetRegistry.createAsset( this.flatShadedMaterialJSON, {\n      success: function( matAsset ) {\n        matAsset.load();\n      }\n    } );\n\n    // var overlayMat = that.renderModes["Flat-shaded Wireframe"].overlayMaterial;\n    // overlayMat.static.uniforms = THREE.UniformsUtils.clone( overlayMat.static.uniforms );\n    // overlayMat.skinned.skinning = true;\n    // overlayMat.skinned.uniforms = THREE.UniformsUtils.clone( overlayMat.skinned.uniforms );\n    // overlayMat = that.renderModes["Wireframe"].overlayMaterial;\n    // overlayMat.static.uniforms = THREE.UniformsUtils.clone( overlayMat.static.uniforms );\n    // overlayMat.skinned.skinning = true;\n    // overlayMat.skinned.uniforms = THREE.UniformsUtils.clone( overlayMat.skinned.uniforms );\n  }\n};\n\n/**\n * Called when a verold object is destroyed or this RenderModes is removed\n * from a verold object.\n */\nRenderModes.prototype.shutdown = function() {\n  var x, y;\n  VAPI.globalEvents.off(\'setRenderMode\', this.setRenderMode, this);\n  if ( this.wireframeScene ) {\n    this.wireframeScene = undefined;\n  }\n  _.each( this.wireframeCache, function( helper ) {\n    helper.geometry.dispose();\n  }, this );\n\n  for ( x in this.renderModes) {\n    // if ( _.isObject( this.renderModes[x].overlayMaterial ) ) {\n    //   for ( y in this.renderModes[x].overlayMaterial ) {\n    //     if ( this.renderModes[x].overlayMaterial[y] ) {\n    //       this.renderModes[x].overlayMaterial[y].dispose();\n    //     }\n    //   }\n    // }\n    if ( _.isObject( this.renderModes[x].overrideMaterial ) ) {\n      for ( y in this.renderModes[x].overrideMaterial ) {\n        if ( this.renderModes[x].overrideMaterial[y] ) {\n          this.renderModes[x].overrideMaterial[y].dispose();\n        }\n      }\n    }\n  }\n};\n\nRenderModes.prototype.preRenderView = function( scene, camera ) {\n\n  if ( !this.currentRenderMode || !this.renderModes ) {\n    return;\n  }\n  \n  var renderMode = this.renderModes[ this.currentRenderMode ];\n  \n  if ( _.isString( renderMode.overrideMaterial ) ) {\n    this.assetRegistry.getAssetById( renderMode.overrideMaterial ).load();\n    scene.overrideMaterial = this.assetRegistry.getAssetById( renderMode.overrideMaterial ).threeData;\n  }\n  else {\n    scene.overrideMaterial = renderMode.overrideMaterial;\n  }\n\n  // scene.overrideUniforms = renderMode.overrideUniforms;\n  if ( scene.overrideMaterial ) {\n    scene.overrideMaterial.skinned.skinning = true;\n  }\n};\n\nRenderModes.prototype.postRenderView = function( scene, camera ) {\n  if ( !this.currentRenderMode || !this.renderModes ) {\n    return;\n  }\n  var renderMode = this.renderModes[ this.currentRenderMode ];\n  if ( renderMode.wireframeEnable ) {\n    this.getThreeRenderer().setViewport( 0, 0, this.getRenderer().getWidth(), this.getRenderer().getHeight() );\n    this.getThreeRenderer().render( this.wireframeScene, camera );\n  }\n};\n\nRenderModes.prototype.setRenderMode = function( modeName ) {\n\n  //for each scene, set the render mode\n  var scenes = this.getAssetRegistry().Scenes.getAssets();\n  _.each( scenes, function( scene, id ) {\n    if ( scene.isLoaded() ) {\n      var cameras = scene.getObjects({"type": "camera"});\n      _.each( cameras, function( camera ) {\n        this.applyRenderModeForScene( scene, camera, modeName );\n      }, this );\n    }\n  }, this );\n\n  if ( this.renderModes[ modeName ].overrideUniforms ) {\n    var uniforms = this.renderModes[ modeName ].overrideUniforms;\n    var materials = this.getAssetRegistry().Materials.getAssets({"type" : "material"});\n    _.each( uniforms, function( uniform ) {\n      _.each( materials, function( material, id ) {\n        // var json = {};\n        // json[ uniform.name ] = uniform.value;\n        material.setUniform( uniform.name, uniform.value );\n      }, this );\n    }, this );\n  }\n  // if ( this.renderModes[ modeName ].overlayEnable ) {\n  //   if ( !this.overlayRenderPass ) {\n  //     this.overlayRenderPass = new THREE.RenderPass();\n  //   }\n  //   this.getRenderer().removeRenderPass( this.overlayRenderPass );\n  //   this.overlayRenderPass.scene = null;\n  //   this.overlayRenderPass.camera = null;\n  //   this.overlayRenderPass.clear = false;\n  //   this.overlayRenderPass.overrideMaterial = this.renderModes[ modeName ].overlayMaterial;\n  //   this.getRenderer().addRenderPass( this.overlayRenderPass, 2 );\n  // }\n  // else {\n  //   this.getRenderer().removeRenderPass( this.overlayRenderPass );\n  // }\n  if ( this.renderModes[ modeName ].wireframeEnable ) {\n    // _.each( this.meshRegistry, function( meshEntry, id ) {\n\n    // })\n  }\n  this.getEngine().needsRender = true;\n};\n\nRenderModes.prototype.applyRenderModeForScene = function( scene, camera, modeName ) {\n\n  if ( !this.renderModes[ modeName ] ) {\n    modeName = "Lit";\n  }\n  this.currentRenderMode = modeName;\n\n  //Disable lights is they should be for this render mode\n  if ( this.renderModes[ modeName ].disableLights ) {\n    this.lightsDisabled = true;\n    scene.traverse( function( obj ) {\n      if ( obj.type === "light" ) {\n        if ( obj.getProperty("type") === "AmbientLight") {\n          obj.threeData.color.setRGB( 1.0, 1.0, 1.0 );\n        }\n        else {\n          obj.threeData.intensity = 0;\n        }\n      }\n    });\n  }\n  //Re-enable lights if they were turned off\n  else if ( this.lightsDisabled ) {\n    scene.traverse( function( obj ) {\n      if ( obj.type === "light" ) {\n        //var json = obj.entityModel.toJSON();\n        //obj.entityModel.trigger( "change:payload", json );\n        if ( obj.getProperty("type") === "AmbientLight") {\n          var colour = obj.getProperty("color");\n          obj.set( {"payload.color" : 0x000000 }, {silent: true});\n          obj.set( {"payload.color" : colour } );\n        }\n        else {\n          var intensity = obj.getProperty("intensity");\n          obj.set( {"payload.intensity" : 0 }, {silent: true});\n          obj.set( {"payload.intensity" : intensity } );\n        }\n      }\n    });\n  }\n\n  var that = this;\n  if ( this.renderModes[ modeName ].wireframeEnable ) {\n    _.each( this.wireframeCache, function( obj, id ) {\n      obj.visible = false;\n    }, this);\n    scene.traverse( function( obj ) {\n      if ( obj.type === "mesh" || obj.type === "skinned_mesh" ) {\n        if ( that.wireframeCache[ obj.id ] ) {\n          that.wireframeCache[ obj.id ].visible = true;\n        }\n        else {\n          if ( obj.threeData ) {\n            that.wireframeCache[ obj.id ] = new THREE.WireframeHelper( obj.threeData, 0x050505 );\n          }\n        }\n        if ( that.wireframeScene ) {\n          that.wireframeScene.add( that.wireframeCache[ obj.id ] );\n        }\n      }\n    });\n  }\n\n};\n\n\nreturn RenderModes;\n';});


define('text!VeroldEngine/Components/BuiltIn/ReflectionCapturePlane.js',[],function () { return '// var reflectionActorNumber = 0;\n/**\n * @author Mike Bond\n * A component to make rendering a planar reflection easier.\n * Based largely on Slayvin\'s (http://slayvin.net) THREE.Mirror class\n *\n * @class ReflectionCapture\n */\nfunction ReflectionCapture() {\n  this.framesElapsed = 0;\n  this.perspectiveCamera = null;\n  this.orthoCamera = null;\n  this.reflectionNormal = new THREE.Vector3( 0, 1, 0 );\n  this.reflectionPlane = new THREE.Plane();\n  this.clipPlane = new THREE.Vector4();\n\n  this.reflectionPosition = new THREE.Vector3();\n  this.cameraWorldPosition = new THREE.Vector3();\n  this.rotationMatrix = new THREE.Matrix4();\n  this.lookAtPosition = new THREE.Vector3(0, 0, -1);\n  this.up = new THREE.Vector3(0, 1, 0);\n\n  // reflectionActorNumber++;\n  // this.reflectionActorId = reflectionActorNumber;\n}\n\nReflectionCapture.prototype = new VAPI.VeroldComponent();\n\nReflectionCapture.prototype.init = function() {\n};\n\nReflectionCapture.prototype.editorInit = function() {\n  \n  this.veroldEntity.getParentAsset().when(\'load\', this.sceneLoadedEditor, this );\n  this.veroldEntity.when(\'load_base\', this.objectCreatedEditor, this );\n  \n  this.getEngine().on( "preRenderView", this.preRenderView, this );\n  this.inEditor = true;\n  this.init();\n};\n\nReflectionCapture.prototype.shutdown = function() {\n  // this.getEngine().off( "resize", this.resizeCamera, this );\n};\n\nReflectionCapture.prototype.editorShutdown = function() {\n\n  this.getEngine().off( "preRenderView", this.preRenderView, this );\n  var renderer = this.getThreeRenderer();\n  if ( renderer ) {\n    if ( this.reflectionTexture && this.reflectionTexture.threeData ) {\n      this.getThreeRenderer().setRenderTarget( this.reflectionTexture.threeData );\n      this.getThreeRenderer().clear();\n    }\n    else if ( this.tempRenderTexture && this.tempRenderTexture.threeData ) {\n      this.getThreeRenderer().setRenderTarget( this.tempRenderTexture.threeData );\n      this.getThreeRenderer().clear();\n    }\n  }\n  if ( this.tempRenderTexture ) {\n    this.tempRenderTexture.destroy();\n  }\n  if ( this.reflectionMaterial ) {\n    this.reflectionMaterial.destroy();\n  }\n  this.shutdown();\n};\n\n/**\n * Called once the data is available is available\n */\nReflectionCapture.prototype.sceneLoadedEditor = function() {\n  var that = this;\n  \n  window.verold.veroldEvents.trigger( \'studioApp::getCurrentCamera\', function( camera ) {\n    console.log("Reflection Actor - Assigning editor camera to be used. ", camera );\n    that.editorCamera = camera;\n    //that.sceneCamera = camera;\n    that.initCameras();\n  });\n};\n\nReflectionCapture.prototype.objectCreated = function() {\n  this.initCameras();\n  this.initTexture();\n};\n\nReflectionCapture.prototype.objectCreatedEditor = function() {\n  this.initEditorObject();\n};\n\nReflectionCapture.prototype.initEditorObject = function() {\n  var that = this;\n  this.planeGeometry = new THREE.PlaneBufferGeometry( 0.5, 0.5, 1, 1 );\n  //this.planeGeometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5, 1, 1, 1 );\n  this.planeGeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\n  this.planeGeometry.computeTangents();\n  this.planeGeometry.computeVertexNormals();\n//   this.planeGeometry.computeFaceNormals();\n  this.planeGeometry.dynamic = true;\n  this.planeMesh = new THREE.Mesh( this.planeGeometry );\n  this.planeMesh.castShadow = false;\n  this.planeMesh.receiveShadow = false;\n  this.planeMesh.name = "ReflectionCapturePlane";\n\n  this.getThreeObject().add( this.planeMesh );\n  this.getEngine().globalEvents.trigger( "studioApp::registerPickingObject", this.getEntity(), this.planeMesh );\n\n  if ( !this.reflectionTexture ) {\n    this.createTempRenderTexture();\n  }\n\n  this.getAssetRegistry().createAsset( { type: "material", id: "reflection_material", payload: {\n    materialType: "Simple",\n    diffuseColor: 0x000000,\n    gloss: 1.0,\n    //diffuseTexture: that.reflectionTexture.id,\n    // environmentMappingType : 2,\n    environmentTexture2D: that.reflectionTexture ? that.reflectionTexture.id : that.tempRenderTexture.id,\n    reflectionBias: 1\n  }}, {\n    success: function( mat ) {\n      mat.load();\n      mat.enableFeature( "Reflections", undefined, true );\n      mat.setProperty("environmentMappingType", 2);\n\n      that.reflectionMaterial = mat;\n      that.planeMesh.material = mat.threeData.static;\n      that.initTexture();\n    }\n  });\n};\n\nReflectionCapture.prototype.createTempRenderTexture = function( changes ) {\n  var that = this;\n  this.getAssetRegistry().createAsset( { type: "renderTexture2D", id: "render_tex_reflection", payload: {\n      width: 512,\n      height: 512,\n      format: THREE.RGBAFormat,\n      type: THREE.UnsignedByteType,\n    }}, {\n    success: function( tex ) {\n      that.tempRenderTexture = tex;\n      tex.load();\n    }\n  });\n};\n\n// ReflectionCapture.prototype.onEnable = function() {\n// };\n\n// ReflectionCapture.prototype.onEnable = function() {\n// };\n\nReflectionCapture.prototype.attributesChanged = function( changes ) {\n  if ( changes.reflectionTexture !== undefined ) {\n    this.initTexture();\n  }\n  // if ( changes.sceneCamera !== undefined ) {\n  //   if ( this.inEditor ) {\n  //     this.sceneCamera = this.editorCamera;\n  //   }\n  // }\n};\n\nReflectionCapture.prototype.initTexture = function() {\n  if ( this.reflectionTexture ) {\n    var that = this;\n    \n    this.reflectionTexture.when( \'load\', function() {\n      if ( that.tempRenderTexture ) {\n        that.tempRenderTexture.unload();\n      }\n      var pars = { \n        format: that.reflectionTexture.threeData.format, \n        minFilter: that.reflectionTexture.threeData.minFilter, \n        magFilter: that.reflectionTexture.threeData.magFilter\n      };\n      pars.type = that.reflectionTexture.threeData.type;\n      \n      var renderTarget = new THREE.WebGLRenderTarget( that.reflectionTexture.getWidth(), that.reflectionTexture.getHeight(), pars );\n      renderTarget.name = that.getEntity().getName() + ": Reflection Capture Render Buffer";\n      if ( !that.composer ) {\n        that.composer = new THREE.EffectComposer( that.getThreeRenderer(), renderTarget );\n        that.gammaPass = new THREE.ShaderPass( THREE.GammaShader );\n        that.gammaPass.renderToScreen = true;\n        that.composer.addPass( that.gammaPass );\n      }\n      else {\n        that.composer.reset( renderTarget );\n      }\n      that.composer.enabled = true;\n      that.composer.renderPassesNeedUpdate = true;\n      if ( that.planeMesh ) {\n        that.planeMesh.material.uniforms.environmentTexture2D.value = that.reflectionTexture.threeData;\n      }\n    } );\n    // this.reflectionTexture.load();\n  }\n  else {\n    this.createTempRenderTexture();\n    if ( this.planeMesh ) {\n      this.planeMesh.material.uniforms.environmentTexture2D.value = this.tempRenderTexture.threeData;\n    }\n  }\n};\n\n/**\n * Called immediately after after component creation\n */\nReflectionCapture.prototype.initCameras = function() {\n  if ( this.reflectionTexture ) {\n    this.reflectionTexture.load();\n  }\n\n  this.perspectiveCamera = new THREE.PerspectiveCamera();\n  this.orthoCamera = new THREE.OrthographicCamera();\n};\n\nReflectionCapture.prototype.updateReflection = function( scene, camera ) {\n  if ( this.isEnabled() ) {\n    var sign = function( num ) {\n      return num < 0 ? -1 : 1;\n    }\n    this.veroldEntity.threeData.updateMatrixWorld();\n    // this.sceneCamera.threeData.updateMatrixWorld();\n\n    this.reflectionPosition.setFromMatrixPosition( this.veroldEntity.threeData.matrixWorld );\n    this.cameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n    this.rotationMatrix.extractRotation(  this.veroldEntity.threeData.matrixWorld );\n\n    this.reflectionNormal.set( 0, 1, 0 );\n    this.reflectionNormal.applyMatrix4( this.rotationMatrix );\n\n    var view = this.reflectionPosition.clone().sub( this.cameraWorldPosition );\n    var reflectView = view.reflect( this.reflectionNormal ).negate();\n    reflectView.add( this.reflectionPosition );\n\n    this.rotationMatrix.extractRotation( camera.matrixWorld );\n\n    this.lookAtPosition.set(0, 0, -1);\n    this.lookAtPosition.applyMatrix4( this.rotationMatrix );\n    this.lookAtPosition.add( this.cameraWorldPosition );\n\n    var target = this.reflectionPosition.clone().sub( this.lookAtPosition );\n    var reflectTarget = target.reflect( this.reflectionNormal ).negate();\n    reflectTarget.add( this.reflectionPosition );\n\n    this.up.set( 0, -1, 0 );\n    this.up.applyMatrix4( this.rotationMatrix );\n    var reflectUp = this.up.reflect( this.reflectionNormal ).negate();\n\n    if ( camera instanceof THREE.PerspectiveCamera && this.perspectiveCamera ) {\n      this.perspectiveCamera.aspect = camera.aspect;\n      this.perspectiveCamera.fov = camera.fov;\n      this.reflectionCamera = this.perspectiveCamera;\n    }\n    else if ( this.orthoCamera ) {\n      this.orthoCamera.left = camera.left;\n      this.orthoCamera.right = camera.right;\n      this.orthoCamera.top = camera.top;\n      this.orthoCamera.bottom = camera.bottom;\n      this.reflectionCamera = this.orthoCamera;\n    }\n    else {\n      return;\n    }\n    this.reflectionCamera.position.copy( reflectView );\n    this.reflectionCamera.up = reflectUp;\n    this.reflectionCamera.lookAt( reflectTarget );\n\n\n    this.reflectionCamera.updateProjectionMatrix();\n    this.reflectionCamera.updateMatrixWorld();\n    this.reflectionCamera.matrixWorldInverse.getInverse( this.reflectionCamera.matrixWorld );\n\n    // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n    this.reflectionPlane.setFromNormalAndCoplanarPoint( this.reflectionNormal, this.reflectionPosition );\n    this.reflectionPlane.applyMatrix4( this.reflectionCamera.matrixWorldInverse );\n\n    this.clipPlane.set( this.reflectionPlane.normal.x,\n                       this.reflectionPlane.normal.y,\n                       this.reflectionPlane.normal.z,\n                       this.reflectionPlane.constant );\n\n    var q = new THREE.Vector4();\n    var projectionMatrix = this.reflectionCamera.projectionMatrix;\n\n    q.x = ( sign(this.clipPlane.x) + projectionMatrix.elements[8] ) / projectionMatrix.elements[0];\n    q.y = ( sign(this.clipPlane.y) + projectionMatrix.elements[9] ) / projectionMatrix.elements[5];\n    q.z = - 1.0;\n    q.w = ( 1.0 + projectionMatrix.elements[10] ) / projectionMatrix.elements[14];\n\n    // Calculate the scaled plane vector\n    var c = new THREE.Vector4();\n    c = this.clipPlane.multiplyScalar( 2.0 / this.clipPlane.dot(q) );\n\n    // Replacing the third row of the projection matrix\n    projectionMatrix.elements[2] = c.x;\n    projectionMatrix.elements[6] = c.y;\n    projectionMatrix.elements[10] = c.z + 1.0 - this.clipBias;\n    projectionMatrix.elements[14] = c.w;\n  }\n};\n\nReflectionCapture.prototype.preRenderView = function( scene, camera, options ) {\n  if ( this.isEnabled() ) {\n    if ( this.framesElapsed >= this.updateFrameInterval ) {\n      this.updateReflection( scene, camera );\n      //render reflection\n      // Render the mirrored view of the current scene into the target texture\n      //var scene = this.veroldEntity.getParentAsset();\n      if ( scene && camera ) {\n        //this.getThreeRenderer().setRenderTarget( this.reflectionTexture.threeData );\n        var viewport = this.getThreeRenderer().getViewport();\n        if ( this.reflectionTexture && this.reflectionTexture.threeData ) {\n          this.getRenderer().renderView( scene, this.reflectionCamera, {\n            viewPort: { x:0,y:0, width: this.reflectionTexture.getWidth(), height: this.reflectionTexture.getHeight()  },\n            renderTarget: this.reflectionTexture.threeData,\n            clearColor: true,\n            clearDepth: true,\n            composer: this.getThreeRenderer().gammaOutput ? this.composer : null,\n            enableShadows: false,\n            enablePreRenderFunctions: false });\n        }\n        else if ( this.tempRenderTexture ) {\n          this.getRenderer().renderView( scene, this.reflectionCamera, {\n            viewPort: { x:0,y:0, width: this.tempRenderTexture.getWidth(), height: this.tempRenderTexture.getHeight()  },\n            renderTarget: this.tempRenderTexture.threeData,\n            clearColor: true,\n            clearDepth: true,\n            composer: this.getThreeRenderer().gammaOutput ? null : this.composer,\n            enableShadows: false,\n            enablePreRenderFunctions: false });\n        }\n      }\n      this.framesElapsed = 0;\n    }\n    else {\n      this.framesElapsed++;\n    }\n  }\n};\n\nreturn ReflectionCapture;\n';});


define('text!VeroldEngine/Components/BuiltIn/CubeMapCapture.js',[],function () { return '/**\n * @author Mike Bond\n * A component to make rendering to a cube map easier.\n *\n * @class CubeMapCapture\n */\nfunction CubeMapCapture() {\n  this.framesElapsed = 0;\n\n  this.near = 1.0;\n  this.far = 12000.0;\n  this.updateFrameInterval = 0.0;\n\n  this.cubeMaterial = undefined;\n  this.tempRenderTexture = undefined;\n\n  this.cubeMaterialDef = {\n\n    uniforms: { "tCube": { type: "t", value: null },\n          "tFlip": { type: "f", value: 1 } },\n\n    vertexShader: [\n\n      "varying vec3 vWorldPosition;",\n\n      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],\n\n      "void main() {",\n\n      " vec4 worldPosition = vec4( position, 1.0 );",\n      " vWorldPosition = worldPosition.xyz;",\n\n      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",\n\n        THREE.ShaderChunk[ "logdepthbuf_vertex" ],\n\n      "}"\n\n    ].join("\\n"),\n\n    fragmentShader: [\n\n      "uniform samplerCube tCube;",\n      "uniform float tFlip;",\n\n      "varying vec3 vWorldPosition;",\n\n      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],\n\n      "void main() {",\n      // " vec3 poop = normalize(vWorldPosition);",\n      " gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",\n\n        THREE.ShaderChunk[ "logdepthbuf_fragment" ],\n\n      "}"\n\n    ].join("\\n")\n\n  };\n}\n\n/*global VAPI*/\nCubeMapCapture.prototype = new VAPI.VeroldComponent();\n\nCubeMapCapture.prototype.init = function() {\n  \n  this.initCameras();\n};\n\nCubeMapCapture.prototype.editorInit = function() {\n  this.init();\n  this.veroldEntity.getParentAsset().once(\'load\', this.initEditorObject, this );\n  if ( this.veroldEntity.state_base === "loaded") {\n    this.veroldEntity.load();\n  }\n  // this.getEngine().on( "preRenderView", this.preRenderView, this );\n  this.getEngine().on( "preRender", this.preRender, this );\n  this.getEngine().on( "postUpdate", this.postUpdate, this );\n  this.getEntity().on( "editorSelected", this.onSelected, this );\n  this.getEntity().on( "editorUnselected", this.onUnselected, this );\n};\n\nCubeMapCapture.prototype.shutdown = function() {\n  // this.getEngine().globalEvents.trigger(\'renderer::unregisterPreRenderFn\', "Reflection_" + this.reflectionActorId, this.preRenderPass, this );\n};\n\nCubeMapCapture.prototype.editorShutdown = function() {\n\n  this.getEntity().off( "editorSelected", this.onSelected, this );\n  this.getEntity().off( "editorUnselected", this.onUnselected, this );\n  this.getEngine().off( "preRender", this.preRender, this );\n  this.getEngine().off( "postUpdate", this.postUpdate, this );\n  this.shutdown();\n};\n\nCubeMapCapture.prototype.onSelected = function() {\n  this.cubeCamera.traverse( function( obj ) {\n    if ( obj instanceof THREE.PerspectiveCamera ) {\n      if ( !obj.cameraHelper ) {\n        obj.cameraHelper = new THREE.CameraHelper( obj );\n        obj.add( obj.cameraHelper );\n      }\n      obj.cameraHelper.visible = true;\n    }\n  });\n};\n\nCubeMapCapture.prototype.onUnselected = function() {\n  this.cubeCamera.traverse( function( obj ) {\n    if ( obj instanceof THREE.PerspectiveCamera ) {\n      if ( obj.cameraHelper ) {\n        obj.cameraHelper.visible = false;\n      }\n    }\n  });\n};\n\nCubeMapCapture.prototype.objectCreated = function() {\n\n  var threeObj = this.getThreeScene();\n  threeObj.add( this.cubeCamera );\n};\n\nCubeMapCapture.prototype.initEditorObject = function() {\n  this.objectCreated();\n\n  this.boxGeometry = new THREE.BoxGeometry( 0.25, 0.25, 0.25, 1, 1, 1 );\n\n  this.boxGeometry.dynamic = true;\n  this.boxMesh = new THREE.Mesh( this.boxGeometry );\n  this.boxMesh.castShadow = false;\n  this.boxMesh.receiveShadow = false;\n  this.boxMesh.name = "CubeMapCapturePlane";\n  this.getThreeObject().add( this.boxMesh );\n  this.getEngine().globalEvents.trigger( "studioApp::registerPickingObject", this.getEntity(), this.boxMesh );\n\n  if ( !this.cubeTexture ) {\n    this.createTempRenderTexture();\n  }\n  else {\n    this.cubeTexture.load();\n  }\n  \n  this.cubeMaterialDef.uniforms[ "tCube" ].value = this.cubeTexture ? this.cubeTexture.threeData : this.tempRenderTexture.threeData;\n  this.cubeMaterial = new THREE.ShaderMaterial( this.cubeMaterialDef );\n  this.boxMesh.material = this.cubeMaterial;\n};\n\nCubeMapCapture.prototype.createTempRenderTexture = function( changes ) {\n  var that = this;\n  this.getAssetRegistry().createAsset( { type: "renderTextureCube", id: "render_tex_cube", payload: {\n      width: 512,\n      height: 512,\n      format: THREE.RGBAFormat,\n      type: THREE.UnsignedByteType,\n    }}, {\n    success: function( tex ) {\n      that.tempRenderTexture = tex;\n      tex.load();\n    }\n  });\n};\n\nCubeMapCapture.prototype.attributesChanged = function( changes ) {\n  if ( changes.cubeTexture !== undefined ) {\n    if ( this.cubeTexture ) {\n      var that = this;\n      this.cubeTexture.when( \'load\', function() {\n        if ( that.tempRenderTexture ) {\n          that.tempRenderTexture.unload();\n        }\n        var pars = { \n          format: that.cubeTexture.threeData.format, \n          minFilter: that.cubeTexture.threeData.minFilter, \n          magFilter: that.cubeTexture.threeData.magFilter\n        };\n        pars.type = that.cubeTexture.threeData.type;\n        \n        var renderTarget = new THREE.WebGLRenderTarget( that.cubeTexture.getWidth(), that.cubeTexture.getHeight(), pars );\n        renderTarget.name = that.getEntity().getName() + ": Reflection Capture Render Buffer";\n        if ( !that.composer ) {\n          that.composer = new THREE.EffectComposer( that.getThreeRenderer(), renderTarget );\n          that.gammaPass = new THREE.ShaderPass( THREE.GammaShader );\n          that.gammaPass.renderToScreen = true;\n          that.composer.addPass( that.gammaPass );\n        }\n        else {\n          that.composer.reset( renderTarget );\n        }\n        that.composer.enabled = true;\n        that.composer.renderPassesNeedUpdate = true;\n        that.cubeMaterial.uniforms[ "tCube" ].value = that.cubeTexture.threeData;\n      } );\n      this.cubeTexture.load();\n    }\n    else if ( !this.tempRenderTexture ) {\n      this.createTempRenderTexture();\n      this.cubeMaterial.uniforms[ "tCube" ].value = this.tempRenderTexture.threeData;\n    }\n  }\n  if ( changes.near || changes.far ) {\n    this.cameraPX.near = this.near;\n    this.cameraPX.far = this.far;\n    this.cameraPX.updateProjectionMatrix();\n    this.cameraNX.near = this.near;\n    this.cameraNX.far = this.far;\n    this.cameraNX.updateProjectionMatrix();\n    this.cameraPY.near = this.near;\n    this.cameraPY.far = this.far;\n    this.cameraPY.updateProjectionMatrix();\n    this.cameraNY.near = this.near;\n    this.cameraNY.far = this.far;\n    this.cameraNY.updateProjectionMatrix();\n    this.cameraPZ.near = this.near;\n    this.cameraPZ.far = this.far;\n    this.cameraPZ.updateProjectionMatrix();\n    this.cameraNZ.near = this.near;\n    this.cameraNZ.far = this.far;\n    this.cameraNZ.updateProjectionMatrix();\n    this.cubeCamera.traverse( function( obj ) {\n    if ( obj instanceof THREE.PerspectiveCamera ) {\n      if ( obj.cameraHelper ) {\n        obj.cameraHelper.update();\n      }\n    }\n  });\n  }\n};\n\n/**\n * Called immediately after after component creation\n */\nCubeMapCapture.prototype.initCameras = function() {\n  this.cubeCamera = new THREE.Object3D();\n  this.cubeCamera.position.copy( this.getEntity().getPosition() );\n\n  var fov = 90, aspect = 1;\n\n  this.cameraPX = new THREE.PerspectiveCamera( fov, aspect, this.near, this.far );\n  this.cameraPX.up.set( 0, - 1, 0 );\n  this.cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n  this.cameraPX.rotationAutoUpdate = false;\n  this.cubeCamera.add( this.cameraPX );\n\n  this.cameraNX = new THREE.PerspectiveCamera( fov, aspect, this.near, this.far );\n  this.cameraNX.up.set( 0, - 1, 0 );\n  this.cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\n  this.cameraNX.rotationAutoUpdate = false;\n  this.cubeCamera.add( this.cameraNX );\n\n  this.cameraPY = new THREE.PerspectiveCamera( fov, aspect, this.near, this.far );\n  this.cameraPY.up.set( 0, 0, 1 );\n  this.cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n  this.cameraPY.rotationAutoUpdate = false;\n  this.cubeCamera.add( this.cameraPY );\n\n  this.cameraNY = new THREE.PerspectiveCamera( fov, aspect, this.near, this.far );\n  this.cameraNY.up.set( 0, 0, - 1 );\n  this.cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\n  this.cameraNY.rotationAutoUpdate = false;\n  this.cubeCamera.add( this.cameraNY );\n\n  this.cameraPZ = new THREE.PerspectiveCamera( fov, aspect, this.near, this.far );\n  this.cameraPZ.up.set( 0, - 1, 0 );\n  this.cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n  this.cameraPZ.rotationAutoUpdate = false;\n  this.cubeCamera.add( this.cameraPZ );\n\n  this.cameraNZ = new THREE.PerspectiveCamera( fov, aspect, this.near, this.far );\n  this.cameraNZ.up.set( 0, - 1, 0 );\n  this.cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\n  this.cameraNZ.rotationAutoUpdate = false;\n  this.cubeCamera.add( this.cameraNZ );\n};\n\nCubeMapCapture.prototype.postUpdate = function( delta ) {\n  if ( this.cubeCamera && this.hasThreeData() && this.isEnabled() ) {\n    this.cubeCamera.position.setFromMatrixPosition( this.getThreeObject().matrixWorld );\n  }\n};\n\nCubeMapCapture.prototype.preRender = function( delta ) {\n  this.framesElapsed++;\n  if ( this.framesElapsed >= this.updateFrameInterval && this.isEnabled() ) {\n    this.framesElapsed = 0.0;\n    var renderer = this.getRenderer();\n    var scene = this.getScene().threeData;\n    \n    if ( this.cubeTexture || this.tempRenderTexture ) {\n\n      var renderTarget = this.cubeTexture ? this.cubeTexture.threeData : this.tempRenderTexture.threeData;\n      var generateMipmaps = renderTarget.generateMipmaps;\n\n      renderTarget.generateMipmaps = false;\n\n      if ( this.renderPosX ) {\n        renderTarget.activeCubeFace = 0;\n        renderer.renderView( scene, this.cameraPX, { \n          renderTarget: renderTarget, \n          clearColor: true,\n          composer: this.getThreeRenderer().gammaOutput ? null : this.composer, } );\n      }\n\n      if ( this.renderNegX ) {\n        renderTarget.activeCubeFace = 1;\n        renderer.renderView( scene, this.cameraNX, { \n          renderTarget: renderTarget, \n          clearColor: true,\n          composer: this.getThreeRenderer().gammaOutput ? null : this.composer, } );\n      }\n\n      if ( this.renderPosY ) {\n        renderTarget.activeCubeFace = 2;\n        renderer.renderView( scene, this.cameraPY, { \n          renderTarget: renderTarget, \n          clearColor: true,\n          composer: this.getThreeRenderer().gammaOutput ? null : this.composer, } );\n      }\n\n      if ( this.renderNegY ) {\n        renderTarget.activeCubeFace = 3;\n        renderer.renderView( scene, this.cameraNY, { \n          renderTarget: renderTarget, \n          clearColor: true,\n          composer: this.getThreeRenderer().gammaOutput ? null : this.composer, } );\n      }\n\n      if ( this.renderPosZ ) {\n        renderTarget.activeCubeFace = 4;\n        renderer.renderView( scene, this.cameraPZ, { \n          renderTarget: renderTarget, \n          clearColor: true,\n          composer: this.getThreeRenderer().gammaOutput ? null : this.composer, } );\n      }\n\n      renderTarget.generateMipmaps = generateMipmaps;\n\n      if ( this.renderNegZ ) {\n        renderTarget.activeCubeFace = 5;\n        renderer.renderView( scene, this.cameraNZ, { \n          renderTarget: renderTarget, \n          clearColor: true,\n          composer: this.getThreeRenderer().gammaOutput ? null : this.composer, } );\n      }\n      renderTarget.needsUpdate = true;\n    }\n  }\n};\n\n\nreturn CubeMapCapture;\n';});


define('text!VeroldEngine/Components/BuiltIn/PanoramaToCubeMap.js',[],function () { return '/*\r\n@vname Panorama To Cube Map\r\n@vdescription A controller that allows a camera to easily orbit a target object.\r\n@vfilter renderTextureCube\r\n@vcategory Rendering\r\n@vattr asset panoramaTexture { \r\n  default : null,\r\n  filter : { texture2D: true, renderTexture2D: true },\r\n  description : \'The texture to convert to a cube map.\'\r\n}\r\n*/\r\n\r\nvar _ = require(\'underscore\');\r\n\r\n/* global VAPI */\r\n\r\n/**\r\n * A custom component class.\r\n *\r\n * @class PanoramaToCubeMap\r\n */\r\nfunction PanoramaToCubeMap() {\r\n  this.skyboxScene = undefined;\r\n  this.cameras = new Array(6);\r\n}\r\n\r\nPanoramaToCubeMap.prototype = new VAPI.VeroldComponent();\r\n\r\nPanoramaToCubeMap.prototype.attributesChanged = function( changes ) {\r\n  if ( changes.panoramaTexture !== undefined ) {\r\n    if ( this.panoramaTexture ) {\r\n      if ( this.panoramaTexture.getProperty(\'isHDR\') ) {\r\n        this.getEntity().setProperty(\'isHDR\', true );\r\n        this.getEntity().setProperty(\'packingOverride\', this.panoramaTexture.getPixelFormat());\r\n      }\r\n      else {\r\n        this.getEntity().setProperty(\'isHDR\', false );\r\n        this.getEntity().setProperty(\'packingOverride\', 0);\r\n      }\r\n      var that = this;\r\n      setTimeout( function() {\r\n        that.getEntity().save();\r\n      }, 10 );\r\n      this.panoramaTexture.when(\'load\', this.renderToCube, this );\r\n      this.panoramaTexture.load();\r\n    }\r\n  }\r\n};\r\n\r\nPanoramaToCubeMap.prototype.editorInit = function() {\r\n  this.getEntity().when(\'load_base\', this.objectCreated, this );\r\n};\r\n\r\nPanoramaToCubeMap.prototype.objectCreated = function() {\r\n  this.skyboxScene = new THREE.Scene();\r\n  this.initCameras();\r\n  this.createSkybox();\r\n\r\n  if ( this.panoramaTexture ) {\r\n    \r\n    this.panoramaTexture.when(\'load\', this.renderToCube, this );\r\n    this.panoramaTexture.load();\r\n  }\r\n  // this.on( \'enable\', this.onEnable, this );\r\n  // this.on( \'disable\', this.onDisable, this );\r\n};\r\n\r\nPanoramaToCubeMap.prototype.shutdown = PanoramaToCubeMap.prototype.editorShutdown = function() {\r\n  // make sure to clean up any events or other bindings that you have created\r\n  // to avoid memory leaks\r\n  var engine = this.getEngine();\r\n  // this.off( \'enable\', this.onEnable, this );\r\n  // this.off( \'disable\', this.onDisable, this );\r\n\r\n};\r\n\r\nPanoramaToCubeMap.prototype.createSkybox = function() {\r\n  var equirectShader = THREE.ShaderLib[ "equirect" ];\r\n  equirectShader.uniforms.tFlip.value = 1.0;\r\n  this.equirectMaterial = new THREE.ShaderMaterial( {\r\n    fragmentShader: equirectShader.fragmentShader,\r\n    vertexShader: equirectShader.vertexShader,\r\n    uniforms: equirectShader.uniforms,\r\n    depthWrite: false,\r\n    side: THREE.BackSide\r\n  } );\r\n\r\n  this.skyboxGeometry = new THREE.BoxGeometry( 100, 100, 100, 1, 1, 1 );\r\n  //this.skyboxGeometry.computeTangents();\r\n  this.skyboxGeometry.dynamic = false;\r\n  this.skyboxMesh = new THREE.Mesh( this.skyboxGeometry, this.equirectMaterial );\r\n  this.skyboxMesh.frustumCulled = false;\r\n  this.skyboxMesh.castShadow = false;\r\n  this.skyboxMesh.receiveShadow = false;\r\n  // this.skyboxMesh.name = "Skybox";\r\n  if ( this.isEnabled() ) {\r\n    this.skyboxScene.add( this.skyboxMesh );\r\n  }\r\n};\r\n\r\nPanoramaToCubeMap.prototype.initCameras = function() {\r\n  \r\n  var fov = 90, aspect = 1;\r\n\r\n  this.cameras[0] = new THREE.PerspectiveCamera( fov, aspect, 1, 1000 );\r\n  this.cameras[0].up.set( 0, - 1, 0 );\r\n  this.cameras[0].lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n  this.cameras[0].rotationAutoUpdate = false;\r\n  this.skyboxScene.add( this.cameras[0] );\r\n\r\n  this.cameras[1] = new THREE.PerspectiveCamera( fov, aspect, 1, 1000 );\r\n  this.cameras[1].up.set( 0, - 1, 0 );\r\n  this.cameras[1].lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n  this.cameras[1].rotationAutoUpdate = false;\r\n  this.skyboxScene.add( this.cameras[1] );\r\n\r\n  this.cameras[2] = new THREE.PerspectiveCamera( fov, aspect, 1, 1000 );\r\n  this.cameras[2].up.set( 0, 0, 1 );\r\n  this.cameras[2].lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n  this.cameras[2].rotationAutoUpdate = false;\r\n  this.skyboxScene.add( this.cameras[2] );\r\n\r\n  this.cameras[3] = new THREE.PerspectiveCamera( fov, aspect, 1, 1000 );\r\n  this.cameras[3].up.set( 0, 0, - 1 );\r\n  this.cameras[3].lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n  this.cameras[3].rotationAutoUpdate = false;\r\n  this.skyboxScene.add( this.cameras[3] );\r\n\r\n  this.cameras[4] = new THREE.PerspectiveCamera( fov, aspect, 1, 1000 );\r\n  this.cameras[4].up.set( 0, - 1, 0 );\r\n  this.cameras[4].lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n  this.cameras[4].rotationAutoUpdate = false;\r\n  this.skyboxScene.add( this.cameras[4] );\r\n\r\n  this.cameras[5] = new THREE.PerspectiveCamera( fov, aspect, 1, 1000 );\r\n  this.cameras[5].up.set( 0, - 1, 0 );\r\n  this.cameras[5].lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n  this.cameras[5].rotationAutoUpdate = false;\r\n  this.skyboxScene.add( this.cameras[5] );\r\n};\r\n\r\nPanoramaToCubeMap.prototype.renderToCube = function() {\r\n  if ( this.hasThreeData() ) {\r\n    this.equirectMaterial.uniforms.tEquirect.value = this.panoramaTexture.threeData;\r\n    var renderTarget = this.getThreeData();\r\n    var renderer = this.getThreeRenderer();\r\n    var prevGammaInput = renderer.gammaInput;\r\n    var prevGammaOutput = renderer.gammaOutput;\r\n    var manuallyGenerateMips = false;\r\n    if ( renderTarget.hdrPacking === THREE.HDRRGBE ) {\r\n      if ( renderTarget.generateMipmaps ) {\r\n        manuallyGenerateMips = true;\r\n        renderTarget.generateMipmaps = false;\r\n      }\r\n\r\n      //render cubemap as HDR and then repack.\r\n      this.equirectMaterial.hdrInputEnabled = true;\r\n      this.equirectMaterial.hdrOutputEnabled = true;\r\n      this.equirectMaterial.hdrOutputType = THREE.HDRRGBE;\r\n      this.equirectMaterial.defines[\'ENVMAP_HDR_INPUT\'] = this.panoramaTexture.threeData.hdrPacking;\r\n      this.equirectMaterial.needsUpdate = true;\r\n      renderer.gammaInput = false;\r\n      renderer.gammaOutput = false;\r\n    }\r\n    // if ( this.panoramaTexture.threeData.hdrPacking ) {\r\n      // this.equirectMaterial.hdrInputEnabled = true;\r\n      // this.equirectMaterial.defines[\'ENVMAP_HDR_INPUT\'] = this.panoramaTexture.threeData.hdrPacking;\r\n      // this.equirectMaterial.needsUpdate = true;\r\n      \r\n    // }\r\n    // else {\r\n    //   this.equirectMaterial.hdrInputEnabled = true;\r\n    //   this.equirectMaterial.defines[\'ENVMAP_HDR_INPUT\'] = this.panoramaTexture.threeData.hdrPacking;\r\n    //   this.equirectMaterial.needsUpdate = true;\r\n    // }\r\n    \r\n    renderTarget.generateMipmaps = false;\r\n    \r\n    renderer.setViewport( 0, 0, renderTarget.width, renderTarget.height );\r\n    for ( var i = 0; i < 5; i++ ) {\r\n      renderTarget.activeCubeFace = i;\r\n      renderer.render( this.skyboxScene, this.cameras[i], renderTarget );\r\n    }\r\n    renderTarget.generateMipmaps = this.getEntity().getProperty(\'generateMipmaps\');\r\n    \r\n    renderTarget.activeCubeFace = 5;\r\n    renderer.render( this.skyboxScene, this.cameras[5], renderTarget );\r\n\r\n    // if ( manuallyGenerateMips ) {\r\n      // this.getEntity().generateManualMipmaps();\r\n      renderer.gammaInput = prevGammaInput;\r\n      renderer.gammaOutput = prevGammaOutput;\r\n    // }\r\n  }\r\n};\r\n\r\nreturn PanoramaToCubeMap;\r\n';});


define('text!VeroldEngine/Components/BuiltIn/SphereMapCapture.js',[],function () { return '/**\n * @author Mike Bond\n * A component to make rendering to a cube map easier.\n *\n * @class SphereMapCapture\n */\nfunction SphereMapCapture() {\n  this.framesElapsed = 0;\n\n  this.near = 1.0;\n  this.far = 12000.0;\n  this.updateFrameInterval = 0.0;\n\n  this.sphereMaterial = undefined;\n  this.tempRenderTexture = undefined;\n\n  this.sphereMaterialDef = {\n\n    uniforms: { "tSphere": { type: "t", value: null }},\n\n    vertexShader: [\n\n      "varying vec4 vPositionVS;",\n      "varying vec3 vNormal;",\n\n      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],\n\n      "void main() {",\n\n      // " vec4 worldPosition = vec4( position, 1.0 );",\n      " vPositionVS = modelViewMatrix * vec4( position, 1.0 );",\n      " vNormal = normalMatrix * normal;",\n\n      " gl_Position = projectionMatrix * vPositionVS;",\n\n        THREE.ShaderChunk[ "logdepthbuf_vertex" ],\n\n      "}"\n\n    ].join("\\n"),\n\n    fragmentShader: [\n\n      "uniform sampler2D tSphere;",\n\n      "varying vec4 vPositionVS;",\n      "varying vec3 vNormal;",\n      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],\n\n      "void main() {",\n      " vec3 eyeVector = normalize( vPositionVS.xyz - (viewMatrix * vec4( cameraPosition, 0.0 )).xyz );",\n      " vec3 normal = normalize( vNormal );",\n      " normal.xy = normal.xy * 0.5 + 0.5;",\n      " normal.z = 0.0;",\n      // " float VdotN = dot( eyeVector, normal );",\n      // " vec3 poop = normalize(vPositionVS);",\n      " vec4 reflectedColor = texture2D( tSphere, normal.xy );",\n      // " gl_FragColor = textureCube( tSphere, vec3( vPositionVS.x, vPositionVS.yz ) );",\n        "gl_FragColor = vec4( reflectedColor.xyz, 1.0 );",\n        THREE.ShaderChunk[ "logdepthbuf_fragment" ],\n\n      "}"\n\n    ].join("\\n")\n\n  };\n}\n\n/*global VAPI*/\nSphereMapCapture.prototype = new VAPI.VeroldComponent();\n\nSphereMapCapture.prototype.init = function() {\n  \n  this.initCamera();\n};\n\nSphereMapCapture.prototype.editorInit = function() {\n  this.init();\n  this.veroldEntity.getParentAsset().once(\'load\', this.initEditorObject, this );\n  if ( this.veroldEntity.state_base === "loaded") {\n    this.veroldEntity.load();\n  }\n  // this.getEngine().on( "preRenderView", this.preRenderView, this );\n  this.getEngine().on( "preRenderView", this.preRenderView, this );\n  this.getEngine().on( "postUpdate", this.postUpdate, this );\n  this.getEntity().on( "editorSelected", this.onSelected, this );\n  this.getEntity().on( "editorUnselected", this.onUnselected, this );\n  this.getEngine().on( "update", this.update, this );\n};\n\nSphereMapCapture.prototype.shutdown = function() {\n  // this.getEngine().globalEvents.trigger(\'renderer::unregisterPreRenderFn\', "Reflection_" + this.reflectionActorId, this.preRenderPass, this );\n};\n\nSphereMapCapture.prototype.editorShutdown = function() {\n\n  this.getEntity().off( "editorSelected", this.onSelected, this );\n  this.getEntity().off( "editorUnselected", this.onUnselected, this );\n  this.getEngine().off( "preRenderView", this.preRenderView, this );\n  this.getEngine().off( "postUpdate", this.postUpdate, this );\n  this.getEngine().off( "update", this.update, this );\n  this.shutdown();\n};\n\nSphereMapCapture.prototype.onSelected = function() {\n  this.sphereCamera.traverse( function( obj ) {\n    if ( obj instanceof THREE.PerspectiveCamera ) {\n      if ( !obj.cameraHelper ) {\n        obj.cameraHelper = new THREE.CameraHelper( obj );\n        obj.add( obj.cameraHelper );\n      }\n      obj.cameraHelper.visible = true;\n    }\n  });\n};\n\nSphereMapCapture.prototype.onUnselected = function() {\n  this.sphereCamera.traverse( function( obj ) {\n    if ( obj instanceof THREE.PerspectiveCamera ) {\n      if ( obj.cameraHelper ) {\n        obj.cameraHelper.visible = false;\n      }\n    }\n  });\n};\n\nSphereMapCapture.prototype.objectCreated = function() {\n\n  var threeObj = this.getThreeScene();\n  threeObj.add( this.sphereCamera );\n};\n\nSphereMapCapture.prototype.initEditorObject = function() {\n  this.objectCreated();\n\n  this.sphereGeometry = new THREE.SphereGeometry( 0.25, 12, 12 );\n\n  this.sphereGeometry.dynamic = true;\n  this.sphereMesh = new THREE.Mesh( this.sphereGeometry );\n  this.sphereMesh.castShadow = false;\n  this.sphereMesh.receiveShadow = false;\n  this.sphereMesh.name = "SphereMapCapturePlane";\n  this.getThreeObject().add( this.sphereMesh );\n  this.getEngine().globalEvents.trigger( "studioApp::registerPickingObject", this.getEntity(), this.sphereMesh );\n\n  if ( !this.sphereTexture ) {\n    this.createTempRenderTexture();\n  }\n  else {\n    this.sphereTexture.load();\n  }\n  \n  this.sphereMaterialDef.uniforms[ "tSphere" ].value = this.sphereTexture ? this.sphereTexture.threeData : this.tempRenderTexture.threeData;\n  this.sphereMaterial = new THREE.ShaderMaterial( this.sphereMaterialDef );\n  this.sphereMesh.material = this.sphereMaterial;\n};\n\nSphereMapCapture.prototype.createTempRenderTexture = function( changes ) {\n  var that = this;\n  this.getAssetRegistry().createAsset( { type: "renderTexture2D", id: "render_tex_sphere_map", payload: {\n      width: 512,\n      height: 512,\n      format: THREE.RGBAFormat,\n      type: THREE.UnsignedByteType,\n    }}, {\n    success: function( tex ) {\n      that.tempRenderTexture = tex;\n      tex.load();\n    }\n  });\n};\n\nSphereMapCapture.prototype.attributesChanged = function( changes ) {\n  if ( changes.sphereTexture !== undefined ) {\n    if ( this.sphereTexture ) {\n      var that = this;\n      this.sphereTexture.once( \'load\', function() {\n        if ( that.tempRenderTexture ) {\n          that.tempRenderTexture.unload();\n        }\n        that.sphereMaterial.uniforms[ "tSphere" ].value = that.sphereTexture.threeData;\n      } );\n      this.sphereTexture.load();\n    }\n    else if ( !this.tempRenderTexture ) {\n      this.createTempRenderTexture();\n      this.sphereMaterial.uniforms[ "tSphere" ].value = this.tempRenderTexture.threeData;\n    }\n  }\n  if ( changes.near || changes.far ) {\n    this.sphereCamera.near = this.near;\n    this.sphereCamera.far = this.far;\n    this.sphereCamera.updateProjectionMatrix();\n   \n    if ( this.sphereCamera.cameraHelper ) {\n      this.sphereCamera.cameraHelper.update();\n    }\n  }\n};\n\n/**\n * Called immediately after after component creation\n */\nSphereMapCapture.prototype.initCamera = function() {\n  this.sphereCamera = new THREE.PerspectiveCamera( 179.0, 1.0, this.near, this.far );\n  this.sphereCamera.position.copy( this.getEntity().getPosition() );\n};\n\nSphereMapCapture.prototype.postUpdate = function( delta ) {\n  if ( this.sphereCamera && this.hasThreeData() ) {\n    this.sphereCamera.position.setFromMatrixPosition( this.getThreeObject().matrixWorld );\n  }\n};\n\nSphereMapCapture.prototype.update = function( delta ) {\n  this.framesElapsed++;\n  this.performRender = false;\n  if ( this.framesElapsed >= this.updateFrameInterval ) {\n    this.framesElapsed = 0.0;\n    if ( this.sphereTexture || this.tempRenderTexture ) {\n      this.performRender = true;\n    }\n  }\n};\n\nSphereMapCapture.prototype.preRenderView = function( scene, camera, options ) {\n  if ( this.performRender ) {\n    var renderer = this.getRenderer();\n    this.sphereCamera.lookAt( camera.position );\n    \n    //This render needs to be done with a fish-eye distortion but we don\'t have a current way of enabling this for a single render pass...\n    // #ifdef USE_FISHEYE\n    //   vec4 tempPoint = modelViewMatrix * displacedPosition;\n    //   gl_Position.xy = tempPoint.xy / length( tempPoint.xyz );\n    // #endif\n    var renderTarget = this.sphereTexture ? this.sphereTexture.threeData : this.tempRenderTexture.threeData;\n\n    renderer.renderView( scene, this.sphereCamera, { renderTarget: renderTarget, clearColor: true } );\n    \n  }\n};\n\n\nreturn SphereMapCapture;\n';});


define('text!VeroldEngine/Components/BuiltIn/SimplexNoiseGenerator.js',[],function () { return '\nvar _ = require(\'underscore\');\n\nfunction SimplexNoiseRenderer() {\n  // this.m_Renderer = null;\n  this.m_Uniforms = null;\n  this.m_NoiseMat = null;\n}\n\nSimplexNoiseRenderer.prototype = new VAPI.VeroldComponent();\n\nSimplexNoiseRenderer.prototype.editorInit = function(){\n  this.init();\n  this.getEntity().on("load_base", this.objectCreated, this );\n};\n\nSimplexNoiseRenderer.prototype.editorShutdown = function() {\n  this.getEntity().off("load_base", this.objectCreated, this );\n  this.shutdown();\n};\n\nSimplexNoiseRenderer.prototype.init = function() {\n  \n  this.getEntity().on( \'changeNoiseValues\', this.changeNoiseValues, this );\n  this.getEntity().on( \'renderNoise\', this.renderNoise, this );\n  this.m_Uniforms = {\n    time   : { type : "f", value : 1.0 }, \n    scale  : { type : "v2", value : this.scale },\n    offset : { type : "v2", value : this.offset },\n    layerAmplitude : { type : "v4", value : this.layerAmplitude },\n    layerScale : { type : "v4", value : this.layerScale }\n  };\n  \n  //create noise material\n  this.m_NoiseMat = new THREE.ShaderMaterial( {\n    uniforms       : this.m_Uniforms,\n    vertexShader   : SimplexNoiseRenderer.VertexShader,\n    fragmentShader : SimplexNoiseRenderer.FragmentShader\n  } );\n  \n  // this.m_NoiseMat.depthTest = false;\n  // this.m_NoiseMat.depthWrite = false;\n    \n  this.cameraRTT = new THREE.OrthographicCamera( -0.5, 0.5, 0.5, -0.5, -10, 10 );\n  this.cameraRTT.position.z = 1;\n  this.sceneRTT = new THREE.Scene();\n  this.sceneRTT.add( this.cameraRTT );\n  \n  this.quadGeo = new THREE.PlaneGeometry( 1, 1 );\n  this.quadRTT = new THREE.Mesh( this.quadGeo, this.m_NoiseMat );\n  this.quadRTT.position.z = -5;\n  this.sceneRTT.add( this.quadRTT );\n  \n};\n\nSimplexNoiseRenderer.prototype.shutdown = function() {\n  this.getEntity().off( \'changeNoiseValues\', this.changeNoiseValues, this );\n  this.getEntity().off( \'renderNoise\', this.renderNoise, this );\n  this.sceneRTT.remove( this.cameraRTT );\n  this.sceneRTT.remove( this.quadRTT );\n  this.sceneRTT = undefined;\n  this.quadRTT = undefined;\n  this.quadGeo.dispose();\n  this.m_NoiseMat.dispose();\n  this.m_Uniforms = undefined;\n};\n\nSimplexNoiseRenderer.prototype.objectCreated = function() {\n  if ( this.autoLoad ) {\n    this.renderNoise();\n  }\n};\n\nSimplexNoiseRenderer.prototype.renderNoise = function(texture) {\n  // this.getThreeRenderer().setViewport( 0, 0, this.getEntity().getWidth(), this.getEntity().getHeight() );\n  this.getThreeRenderer().render( this.sceneRTT, this.cameraRTT, this.getThreeObject(), true );\n  this.getThreeRenderer().setRenderTarget( null );\n};\n\nSimplexNoiseRenderer.prototype.changeNoiseValues = function( layerAmplitude, layerScale, scale, offset ) {\n  var values = {};\n  if ( layerAmplitude ) {\n    values.layerAmplitude = layerAmplitude;\n  }\n  if ( layerScale ) {\n    values.layerScale = layerScale;\n  }\n  if ( scale ) {\n    values.scale = scale;\n  }\n  if ( offset ) {\n    values.offset = offset;\n  }\n  this.attributesChanged( values );\n};\n\nSimplexNoiseRenderer.prototype.attributesChanged = function( attributes ) {\n  if ( attributes.scale && attributes.scale.x !== undefined ) {\n    this.m_Uniforms.scale.value.x = attributes.scale.x;\n    this.m_Uniforms.scale.value.y = attributes.scale.y;\n  }\n  if ( attributes.offset && attributes.offset.x !== undefined ) {\n    this.m_Uniforms.offset.value.x = attributes.offset.x;\n    this.m_Uniforms.offset.value.y = attributes.offset.y;\n  }\n  if ( attributes.layerScale && attributes.layerScale.x !== undefined ) {\n    this.m_Uniforms.layerScale.value.x = attributes.layerScale.x;\n    this.m_Uniforms.layerScale.value.y = attributes.layerScale.y;\n    this.m_Uniforms.layerScale.value.z = attributes.layerScale.z;\n    this.m_Uniforms.layerScale.value.w = attributes.layerScale.w;\n  }\n  if ( attributes.layerAmplitude && attributes.layerAmplitude.x !== undefined ) {\n    this.m_Uniforms.layerAmplitude.value.x = attributes.layerAmplitude.x;\n    this.m_Uniforms.layerAmplitude.value.y = attributes.layerAmplitude.y;\n    this.m_Uniforms.layerAmplitude.value.z = attributes.layerAmplitude.z;\n    this.m_Uniforms.layerAmplitude.value.w = attributes.layerAmplitude.w;\n  }\n  this.renderNoise();\n};\n\nSimplexNoiseRenderer.VertexShader = [\n  "varying vec2 vUv;",\n  "uniform vec2 scale;",\n  "uniform vec2 offset;",\n  "void main() {",\n\n    "vUv = uv * scale + offset;",\n    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",\n\n  "}"\n\n].join("\\n");\n\nSimplexNoiseRenderer.FragmentShader = [\n  //\n  // Description : Array and textureless GLSL 3D simplex noise function.\n  //      Author : Ian McEwan, Ashima Arts.\n  //  Maintainer : ijm\n  //     Lastmod : 20110409 (stegu)\n  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n  //               Distributed under the MIT License. See LICENSE file.\n  //\n  //"precision lowp float;",\n  "uniform float time;",\n  "uniform vec4 layerAmplitude;",\n  "uniform vec4 layerScale;",\n  "varying vec2 vUv;",\n\n//   "vec3 mod289(vec3 x) {",\n//   "return x - floor(x * (1.0 / 289.0)) * 289.0;",\n// "}",\n\n// "vec2 mod289(vec2 x) {",\n//   "return x - floor(x * (1.0 / 289.0)) * 289.0;",\n// "}",\n\n// "vec3 permute(vec3 x) {",\n//   "return mod289(((x*34.0)+1.0)*x);",\n// "}",\n\n// "float snoise(vec2 v)",\n//   "{",\n//   "const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0",\n//                       "0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)",\n//                      "-0.577350269189626,  // -1.0 + 2.0 * C.x",\n//                       "0.024390243902439); // 1.0 / 41.0",\n// // First corner\n//   "vec2 i  = floor(v + dot(v, C.yy) );",\n//   "vec2 x0 = v -   i + dot(i, C.xx);",\n\n// // Other corners\n//   "vec2 i1;",\n//   //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n//   //i1.y = 1.0 - i1.x;\n//   "i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);",\n//   // x0 = x0 - 0.0 + 0.0 * C.xx ;\n//   // x1 = x0 - i1 + 1.0 * C.xx ;\n//   // x2 = x0 - 1.0 + 2.0 * C.xx ;\n//   "vec4 x12 = x0.xyxy + C.xxzz;",\n//   "x12.xy -= i1;",\n\n// // Permutations\n//   "i = mod289(i); // Avoid truncation effects in permutation",\n//   "vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))",\n//    "+ i.x + vec3(0.0, i1.x, 1.0 ));",\n\n//   "vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);",\n//   "m = m*m;",\n//   "m = m*m;",\n\n// // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n//   "vec3 x = 2.0 * fract(p * C.www) - 1.0;",\n//   "vec3 h = abs(x) - 0.5;",\n//   "vec3 ox = floor(x + 0.5);",\n//   "vec3 a0 = x - ox;",\n\n// // Normalise gradients implicitly by scaling m\n// // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n//   "m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );",\n\n// // Compute final noise value at P\n//   "vec3 g;",\n//   "g.x  = a0.x  * x0.x  + h.x  * x0.y;",\n//   "g.yz = a0.yz * x12.xz + h.yz * x12.yw;",\n//   "return 130.0 * dot(m, g);",\n// "}",\n  "precision highp float;",\n  \n  "vec4 permute( vec4 x ) {",\n\n    "return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );",\n\n  "}",\n\n  "vec4 taylorInvSqrt( vec4 r ) {",\n\n    "return 1.79284291400159 - 0.85373472095314 * r;",\n\n  "}",\n\n  "float snoise( vec3 v ) {",\n\n    "vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );",\n    "const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );",\n\n    // First corner\n\n    "vec3 i  = floor( v + dot( v, C.yyy ) );",\n    "vec3 x0 = v - i + dot( i, C.xxx );",\n\n    // Other corners\n\n    "vec3 g = step( x0.yzx, x0.xyz );",\n    "vec3 l = 1.0 - g;",\n    "vec3 i1 = min( g.xyz, l.zxy );",\n    "vec3 i2 = max( g.xyz, l.zxy );",\n\n    "vec3 x1 = x0 - i1 + 1.0 * C.xxx;",\n    "vec3 x2 = x0 - i2 + 2.0 * C.xxx;",\n    "vec3 x3 = x0 - 1. + 3.0 * C.xxx;",\n\n    // Permutations\n\n    "i = mod( i, 289.0 );",\n    "vec4 p = permute( permute( permute(",\n         "i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )",\n         "+ i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )",\n         "+ i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );",\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n\n    "float n_ = 1.0 / 7.0; // N=7",\n\n    "vec3 ns = n_ * D.wyz - D.xzx;",\n\n    "vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)",\n\n    "vec4 x_ = floor( j * ns.z );",\n    "vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)",\n\n    "vec4 x = x_ *ns.x + ns.yyyy;",\n    "vec4 y = y_ *ns.x + ns.yyyy;",\n    "vec4 h = 1.0 - abs( x ) - abs( y );",\n\n    "vec4 b0 = vec4( x.xy, y.xy );",\n    "vec4 b1 = vec4( x.zw, y.zw );",\n\n\n    "vec4 s0 = floor( b0 ) * 2.0 + 1.0;",\n    "vec4 s1 = floor( b1 ) * 2.0 + 1.0;",\n    "vec4 sh = -step( h, vec4( 0.0 ) );",\n\n    "vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;",\n    "vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;",\n\n    "vec3 p0 = vec3( a0.xy, h.x );",\n    "vec3 p1 = vec3( a0.zw, h.y );",\n    "vec3 p2 = vec3( a1.xy, h.z );",\n    "vec3 p3 = vec3( a1.zw, h.w );",\n\n    // Normalise gradients\n\n    "vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );",\n    "p0 *= norm.x;",\n    "p1 *= norm.y;",\n    "p2 *= norm.z;",\n    "p3 *= norm.w;",\n\n    // Mix final noise value\n\n    "vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );",\n    "m = m * m;",\n    "return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),",\n                    "dot( p2, x2 ), dot( p3, x3 ) ) );",\n\n  "}",\n\n  "float surface3( vec3 coord ) {",\n\n    "float n = 0.0;",\n\n    "n += layerAmplitude.x * abs( snoise( coord * layerScale.x ) );",\n//     "n += 0.5 * abs( snoise( coord * 2.0 ) );",\n//     "n += 0.25 * abs( snoise( coord * 4.0 ) );",\n//     "n += 0.125 * abs( snoise( coord * 8.0 ) );",\n    "n += layerAmplitude.y * abs( snoise( coord * layerScale.y ) );",\n    "n += layerAmplitude.z * abs( snoise( coord * layerScale.z ) );",\n    "n += layerAmplitude.w * abs( snoise( coord * layerScale.w ) );",\n\n    "return n;",\n\n  "}",\n\n  "void main( void ) {",\n\n    "vec3 coord = vec3( vUv, -time );",\n    "float n = surface3( coord );",\n\n    "gl_FragColor = vec4( vec3( n, n, n ), 1.0 );",\n\n  "}"\n].join("\\n");\n\nreturn SimplexNoiseRenderer;\n';});


define('text!VeroldEngine/Components/BuiltIn/NormalMapGenerator.js',[],function () { return '\nvar _ = require(\'underscore\');\n\nfunction NormalMapGenerator() {\n  // this.m_Renderer = null;\n  this.m_Uniforms = null;\n  this.normalMaterial = null;\n}\n\nNormalMapGenerator.prototype = new VAPI.VeroldComponent();\n\nNormalMapGenerator.prototype.editorInit = function(){\n  this.init();\n  this.getEntity().on("load_base", this.objectCreated, this );\n};\n\nNormalMapGenerator.prototype.editorShutdown = function() {\n  this.getEntity().off("load_base", this.objectCreated, this );\n  this.shutdown();\n};\n\nNormalMapGenerator.prototype.init = function() {\n  \n  this.getEntity().on( \'renderNormalMap\', this.renderNormalMap, this );\n  this.m_Uniforms = {\n    "bumpTexture":  { type: "t", value: null },\n    "resolution": { type: "v2", value: new THREE.Vector2( 256, 256 ) },\n    // "scale":      { type: "v2", value: new THREE.Vector2( 1, 1 ) },\n    "smoothness":     { type: "f", value: 0.25 },\n    "spread":     { type: "f", value: 4.0 }\n  };\n  \n  //create noise material\n  this.normalMaterial = new THREE.ShaderMaterial( {\n    uniforms       : this.m_Uniforms,\n    vertexShader   : NormalMapGenerator.VertexShader,\n    fragmentShader : NormalMapGenerator.FragmentShader,\n    blending        : THREE.NoBlending\n  } );\n  \n  this.normalMaterial.depthTest = false;\n  this.normalMaterial.depthWrite = false;\n    \n  this.cameraRTT = new THREE.OrthographicCamera( -0.5, 0.5, 0.5, -0.5, -10, 10 );\n  this.cameraRTT.position.z = 1;\n  this.sceneRTT = new THREE.Scene();\n  this.sceneRTT.add( this.cameraRTT );\n  \n  this.quadGeo = new THREE.PlaneGeometry( 1, 1 );\n  this.quadRTT = new THREE.Mesh( this.quadGeo, this.normalMaterial );\n  this.quadRTT.position.z = -5;\n  this.sceneRTT.add( this.quadRTT );\n  // this.updateUniforms();\n};\n\nNormalMapGenerator.prototype.shutdown = function() {\n  this.getEntity().off( \'renderNormalMap\', this.renderNormalMap, this );\n  this.sceneRTT.remove( this.cameraRTT );\n  this.sceneRTT.remove( this.quadRTT );\n  this.sceneRTT = undefined;\n  this.quadRTT = undefined;\n  this.quadGeo.dispose();\n  this.normalMaterial.dispose();\n  this.m_Uniforms = undefined;\n};\n\nNormalMapGenerator.prototype.objectCreated = function() {\n  \n  var that = this;\n  this.updateUniforms( function() {\n    if ( that.autoLoad ) {\n      that.renderNormalMap();\n    }\n  });\n};\n\nNormalMapGenerator.prototype.renderNormalMap = function( smoothness ) {\n  // if ( scale && scale.x !== undefined ) {\n  //   this.m_Uniforms.scale.value.x = scale.x;\n  //   this.m_Uniforms.scale.value.y = scale.y;\n  // }\n  if ( smoothness !== undefined ) {\n    this.m_Uniforms.smoothness.value = smoothness;\n  }\n  //this.getThreeRenderer().setRenderTarget( this.getEntity().threeData );\n  var renderer = this.getThreeRenderer();\n  renderer.render( this.sceneRTT, this.cameraRTT, this.getEntity().threeData, true );\n  this.getThreeRenderer().setRenderTarget( null );\n};\n\n\nNormalMapGenerator.prototype.attributesChanged = function( attributes ) {\n  var that = this;\n  this.updateUniforms( function() {\n    that.renderNormalMap();\n  });\n  // if ( attributes.scale && attributes.scale.x !== undefined ) {\n  //   this.m_Uniforms.scale.value.x = attributes.scale.x;\n  //   this.m_Uniforms.scale.value.y = attributes.scale.y;\n  // }\n  // if ( attributes.smoothness !== undefined ) {\n  //   this.m_Uniforms.smoothness.value = attributes.smoothness;\n  // }\n  // if ( attributes.bumpTexture ) {\n  //   if ( this.bumpTexture.threeData ) {\n  //     this.m_Uniforms.bumpTexture.value = this.bumpTexture.threeData;\n  //   }\n  //   else {\n  //     this.bumpTexture.once( \'load\', function() {\n  //       this.m_Uniforms.bumpTexture.value = this.bumpTexture.threeData;\n  //     }, this );\n  //     this.bumpTexture.load();\n  //   }\n  // }\n\n};\n\nNormalMapGenerator.prototype.updateUniforms = function( callback ) {\n  // this.m_Uniforms.scale.value.x = this.scale.x;\n  // this.m_Uniforms.scale.value.y = this.scale.y;\n  this.m_Uniforms.smoothness.value = this.smoothness;\n  this.m_Uniforms.spread.value = this.spread;\n  if ( this.bumpTexture ) {\n    if ( this.bumpTexture.threeData ) {\n      this.m_Uniforms.bumpTexture.value = this.bumpTexture.threeData;\n      this.m_Uniforms.resolution.value.set( this.bumpTexture.getWidth(), this.bumpTexture.getHeight() );\n      if ( _.isFunction( callback ) ) {\n        callback();\n      }\n    }\n    else {\n      this.bumpTexture.once( \'load\', function() {\n        this.m_Uniforms.bumpTexture.value = this.bumpTexture.threeData;\n        this.m_Uniforms.resolution.value.set( this.bumpTexture.getWidth(), this.bumpTexture.getHeight() );\n        if ( _.isFunction( callback ) ) {\n          callback();\n        }\n      }, this );\n      this.bumpTexture.load();\n    }\n  }\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Normal map shader\n * - compute normals from bumpTexture\n */\n\nNormalMapGenerator.VertexShader = [\n\n  "varying vec2 vUv;",\n\n  "void main() {",\n\n    "vUv = uv;",\n    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",\n\n  "}"\n\n].join("\\n");\n\nNormalMapGenerator.FragmentShader = [\n  "precision lowp float;",\n  "uniform float smoothness;",\n  "uniform float spread;",\n  "uniform vec2 resolution;",\n  "uniform sampler2D bumpTexture;",\n\n  "vec2 size = vec2( smoothness, 0.0 );",\n  "vec3 off = vec3(-spread / resolution.x, 0.0, spread / resolution.y);",\n\n  "varying vec2 vUv;",\n\n  "void main() {",\n\n    // "float val = texture2D( bumpTexture, vUv ).x;",\n\n    // "float valU = texture2D( bumpTexture, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;",\n    // "float valV = texture2D( bumpTexture, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;",\n\n    // "gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, smoothness ) ) + 0.5 ), val );",\n    // "gl_FragColor.z = val;",\n\n    "vec4 wave = texture2D( bumpTexture, vUv);",\n    "float s11 = wave.x;",\n    "float s01 = texture2D( bumpTexture, vUv + off.xy ).x;",\n    "float s21 = texture2D( bumpTexture, vUv + off.zy ).x;",\n    "float s10 = texture2D( bumpTexture, vUv + off.yx ).x;",\n    "float s12 = texture2D( bumpTexture, vUv + off.yz ).x;",\n    "vec3 va = normalize(vec3( size.xy, s21-s01));",\n    "vec3 vb = normalize(vec3( size.yx, s12-s10));",\n    "vec3 norm = cross(va,vb);",\n    "gl_FragColor = vec4( norm * 0.5 + 0.5, s11 );",\n  "}"\n\n].join("\\n");\n\nreturn NormalMapGenerator;\n';});


define('text!VeroldEngine/Components/BuiltIn/SceneLoader.js',[],function () { return 'function SceneLoader() {\n  this.m_bHierarchy = false;\n  this.m_bDependencies = false;\n  this.scene = undefined;\n  this.loadTime = 0;\n}\n\nSceneLoader.prototype = new VAPI.VeroldComponent();\n\n\nSceneLoader.prototype.init = function() {\n  if ( this.scene ) {\n    this.scene.on( "load_progress", this.onProgress, this );\n    this.scene.once( "load", this.onLoadComplete, this );\n    this.scene.once( "load_hierarchy_failure", this.onLoadComplete, this );\n  }\n};\n\nSceneLoader.prototype.shutdown = function() {\n  if ( this.scene ) {\n    this.scene.off( "load_progress", this.onProgress, this );\n  }\n};\n\nSceneLoader.prototype.update = function( delta ) {\n  this.loadTime += delta;\n};\n\n//fired as progress loading occurs\nSceneLoader.prototype.onProgress = function(scene){\n  var progress = scene.getLoadingProgress();//0.0 -> 1.0\n\n  this.getEvents().trigger("sceneLoadProgress", progress, this.scene );\n\n  /*****INCREASE THE SIZE OF THE BAR BASED OFF OF THE PERCENT LOADED  - CUSTOM CODE******/\n  if(document.getElementById(\'load-bar\')) {\n    document.getElementById(\'load-bar\').style.width = (progress*100) + \'%\';\n  }\n\n  //If no progress happens for a full second, trigger load complete\n  if ( this.timeoutId ) {\n    clearTimeout( this.timeoutId );\n  }\n  var that = this;\n  this.timeoutId = setTimeout( function() {\n    that.onLoadComplete();\n  }, 5000 );\n  /**************************************************************************************/\n};\n\n//fired when everything has been loaded\nSceneLoader.prototype.onLoadComplete = function(){\n  var loadBar;\n  if ( document.getElementById(\'load-scene\') ) {\n    if((loadBar = document.getElementById(\'load-bar\'))) {\n      var loadBars = document.querySelectorAll(\'.load-bar\');\n      [].forEach.call(loadBars,function(el) {\n        el.style[\'-webkit-transition\'] = \'width 0s ease\';\n        el.style[\'-moz-transition\'] = \'width 0s ease\';\n\n      });\n      loadBar.style.width = 100 + \'%\';\n    }\n\n    /************************show the app and remove the loading scene -  CUSTOM CODE **************************/\n    var that = this;\n    setTimeout(function() {\n      document.body.removeChild(document.getElementById(\'load-scene\'));\n      console.log("Scene load completed in " + that.loadTime.toFixed(2) + " seconds.");\n      parent.postMessage({command: \'loadComplete\', params: []}, \'*\');\n    }, 100);\n    /**************************************************************************************/\n  }\n\n  this.getEvents().trigger("sceneLoadComplete", this.scene );\n};\n\n\nreturn SceneLoader;\n';});


define('text!VeroldEngine/Components/BuiltIn/Rotate.js',[],function () { return '/** \n * @vname Rotate\n *\n * @vdescription \n * A simple component to rotate an object.\n * \n * @vcategory Animation\n * \n * @vfilter object\n */\n\n/**\n * @vattr Boolean autoRotate  {\n *   description: "Automatically start the rotation upon load.",\n *   default: true,\n * }\n *\n * @vattr Boolean previewRotation {\n *   description: "Show the rotation in the editor.",\n *   default: true\n * }\n *\n * @vattr Vector3 rotation {\n *   description: \'Amount of rotation per second about the x, y and z axes.\',\n *   default: { x: 0, y: 0.5, z: 0 }\n * }\n *\n * @vattr Boolean local {\n *   description: \'Rotate relative to the local orientation of the object. If false, the rotation will be relative to the world.\',\n *   default: false\n * }\n */\n\n/**\n * @vevent local startRotate {\n *   action: true,\n *   category: \'Rotate\',\n *   parameters: []\n * }\n * \n * @vevent local stopRotate {\n *   action: true,\n *   category: \'Rotate\',\n *   parameters: []\n * }\n *\n * @vevent local toggleRotate {\n *   action: true,\n *   category: \'Rotate\',\n *   parameters: []\n * }\n */ \n\n/* global VAPI */\nvar tmpVec = new THREE.Vector3(),\n    tmpEuler = new THREE.Euler();\n\nfunction Rotate() {\n  this.quaternion = new THREE.Quaternion();\n  this.currentGlobalQuaternion = new THREE.Quaternion();\n}\n\nRotate.prototype = new VAPI.VeroldComponent();\n\nRotate.prototype.editorInit = function() {\n  this.getEngine().on("update", this.update, this );\n  this.getEntity().once("load_base", this.objectCreated, this );\n  this.rotate = this.previewRotation;\n  if ( this.getEntity().state_base === "loaded") {\n    this.objectCreated();\n  }\n  this.on(\'enable\', this.onEnable, this );\n  this.on(\'disable\', this.onDisable, this );\n};\n\nRotate.prototype.editorShutdown = function() {\n  this.getEngine().off("update", this.update, this );\n  this.getThreeData().position.copy( this.getEntity().getPosition() );\n  this.getThreeData().quaternion.copy( this.getEntity().getQuaternion() );\n  this.off(\'enable\', this.onEnable, this );\n  this.off(\'disable\', this.onDisable, this );\n};\n\nRotate.prototype.init = function() {\n  this.rotate = this.autoRotate;\n\n  this.getEntity().on(\'startRotate\', this.onStartRotate, this);\n  this.getEntity().on(\'stopRotate\', this.onStopRotate, this);\n  this.getEntity().on(\'toggleRotate\', this.onToggleRotate, this);\n};\n\nRotate.prototype.shutdown = function() {\n  this.getEntity().off(\'startRotate\', this.onStartRotate, this);\n  this.getEntity().off(\'stopRotate\', this.onStopRotate, this);\n  this.getEntity().off(\'toggleRotate\', this.onToggleRotate, this);\n};\n\nRotate.prototype.onEnable = function() {\n  this.rotate = this.autoRotate;\n  this.initRotation();\n};\n\nRotate.prototype.onDisable = function() {\n  this.getThreeData().position.copy( this.getEntity().getPosition() );\n  this.getThreeData().quaternion.copy( this.getEntity().getQuaternion() );\n  this.rotate = false;\n};\n\nRotate.prototype.attributesChanged = function( changes ) {\n  if ( changes.rotation && !_.isEmpty( changes.rotation )) {\n    this.initRotation();\n  }\n  if ( changes.previewRotation !== undefined ) {\n    this.rotate = this.previewRotation;\n    this.initRotation();\n  }\n};\n\nRotate.prototype.objectCreated = function() {\n  this.initialQuaternion = new THREE.Quaternion();\n  this.initialQuaternion.copy(this.getThreeData().quaternion);\n  this.initRotation();\n};\n\nRotate.prototype.initRotation = function() {\n  tmpEuler.set( this.rotation.x, this.rotation.y, this.rotation.z );\n  if ( this.local ) {\n    this.getThreeData().quaternion.copy( this.initialQuaternion );\n  }\n  else {\n    this.currentGlobalQuaternion.set( 0,0,0,1 );\n  }\n};\n\nRotate.prototype.update = function( delta ) {\n  if(this.rotate && this.isEnabled() ) {\n    this.getEngine().needsRender = true;\n    if (this.getThreeData() && this.rotation ) {\n      tmpVec.copy(this.rotation).multiplyScalar( delta );\n      tmpEuler.set(tmpVec.x, tmpVec.y, tmpVec.z);\n      this.quaternion.setFromEuler( tmpEuler );\n      if ( this.local ) {\n        this.getThreeData().quaternion.multiply( this.quaternion );\n      }\n      else {\n        this.currentGlobalQuaternion.multiply( this.quaternion );\n        this.getThreeData().quaternion.multiplyQuaternions( this.currentGlobalQuaternion, this.initialQuaternion );\n      }\n    }\n  }\n};\n\nRotate.prototype.onStartRotate = function() {\n  this.rotate = true;\n};\n\nRotate.prototype.onStopRotate = function() {\n  this.rotate = false;\n};\n\nRotate.prototype.onToggleRotate = function() {\n  this.rotate = !this.rotate;\n};\n\nreturn Rotate;\n';});


define('text!VeroldEngine/Components/BuiltIn/LookAt.js',[],function () { return '/**\n * A component to automatically point an object at another. This can be used for\n * billboarding an object to the camera, making a character look at another, etc.\n *\n * @class LookAt\n */\nfunction LookAt() {\n  this.playing = true;\n}\n\nLookAt.prototype = new VAPI.VeroldComponent();\n\nLookAt.prototype.editorInit = function() {\n  this.init();\n  var engine = this.getEngine(); \n  engine.on( \'postUpdate\', this.postUpdate, this );\n  this.on(\'enable\', this.onEnable, this );\n  this.on(\'disable\', this.onDisable, this );\n};\n\n/**\n * Called when a verold object is destroyed or this component is removed\n * from a verold object.\n */\nLookAt.prototype.editorShutdown = function() {\n  var engine = this.getEngine();\n  engine.off( \'postUpdate\', this.postUpdate, this );\n  this.shutdown();\n  this.off(\'enable\', this.onEnable, this );\n  this.off(\'disable\', this.onDisable, this );\n};\n\n/**\n * Called immediately after after component creation\n */\nLookAt.prototype.init = function() {\n  this.tempVec = new THREE.Vector3();\n  this.tempMatrix = new THREE.Matrix4();\n  this.tempQuaternion = new THREE.Quaternion();\n};\n\nLookAt.prototype.attributesChanged = function( changes ) {\n  if ( changes.showPreview !== undefined ) {\n    this.playing = this.showPreview;\n  }\n  if ( !this.playing ) {\n    this.getThreeData().position.copy( this.getEntity().getPosition() );\n    this.getThreeData().quaternion.copy( this.getEntity().getQuaternion() );\n  }\n};\n\nLookAt.prototype.onEnable = function() {\n  this.playing = this.showPreview;\n};\n\nLookAt.prototype.onDisable = function() {\n  this.playing = false;\n  this.getThreeData().position.copy( this.getEntity().getPosition() );\n  this.getThreeData().quaternion.copy( this.getEntity().getQuaternion() );\n};\n\n/**\n * Called per VeroldEngine update (per frame)\n * @param  {float} delta The number of seconds since the last call to `update`\n */\nLookAt.prototype.postUpdate = function(delta) {\n  var threeData;\n  if (this.hasThreeData() && this.playing && this.isEnabled() ) {\n      \n    threeData = this.getThreeData();\n    if ( this.target && this.target.threeData ) {\n      this.getEngine().needsRender = true;\n      var lookAtObject = this.target.threeData;\n      \n      this.tempVec.setFromMatrixPosition( lookAtObject.matrixWorld );\n      if ( threeData.parent ) {\n        this.tempMatrix.getInverse( threeData.parent.matrixWorld );\n      }\n      else {\n        this.tempMatrix.identity();\n      }\n      this.tempVec.applyMatrix4( this.tempMatrix );\n      \n      if ( this.local ) {\n        threeData.lookAt( this.tempVec );\n        threeData.quaternion.multiply( this.getEntity().getQuaternion() );\n      }\n      else {\n        threeData.lookAt( this.tempVec );\n      }\n    }\n  }\n};\n\n/**\n * Called when a verold object is destroyed or this component is removed\n * from a verold object.\n */\nLookAt.prototype.shutdown = function() {\n  // make sure to clean up any events or other bindings that you have created\n  // to avoid memory leaks\n};\n\nreturn LookAt;';});


define('text!VeroldEngine/Components/BuiltIn/TextRenderer2D.js',[],function () { return '/*\n@vname Text Renderer\n@vdescription Render the desired text to the texture we are attached to\n@vfilter renderTexture2D\n@vcategory Text\n@vattr string text { default : \'My Text\', description : \'Text you want to display\' }\n@vattr color fontColor { default : 0xFFFFFF, description : \'Color of the text\'}\n@vattr string fontFamily { default : \'Calibri\', description : \'Font family to render\'}\n@vattr integer pointSize { default : 48, description : \'Font size\', min : 2, max : 100 }\n*/\n\n\nfunction Component() {\n  this.m_Material = null;\n  this.m_Canvas = null;\n  this.m_Mesh = null;\n  this.m_RTCam = null;\n  this.m_RTScene = null;\n}\n\nComponent.prototype = new VAPI.VeroldComponent();\n\nComponent.prototype.editorInit = function(){\n  this.init();\n  this.getEntity().once(\'load\', this.sceneLoaded, this );\n  this.listenTo(this.getEntity().entityModel, \'change\', this.attributesChanged.bind(this));\n};\n\nComponent.prototype.editorShutdown = function(){\n  this.shutdown();\n};\n\nComponent.prototype.init = function() {\n  this.createLabel();\n};\n\nComponent.prototype.sceneLoaded = function(){\n  this.renderText();\n};\n\nComponent.prototype.shutdown = function() {\n  this.m_Material.dispose();\n  this.m_Geom.dispose();\n  this.m_Mesh = null;\n};\n\nComponent.prototype.createLabel = function() {\n\n  var text = this.text,\n      size = this.pointSize,\n      color = "#" + this.fontColor.getHexString();\n\n  if(!this.m_Canvas){\n    this.m_Canvas = document.createElement("canvas");\n  }\n  \n  var fontType = size + "pt " + this.fontFamily;\n  \n  var context = this.m_Canvas.getContext("2d");\n  context.font = fontType;\n\n  var textWidth = context.measureText("  " + text + "  ").width;\n  this.m_Canvas.width = this.getEntity().getWidth();\n  this.m_Canvas.height = this.getEntity().getHeight();\n\n  context.font = size + "pt " + this.fontFamily;\n  context.textAlign = "left";\n  context.textBaseline = "hanging";\n  context.fillStyle = color;\n\n  this.wrapAndRender( context, text, this.pointSize*0.5, this.pointSize*0.5, this.m_Canvas.width - this.pointSize*0.5, this.pointSize*1.5 );\n  \n  /* CONVERT TO SOMETHING VEROLD CAN USE */\n  var texture = new THREE.Texture(this.m_Canvas);\n  texture.mapping = null;\n  texture.generateMipmaps = true;\n  texture.magFilter = THREE.LinearFilter;\n  texture.minFilter = THREE.LinearMipMapLinearFilter;\n  texture.needsUpdate = true;\n\n  if(this.m_Material)this.m_Material.dispose();\n  this.m_Material = new THREE.MeshBasicMaterial({\n    map:texture\n  });\n  this.m_Material.side = THREE.DoubleSide;\n\n  if(this.m_Geom)this.m_Geom.dispose();\n  this.m_Geom = new THREE.PlaneGeometry(this.m_Canvas.width, this.m_Canvas.height);\n\n  if(this.m_Mesh){\n    this.m_RTScene.remove(this.m_Mesh);\n    this.m_Mesh = null;\n  }\n  this.m_Mesh = new THREE.Mesh(this.m_Geom, this.m_Material);\n  this.m_Mesh.position.z = 0;\n  \n  var halfwidth = this.m_Canvas.width*0.5;\n  var halfheight = this.m_Canvas.height*0.5;\n  \n  if(!this.m_RTCam)this.m_RTCam = new THREE.OrthographicCamera(-halfwidth,halfwidth,-halfheight,halfheight,-10, 1000);\n  this.m_RTCam.position.z = 10;\n  this.m_RTCam.rotation.z = Math.PI;\n  // left, right, top, bottom\n  this.m_RTCam.left = halfwidth;\n  this.m_RTCam.right = -halfwidth;\n  this.m_RTCam.top = halfheight;\n  this.m_RTCam.bottom = -halfheight;\n  this.m_RTCam.updateProjectionMatrix();\n  \n  \n  if(!this.m_RTScene) \n  {\n    this.m_RTScene = new THREE.Scene();\n    this.m_RTScene.add(this.m_RTCam);\n  }\n  \n   this.m_RTScene.add(this.m_Mesh);\n};\n\nComponent.prototype.attributesChanged = function(attribs){\n  this.createLabel();\n  this.renderText();\n};\n\nComponent.prototype.renderText = function() {\n  if(!this.text) this.text = \' \';\n  \n  if(this.getThreeData()){\n    this.getThreeRenderer().render(this.m_RTScene, this.m_RTCam, this.getThreeData());\n  }\n  else {\n    this.once("load", function() {\n      this.getThreeRenderer().render(this.m_RTScene, this.m_RTCam, this.getThreeData());\n    }, this );\n    this.load();\n  }\n};\n\nComponent.prototype.wrapAndRender = function(context, text, x, y, maxWidth, lineHeight) {\n  var words = text.split(\' \');\n  var line = \'\';\n\n  for(var n = 0; n < words.length; n++) {\n    var testLine = line + words[n] + \' \';\n    var metrics = context.measureText(testLine);\n    var testWidth = metrics.width;\n    if (testWidth > maxWidth && n > 0) {\n      context.fillText(line, x, y);\n      line = words[n] + \' \';\n      y += lineHeight;\n    }\n    else {\n      line = testLine;\n    }\n  }\n  context.fillText(line, x, y);\n};\n\nreturn Component;\n\n\n/*\n\n\n        "2D Text Renderer" : {\n          id: "text_renderer_component",\n          type: "script",\n          payload : {\n            "script": TextRendererJS\n          }\n        },\n*/\n';});


define('text!VeroldEngine/Components/BuiltIn/TextLabel2D.js',[],function () { return '/* global VAPI */\r\n\r\nvar tmpVec3 = new THREE.Vector3();\r\n\r\nfunction TextLabel2D() {\r\n}\r\n\r\nTextLabel2D.prototype = new VAPI.VeroldComponent();\r\n\r\nTextLabel2D.prototype.editorInit = function() {\r\n  if ( this.getThreeData() ) {\r\n    this.objectCreated();\r\n  }\r\n  else {\r\n    this.getEntity().once("load_base", this.objectCreated, this );\r\n  }\r\n}\r\n\r\nTextLabel2D.prototype.objectCreated = function() {\r\n  this.el = document.createElement(\'div\');\r\n\r\n  this.el.style.position = \'absolute\';\r\n  this.el.style.left = 0;\r\n  this.el.style.top = 0;\r\n  this.el.style.background = \'rgba(0,0,0,0.2)\';\r\n  this.el.style.padding = \'10px\';\r\n  this.el.style.margin = \'5px\';\r\n  this.el.style[\'border-radius\'] = \'5px\';\r\n  this.el.style.color = \'#fff\';\r\n  this.el.style[\'font-family\'] = \'tahoma, verdana, sans\';\r\n\r\n  this.el.innerHTML = VAPI.safeHTML( this.text ) || \'add content here\';\r\n\r\n  this.getThreeRenderer().domElement.parentElement.appendChild(this.el);\r\n\r\n  this.getEngine().globalEvents.trigger(\'renderer::registerPreRenderFn\', "TextLabel", this.preRenderPass, this );\r\n};\r\n\r\nTextLabel2D.prototype.preRenderView = function( scene, camera, options ) {\r\n  if (this.veroldEntity.threeData) {\r\n    var position = this.getThreeData().position.clone(),\r\n        screenPos = this.worldToScreen(position, camera );\r\n\r\n    this.el.style.left = screenPos.x + \'px\';\r\n    this.el.style.top = screenPos.y + \'px\';\r\n  }\r\n};\r\n\r\nTextLabel2D.prototype.shutdown = function() {\r\n  this.getThreeRenderer().domElement.parentElement.removeChild(this.el);\r\n};\r\n\r\nTextLabel2D.prototype.worldToScreen = function(worldPosition, camera ) {\r\n  var vector,\r\n    halfWidth = this.getThreeRenderer().domElement.width / 2,\r\n    halfHeight = this.getThreeRenderer().domElement.height / 2;\r\n\r\n  tmpVec3.copy(worldPosition);\r\n\r\n  vector = tmpVec3.project(camera);\r\n\r\n  return {\r\n    x: Math.round(vector.x * halfWidth + halfWidth),\r\n    y: Math.round(-vector.y * halfHeight + halfHeight)\r\n  };\r\n};\r\n\r\nreturn TextLabel2D;\r\n';});


define('text!VeroldEngine/Components/BuiltIn/EventHandler.js',[],function () { return '/* global VAPI */\nvar _ = require(\'underscore\');\n\nfunction callEvent(object, eventName, parameters) {\n  var events,\n      data = [],\n      i;\n\n  if ( object.getEvents ) {\n    events = object.getEvents();\n    data.push(eventName);\n\n    if (events[eventName]) {\n      for (i in events[eventName].params) {\n        if (!_.isUndefined(parameters[i]) && !_.isNull(parameters[i])) {\n          data.push(parameters[i]);\n        } else {\n          data.push(events[eventName].params[i].default);\n        }\n      }\n    }\n\n    object.trigger.apply(object, data);\n  }\n  else {\n    data.push( eventName );\n    object.trigger.apply(object, data.concat( parameters ));\n  }\n\n}\n\n/**\n * A custom component class.\n *\n * @class Component\n */\nfunction EventHandler() {\n}\n\nEventHandler.prototype = new VAPI.VeroldComponent();\n\n/**\n * Called immediately after after component creation\n */\nEventHandler.prototype.init = function() {\n  // this.veroldEntity is available\n  var local = \'this \' + this.getEntity().entityModel.get(\'type\');\n  var sourceEvent = this.listen;\n  var entity;\n  var bindEventName;\n\n  if ( sourceEvent && this.isEnabled() ) {\n    if(sourceEvent.eventScope === local) {\n      entity = this.getEntity();\n      this.listenTo( entity, sourceEvent.event, this.onEvent );\n    } else if(sourceEvent.eventScope === \'object\') {\n      entity = this.getEngine().getEntityById( sourceEvent.object );\n      this.listenTo( entity, sourceEvent.event, this.onEvent );\n    } else if(sourceEvent.eventScope === \'asset\') {\n      entity = this.getEngine().getEntityById( sourceEvent.asset );\n      this.listenTo( entity, sourceEvent.event, this.onEvent);\n    } else {\n      entity = this.getEvents();\n      this.listenTo( entity, sourceEvent.event, this.onEvent);\n    }\n    bindEventName = sourceEvent.event + ":bound";\n    this.getEngine().trigger( bindEventName, entity );\n  }\n};\n\nEventHandler.prototype.onEvent = function() {\n  if ( this.isEnabled() ) {\n    var local = \'this \' + this.getEntity().entityModel.get(\'type\');\n    var actions = this.triggers;\n    _.each(actions, _.bind(function(action) {\n      if ( action ) {\n        var eventName = action.event;\n        var parameters = action.parameters;\n\n        if(action.eventScope === local) {\n          callEvent(this.getEntity(), eventName, parameters);\n        } else if(action.eventScope === \'object\') {\n          callEvent(this.getEngine().getEntityById(action.object), eventName, parameters);\n        } else if(action.eventScope === \'asset\') {\n          callEvent(this.getEngine().getEntityById(action.asset), eventName, parameters);\n        } else {\n          callEvent(this.getEvents(), eventName, parameters);\n        }\n      }\n    }, this));\n  }\n};\n\n/**\n * Called when a verold object is destroyed or this component is removed\n * from a verold object.\n */\nEventHandler.prototype.shutdown = function() {\n  // make sure to clean up any events or other bindings that you have created\n  // to avoid memory leaks\n};\n\nreturn EventHandler;\n';});


define('text!VeroldEngine/Components/BuiltIn/CustomControl.js',[],function () { return '/* global VAPI */\nvar _ = require(\'underscore\');\n\n/**\n * A custom component class.\n *\n * @class Component\n */\nfunction CustomControl() {\n}\n\nCustomControl.prototype = new VAPI.VeroldComponent();\n\n/**\n * Called immediately after after component creation\n */\nCustomControl.prototype.init = function() {\n  // this.veroldEntity is available\n\n};\n\nCustomControl.prototype.onEvent = function() {\n  if(this.isEnabled()) {\n\n  }\n};\n\nCustomControl.prototype.sceneLoaded = function( ) {\n  if ( this.isEnabled() ) {\n    if ( this.control.type ) {\n      parent.postMessage({command: \'controlsEnabled\', params: {name: this.name, type: this.control.type, events: this.control.events} }, \'*\');\n    }\n  }\n};\n\n/**\n * Called when a verold object is destroyed or this component is removed\n * from a verold object.\n */\nCustomControl.prototype.shutdown = function() {\n  // make sure to clean up any events or other bindings that you have created\n  // to avoid memory leaks\n};\n\nreturn CustomControl;\n';});


define('text!VeroldEngine/Components/BuiltIn/KeyboardController.js',[],function () { return '/* global VAPI */\nvar _ = require(\'underscore\');\n\n/**\n * A builtin component class.\n *\n * @class InputController\n */\nfunction KeyboardController() {\n}\n\nKeyboardController.prototype = new VAPI.VeroldComponent();\n\n/**\n * Called immediately after after component creation\n */\nKeyboardController.prototype.init = function() {\n  // this.veroldEntity is available\n  this.getEngine().on(\'keyDown\', this.onKeyDown, this);\n};\n\n/**\n * Called when a verold object is destroyed or this component is removed\n * from a verold object.\n */\nKeyboardController.prototype.shutdown = function() {\n  // make sure to clean up any events or other bindings that you have created\n  // to avoid memory leaks\n  this.getEngine().off(\'keyDown\', this.onkeydown, this);\n};\n\nKeyboardController.prototype.editorShutdown = function() {\n  //this.shutdown();\n};\n\n/**\n * Called once the data is available\n */\nKeyboardController.prototype.objectCreated = function() {\n  // this.veroldEntity.threeData is available\n};\n\nKeyboardController.prototype.onKeyDown = function(key) {\n  switch(key.keyCode) {\n  case 65:\n    this.keypress(\'a\');\n    break;\n  case 66:\n    this.keypress(\'b\');\n    break;\n  case 67:\n    this.keypress(\'c\');\n    break;\n  case 68:\n    this.keypress(\'d\');\n    break;\n  case 69:\n    this.keypress(\'e\');\n    break;\n  case 70:\n    this.keypress(\'f\');\n    break;\n  case 71:\n    this.keypress(\'g\');\n    break;\n  case 72:\n    this.keypress(\'h\');\n    break;\n  case 73:\n    this.keypress(\'i\');\n    break;\n  case 74:\n    this.keypress(\'j\');\n    break;\n  case 75:\n    this.keypress(\'k\');\n    break;\n  case 76:\n    this.keypress(\'l\');\n    break;\n  case 77:\n    this.keypress(\'m\');\n    break;\n  case 78:\n    this.keypress(\'n\');\n    break;\n  case 79:\n    this.keypress(\'o\');\n    break;\n  case 80:\n    this.keypress(\'p\');\n    break;\n  case 81:\n    this.keypress(\'q\');\n    break;\n  case 82:\n    this.keypress(\'r\');\n    break;\n  case 83:\n    this.keypress(\'s\');\n    break;\n  case 84:\n    this.keypress(\'t\');\n    break;\n  case 85:\n    this.keypress(\'u\');\n    break;\n  case 86:\n    this.keypress(\'v\');\n    break;\n  case 87:\n    this.keypress(\'w\');\n    break;\n  case 88:\n    this.keypress(\'x\');\n    break;\n  case 89:\n    this.keypress(\'y\');\n    break;\n  case 90:\n    this.keypress(\'z\');\n    break;\n  case 37:\n    this.keypress(\'left_arrow\');\n    break;\n  case 38:\n    this.keypress(\'up_arrow\');\n    break;\n  case 39:\n    this.keypress(\'right_arrow\');\n    break;\n  case 40:\n    this.keypress(\'down_arrow\');\n    break;\n  case 32:\n    this.keypress(\'space\');\n    break;\n  default:\n    console.log(key.keyCode);\n    break;\n  }\n};\n\nKeyboardController.prototype.keypress = function(key) {\n  var event = \'keypress_\' + key;\n  this.getEvents().trigger(event);\n};\n\n/**\n * Called per VeroldEngine update (per frame)\n * @param  {float} delta The number of seconds since the last call to `update`\n */\nKeyboardController.prototype.update = function(delta) {\n  var threeData;\n  // since update is called before threeData is present, you should always\n  // check for its presence before making use of it\n  if (this.hasThreeData()) {\n    // It is safe to manipulate threeData now.\n    threeData = this.getThreeData();\n  }\n};\n\nreturn KeyboardController;';});


define('text!VeroldEngine/Components/BuiltIn/MouseController.js',[],function () { return '/* global VAPI */\nvar _ = require(\'underscore\');\n\n/**\n * A builtin component class.\n *\n * @class InputController\n */\nfunction MouseController() {\n}\n\nMouseController.prototype = new VAPI.VeroldComponent();\n\n/**\n * Called immediately after after component creation\n */\nMouseController.prototype.init = function() {\n  // this.veroldEntity is available\n  this.getEngine().on(\'mouseUp\', this.onMouseUp, this);\n  this.getEngine().on(\'mouseDown\', this.onMouseDown, this);\n};\n\n/**\n * Called when a verold object is destroyed or this component is removed\n * from a verold object.\n */\nMouseController.prototype.shutdown = function() {\n  // make sure to clean up any events or other bindings that you have created\n  // to avoid memory leaks\n  this.getEngine().off(\'mouseUp\', this.onMouseUp, this);\n  this.getEngine().off(\'mouseDown\', this.onMouseDown, this);\n};\n\nMouseController.prototype.editorShutdown = function() {\n  //this.shutdown();\n};\n\n/**\n * Called once the data is available\n */\nMouseController.prototype.objectCreated = function() {\n  // this.veroldEntity.threeData is available\n};\n\nMouseController.prototype.onMouseDown = function(event) {\n  switch(event.button) {\n  case 0:\n    this.mouseDown(\'left\', event);\n    break;\n  case 1:\n    this.mouseDown(\'middle\', event);\n    break;\n  case 2:\n    this.mouseDown(\'right\', event);\n    break;\n  default:\n    console.log(event.button);\n    break;\n  }\n};\n\nMouseController.prototype.onMouseUp = function(event) {\n  switch(event.button) {\n  case 0:\n    this.mouseUp(\'left\', event);\n    break;\n  case 1:\n    this.mouseUp(\'middle\', event);\n    break;\n  case 2:\n    this.mouseUp(\'right\', event);\n    break;\n  default:\n    console.log(event.button);\n    break;\n  }\n};\n\nMouseController.prototype.mouseDown = function(button) {\n  var event = \'mouse_down_\' + button;\n  this.getEvents().trigger(event);\n};\n\nMouseController.prototype.mouseUp = function(button) {\n  var event = \'mouse_up_\' + button;\n  this.getEvents().trigger(event);\n};\n\n/**\n * Called per VeroldEngine update (per frame)\n * @param  {float} delta The number of seconds since the last call to `update`\n */\nMouseController.prototype.update = function(delta) {\n  var threeData;\n  // since update is called before threeData is present, you should always\n  // check for its presence before making use of it\n  if (this.hasThreeData()) {\n    // It is safe to manipulate threeData now.\n    threeData = this.getThreeData();\n  }\n};\n\nreturn MouseController;';});


define('text!VeroldEngine/Components/BuiltIn/ObjectPicker.js',[],function () { return '/* global VAPI */\r\nvar _ = require(\'underscore\');\r\n\r\n/**\r\n * A custom component class.\r\n *\r\n * @class ObjectPicker\r\n */\r\nfunction ObjectPicker() {\r\n  this.pickingMaterialDef = undefined;\r\n  this.meshRegistry = {};\r\n  this.meshList = [];\r\n  this.pickingTexture = undefined;\r\n  this.currentHoverObject = undefined;\r\n  this.currentFrame = 0;\r\n\r\n  this.enableHoverByDefault = false;\r\n  this.pickTrigger = null;\r\n  this.hoverEnabled = false;\r\n}\r\n\r\nObjectPicker.prototype = new VAPI.VeroldComponent();\r\n\r\nObjectPicker.prototype.preInit = function() {\r\n  this.getEngine().once(\'endHover:bound\', this.enableHover, this );\r\n  this.getEngine().once(\'beginHover:bound\', this.enableHover, this );\r\n}\r\n/**\r\n * Called immediately after after component creation\r\n */\r\nObjectPicker.prototype.init = function() {\r\n  // this.veroldEntity is available\r\n  this.getEngine().on( \'resize\', this.resize, this );\r\n\r\n  this.initPickingEvents();\r\n  this.initPickingMaterial();\r\n  this.initMeshRegistry();\r\n\r\n  //listen to register objects\r\n  this.getEvents().on(\'registerPickingObject\', this.registerObject, this);\r\n  this.getEvents().on(\'unregisterPickingObject\', this.unregisterObject, this);\r\n\r\n  this.resize();\r\n};\r\n\r\n/**\r\n * Called when a verold object is destroyed or this component is removed\r\n * from a verold object.\r\n */\r\nObjectPicker.prototype.shutdown = function() {\r\n  // make sure to clean up any events or other bindings that you have created\r\n  // to avoid memory leaks\r\n  this.uninitPickingEvents();\r\n\r\n  this.getEngine().off( \'resize\', this.resize, this );\r\n  this.getEvents().off(\'registerPickingObject\', this.registerObject, this);\r\n  this.getEvents().off(\'unregisterPickingObject\', this.unregisterObject, this);\r\n\r\n  var parentAsset = this.getEntity().getParentAsset();\r\n  parentAsset.off( "meshLoaded", this.registerMesh, this );\r\n  parentAsset.off( "meshUnloaded", this.unregisterMesh, this );\r\n  if ( this.pickingTexture ) {\r\n    this.pickingTexture.dispose();\r\n    this.pickingTexture = undefined;\r\n  }\r\n  for ( var x in this.meshRegistry ) {\r\n    if ( this.meshRegistry[x].pickingMaterial ) {\r\n      this.meshRegistry[x].pickingMaterial.dispose();\r\n    }\r\n  }\r\n  this.meshRegistry = {};\r\n  this.meshList = [];\r\n};\r\n\r\nObjectPicker.prototype.initPickingEvents = function() {\r\n  if ( this.pickTrigger.substr(-2) === "Up" ) {\r\n    if ( VAPI.isMobile() ) {\r\n      this.getEngine().on( "touchEnd", this.touchPick, this );\r\n    }\r\n    else {\r\n      this.getEngine().on( "mouseUp", this.pick, this );\r\n    }\r\n  }\r\n  else if ( this.pickTrigger.substr(-4) === "Down" ) {\r\n    if ( VAPI.isMobile() ) {\r\n      this.getEngine().on( "touchStart", this.touchPick, this );\r\n    }\r\n    else {\r\n      this.getEngine().on( "mouseDown", this.pick, this );\r\n    }\r\n  }\r\n  else if ( this.pickTrigger.substr(-5) === "Click" ) {\r\n    if ( VAPI.isMobile() ) {\r\n      this.getEngine().on( "touchEnd", this.touchPickNoDrag, this );\r\n    }\r\n    else {\r\n      this.getEngine().on( "mouseUp", this.pickNoDrag, this );\r\n    }\r\n  }\r\n\r\n  if ( this.enableHoverByDefault && !VAPI.isMobile() ) {\r\n    this.enableHover();\r\n  }\r\n};\r\n\r\nObjectPicker.prototype.uninitPickingEvents = function() {\r\n  if ( this.pickTrigger.substr(-2) === "Up" ) {\r\n    if ( VAPI.isMobile() ) {\r\n      this.getEngine().off( "touchEnd", this.touchPick, this );\r\n    }\r\n    else {\r\n      this.getEngine().off( "mouseUp", this.pick, this );\r\n    }\r\n  }\r\n  else {\r\n    if ( VAPI.isMobile() ) {\r\n      this.getEngine().off( "touchStart", this.touchPick, this );\r\n    }\r\n    else {\r\n      this.getEngine().off( "mouseDown", this.pick, this );\r\n    }\r\n  }\r\n\r\n  if ( this.enableHoverByDefault && !VAPI.isMobile() ) {\r\n    this.getEngine().off( "postRender", this.hoverUpdate, this );\r\n  }\r\n};\r\n\r\nObjectPicker.prototype.initPickingMaterial = function() {\r\n  this.pickingMaterialDef = {\r\n\r\n    depthTest: true,\r\n    depthWrite: true,\r\n    transparent: false,\r\n    side: THREE.DoubleSide,\r\n\r\n    uniforms: {\r\n      color: { type: "c", value: 0xff0000 },\r\n    },\r\n\r\n    vertexShader: [\r\n      THREE.ShaderChunk[ "skinning_pars_vertex" ],\r\n      THREE.ShaderChunk[ \'logdepthbuf_pars_vertex\'],\r\n\r\n      "void main() {",\r\n        THREE.ShaderChunk[ "skinbase_vertex" ],\r\n        THREE.ShaderChunk[ "skinnormal_vertex" ],\r\n        THREE.ShaderChunk[ "defaultnormal_vertex" ],\r\n        THREE.ShaderChunk[ "skinning_vertex" ],\r\n        THREE.ShaderChunk[ "default_vertex" ],\r\n        THREE.ShaderChunk[ \'logdepthbuf_vertex\'],\r\n        \r\n      "}"\r\n\r\n    ].join("\\n"),\r\n\r\n    fragmentShader: [\r\n      "uniform vec3 color;",\r\n      THREE.ShaderChunk[ \'logdepthbuf_pars_fragment\'],\r\n\r\n      "void main() {",\r\n        THREE.ShaderChunk[ \'logdepthbuf_fragment\'],\r\n        "gl_FragColor = vec4( color, 1.0 );",\r\n      "}"\r\n\r\n    ].join("\\n")\r\n\r\n  };\r\n};\r\n\r\nObjectPicker.prototype.initMeshRegistry = function() {\r\n  var parentAsset = this.getEntity().getParentAsset();\r\n  parentAsset.on( "meshLoaded", this.registerMesh, this );\r\n  parentAsset.on( "meshUnloaded", this.unregisterMesh, this );\r\n\r\n  var that = this;\r\n  parentAsset.traverse( function( obj ) {\r\n    if ( obj.type === "mesh" || obj.type === "skinned_mesh") {\r\n      that.registerMesh( obj );\r\n    }\r\n  });\r\n};\r\n\r\nObjectPicker.prototype.enableHover = function( ) {\r\n  if ( !this.hoverEnabled && !VAPI.isMobile() ) {\r\n    this.getEngine().on( "postRender", this.hoverUpdate, this );\r\n    this.hoverEnabled = true;\r\n  }\r\n}\r\n\r\n/**\r\n* reset the size of the texture used to test against geometry picking parameters\r\n* @method resize\r\n*/\r\nObjectPicker.prototype.resize = function() {\r\n  var oldPickingTexture = this.pickingTexture;\r\n  var width = this.getRenderer().getWidth();\r\n  var height = this.getRenderer().getHeight();\r\n  this.pickingTexture = new THREE.WebGLRenderTarget( Math.floor( width / 4.0 ), Math.floor( height / 4.0), {minFilter: THREE.LinearFilter} );\r\n  this.pickingTexture.generateMipmaps = false;\r\n  if ( oldPickingTexture ) {\r\n    oldPickingTexture.dispose();\r\n  }\r\n};\r\n\r\nObjectPicker.prototype.registerObject = function( veroldObject, threeData ) {\r\n  \r\n  if ( !this.meshRegistry[ threeData.id ] ) {\r\n    this.meshRegistry[ threeData.id ] = { \r\n      veroldEntity: veroldObject,\r\n      threeData: threeData,\r\n      prevMaterial : null, \r\n      pickingMaterial: new THREE.ShaderMaterial( this.pickingMaterialDef ),\r\n    };\r\n    //Array for fast iteration\r\n    this.meshList.push( this.meshRegistry[ threeData.id ] );\r\n    this.meshRegistry[ threeData.id ].index = this.meshList.length - 1;\r\n    var material = this.meshRegistry[ threeData.id ].pickingMaterial;\r\n    material.uniforms = THREE.UniformsUtils.clone( this.pickingMaterialDef.uniforms );\r\n    material.uniforms.color.value = new THREE.Color( threeData.id );\r\n\r\n    if ( threeData instanceof THREE.SkinnedMesh ) {\r\n      material.skinning = true;\r\n    }\r\n  }\r\n};\r\n\r\nObjectPicker.prototype.unregisterObject = function( veroldObject, threeData ) {\r\n  if ( threeData ) {\r\n    //remove the enitity data from the pick history, if it\'s there\r\n    this.removeFromHistory( threeData.id);\r\n    //The meshUnloaded event should fire just before the threeData is deleted.\r\n    if ( this.meshRegistry[ threeData.id ] ) {\r\n      this.meshRegistry[ threeData.id ].veroldEntity = null;\r\n      this.meshRegistry[ threeData.id ].pickingMaterial.dispose();\r\n      this.meshList.splice( this.meshRegistry[ threeData.id ].index, 1 );\r\n      delete this.meshRegistry[ threeData.id ];\r\n    }\r\n  }\r\n};\r\n\r\nObjectPicker.prototype.registerMesh = function( veroldMesh ) {\r\n  //When the THREE.Mesh is created, register it so that it can be selected.\r\n  veroldMesh.when("load_base", function( mesh ) {\r\n    this.registerObject( mesh, mesh.threeData );\r\n  }, this );\r\n};\r\n\r\nObjectPicker.prototype.unregisterMesh = function( veroldMesh ) {\r\n  if ( veroldMesh ) {\r\n    this.unregisterObject( veroldMesh.threeData );\r\n  }\r\n};\r\n\r\nObjectPicker.prototype.getThreeObjects = function(objects) {\r\n  var sceneObjects = [];\r\n  _.each(objects, function(object) {\r\n    if ( object && object.threeData ) {\r\n      sceneObjects.push(object.threeData);\r\n    }\r\n  });\r\n\r\n  return sceneObjects;\r\n};\r\n\r\nObjectPicker.prototype.touchPickNoDrag = function(event, callback) {\r\n  //Check drag state\r\n  if ( !this.getInput().touchDragStatePrevious ) {\r\n    this.touchPick( event, callback );\r\n  }\r\n};\r\n\r\nObjectPicker.prototype.touchPick = function(event, callback) {\r\n\r\n  if ( !this.isEnabled() ) {\r\n    return;\r\n  }\r\n  \r\n  // if ( this.getInput().touchPosition.x ) {\r\n    var x = this.getInput().touchPosition.x;\r\n    var y = this.getInput().touchPosition.y;\r\n    \r\n    var mesh = this.pickMesh( x, y );\r\n    if ( mesh ) {\r\n      \r\n      mesh.trigger(\'pick\');\r\n      var parent = mesh.getParentObject();\r\n      while ( parent ) {\r\n        parent.trigger(\'pick\');\r\n        parent = parent.getParentObject();\r\n      }\r\n      if ( _.isFunction( callback ) ) {\r\n        callback( mesh );\r\n      }\r\n    }\r\n  // }\r\n};\r\n\r\nObjectPicker.prototype.pickNoDrag = function(event, callback) {\r\n  //Check drag state\r\n  if ( !this.getInput().mouseDragStatePrevious[ event.button ] ) {\r\n    this.pick( event, callback );\r\n  }\r\n};\r\n\r\nObjectPicker.prototype.pick = function(event, callback) {\r\n  if ( !this.isEnabled() ) {\r\n    return;\r\n  }\r\n  if ( this.pickTrigger.substr(0, 4) === "left" ) {\r\n    if ( event.button !== 0 ) {\r\n      return;\r\n    }\r\n  }\r\n  else if ( this.pickTrigger.substr(0, 4) === "right" ) {\r\n    if ( event.button !== 2 ) {\r\n      return;\r\n    }\r\n  }\r\n  else if ( event.button !== 1 ) {\r\n    return;\r\n  }\r\n  var x = event.clientX;\r\n  var y = event.clientY;\r\n  var mesh = this.pickMesh( x, y );\r\n  if ( mesh ) {\r\n    mesh.trigger(\'pick\');\r\n    var parent = mesh.getParentObject();\r\n    while ( parent ) {\r\n      parent.trigger(\'pick\');\r\n      parent = parent.getParentObject();\r\n    }\r\n    if ( _.isFunction( callback ) ) {\r\n      callback( mesh );\r\n    }\r\n  }\r\n};\r\n\r\nObjectPicker.prototype.hoverUpdate = function( delta ) {\r\n  if ( !this.isEnabled() ) {\r\n    return;\r\n  }\r\n  if ( this.currentFrame < this.hoverFrameSkip ) {\r\n    this.currentFrame++;\r\n    return;\r\n  }\r\n  this.currentFrame = 0;\r\n  var x = this.getInput().mousePosition.x;\r\n  var y = this.getInput().mousePosition.y;\r\n  var parent;\r\n  var mesh = this.pickMesh( x, y );\r\n  if ( mesh !== this.currentHoverObject ) {\r\n    if ( this.currentHoverObject ) {\r\n      \r\n      this.currentHoverObject.trigger("endHover");\r\n      parent = this.currentHoverObject.getParentObject();\r\n      while ( parent ) {\r\n        parent.trigger(\'endHover\');\r\n        parent = parent.getParentObject();\r\n      }\r\n    }\r\n    if ( mesh ) {\r\n      this.currentHoverObject = mesh;\r\n      \r\n      mesh.trigger("beginHover");\r\n      parent = mesh.getParentObject();\r\n      while ( parent ) {\r\n        parent.trigger(\'beginHover\');\r\n        parent = parent.getParentObject();\r\n      }\r\n    }\r\n    else {\r\n      this.currentHoverObject = null;\r\n    }\r\n  }\r\n  \r\n};\r\n\r\nObjectPicker.prototype.pickMesh = function( x, y ) {\r\n\r\n  var that = this;\r\n  var scenes = this.getEngine().assetRegistry.getAssets({\'type\':\'scene\'});\r\n  var i;\r\n  var pickedMesh = null;\r\n  _.each(scenes, function(scene) {\r\n    var cameras = scene.getObjects({\'type\': \'camera\'});\r\n    \r\n    var renderViews = [];\r\n    _.each(cameras, function(camera) {\r\n      var renderViewComponents = camera.getComponentsByScriptId(\'render_view_component\');\r\n      _.each(renderViewComponents, function(renderViewComponent) {\r\n        if(renderViewComponent.isEnabled()) {\r\n          if(renderViews.length > 0) {\r\n            for ( i = 0; i < renderViews.length; i++ ) {\r\n              var renderView = renderViews[i];\r\n              if(renderViewComponent.renderGroup >= renderView.renderGroup) {\r\n                renderViews.splice(i, 0, renderViewComponent);\r\n                break;\r\n              }\r\n            }\r\n          } else {\r\n            renderViews.push(renderViewComponent);\r\n          }\r\n        }\r\n      });\r\n    }, this );\r\n\r\n    for ( i = 0; i < renderViews.length; i++ ) {\r\n      var renderView = renderViews[i];\r\n      var canvas_height = that.getRenderer().getHeight();\r\n      var viewport_offset = canvas_height - renderView._height - renderView._y;\r\n      //Get the percentage x,y positions of the mouse on the viewport\r\n      var mouseX = ((x - renderView._x)/ renderView._width);\r\n      var mouseY = ((y - viewport_offset)/ renderView._height);\r\n\r\n      // pickedMesh = this.doRaycastPick( scene, renderView.veroldEntity, mouseX, mouseY );\r\n      pickedMesh = this.doGPUPick( scene, renderView.veroldEntity, mouseX, mouseY );\r\n      if ( pickedMesh ) {\r\n        return;\r\n      }\r\n\r\n    }\r\n  }, this );\r\n  \r\n  return pickedMesh;\r\n};\r\n\r\nObjectPicker.prototype.doRaycastPick = function( scene, camera, mouseX, mouseY ) {\r\n  var x = mouseX * 2 - 1;\r\n  var y = -mouseY * 2 + 1;\r\n\r\n  var vector = new THREE.Vector3(x, y, 0.5);\r\n\r\n  vector.unproject(camera.threeData);\r\n\r\n  var raycaster = new THREE.Raycaster( camera.threeData.position, vector.sub( camera.threeData.position ).normalize() );\r\n\r\n  var sceneObjects = this.getThreeObjects(scene.getObjects());\r\n  var intersections = raycaster.intersectObjects( sceneObjects, false );\r\n\r\n  if(intersections.length > 0) {\r\n    for ( var i = 0; i < intersections.length; i++ ) {\r\n      var parent = intersections[i].object.parent;\r\n      var entityId = intersections[i].object.veroldEntityId;\r\n      var isVisible = true;\r\n      if ( !intersections[i].object.visible ) {\r\n        isVisible = false;\r\n        continue;\r\n      }\r\n      while(parent) {\r\n        \r\n        if ( !parent.visible ) {\r\n          isVisible = false;\r\n          break;\r\n        }\r\n        \r\n        parent = parent.parent;\r\n      }\r\n\r\n      if ( isVisible ) {\r\n        return this.getEngine().getEntityById( entityId );\r\n        // this.getEngine().getEntityById(entityId).trigger(\'pick\');\r\n        // parent = intersections[i].object.parent;\r\n        // while(parent) {\r\n        //   entityId = parent.veroldEntityId;\r\n        //   this.getEngine().getEntityById(entityId).trigger(\'pick\');\r\n        //   parent = parent.parent;\r\n        // }\r\n        // return 1;\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\nObjectPicker.prototype.doGPUPick = function( scene, camera, mouseX, mouseY ) {\r\n  \r\n  if ( mouseX < 0.0 || mouseY < 0.0 || mouseX > 1.0 || mouseY > 1.0 ) {\r\n    return null;\r\n  }\r\n\r\n  var i = 0;\r\n  var material;\r\n  for ( i = 0; i < this.meshList.length; i++ ) {\r\n    if ( this.meshList[ i ].threeData ) {\r\n      material = this.meshList[ i ].threeData.material;\r\n      this.meshList[ i ].prevMaterial = material;\r\n      this.meshList[ i ].threeData.material = this.meshList[ i ].pickingMaterial;\r\n    }\r\n  }\r\n  var renderer = this.getThreeRenderer();\r\n  var currentShadowMapEnabled = renderer.shadowMapEnabled;\r\n  renderer.shadowMapEnabled = false;\r\n  // renderer.enableScissorTest( true );\r\n  renderer.setViewport( 0, 0, this.pickingTexture.width, this.pickingTexture.height );\r\n  // renderer.setScissor( mouseX * this.pickingTexture.width - 25, this.pickingTexture.height * ( 1.0 - mouseY) - 25, 50, 50 );\r\n  //render the picking scene off-screen\r\n  var gl = renderer.getContext();\r\n  renderer.render( scene.threeData, camera.threeData, this.pickingTexture, true );\r\n  \r\n  //Return materials to their previous state\r\n  for ( i = 0; i < this.meshList.length; i++ ) {\r\n    if ( this.meshList[ i ].threeData ) {\r\n      this.meshList[ i ].threeData.material = this.meshList[ i ].prevMaterial;\r\n    }\r\n  }\r\n\r\n  var pixelBuffer = new Uint8Array(4);\r\n  //read the pixel under the mouse from the texture\r\n  gl.readPixels( mouseX * this.pickingTexture.width, this.pickingTexture.height * ( 1.0 - mouseY), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer);\r\n  \r\n  //interpret the pixel as an ID\r\n  var id = (pixelBuffer[0] << 16) | (pixelBuffer[1] << 8) | (pixelBuffer[2]);\r\n  \r\n  renderer.shadowMapEnabled = currentShadowMapEnabled;\r\n  // renderer.enableScissorTest( false );\r\n  renderer.setRenderTarget( null );\r\n\r\n  if ( this.meshRegistry[ id ] ) {\r\n    var entityId = this.meshRegistry[ id ].veroldEntity.id;\r\n    return this.getEngine().getEntityById( entityId );\r\n    // var parent = this.meshRegistry[ id ].threeData.parent;\r\n    // this.getEngine().getEntityById(entityId).trigger(\'pick\');\r\n    // while(parent) {\r\n    //   entityId = parent.veroldEntityId;\r\n    //   this.getEngine().getEntityById(entityId).trigger(\'pick\');\r\n    //   parent = parent.parent;\r\n    // }\r\n  }\r\n  return null;\r\n};\r\n\r\nreturn ObjectPicker;\r\n';});


define('text!VeroldEngine/Components/BuiltIn/Curve.js',[],function () { return 'var _ = require( \'underscore\' );\n\n/**\n * A custom component class.\n *\n * @class Curve\n */\nfunction Curve() {\n  this.isEditor = false;\n  this.controlPoints = undefined;\n  this.prevControlPointsLength = 0;\n  this.closed = false;\n  \n  //Editor\n  this.cameraPosition = new THREE.Vector3();\n  this.tempPosition = new THREE.Vector3();\n  this.tempVector = new THREE.Vector3();\n  this.tempVector4 = new THREE.Vector4();\n  this.tempMatrix = new THREE.Matrix4();\n  this.editorCurveColour = 0x222222;\n  this.editorCurveSelectedColour = 0x0d56a6;\n  this.orientationHelpers = [];\n  this.canTryUpdateAgain = true;\n\n  this.curveMaterial = undefined;\n  this.curveGeometry = undefined;\n  this.curveMesh = undefined;\n  this.curveTesselation = 200;\n  this.selected = false;\n  this.updateStarted = false;\n\n}\n\nCurve.prototype = new VAPI.VeroldComponent();\n\nCurve.prototype.init = function() {\n  this.initCurve();\n};\n\nCurve.prototype.shutdown = function( ) {\n};\n\nCurve.prototype.onSelected = function( ) {\n  this.selected = true;\n  if ( this.curveMaterial ) {\n    this.curveMaterial.color.setHex( this.editorCurveSelectedColour );\n  }\n  function show( obj ) {\n    obj.visible = true;\n  }\n  for ( var i = 0; i < this.orientationHelpers.length; i++ ) {\n    this.orientationHelpers[i].traverse( show );\n  }\n};\n\nCurve.prototype.onUnselected = function( ) {\n  this.selected = false;\n  if ( this.curveMaterial ) {\n    this.curveMaterial.color.setHex( this.editorCurveColour );\n  }\n  function hide( obj ) {\n    obj.visible = false;\n  }\n  for ( var i = 0; i < this.orientationHelpers.length; i++ ) {\n    this.orientationHelpers[i].traverse( hide );\n  }\n};\n\nCurve.prototype.initCurve = function() {\n  if ( !this.updateStarted && this.controlPoints && this.controlPoints.length ) {\n    \n    this.updateStarted = true;\n\n    this.cleanupCurveMesh();\n    this.cleanupOrientationHelpers();\n\n    this.prevControlPointsLength = this.controlPoints.length;\n\n    this.createCurve();\n    \n  }\n};\n\nCurve.prototype.isCurveInit = function() {\n  return this.curve.points.length > 0;\n};\n\nCurve.prototype.createCurve = function() {\n  for ( var i in this.controlPoints ) {\n    if ( this.controlPoints[ i ] ) {\n      this.controlPoints[ i ].entityModel.off(\'change:payload.position\', this.updateCurve, this );\n    }\n  }\n\n  if ( this.closed ) {\n    this.curve = new THREE.ClosedSplineCurve3();\n  }\n  else {\n    this.curve = new THREE.SplineCurve3();\n  }\n\n  // this.curve.points.push( this.getEntity().getPosition() );\n  \n  var that = this;\n  var scene = this.getEntity().getParentAsset();\n  scene.when( \'load_hierarchy\', function( scene ) {\n    scene.threeData.updateMatrixWorld( true );\n    _.each( that.controlPoints, function( point ) {\n      if ( point ) {\n        // this.tempVector.copy( point.threeData.position );\n        // this.tempVector.applyMatrix4( point.threeData.matrixWorld );\n        // this.tempVector.setFromMatrixPosition( point.threeData.matrixWorld );\n        var newPos = new THREE.Vector3();\n        // newPos.copy( this.tempVector );\n        this.curve.points.push( newPos );\n        this.tempMatrix.makeRotationFromQuaternion( point.threeData.quaternion );\n        var matArray = this.tempMatrix.toArray();\n        this.tempVector.set( matArray[0], matArray[1], matArray[2] );\n        this.orientationHelpers.push( new THREE.ArrowHelper( this.tempVector, newPos, 1, 0xff0000 ) );\n        this.tempVector.set( matArray[4], matArray[5], matArray[6] );\n        this.orientationHelpers.push( new THREE.ArrowHelper( this.tempVector, newPos, 1, 0x00ff00 ) );\n        this.tempVector.set( matArray[8], matArray[9], matArray[10] );\n        this.orientationHelpers.push( new THREE.ArrowHelper( this.tempVector, newPos, 1, 0x0000ff ) );\n          \n        point.entityModel.on(\'change:payload.position\', that.updateCurve, that );\n        point.entityModel.on(\'change:payload.orientation\', that.updateOrientationHelpers, that );\n      }\n      else {\n        this.tempVector.set(0,0,0);\n        this.orientationHelpers.push( new THREE.ArrowHelper( this.tempVector, this.tempVector, 1, 0xff0000 ) );\n        this.orientationHelpers.push( new THREE.ArrowHelper( this.tempVector, this.tempVector, 1, 0xff0000 ) );\n        this.orientationHelpers.push( new THREE.ArrowHelper( this.tempVector, this.tempVector, 1, 0xff0000 ) );\n      }\n      \n    }, that );\n\n    that.updateCurve();\n\n    that.updateStarted = false;\n    if ( !this.selected ) {\n      this.onUnselected();\n    }\n    that.trigger(\'curveInit\');\n    \n  }, this );\n};\n\nCurve.prototype.updateCurve = function() {\n  \n  var helperIndex = 0;\n  var index = 0;\n  var that = this;\n\n  _.each( this.controlPoints, function( point ) {\n    if ( point ) {\n      if ( point.threeData.parent ) {\n        point.getPosition( this.tempVector );\n        this.tempVector4.set( this.tempVector.x, this.tempVector.y, this.tempVector.z, 1.0 );\n        this.tempVector4.applyMatrix4( point.threeData.parent.matrixWorld );\n        this.curve.points[ index ].set( this.tempVector4.x, this.tempVector4.y, this.tempVector4.z );\n        \n        index++;\n      }\n      else if ( this.canTryUpdateAgain ) {\n        this.canTryUpdateAgain = false;\n        setTimeout( function() {\n          console.log("Trying again");\n          that.updateCurve();\n        }, 10 );\n      }\n    }\n    \n  }, this );\n  \n  if ( this.isEditor ) {\n    this.cleanupCurveMesh();\n    this.createCurveMesh();\n  }\n    \n  this.canTryUpdateAgain = true;\n};\n\nCurve.prototype.cleanupCurveMaterial = function() {\n  if ( this.curveMaterial ) {\n    this.curveMaterial.dispose();\n    this.curveMaterial = undefined;\n  }\n};\n\nCurve.prototype.cleanupOrientationHelpers = function() {\n  var i = 0;\n  for ( i in this.controlPoints ) {\n    if ( this.controlPoints[ i ] ) {\n      this.controlPoints[ i ].entityModel.off(\'change:payload.orientation\', this.updateOrientationHelpers, this );\n    }\n  }\n  for ( var i in this.orientationHelpers ) {\n    this.getThreeScene().remove( this.orientationHelpers[i] );\n  }\n  this.orientationHelpers = [];\n};\n\nCurve.prototype.cleanupCurveMesh = function() {\n  \n  if ( this.isEditor && this.curveMesh ) {\n    this.getEngine().globalEvents.trigger( "studioApp::unregisterPickingObject", this.getEntity(), this.curveMesh );\n    this.getThreeScene().remove( this.curveMesh );\n    this.curveGeometry.dispose();\n    this.curveMesh.material = undefined;\n  }\n};\n\nCurve.prototype.createCurveMesh = function() {\n  if ( !this.curveMaterial ) {\n    this.curveMaterial = new THREE.MeshBasicMaterial( { color: this.editorCurveColour, transparent: true, opacity: 0.75, blending: THREE.AdditiveBlending } );\n  }\n  if ( this.curve.points.length ) {\n    //this.curveGeometry = new THREE.Geometry();\n    this.curveGeometry = new THREE.TubeGeometry( this.curve, this.curveTesselation, 0.05, 8, this.closed );\n    //this.curveGeometry.vertices = this.curve.getPoints( this.curveTesselation );\n    this.curveMesh = new THREE.Mesh( this.curveGeometry, this.curveMaterial );\n\n    this.getScene().once( \'load_base\', function() {\n      this.getThreeScene().add( this.curveMesh );\n      _.each( this.orientationHelpers, function( helper ) {\n        this.getThreeScene().add( helper );\n      }, this );\n    }, this );\n\n    this.getScene().once( \'load\', function() {\n      this.getEngine().globalEvents.trigger( "studioApp::registerPickingObject", this.getEntity(), this.curveMesh );\n      VAPI.globalEvents.on( "studioApp::toggleEditorVisualization", this.toggleVisualization, this );\n    }, this );\n    \n    this.getScene().load();\n\n    this.updateOrientationHelpers();\n  }\n};\n\n\n//Update arrow helpers when a control point\'s orientation changes\nCurve.prototype.updateOrientationHelpers = function( ) {\n  for ( var i in this.controlPoints ) {\n    if ( this.controlPoints[i] ) {\n      var obj = this.controlPoints[i].threeData;\n\n      this.orientationHelpers[ i * 3 ].position.copy( this.curve.points[i] );\n      this.orientationHelpers[ i * 3 + 1 ].position.copy( this.curve.points[i] );\n      this.orientationHelpers[ i * 3 + 2 ].position.copy( this.curve.points[i] );\n      this.tempMatrix.makeRotationFromQuaternion( obj.quaternion );\n      var matArray = this.tempMatrix.toArray();\n      this.tempVector.set( matArray[0], matArray[1], matArray[2] );\n      this.orientationHelpers[ i * 3 ].setDirection( this.tempVector );\n      this.tempVector.set( matArray[4], matArray[5], matArray[6] );\n      this.orientationHelpers[ i * 3 + 1 ].setDirection( this.tempVector );\n      this.tempVector.set( matArray[8], matArray[9], matArray[10] );\n      this.orientationHelpers[ i * 3 + 2 ].setDirection( this.tempVector );\n    }\n  }\n};\n\nCurve.prototype.attributesChanged = function( changes ) {\n  this.initCurve();\n};\n\nCurve.prototype.editorInit = function() {\n  this.isEditor = true;\n  this.init();\n\n  this.getEngine().on( "update", this.editorUpdate, this );\n  this.getEngine().on( "mouseUp", this.onMouseUp, this );\n  this.getEntity().on( "editorSelected", this.onSelected, this );\n  this.getEntity().on( "editorUnselected", this.onUnselected, this );\n  \n  var that = this;\n  this.getEngine().globalEvents.trigger(\'studioApp::getCurrentCamera\', function( camera ) {\n    if ( camera ) {\n      camera.once( \'load_base\', function() {\n        that.editorCamera = camera.threeData;\n      }, that );\n      camera.load_base();\n    }\n  });\n\n  this.getEntity().entityModel.on(\'change:payload.position\', that.initCurve, this );\n  this.getEntity().entityModel.on(\'change:payload.orientation\', that.initCurve, this );\n  this.getEntity().entityModel.on(\'change:payload.scale\', that.initCurve, this );\n};\n\nCurve.prototype.editorShutdown = function() {\n  this.getEngine().off( "update", this.editorUpdate, this );\n  this.getEngine().off( "mouseUp", this.onMouseUp, this );\n  this.getEntity().off( "editorSelected", this.onSelected, this );\n  this.getEntity().off( "editorUnselected", this.onUnselected, this );\n  this.getEntity().entityModel.off(\'change:payload.position\', this.initCurve, this );\n  this.getEntity().entityModel.off(\'change:payload.orientation\', this.initCurve, this );\n  this.getEntity().entityModel.off(\'change:payload.scale\', this.initCurve, this );\n  VAPI.globalEvents.off( "studioApp::toggleEditorVisualization", this.toggleVisualization, this );\n  \n  this.cleanupCurveMesh();\n  this.cleanupOrientationHelpers();\n  this.cleanupCurveMaterial();\n};\n\nCurve.prototype.editorUpdate = function( delta ) {\n  if ( this.editorCamera ) {\n    this.cameraPosition.setFromMatrixPosition( this.editorCamera.matrixWorld );\n    var scale = 1.0;\n    for ( var i = 0; i < this.orientationHelpers.length; i++ ) {\n      this.tempPosition.setFromMatrixPosition( this.orientationHelpers[ i ].matrixWorld );\n      scale = this.tempPosition.distanceTo( this.cameraPosition ) / 12;\n      this.orientationHelpers[ i ].scale.set( scale, scale, scale );\n    }\n  }\n};\n\nCurve.prototype.toggleVisualization = function() {\n  var that = this;\n  this.curveMesh.visible = !this.curveMesh.visible;\n  \n  function toggle( obj ) {\n    obj.visible = that.selected && !obj.visible;\n  }\n  for ( var i = 0; i < this.orientationHelpers.length; i++ ) {\n    this.orientationHelpers[i].traverse( toggle );\n  }\n};\n\n\nreturn Curve;';});


define('text!VeroldEngine/Components/BuiltIn/ShotManager.js',[],function () { return '/* global VAPI */\nfunction ShotPreview() {\n  this.cameraName = "";\n  this.name = "";\n  this.description = "";\n  //this.links = [];\n  this.imageData = "";\n}\n/**\n * A custom component class.\n *\n * @class ShotManager\n */\nfunction ShotManager() {\n\n  this.cameras = [];\n  this.renderTargets = [];\n  this.playing = false;\n  this.currentTime = 0.0;\n  this.fadeStarted = false;\n\n  this.tempVector1 = new THREE.Vector3();\n  this.tempVector2 = new THREE.Vector3();\n  this.tempVector3 = new THREE.Vector3();\n  this.tempMatrix = new THREE.Matrix4();\n\n  this.shotPreviewData = [];\n  this.inEditor = false;\n}\n\nShotManager.prototype = new VAPI.VeroldComponent();\n\n\nShotManager.prototype.init = function() {\n  if ( this.isEnabled() ) {\n    VAPI.globalEvents.on( "shotManager::play", this.playShot, this );\n    this.getEntity().on( "playShot", this.playShot, this );\n  }\n};\n\nShotManager.prototype.editorInit = function() {\n  if ( this.isEnabled() ) {\n    if ( this.getScene().isLoaded() ) {\n      this.initShotPreviews();\n    }\n    else {\n      this.getScene().once( \'load\', this.initShotPreviews, this );\n    }\n    this.inEditor = true;\n  }\n};\n\n/**\n * Called when a verold object is destroyed or this component is removed\n * from a verold object.\n */\nShotManager.prototype.shutdown = function() {\n  VAPI.globalEvents.off( "shotManager::play", this.playShot, this );\n  this.getEntity().off( "playShot", this.playShot, this );\n};\n\nShotManager.prototype.playShot = function( shotNum ) {\n  if ( this.cameras.length && (!shotNum || shotNum < this.cameras.length )) {\n\n    if ( shotNum === undefined ) {\n      shotNum = 0;\n    }\n\n    var components;\n\n    //Cancel current shot\n    if ( this.currentCamera ) {\n      this.currentCamera.trigger( "endShot" );\n      this.currentCamera.trigger( "disableRenderView", 0.0 );\n      components = this.currentCamera.getComponents();\n      _.each( components, function( comp ) {\n        comp.disable();\n      }, this );\n    }\n\n    this.currentCamera = this.cameras[ shotNum ].cameraObject;\n\n    if ( this.currentCamera ) {\n\n      //Start new shot\n      this.currentTime = 0.0;\n      this.fadeStarted = false;\n      components = this.currentCamera.getComponents();\n      _.each( components, function( comp ) {\n        if ( comp.getProperty(\'enabled\') ) {\n          comp.enable();\n        }\n      }, this );\n\n      this.currentCamera.trigger( "enableRenderView", this.fadeIn );\n      this.currentCamera.trigger( "beginShot" );\n    }\n  }\n};\n\nShotManager.prototype.sceneLoaded = function( ) {\n  if ( this.isEnabled() ) {\n    this.initShotPreviews();\n    //Disable all render views to begin with\n    _.each( this.cameras, function( camera ) {\n      if ( camera.cameraObject ) {\n        camera.cameraObject.trigger( "disableRenderView", 0.0 );\n        var components = camera.cameraObject.getComponents();\n        _.each( components, function( comp ) {\n          comp.disable();\n        }, this );\n      }\n    }, this );\n\n    if ( this.cameras.length > 0 ) {\n      parent.postMessage({command: \'shotManagerEnabled\', params: this.shotPreviewData }, \'*\');\n    }\n  }\n};\n\nShotManager.prototype.initShotPreviews = function() {\n  this.previewWidth = Math.round( this.getRenderer().getWidth() * 0.2 );\n  this.previewHeight = Math.round( 2 / 3 * this.previewWidth ); //Locked at 3:2 for now\n  // if ( this.cameras.length && this.shotPreviewData.length !== this.cameras.length ) {\n  //   this.shotPreviewData = new Array( this.cameras.length );\n  //   this.renderTargets = new Array( this.cameras.length );\n  // }\n  for ( var i = 0; i < this.cameras.length; i++ ) {\n    // if ( this.cameras[i] ) {\n      this.createShotData( i );\n    // }\n  }\n\n  if(this.inEditor) {\n    VAPI.globalEvents.trigger(\'shotManager::shotPreviews\', this.shotPreviewData);\n  }\n};\n\nShotManager.prototype.createShotData = function( num ) {\n  if ( this.cameras[ num ] ) {\n    var renderTarget = new THREE.WebGLRenderTarget( this.previewWidth, this.previewHeight, { format: THREE.RGBAFormat, minFilter: THREE.LinearFilter } );\n    renderTarget.generateMipmaps = false;\n    renderTarget.name = "Shot # " + num + " Preview";\n    // this.renderTargets.splice( num, 0, [renderTarget] );\n    // this.shotPreviewData.splice( num, 0, [new ShotPreview()] );\n    this.renderTargets.push( renderTarget );\n    this.shotPreviewData.push( new ShotPreview() );\n    this.renderShotPreview( num );\n  }\n  else {\n    this.renderTargets.push( null );\n    this.shotPreviewData.push( null );\n  }\n};\n\n// ShotManager.prototype.destroyShotData = function( num ) {\n//   if ( this.renderTargets[ num ] ) {\n//     this.renderTargets[ num ].dispose();\n//     this.renderTargets.splice( num, 1 );\n//     this.shotPreviewData.splice( num, 1 );\n//   }\n// };\nShotManager.prototype.cleanupShotData = function() {\n  for ( var i = 0; i < this.renderTargets.length; i++ ) {\n    if ( this.renderTargets[ i ] ) {\n      this.renderTargets[ i ].dispose();\n    }\n  }\n  this.renderTargets = [];\n  this.shotPreviewData = [];\n};\n\nShotManager.prototype.renderShotPreview = function( num ) {\n  if ( this.isEnabled() && this.cameras[ num ] && this.cameras[ num ].cameraObject.threeData && this.renderTargets[ num ] ) {\n    var oldAspect = this.cameras[ num ].cameraObject.threeData.aspect;\n    this.cameras[ num ].cameraObject.threeData.aspect = 3 / 2;\n    this.cameras[ num ].cameraObject.threeData.updateProjectionMatrix();\n\n    this.getThreeRenderer().setRenderTarget( this.renderTargets[ num ] );\n    var cameraObject = this.cameras[ num ].cameraObject;\n    var filters = cameraObject.getComponentByScriptId(\'camera_filters_script\');\n    this.getRenderer().renderView( this.getThreeData(), this.cameras[ num ].cameraObject.threeData, { renderTarget: this.renderTargets[ num ],\n      clearColor: false, //TEMP\n      clearDepth: true,\n      composer: filters ? filters.composer : null,\n      viewPort: { x: 0, y: 0, width: this.previewWidth, height: this.previewHeight }\n    });\n    \n    this.shotPreviewData[ num ].name = VAPI.safeHTML( this.cameras[num].name );\n    this.shotPreviewData[ num ].description = VAPI.safeHTML( this.cameras[num].description );\n  \n    this.shotPreviewData[ num ].cameraName = this.cameras[ num ].cameraObject.getName();\n    this.shotPreviewData[ num ].imageData = this.getDataURIFromFramebuffer( this.renderTargets[ num ], num );\n\n    this.getThreeRenderer().setRenderTarget( null );\n\n    this.cameras[ num ].cameraObject.threeData.aspect = oldAspect;\n    this.cameras[ num ].cameraObject.threeData.updateProjectionMatrix();\n  }\n};\n\nShotManager.prototype.resize = function() {\n  //TODO: Regenerate the textures and thumbnails\n};\n\nShotManager.prototype.attributesChanged = function( changes, prevChanges ) {\n  if ( changes.cameras ) {\n    this.cleanupShotData();\n    var i;\n    for ( i = 0; i < this.cameras.length; i++ ) {\n      this.createShotData( i );\n    }\n\n    if(this.inEditor) {\n      if(changes.cameras[changes.cameras.length - 1]) {\n        VAPI.globalEvents.trigger(\'shotManager::shotPreviews\', this.shotPreviewData);\n      }\n    }\n  }\n};\n\nShotManager.prototype.getDataURIFromFramebuffer = function( texture, index ) {\n  var gl = this.getThreeRenderer().getContext();\n  // Read the contents of the framebuffer\n  var data = new Uint8Array( texture.width * texture.height * 4);\n  gl.readPixels(0, 0, texture.width, texture.height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n  // Create a 2D canvas to store the result\n  var canvas = document.createElement(\'canvas\');\n  canvas.width = texture.width;\n  canvas.height = texture.height;\n  canvas.style.width = texture.width + \'px\';\n  canvas.style.height = texture.height + \'px\';\n  // canvas.clientWidth = canvas.width;\n  // canvas.clientHeight = canvas.height;\n  var context = canvas.getContext(\'2d\');\n\n  // Copy the pixels to a 2D canvas\n  var imageData = context.createImageData( texture.width, texture.height );\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n\n  return canvas.toDataURL();\n};\n\nreturn ShotManager;\n';});


define('text!VeroldEngine/Components/BuiltIn/ObjectAnimator.js',[],function () { return '/* global VAPI */\r\nvar _ = require(\'underscore\');\r\n\r\n/**\r\n * A custom component class.\r\n *\r\n * @class Component\r\n */\r\nfunction ObjectAnimator() {\r\n  this.playingCurveAnimation = false;\r\n  this.curveAnim = undefined;\r\n}\r\n\r\nObjectAnimator.prototype = new VAPI.VeroldComponent();\r\n\r\n/**\r\n * Called immediately after after component creation\r\n */\r\nObjectAnimator.prototype.init = function() {\r\n  this.getEntity().on(\'playAnimateAlongCurve\', this.animateAlongCurve, this);\r\n  this.getEntity().on(\'playAnimateToObject\', this.animateToObject, this);\r\n  this.getEntity().on(\'playAnimateTranslation\', this.animateTranslation, this);\r\n  this.getEntity().on(\'playAnimateRotation\', this.animateRotation, this);\r\n  this.getEntity().on(\'playAnimateScale\', this.animateScale, this);\r\n  this.getEntity().on(\'pauseCurveAnimation\', this.onPauseCurveAnimation, this);\r\n  this.getEntity().on(\'unpauseCurveAnimation\', this.onUnpauseCurveAnimation, this);\r\n  this.getEntity().on(\'stopCurveAnimation\', this.stopCurveAnimation, this);\r\n\r\n  this.on(\'disable\', this.onDisable, this );\r\n};\r\n\r\nObjectAnimator.prototype.shutdown = function() {\r\n  this.getEntity().off(\'playAnimateAlongCurve\', this.animateAlongCurve, this);\r\n  this.getEntity().off(\'playAnimateToObject\', this.animateToObject, this);\r\n  this.getEntity().off(\'playAnimateTranslation\', this.animateTranslation, this);\r\n  this.getEntity().off(\'playAnimateRotation\', this.animateRotation, this);\r\n  this.getEntity().off(\'playAnimateScale\', this.animateScale, this);\r\n  this.getEntity().off(\'pauseCurveAnimation\', this.onPauseCurveAnimation, this);\r\n  this.getEntity().off(\'unpauseCurveAnimation\', this.onUnpauseCurveAnimation, this);\r\n  this.getEntity().off(\'stopCurveAnimation\', this.stopCurveAnimation, this);\r\n\r\n  this.off(\'disable\', this.onDisable, this );\r\n};\r\n\r\nObjectAnimator.prototype.onDisable = function() {\r\n  this.getThreeData().position.copy( this.getEntity().getPosition() );\r\n  this.getThreeData().quaternion.copy( this.getEntity().getQuaternion() );\r\n  this.getThreeData().scale.copy( this.getEntity().getScale() );\r\n};\r\n\r\nObjectAnimator.prototype.stopCurveAnimation = function(){\r\n  this.getEngine().off(\'update\', this.curveAnim, this );\r\n  this.curveAnim = undefined;\r\n  // this.getEntity().trigger("endAnimateAlongCurve"); //DO WE NEED TO CALL END ANIMATE IF IT NEVER REALLY HAPPENS???\r\n};\r\n\r\nObjectAnimator.prototype.animateAlongCurve = function(curveObjectId, animationTime, easeIn, easeOut, orientation, loop) {\r\n\r\n  function curveAnim( delta ) {\r\n    if ( !this.veroldEntity || !this.isEnabled() ) {\r\n      engine.off(\'update\', this.curveAnim, this );\r\n      this.curveAnim = undefined;\r\n      return;\r\n    }\r\n    if(curveComponent && this.playingCurveAnimation) {\r\n      this.getEngine().needsRender = true;\r\n      currentTime += delta;\r\n      var currentTimePercent = currentTime / animationTime;\r\n      if ( currentTimePercent >= 1.0 ) {\r\n        currentTimePercent -= 1.0;\r\n      }\r\n      var easeOutStart = 1 - easeOut;\r\n\r\n      //Ease in\r\n      if (easeIn && currentTimePercent < easeIn ) {\r\n        var easeInProgress = currentTimePercent / easeIn;\r\n        curveProgressPercent += delta * fullSpeed / animationTime * (Math.cos( easeInProgress * Math.PI + Math.PI ) * 0.5 + 0.5);\r\n      }\r\n      //Ease out\r\n      else if (easeOut && currentTimePercent > easeOutStart) {\r\n        var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;\r\n        curveProgressPercent += delta * fullSpeed / animationTime * Math.max( Math.cos( easeOutProgress * Math.PI + Math.PI ) * 0.5 + 0.5, 0.0 );\r\n      }\r\n      //Full speed animation\r\n      else {\r\n        curveProgressPercent += delta * fullSpeed / animationTime;\r\n      }\r\n\r\n      //If the animation is finished\r\n      if (curveProgressPercent >= 1.0 || curveProgressPercent < 0.0) {\r\n        curveProgressPercent %= 1.0;\r\n        currentTime = 0.0;\r\n        if (!loop) {\r\n          curveProgressPercent = 0.99999999;\r\n          this.playingCurveAnimation = false;\r\n\r\n          this.getEngine().off(\'update\', this.curveAnim, this );\r\n          this.curveAnim = undefined;\r\n        }\r\n        this.getEntity().trigger("endAnimateAlongCurve");\r\n      }\r\n\r\n      var curve = curveComponent.curve;\r\n      var curveProgress_NodeRelative = curve.getUtoTmapping( curveProgressPercent );\r\n      threeData.position.copy( curve.getPoint( curveProgress_NodeRelative ) );\r\n\r\n      if ( orientation === "toCurve" ) {\r\n        var tangent = curve.getTangent( curveProgress_NodeRelative );\r\n        tempVector1.set(0,-1,0);\r\n        tempVector2.crossVectors( tangent, tempVector1 );\r\n        tempVector3.crossVectors( tangent, tempVector2 );\r\n        tempVector1.copy( threeData.position );\r\n        tempVector1.add( tangent );\r\n        tempMatrix.lookAt( threeData.position, tempVector1, tempVector3 );\r\n        threeData.quaternion.setFromRotationMatrix( tempMatrix );\r\n\r\n      } else if ( orientation === "toNode" ) {\r\n        var curveSegments;\r\n        if ( curveComponent.closed ) {\r\n          curveSegments = curve.points.length;\r\n        }\r\n        else {\r\n          curveSegments = curve.points.length - 1;\r\n        }\r\n        var prevNode = Math.floor( curveProgress_NodeRelative * curveSegments );\r\n        var nextNode = Math.ceil( curveProgress_NodeRelative * curveSegments ) % curve.points.length;\r\n\r\n        if ( prevNode !== currentPrevNode ) {\r\n          if ( prevNode > 0 ) {\r\n            curveComponent.controlPoints[ prevNode ].getQuaternionInWorldSpace( prevQuaternion );\r\n          }\r\n          else {\r\n            curveComponent.controlPoints[ 0 ].getQuaternionInWorldSpace( prevQuaternion );\r\n          }\r\n        }\r\n        if ( nextNode !== currentNextNode ) {\r\n          if ( nextNode > 0 ) {\r\n            curveComponent.controlPoints[ nextNode ].getQuaternionInWorldSpace( nextQuaternion );\r\n          }\r\n          else {\r\n            curveComponent.controlPoints[ 0 ].getQuaternionInWorldSpace( nextQuaternion );\r\n          }\r\n        }\r\n        var interp = curveProgress_NodeRelative * curveSegments - prevNode;\r\n        threeData.quaternion.copy( prevQuaternion );\r\n        threeData.quaternion.slerp( nextQuaternion, interp );\r\n      }\r\n    }\r\n  }\r\n  var that = this;\r\n  var curveComponent;\r\n  var curveObject;\r\n\r\n  if(curveObjectId) {\r\n    curveObject = this.getEngine().getEntityById(curveObjectId);\r\n    var components = curveObject.getComponentsByScriptId("curve_component");\r\n    curveComponent = components[_.keys(components)[0]];\r\n  }\r\n  if ( !curveComponent ) {\r\n    return;\r\n  }\r\n\r\n  var threeData = this.getThreeData();\r\n  var engine = this.getEngine();\r\n  var currentTime = 0;\r\n  var curveProgressPercent = 0.0;\r\n\r\n  var tempVector1 = new THREE.Vector3();\r\n  var tempVector2 = new THREE.Vector3();\r\n  var tempVector3 = new THREE.Vector3();\r\n  var tempMatrix = new THREE.Matrix4();\r\n  var prevQuaternion = new THREE.Quaternion();\r\n  var nextQuaternion = new THREE.Quaternion();\r\n\r\n  if (easeIn + easeOut > 1.0) {\r\n    console.warn("Ease-In and Ease-Out value can\'t total more than 1.0.");\r\n    easeIn = 0.5;\r\n    easeOut = 0.5;\r\n  }\r\n\r\n  var fullSpeedTime = 1.0 - easeIn - easeOut;\r\n  var fullSpeed = 1.0 / (easeIn / 2 + easeOut / 2 + fullSpeedTime );\r\n\r\n  if ( animationTime > 0) {\r\n    this.playingCurveAnimation = true;\r\n    var currentPrevNode = -1;\r\n    var currentNextNode = -1;\r\n    if ( curveComponent.isCurveInit() ) {\r\n      \r\n      this.curveAnim = curveAnim;\r\n      this.getEngine().on(\'update\', this.curveAnim, this );\r\n\r\n    }\r\n    else {\r\n      curveComponent.on(\'curveInit\', function() {\r\n        this.curveAnim = curveAnim;\r\n        that.getEngine().on(\'update\', this.curveAnim, that );\r\n      }, this );\r\n    }\r\n  }\r\n};\r\n\r\nObjectAnimator.prototype.onPauseCurveAnimation = function() {\r\n  this.playingCurveAnimation = false;\r\n};\r\n\r\nObjectAnimator.prototype.onUnpauseCurveAnimation = function() {\r\n  this.playingCurveAnimation = true;\r\n};\r\n\r\nObjectAnimator.prototype.animateToObject = function(objectId, animationTime, easeIn, easeOut, orientation) {\r\n\r\n  var that = this;\r\n  var engine = this.getEngine();\r\n\r\n  function _animateTo( threeObject ) {\r\n\r\n    var entity_data = that.getThreeData();\r\n    var tempMatrix = new THREE.Matrix4();\r\n    var currTime = 0;\r\n    var curveProgressPercent = 0.0;\r\n\r\n    if (easeIn + easeOut > 1.0) {\r\n      console.warn("Ease-In and Ease-Out value can\'t total more than 1.0.");\r\n      easeIn = 0.5;\r\n      easeOut = 0.5;\r\n    }\r\n\r\n    var fullSpeedTime = 1.0 - easeIn - easeOut;\r\n    var fullSpeed = 1.0 / (easeIn / 2 + easeOut / 2 + fullSpeedTime );\r\n    //var easeInDistance = easeIn * fullSpeed / 2.0;\r\n    //var easeOutDistance = easeOut * fullSpeed / 2.0;\r\n\r\n    var startPos = new THREE.Vector3();\r\n    var startQuat;\r\n    startPos.copy( entity_data.position );\r\n\r\n    var targetPosition = threeObject.position;\r\n    var targetQuaternion = threeObject.quaternion;\r\n\r\n    if ( targetQuaternion && orientation ) {\r\n      startQuat = new THREE.Quaternion();\r\n      startQuat.copy( entity_data.quaternion );\r\n    }\r\n    threeObject.updateMatrixWorld();\r\n    targetPosition.setFromMatrixPosition( threeObject.matrixWorld );\r\n    tempMatrix.extractRotation( threeObject.matrixWorld );\r\n    targetQuaternion.setFromRotationMatrix( tempMatrix );\r\n\r\n    if ( animationTime > 0) {\r\n      that.getEngine().on(\'update\', function objAnim( delta ) {\r\n        if ( !this.veroldEntity || !this.isEnabled() ) {\r\n          engine.off(\'update\', objAnim, this );\r\n          return;\r\n        }\r\n        that.getEngine().needsRender = true;\r\n        currTime += delta;\r\n        var currentTimePercent = currTime/animationTime;\r\n        var easeOutStart = 1 - easeOut;\r\n\r\n        //Ease in\r\n        if (easeIn && currentTimePercent < easeIn) {\r\n          var easeInProgress = currentTimePercent / easeIn;\r\n          curveProgressPercent += delta * fullSpeed / animationTime * (Math.cos( easeInProgress * Math.PI + Math.PI ) * 0.5 + 0.5);\r\n        }\r\n        //Ease out\r\n        else if ( easeOut && currentTimePercent > easeOutStart ) {\r\n          var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;\r\n          curveProgressPercent += delta * fullSpeed / animationTime * Math.max( Math.cos( easeOutProgress * Math.PI + Math.PI ) * 0.5 + 0.5, 0.0 );\r\n        }\r\n        //Full speed animation\r\n        else {\r\n          curveProgressPercent += delta * fullSpeed / animationTime;\r\n        }\r\n        //clamp at 1\r\n        curveProgressPercent = Math.min( curveProgressPercent, 1.0 );\r\n\r\n        if(curveProgressPercent >= 1.0 || curveProgressPercent < 0.0) {\r\n          that.getEngine().off(\'update\', objAnim, that );\r\n          that.getEntity().trigger(\'endAnimateToObject\');\r\n        }\r\n\r\n        entity_data.position.copy( startPos );\r\n        entity_data.position.lerp( targetPosition, curveProgressPercent );\r\n        if ( targetQuaternion && orientation ) {\r\n          entity_data.quaternion.copy( startQuat );\r\n          entity_data.quaternion.slerp( targetQuaternion, curveProgressPercent );\r\n        }\r\n      }, that );\r\n    } else {\r\n      entity_data.position.copy( targetPosition );\r\n      if ( targetQuaternion ) {\r\n        entity_data.quaternion.copy( targetQuaternion );\r\n      }\r\n\r\n      //complete\r\n      that.getEntity().trigger(\'endAnimateToObject\');\r\n    }\r\n  }\r\n\r\n  var object = this.getEngine().getEntityById( objectId );\r\n  if ( object.threeData ) {\r\n    _animateTo( object.threeData );\r\n  }\r\n  else {\r\n    object.once(\'load_base\', function() {\r\n      _animateTo( object.threeData );\r\n    }, this );\r\n    object.load();\r\n  }\r\n};\r\n\r\nObjectAnimator.prototype.animateTranslation = function( animationTime, easeIn, easeOut, velocity, objectUsage ) {\r\n\r\n  var threeData = this.getThreeData();\r\n  threeData.position.copy( this.getEntity().getPosition() );\r\n  threeData.quaternion.copy( this.getEntity().getQuaternion() );\r\n  threeData.scale.copy( this.getEntity().getScale() );\r\n\r\n  var currTime = 0;\r\n  var engine = this.getEngine();\r\n\r\n  if (easeIn + easeOut > 1.0) {\r\n    console.warn("Ease-In and Ease-Out value can\'t total more than 1.0.");\r\n    easeIn = 0.5;\r\n    easeOut = 0.5;\r\n  }\r\n\r\n  var easeInTime = animationTime * easeIn;\r\n  // var easeOutTime = animationTime * easeOut;\r\n\r\n  var currentVelocity = new THREE.Vector3();\r\n  var direction = new THREE.Vector3();\r\n  direction.copy( velocity );\r\n  var speed = direction.length();\r\n  threeData.updateMatrixWorld();\r\n  // threeData.updateMatrix();\r\n  direction.applyQuaternion( threeData.quaternion );\r\n  direction.normalize();\r\n\r\n  if ( objectUsage ) {\r\n    var fullSpeedTime = (1.0 - easeIn - easeOut) * animationTime;\r\n    var halfSpeedTime = (easeIn + easeOut) * 0.5 * animationTime;\r\n    //Based on the object usage, set the original position so that the\r\n    //animation plays forward from there...\r\n    if ( objectUsage === "middle" ) {\r\n      //postiion - velocity * time * 0.5\r\n      currentVelocity.copy( velocity );\r\n      currentVelocity.multiplyScalar( -0.5 * ( fullSpeedTime + halfSpeedTime ) );\r\n      threeData.position.add( currentVelocity );\r\n    }\r\n    else if ( objectUsage === "end" ) {\r\n      currentVelocity.copy( velocity );\r\n      currentVelocity.multiplyScalar( -1.0 * ( fullSpeedTime + halfSpeedTime ) );\r\n      threeData.position.add( currentVelocity );\r\n    }\r\n  }\r\n\r\n  if ( animationTime > 0) {\r\n    this.getEngine().on(\'update\', function objAnim( delta ) {\r\n      if ( !this.veroldEntity || !this.isEnabled() ) {\r\n        engine.off(\'update\', objAnim, this );\r\n        return;\r\n      }\r\n      currentVelocity.copy( direction );\r\n\r\n      this.getEngine().needsRender = true;\r\n      currTime += delta;\r\n      var currentTimePercent = Math.min( currTime / animationTime, 1.0 );//clamp to 100%\r\n      var easeOutStart = (1.0 - easeOut);\r\n      var easeOutStartTime = animationTime * easeOutStart;\r\n\r\n      //Ease in\r\n      if (easeIn && currTime < easeInTime ) {\r\n        var easeInProgress = currentTimePercent / easeIn;\r\n        currentVelocity.multiplyScalar( delta * speed * (Math.cos( easeInProgress * Math.PI + Math.PI ) * 0.5 + 0.5) );\r\n      }\r\n      //Ease out\r\n      else if ( easeOut && currTime > easeOutStartTime ) {\r\n        var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;\r\n        currentVelocity.multiplyScalar( delta * speed * Math.max( Math.cos( easeOutProgress * Math.PI + Math.PI ) * 0.5 + 0.5, 0.0 ) );\r\n      }\r\n      //Full speed animation\r\n      else {\r\n        currentVelocity.multiplyScalar( delta * speed );\r\n      }\r\n\r\n      if( currTime >= animationTime ) {\r\n        this.getEngine().off(\'update\', objAnim, this );\r\n        this.getEntity().trigger(\'endAnimateTranslation\');\r\n      }\r\n\r\n      threeData.position.add( currentVelocity );\r\n\r\n    }, this );\r\n  }\r\n\r\n};\r\n\r\nObjectAnimator.prototype.animateRotation = function( animationTime, easeIn, easeOut, velocity, objectUsage, axisOrder ) {\r\n\r\n  var threeData = this.getThreeData();\r\n  threeData.position.copy( this.getEntity().getPosition() );\r\n  threeData.quaternion.copy( this.getEntity().getQuaternion() );\r\n  threeData.scale.copy( this.getEntity().getScale() );\r\n\r\n  var currTime = 0;\r\n  var engine = this.getEngine();\r\n\r\n  if (easeIn + easeOut > 1.0) {\r\n    console.warn("Ease-In and Ease-Out value can\'t total more than 1.0.");\r\n    easeIn = 0.5;\r\n    easeOut = 0.5;\r\n  }\r\n\r\n  var easeInTime = animationTime * easeIn;\r\n  // var easeOutTime = animationTime * easeOut;\r\n  var currentVelocity = new THREE.Quaternion();\r\n  var fullSpeedQuat = new THREE.Quaternion();\r\n\r\n  var tempVector1 = new THREE.Vector3();\r\n  var eulerVelocity = new THREE.Euler( axisOrder );\r\n  eulerVelocity.set( velocity.x, velocity.y, velocity.z );\r\n  //Convert the euler angles to quaternion\r\n  currentVelocity.setFromEuler( eulerVelocity );\r\n  fullSpeedQuat.copy( currentVelocity );\r\n\r\n  threeData.updateMatrixWorld();\r\n\r\n  if ( objectUsage ) {\r\n    var fullSpeedTime = (1.0 - easeIn - easeOut) * animationTime;\r\n    var halfSpeedTime = (easeIn + easeOut) * 0.5 * animationTime;\r\n    //Based on the object usage, set the original rotation so that the\r\n    //animation plays forward from there...\r\n    if ( objectUsage === "middle" ) {\r\n      //postiion - velocity * time * 0.5\r\n      tempVector1.copy( velocity );\r\n      tempVector1.multiplyScalar( -0.5 * ( fullSpeedTime + halfSpeedTime ) );\r\n      eulerVelocity.set( tempVector1.x, tempVector1.y, tempVector1.z );\r\n      currentVelocity.setFromEuler( eulerVelocity );\r\n      threeData.quaternion.multiply( currentVelocity );\r\n    }\r\n    else if ( objectUsage === "end" ) {\r\n      tempVector1.copy( velocity );\r\n      tempVector1.multiplyScalar( -1.0 * ( fullSpeedTime + halfSpeedTime ) );\r\n      eulerVelocity.set( tempVector1.x, tempVector1.y, tempVector1.z );\r\n      currentVelocity.setFromEuler( eulerVelocity );\r\n      threeData.quaternion.multiply( currentVelocity );\r\n    }\r\n  }\r\n\r\n  if ( animationTime > 0) {\r\n    this.getEngine().on(\'update\', function objAnim( delta ) {\r\n      if ( !this.veroldEntity || !this.isEnabled() ) {\r\n        engine.off(\'update\', objAnim, this );\r\n        return;\r\n      }\r\n      var speed = 1.0;\r\n\r\n      this.getEngine().needsRender = true;\r\n      currTime += delta;\r\n      var currentTimePercent = Math.min( currTime / animationTime, 1.0 );\r\n      var easeOutStart = (1.0 - easeOut);\r\n      var easeOutStartTime = animationTime * easeOutStart;\r\n\r\n      //Ease in\r\n      if (easeIn && currTime < easeInTime ) {\r\n        var easeInProgress = currentTimePercent / easeIn;\r\n        speed *= delta * (Math.cos( easeInProgress * Math.PI + Math.PI ) * 0.5 + 0.5);\r\n      }\r\n      //Ease out\r\n      else if ( easeOut && currTime > easeOutStartTime ) {\r\n        var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;\r\n        speed *= delta * Math.max( Math.cos( easeOutProgress * Math.PI + Math.PI ) * 0.5 + 0.5, 0.0 );\r\n      }\r\n      //Full speed animation\r\n      else {\r\n        speed *= delta;\r\n      }\r\n\r\n      if( currTime >= animationTime ) {\r\n        this.getEngine().off(\'update\', objAnim, this );\r\n        this.getEntity().trigger(\'endAnimateTranslation\');\r\n      }\r\n      currentVelocity.set( 0.0, 0.0, 0.0, 1.0 );\r\n      currentVelocity.slerp( fullSpeedQuat, speed );\r\n      threeData.quaternion.multiply( currentVelocity );\r\n\r\n    }, this );\r\n  }\r\n\r\n};\r\n\r\nObjectAnimator.prototype.animateScale = function( animationTime, easeIn, easeOut, velocity, objectUsage ) {\r\n\r\n  var threeData = this.getThreeData();\r\n  threeData.position.copy( this.getEntity().getPosition() );\r\n  threeData.quaternion.copy( this.getEntity().getQuaternion() );\r\n  threeData.scale.copy( this.getEntity().getScale() );\r\n\r\n  var currTime = 0;\r\n  var engine = this.getEngine();\r\n\r\n  if (easeIn + easeOut > 1.0) {\r\n    console.warn("Ease-In and Ease-Out value can\'t total more than 1.0.");\r\n    easeIn = 0.5;\r\n    easeOut = 0.5;\r\n  }\r\n\r\n  var easeInTime = animationTime * easeIn;\r\n  // var easeOutTime = animationTime * easeOut;\r\n\r\n  var currentVelocity = new THREE.Vector3();\r\n  threeData.updateMatrixWorld();\r\n\r\n  if ( objectUsage ) {\r\n    var fullSpeedTime = (1.0 - easeIn - easeOut) * animationTime;\r\n    var halfSpeedTime = (easeIn + easeOut) * 0.5 * animationTime;\r\n    //Based on the object usage, set the original scale so that the\r\n    //animation plays forward from there...\r\n    if ( objectUsage === "middle" ) {\r\n      //postiion - velocity * time * 0.5\r\n      currentVelocity.copy( velocity );\r\n      currentVelocity.multiplyScalar( -0.5 * ( fullSpeedTime + halfSpeedTime ) );\r\n      threeData.scale.add( currentVelocity );\r\n    }\r\n    else if ( objectUsage === "end" ) {\r\n      currentVelocity.copy( velocity );\r\n      currentVelocity.multiplyScalar( -1.0 * ( fullSpeedTime + halfSpeedTime ) );\r\n      threeData.scale.add( currentVelocity );\r\n    }\r\n  }\r\n\r\n  if ( animationTime > 0) {\r\n    this.getEngine().on(\'update\', function objAnim( delta ) {\r\n      if ( !this.veroldEntity || !this.isEnabled() ) {\r\n        engine.off(\'update\', objAnim, this );\r\n        return;\r\n      }\r\n      currentVelocity.copy( velocity );\r\n\r\n      this.getEngine().needsRender = true;\r\n      currTime += delta;\r\n      var currentTimePercent = Math.min( currTime / animationTime, 1.0 );//clamp to 100%\r\n      var easeOutStart = (1.0 - easeOut);\r\n      var easeOutStartTime = animationTime * easeOutStart;\r\n\r\n      //Ease in\r\n      if (easeIn && currTime < easeInTime ) {\r\n        var easeInProgress = currentTimePercent / easeIn;\r\n        currentVelocity.multiplyScalar( delta * (Math.cos( easeInProgress * Math.PI + Math.PI ) * 0.5 + 0.5) );\r\n      }\r\n      //Ease out\r\n      else if ( easeOut && currTime > easeOutStartTime ) {\r\n        var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;\r\n        currentVelocity.multiplyScalar( delta * Math.max( Math.cos( easeOutProgress * Math.PI + Math.PI ) * 0.5 + 0.5, 0.0 ) );\r\n      }\r\n      //Full speed animation\r\n      else {\r\n        currentVelocity.multiplyScalar( delta );\r\n      }\r\n\r\n      if( currTime >= animationTime ) {\r\n        this.getEngine().off(\'update\', objAnim, this );\r\n        this.getEntity().trigger(\'endAnimateTranslation\');\r\n      }\r\n\r\n      threeData.scale.add( currentVelocity );\r\n\r\n    }, this );\r\n  }\r\n\r\n};\r\n\r\nreturn ObjectAnimator;\r\n';});


define('text!VeroldEngine/Components/BuiltIn/Annotation.js',[],function () { return '/*\r\n@vname Annotation\r\n@vdescription A way of putting notes or descriptions into your scenes. Places a pin and tag. Hides when obscured by other objects\r\n@vfilter object\r\n@vcategory Annotation\r\n@vattr string Title { \r\n  default : \'Annotation Title\', \r\n  description : \'Title to display on the annotation tag\' \r\n}\r\n@vattr string Description {\r\n  \'default\' : \'A description for your Annotation\',\r\n  \'description\' : \'The description to display on your tag\'\r\n}\r\n@vattr bool ShowDescription {\r\n  \'default\': false,\r\n  \'description\': \'whether or not we show the description for the tag\'\r\n}\r\n@vattr bool ShowLine {\r\n  \'default\': true,\r\n  \'description\': \'Whether or not we show the line\'\r\n}\r\n@vattr custom Pin {\r\n  \'description\' : \'properties of the pin\',\r\n  \'attributes\' : {\r\n    \'visible\' : { \'type\' : \'b\', \'name\' : \'Visible\', \'description\' : \'If enabled, a pin object exists in the scene\', \'default\' : false },\r\n    \'autoScale\' : { \'type\' : \'b\', \'name\' : \'Visible\', \'description\' : \'If enabled, the pin will scale to always be easily selected\', \'default\' : true },\r\n    \'material\' : { \'type\': \'asset\', \'name\': \'Material\', \'description\': \'The material to color the pin with.\', \'default\': null, \'filter\': { \'material\': true } }\r\n  }\r\n}\r\n@vattr custom Colors {\r\n  \'description\' : \'Use some preset styles created by us, or use your own!\',\r\n  \'attributes\' : {\r\n    \'styles\': {\r\n      \'type\': \'dd\',\r\n      default: 2,\r\n      \'options\': { \'Light 1\': 0, \'Light 2\': 1, \'Dark 1\' : 2, \'Dark 2\' : 3, \'Vibrant 1\' : 4, \'Vibrant 2\' : 5},\r\n      \'description\': \'Pick the style you want the Annotation to use\',\r\n      \'advanced\': false\r\n    },\r\n  }\r\n}\r\n@vevent local showAnnotation {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local showAnnotationPin {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local showAnnotationLine {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local showAnnotationDescription {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local showAnnotationTag {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local hideAnnotation {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local hideAnnotationPin {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local hideAnnotationLine {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local hideAnnotationDescription {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local hideAnnotationTag {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local toggleAnnotation {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local enableAnnotation {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local disableAnnotation {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \'parameters\' : []}\r\n@vevent local changeAnnotationPinMaterial {\'scope\' : \'local\', \'action\':true, \'category\':\'Annotation\', \r\n  \'parameters\' : [\r\n      {\'name\': \'MaterialAsset\', \'type\': \'asset\',\'description\': \'The material to color the pin head with.\',\'default\': null, \'filter\': { \'material\': true } }\r\n    ]\r\n  }\r\n*/\r\n/* global VAPI */\r\nfunction css (el, key, value) {\r\n  // if args length is 3, then el, property, value\r\n  if (!el || !el.style) {\r\n    return;\r\n  }\r\n\r\n  if(typeof key !== \'string\') {\r\n    Object.keys(key).forEach(function(styleKey){\r\n      el.style[styleKey] = key[styleKey]; \r\n    });\r\n  }\r\n  else {\r\n    el.style[key] = value; \r\n  }\r\n}\r\n\r\nfunction addClass(el, className) {\r\n  if (el.classList) {\r\n    el.classList.add(className);\r\n  } else {\r\n    el.className += \' \' + className;\r\n  }\r\n}\r\n\r\nfunction showEl(el, duration) {\r\n  el.style.display = \'\';\r\n}\r\n\r\nfunction hideEl(el, duration) {\r\n  el.style.display = \'none\';\r\n}\r\n\r\nfunction toggleEl(el, duration) {\r\n  el.style.display = el.style.display === \'\' ? \'none\' : \'\';\r\n}\r\n\r\n//filter for use with intersects only!\r\nfunction canHideFilter (obj){\r\n  \r\n  var visible = obj.object.visible;\r\n  //also check material on object\r\n  if(visible) {\r\n    var mat = obj.object.material;\r\n    //check for mesh face material\r\n    if(mat instanceof THREE.MeshFaceMaterial){\r\n      for(var i = 0; i<mat.materials.length; ++i){\r\n        if(mat.materials[i].uniforms && mat.materials[i].uniforms.colorOpacity) {\r\n          visible = mat.materials[i].uniforms.colorOpacity.value > 0.001;\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      if(mat.uniforms && mat.uniforms.colorOpacity) {\r\n        visible = mat.uniforms.colorOpacity.value > 0.001;//this is our zero value clamp\r\n      }\r\n    }\r\n  }\r\n  //if STILL visible must traverse parents to check visibility, as well. :[\r\n  if(visible) {\r\n    obj.object.traverseAncestors(function(parent){\r\n      if(!parent.visible) { \r\n        visible = false;\r\n      }\r\n    });\r\n  }\r\n  return visible;\r\n}\r\n\r\nfunction Annotation() {\r\n  //how many steps we\'ve made before we do a raycast\r\n  this.nRaySteps = 0;\r\n  this.bCreated = false;\r\n  //if an object is in a selected state, do not show the labels!\r\n  this.bObjectSelected = false;\r\n  //used to update attributes\r\n  this.bNeedsUpdate = false;\r\n\r\n  this.pinObject = null;\r\n\r\n  this.camera = null;\r\n  this.tempVec = new THREE.Vector3();\r\n  this.posVec = new THREE.Vector3();\r\n  this.worldPosVec = new THREE.Vector3();\r\n  this.tempMatrix = new THREE.Matrix4();\r\n  //html elements to display\r\n  this.el = null;\r\n  this.desc = null;\r\n  this.title = null;\r\n  this.line = null;\r\n  this.cap = null;\r\n\r\n  this.bgColor = \'#323232\';\r\n\r\n  this.Offset = new THREE.Vector2(0, 0.1);\r\n\r\n  //renderer element reference for percentage based offsets!\r\n  this.renderContainer = null;\r\n\r\n  //for calculating offsets for dragging!\r\n  this.bIsEditor = false;\r\n  this.bDragging = false;\r\n  this.vOffset = null;\r\n  this.vWorldPos = null;\r\n\r\n  this.m_bTagIsVisible = true;\r\n  this.bSceneLoaded = false;//if in editor, this will be true\r\n  this.bCanvasDrag = false;\r\n\r\n  //keep track of these to stop recalculation of styles\r\n  this.offsetWidth = 0;\r\n  this.offsetHeight = 0;\r\n  this.elOffsetWidth = 0;\r\n  this.elOffsetHeight = 0;\r\n  //check to see if lies in camera FOV\r\n  this.isInFOV = true;\r\n  //for css for line\r\n  this.lineCSSObj = null;\r\n  this.elCSSObj = null;\r\n\r\n  this.intersects = [];\r\n\r\n  this.tempWorldPos = new THREE.Vector3();\r\n  this.camForward = new THREE.Vector3();\r\n\r\n  this.DVP = window.devicePixelRatio || 1;\r\n\r\n  this.dragStartX = 0;\r\n  this.dragStartY = 0;\r\n}\r\n\r\nAnnotation.EL_CSS = {\r\n  \'position\': \'absolute\',\r\n  \'left\': 0,\r\n  \'top\': 0,\r\n  \'padding\': \'8px\',\r\n  \'border-radius\': \'5px\',\r\n  \'font-family\': \'proxima_nova_regular,Helvetica,Arial,sans-serif\',\r\n  \'max-width\' : \'25%\',\r\n  \'min-width\' : \'25px\',\r\n  \'transition\': \'opacity 0.1s ease-in-out, background 0.1s ease-in-out\',\r\n  \'cursor\' : \'pointer\',\r\n  \'display\' : \'none\'\r\n};\r\n\r\nAnnotation.TEXT_CSS = {\r\n  \'color\': \'#fff\',\r\n  \'font-family\': \'proxima_nova_regular,Helvetica,Arial,sans-serif\',\r\n  \'word-wrap\':\'break-word\',\r\n  \'-webkit-touch-callout\': \'none\',\r\n  \'-webkit-user-select\': \'none\',\r\n  \'-khtml-user-select\': \'none\',\r\n  \'-moz-user-select\': \'none\',\r\n  \'-ms-user-select\': \'none\',\r\n  \'user-select\': \'none\',\r\n  \'pointer-events\' : \'none\',\r\n  \'line-height\' : \'115%\',\r\n  \'font-size\' : \'1.8vmin\'  //1.8vmax for mobile, 1.8vmin for desktop\r\n};\r\n\r\nAnnotation.LINE_CSS = {\r\n  \'height\' : \'1px\',\r\n  \'position\' : \'absolute\',\r\n  \'border-radius\': \'10px\',\r\n  \'pointer-events\' : \'none\',\r\n  \'transform-origin\': \'0 50%\',\r\n  \'transition\': \'opacity 0.1s ease-in-out\',\r\n  \'border-left-style\' : \'none\',\r\n  \'display\' : \'none\',\r\n  \'-webkit-touch-callout\': \'none\',\r\n  \'-webkit-user-select\': \'none\',\r\n  \'-khtml-user-select\': \'none\',\r\n  \'-moz-user-select\': \'none\',\r\n  \'-ms-user-select\': \'none\',\r\n  \'user-select\': \'none\'\r\n};\r\n\r\nAnnotation.CAP_CSS = {\r\n  \'transform-origin\': \'50% 50%\',\r\n  \'padding\': \'2.5px\',\r\n  \'border-radius\': \'3px\',\r\n  \'pointer-events\' : \'none\',\r\n  \'position\' : \'absolute\',\r\n  \'left\' : \'-2.5px\',\r\n  \'top\' : \'-2.5px\',\r\n  \'-webkit-touch-callout\': \'none\',\r\n  \'-webkit-user-select\': \'none\',\r\n  \'-khtml-user-select\': \'none\',\r\n  \'-moz-user-select\': \'none\',\r\n  \'-ms-user-select\': \'none\',\r\n  \'user-select\': \'none\'\r\n};\r\n\r\nAnnotation.ELLIPSE_CSS = {\r\n  \'position\' : \'absolute\',\r\n  \'right\' : \'10px\',\r\n  \'top\' : \'0px\',\r\n  \'font-size\' : \'18px\',\r\n  \'-webkit-touch-callout\': \'none\',\r\n  \'-webkit-user-select\': \'none\',\r\n  \'-khtml-user-select\': \'none\',\r\n  \'-moz-user-select\': \'none\',\r\n  \'-ms-user-select\': \'none\',\r\n  \'user-select\': \'none\',\r\n  \'pointer-events\' : \'none\'\r\n};\r\n\r\nAnnotation.StylePresets = [\r\n  { \'bg\': \'#111\', \'color\': \'#fff\' },\r\n  { \'bg\': \'rgba(0,0,0,0.6)\', \'color\': \'#fff\' },\r\n  { \'bg\': \'#111\', \'color\': \'#59cfe4\' },\r\n  { \'bg\': \'rgba(0,0,0,0.6)\', \'color\': \'#59cfe4\' },\r\n  { \'bg\': \'#fff\', \'color\': \'#222\' },\r\n  { \'bg\': \'rgba(255,255,255,0.6)\', \'color\': \'#222\' }\r\n];\r\n\r\nAnnotation.prototype = new VAPI.VeroldComponent();\r\n\r\nAnnotation.prototype.css = function (el, key, value) {\r\n  // if args length is 3, then el, property, value\r\n  if (!el || !el.style) {\r\n    return;\r\n  }\r\n\r\n  if(typeof key !== \'string\') {\r\n    for(var styleKey in key){\r\n      el.style[styleKey] = key[styleKey];\r\n    }\r\n  }\r\n  else {\r\n    el.style[key] = value; \r\n  }\r\n};\r\n/************   START EDITOR RELATED THINGS  *******************/\r\nAnnotation.prototype.editorInit = function() {\r\n\r\n  this.bIsEditor = true;\r\n  this.bSceneLoaded = true;\r\n\r\n  if ( this.getThreeData() ) {\r\n    this.objectCreated();\r\n  }\r\n  else {\r\n    this.getEntity().once(\'load_base\', this.objectCreated, this );\r\n  }\r\n\r\n  this.listenTo(this.getEngine(), \'preRenderView\', this.preRenderView.bind(this));\r\n\r\n  //hide and show lables on selection in the studio\r\n  this.listenTo(this.getEngine().globalEvents, \'studioApp::selectObject\', this.hideNote.bind(this, true));\r\n  this.listenTo(this.getEngine().globalEvents, \'studioApp::clearSelection\', this.showNote.bind(this, false));\r\n};\r\n\r\nAnnotation.prototype.editorShutdown = function() {\r\n  this.shutdown();\r\n};\r\n\r\nAnnotation.prototype.editorStartDrag = function(event, ui){\r\n  this.bDragging = true;  \r\n  //firefox needs this to \'init\' the drag event\r\n  event.dataTransfer.setData(\'Text\', this.id);\r\n  this.dragStartX = this.el.offsetLeft - event.pageX;\r\n  this.dragStartY = this.el.offsetTop - event.pageY;\r\n};\r\n\r\n//get offset percentages\r\nAnnotation.prototype.editorDrag = function(event, ui){\r\n\r\nif(!this.bDragging)return;\r\n\r\n  var pageX = event.pageX;\r\n  var pageY = event.pageY;\r\n\r\n  //renderContainer\r\n  var left = this.dragStartX + pageX,\r\n      top = this.dragStartY + pageY;\r\n\r\n  this.Offset.x = (left - this.vWorldPos.x + this.elOffsetWidth*0.5) / this.offsetWidth;\r\n  this.Offset.y = (this.vWorldPos.y - top - this.elOffsetHeight*0.5) / this.offsetHeight;\r\n\r\n};\r\n\r\nAnnotation.prototype.editorEndDrag = function(event, ui) {\r\n  this.bDragging = false;\r\n\r\n  var update = { components : {  } };\r\n  update.components[this.getId()] = { componentData : { } };\r\n  update.components[this.getId()].componentData.Offset = { x : this.Offset.x, y : this.Offset.y };\r\n  \r\n  this.getEntity().set(update, { save : true });\r\n};\r\n/**************** ***********************************************/\r\n\r\n//events in here for the event handler stuff!\r\nAnnotation.prototype.init = function(){\r\n  \r\n  if(window.VAPI && window.VAPI.isMobile()){\r\n    Annotation.TEXT_CSS[\'font-size\'] = \'1.8vmax\';\r\n  }\r\n  //showing\r\n  this.listenTo(this.getEntity(), \'showAnnotation\', this.setAllVis.bind(this, true));\r\n  this.listenTo(this.getEntity(), \'showAnnotationDescription\', this.setDescriptionVis.bind(this, true));\r\n  this.listenTo(this.getEntity(), \'showAnnotationLine\', this.setLineVis.bind(this, true));\r\n  this.listenTo(this.getEntity(), \'showAnnotationPin\', this.setPinVis.bind(this, true));\r\n  this.listenTo(this.getEntity(), \'showAnnotationTag\', this.setTagVis.bind(this, true));\r\n  //hiding\r\n  this.listenTo(this.getEntity(), \'hideAnnotation\', this.setAllVis.bind(this, false));\r\n  this.listenTo(this.getEntity(), \'hideAnnotationDescription\', this.setDescriptionVis.bind(this, false));\r\n  this.listenTo(this.getEntity(), \'hideAnnotationLine\', this.setLineVis.bind(this, false));\r\n  this.listenTo(this.getEntity(), \'hideAnnotationPin\', this.setPinVis.bind(this, false));\r\n  this.listenTo(this.getEntity(), \'hideAnnotationTag\', this.setTagVis.bind(this, false));\r\n  //events to change some stuffs!\r\n  this.listenTo(this.getEntity(), \'changeAnnotationPinMaterial\', this.setPinMaterial.bind(this));\r\n  this.listenTo(this.getEntity(), \'toggleAnnotation\', this.toggleVisibility.bind(this));\r\n  this.listenTo(this.getEntity(), \'enableAnnotation\', this.onEnable.bind(this));\r\n  this.listenTo(this.getEntity(), \'disableAnnotation\', this.onDisable.bind(this));\r\n\r\n  /*  TESTING   */\r\n  this.listenTo(this.getEvents(), \'showAnnotation\', this.setAllVis.bind(this, true));\r\n  this.listenTo(this.getEvents(), \'showAnnotationDescription\', this.setDescriptionVis.bind(this, true));\r\n  this.listenTo(this.getEvents(), \'showAnnotationLine\', this.setLineVis.bind(this, true));\r\n  this.listenTo(this.getEvents(), \'showAnnotationPin\', this.setPinVis.bind(this, true));\r\n  this.listenTo(this.getEvents(), \'showAnnotationTag\', this.setTagVis.bind(this, true));\r\n  //hiding\r\n  this.listenTo(this.getEvents(), \'hideAnnotation\', this.setAllVis.bind(this, false));\r\n  this.listenTo(this.getEvents(), \'hideAnnotationDescription\', this.setDescriptionVis.bind(this, false));\r\n  this.listenTo(this.getEvents(), \'hideAnnotationLine\', this.setLineVis.bind(this, false));\r\n  this.listenTo(this.getEvents(), \'hideAnnotationPin\', this.setPinVis.bind(this, false));\r\n  this.listenTo(this.getEvents(), \'hideAnnotationTag\', this.setTagVis.bind(this, false));\r\n  //events to change some stuffs!\r\n  this.listenTo(this.getEvents(), \'changeAnnotationPinMaterial\', this.setPinMaterial.bind(this));\r\n  this.listenTo(this.getEvents(), \'toggleAnnotation\', this.toggleVisibility.bind(this));\r\n  this.listenTo(this.getEvents(), \'enableAnnotation\', this.onEnable.bind(this));\r\n  this.listenTo(this.getEvents(), \'disableAnnotation\', this.onDisable.bind(this));\r\n};\r\n\r\n/************  events listener functions    *****************/\r\nAnnotation.prototype.setDescriptionVis = function(visible){\r\n  this.ShowDescription = visible;\r\n  this.bNeedsUpdate = true;\r\n};\r\n\r\nAnnotation.prototype.setLineVis = function(visible){\r\n  this.ShowLine = visible;\r\n  this.bNeedsUpdate = true;\r\n};\r\n\r\nAnnotation.prototype.setPinVis = function(visible){\r\n  this.Pin.visible = visible;\r\n  this.bNeedsUpdate = true;\r\n};\r\n\r\nAnnotation.prototype.setTagVis = function(visible){\r\n  this.setLineVis(visible);\r\n  this.setTagVisibility(visible);\r\n  this.bNeedsUpdate = true;\r\n};\r\n\r\nAnnotation.prototype.setAllVis = function(visible){\r\n  this.setTagVis(visible);\r\n  this.setDescriptionVis(visible);\r\n  this.setLineVis(visible);\r\n  this.setPinVis(visible);\r\n};\r\n\r\nAnnotation.prototype.setTagVisibility = function(visible){\r\n  this.m_bTagIsVisible = visible;\r\n  this.bNeedsUpdate = true;\r\n};\r\n\r\nAnnotation.prototype.toggleVisibility = function(){\r\n  this.setAllVis(!this.pinObject.visible);\r\n};\r\n\r\n//triggered from the external events system\r\nAnnotation.prototype.setPinMaterial = function(material){\r\n\r\n  var mat = this.getAssetRegistry().getAssetById(material);\r\n\r\n  if(mat && this.pinObject){\r\n    this.listenToOnce(mat, \'load\', function(){\r\n      this.pinObject.children[0].material = mat.threeData.static;\r\n      this.pinObject.children[1].material = mat.threeData.static;\r\n    }.bind(this));\r\n    mat.load();\r\n  }\r\n};\r\n\r\nAnnotation.prototype.onDisable = function(){\r\n  this.disable();\r\n  this.bNeedsUpdate = true;\r\n};\r\n\r\nAnnotation.prototype.onEnable = function(){\r\n  this.enable();\r\n  this.bNeedsUpdate = true;\r\n};\r\n/****************************************************************/\r\n\r\nAnnotation.prototype.objectCreated = function() {\r\n\r\n  window.setTimeout(this.createPrimPin.bind(this), 500);\r\n\r\n  this.renderContainer = this.getThreeRenderer().domElement.parentElement;\r\n\r\n  this.offsetWidth = this.renderContainer.offsetWidth;\r\n  this.offsetHeight = this.renderContainer.offsetHeight;\r\n\r\n  var zIndex = (this.renderContainer.style[\'z-index\'] << 0) + (this.bIsEditor ? 1 : 0);\r\n\r\n  //creation of elements for storing title and description\r\n  this.el = document.createElement(\'div\');\r\n  addClass(this.el, \'annotation-el\');\r\n  this.css(this.el, Annotation.EL_CSS);\r\n  this.css(this.el, \'z-index\', zIndex);\r\n\r\n  this.title = document.createElement(\'div\');\r\n  addClass(this.title, \'annotation-title\');\r\n  this.css(this.title, Annotation.TEXT_CSS);\r\n  this.css(this.title, \'font-weight\', \'bold\');\r\n  this.css(this.title, \'max-width\', \'200px\');\r\n  this.css(this.title, \'padding\', \'0 10px 0 5px\');\r\n\r\n  this.el.appendChild(this.title);\r\n\r\n  this.desc = document.createElement(\'div\');\r\n  addClass(this.desc, \'annotation-desc\');\r\n  this.css(this.desc, Annotation.TEXT_CSS);\r\n  this.css(this.desc, \'font-weight\', \'normal\');\r\n  this.css(this.desc, \'max-width\', \'250px\');\r\n  this.css(this.desc, \'padding\', \'0 0 0 5px\');\r\n\r\n  this.el.appendChild(this.desc);\r\n\r\n  //the line that draws to the pin, from the box\r\n  this.line = document.createElement(\'div\');\r\n  addClass(this.line, \'annotation-line\');\r\n  this.css(this.line, Annotation.LINE_CSS);\r\n  this.css(this.line, \'z-index\', zIndex);\r\n\r\n  this.renderContainer.appendChild(this.line);\r\n  this.renderContainer.appendChild(this.el);\r\n\r\n  //add cap to line!\r\n  this.cap = document.createElement(\'div\');\r\n  addClass(this.cap, \'annotation-cap\');\r\n  this.css(this.cap, Annotation.CAP_CSS);\r\n  this.css(this.cap, \'z-index\', zIndex);\r\n  this.line.appendChild(this.cap);\r\n\r\n  this.bCreated = true;\r\n  this.bNeedsUpdate = true;\r\n\r\n  //create global annotation raycaster!\r\n  if(!VAPI.AnnotationCaster){\r\n    VAPI.AnnotationCaster = new THREE.Raycaster();\r\n    VAPI.AnnotationCaster.STEPS = 15;\r\n  }\r\n\r\n  this.ellipsis = document.createElement(\'div\');\r\n  addClass(this.ellipsis, \'annotation-ellips\');\r\n  this.ellipsis.innerHTML = \'...\';\r\n  this.css(this.ellipsis, Annotation.ELLIPSE_CSS);\r\n  this.el.appendChild(this.ellipsis);\r\n\r\n\r\n  this.onHoverIn = this.onHoverIn.bind(this);\r\n  this.onHoverOut = this.onHoverOut.bind(this);\r\n\r\n  this.el.addEventListener(\'mouseover\', this.onHoverIn);\r\n  this.el.addEventListener(\'mouseout\', this.onHoverOut);\r\n\r\n  //editor specifics\r\n  if(this.bIsEditor){\r\n    //for calculating smart offsets\r\n    this.vWorldPos = new THREE.Vector2();\r\n    //set drag for\r\n    this.el.draggable = true;\r\n    this.el.addEventListener(\'dragstart\', this.editorStartDrag.bind(this));\r\n    //this.el.addEventListener(\'drag\', this.editorDrag.bind(this));\r\n    this.renderContainer.addEventListener(\'dragover\', this.editorDrag.bind(this));\r\n    this.el.addEventListener(\'dragend\', this.editorEndDrag.bind(this));\r\n\r\n\r\n    this.el.addEventListener(\'click\', this.onEditorPinClick.bind(this));\r\n  }\r\n  else {\r\n    this.el.addEventListener(\'click\', this.onTagClick.bind(this));\r\n  }\r\n\r\n  //disable mouse events when scrolling(zooming in/out)\r\n  this.el.addEventListener(\'wheel\', function() {\r\n    this.css(this.el, \'pointer-events\', \'none\');\r\n  }.bind(this));\r\n\r\n  //stop it from eating events if mouse down never happened on it!\r\n  this.renderContainer.addEventListener(\'mousedown\', function(e){ \r\n    if( e.srcElement !== this.el ){\r\n      this.css(this.el, \'pointer-events\', \'none\');\r\n      this.bCanvasDrag = true;\r\n    }\r\n  }.bind(this));\r\n  this.renderContainer.addEventListener(\'mouseup\', function(e){\r\n    this.css(this.el, \'pointer-events\', \'auto\');\r\n    this.bCanvasDrag = false;\r\n  }.bind(this));\r\n};\r\n\r\nAnnotation.prototype.sceneLoaded = function(){\r\n  this.bSceneLoaded = true;\r\n  this.attributesChanged();\r\n};\r\n\r\n//when the pin cap hover and element is selected, select the node instead\r\nAnnotation.prototype.onEditorPinClick = function(e){\r\n  if(!this.bDragging)window.verold.veroldEvents.trigger( \'studioApp::setSelectionFromPickData\', this.getEntity().id, event.button );\r\n};\r\n\r\nAnnotation.prototype.onTagClick = function(){\r\n  if(this.desc.innerHTML.trim().length) {\r\n    toggleEl(this.desc, 100);\r\n  }\r\n};\r\n\r\nAnnotation.prototype.onHoverIn = function(e){\r\n\r\n  if( (this.desc.innerHTML.trim().length || this.bIsEditor) && !this.bObjectSelected){\r\n    var color = this.shadeColor2(this.bgColor, 0.25);\r\n    this.css(this.el, \'background\', color);\r\n    this.css(this.line, \'background\', color);\r\n    this.css(this.cap, \'background\', color);\r\n  }\r\n};\r\n\r\nAnnotation.prototype.onHoverOut = function(e){\r\n  if(!this.bObjectSelected){\r\n    this.css(this.el, \'background\', this.bgColor);\r\n    this.css(this.line, \'background\', this.bgColor);\r\n    this.css(this.cap, \'background\', this.bgColor);\r\n  }\r\n};\r\n\r\n//@param bSelctionTriggered : was this triggered by a selection\r\nAnnotation.prototype.hideNote = function(bSelectionTriggered){\r\n\r\n  this.onHoverOut();\r\n\r\n  this.css(this.el, \'opacity\', \'0.0\');\r\n  this.css(this.line, \'opacity\', \'0.0\');\r\n\r\n  if(typeof bSelectionTriggered !== \'undefined\') {\r\n    this.bObjectSelected = bSelectionTriggered;\r\n  }\r\n  this.css(this.el, \'pointer-events\', \'none\');\r\n};\r\n\r\nAnnotation.prototype.showNote = function(bSelectionTriggered){\r\n  this.css(this.el, \'opacity\', \'1\');\r\n  this.css(this.line, \'background-color\', this.bgColor);\r\n  this.css(this.line, \'opacity\', \'1.0\');\r\n  this.css(this.cap, \'opacity\', \'1.0\');\r\n  if(typeof bSelectionTriggered !== \'undefined\') {\r\n    this.bObjectSelected = bSelectionTriggered;\r\n  }\r\n  if(!this.bCanvasDrag) {\r\n    this.css(this.el, \'pointer-events\', \'auto\'  );\r\n  }\r\n};\r\n\r\nAnnotation.prototype.createPrimPin = function(){\r\n  //node\r\n  var node = new THREE.Object3D();\r\n  //head\r\n  var headGeom = new THREE.SphereGeometry(0.15, 12, 12);\r\n  headGeom.computeVertexNormals();\r\n  headGeom.computeTangents();\r\n  var head = new THREE.Mesh(headGeom);\r\n  head.name = \'Pin_Piece\';\r\n  //cylinder\r\n  var bodyGeom = new THREE.CylinderGeometry(0.14, 0.0, 0.3, 12, 2);\r\n  bodyGeom.computeVertexNormals();\r\n  bodyGeom.computeTangents();\r\n  var body = new THREE.Mesh(bodyGeom);\r\n  body.position.y -= 0.2;\r\n  body.name = \'Pin_Piece\';\r\n\r\n  node.add(head);\r\n  node.add(body);\r\n\r\n  this.getThreeData().add(node);\r\n\r\n  //for studio picking\r\n  this.getEngine().globalEvents.trigger( \'studioApp::registerPickingObject\', this.getEntity(), head );\r\n  this.getEngine().globalEvents.trigger( \'studioApp::registerPickingObject\', this.getEntity(), body );\r\n  //for runtime picking\r\n  this.getEngine().globalEvents.trigger( \'registerPickingObject\', this.getEntity(), head );\r\n  this.getEngine().globalEvents.trigger( \'registerPickingObject\', this.getEntity(), body );\r\n\r\n  this.pinObject = node;\r\n\r\n  this.bNeedsUpdate = true;\r\n\r\n  this.loadMat(Annotation.editor_mat_json, function(mat){\r\n    head.material = mat;\r\n  }.bind(this));\r\n\r\n  this.loadMat(Annotation.head_mat_json, function(mat){\r\n    body.material = mat;\r\n  }.bind(this));\r\n\r\n  this.attributesChanged();\r\n};\r\n\r\nAnnotation.prototype.loadMat = function(json, onload){\r\n  var mat = this.getAssetRegistry().getAssetById(json.id);\r\n  if(mat){\r\n    this.listenToOnce(mat, \'load\', function(){\r\n      onload(mat.threeData.static);\r\n    });\r\n    mat.load();\r\n  }\r\n  else {\r\n    //create head mat\r\n    this.getAssetRegistry().createAsset(json, {\r\n      success : function(asset){\r\n        this.listenToOnce(asset, \'load\', function(){\r\n          onload(asset.threeData.static);\r\n        });\r\n        asset.load();\r\n      }.bind(this)\r\n    });\r\n  }\r\n};\r\n\r\nAnnotation.prototype.entityIsVisible = function() {\r\n\r\n  var threeData = this.getThreeData();\r\n\r\n  var isVisible = threeData.visible;\r\n\r\n  //traverse ancestors\r\n  threeData.traverseAncestors( function(parent){\r\n    if( !parent.visible ) isVisible = false;\r\n  } );\r\n\r\n\r\n  return isVisible;\r\n};\r\n\r\nAnnotation.prototype.preRenderView = function( scene, camera, options ) {\r\n\r\n  //every once and a while, check parents and self to see if visibility broken\r\n  if(!this.entityIsVisible()){\r\n    this.hideNote();\r\n    if( this.bIsEditor ) {\r\n      this.css( this.line, \'opacity\', \'0.0\' );\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (this.hasThreeData() && this.bCreated && this.isEnabled()) {\r\n\r\n    //positioning of annotation elements!\r\n    var threeData = this.getThreeData();\r\n    if ( threeData.parent ) {\r\n      this.tempMatrix.copy( threeData.matrixWorld );\r\n    }\r\n    else {\r\n      this.tempMatrix.identity();\r\n    }\r\n    this.worldPosVec.setFromMatrixPosition( this.tempMatrix );\r\n\r\n    this.tempVec.copy(this.worldPosVec);\r\n    var screenPos = this.worldToScreen( this.tempVec, camera );\r\n    screenPos.x = (Math.round(screenPos.x));\r\n    screenPos.y = (Math.round(screenPos.y));\r\n\r\n    if(this.bIsEditor) {\r\n      this.vWorldPos.set(screenPos.x, screenPos.y);\r\n    }\r\n\r\n    //annotation visiblity using raycaster\r\n    if(this.isInFOV && !this.bObjectSelected && this.pinObject && this.nRaySteps > VAPI.AnnotationCaster.STEPS){\r\n\r\n      this.pinObject.visible = false;\r\n\r\n      this.tempVec.copy(this.worldPosVec);\r\n      VAPI.AnnotationCaster.ray.origin.copy(camera.position);\r\n      VAPI.AnnotationCaster.ray.direction.copy(this.tempVec.sub(camera.position).normalize());\r\n      VAPI.AnnotationCaster.far = this.worldPosVec.distanceTo(camera.position);\r\n     // VAPI.AnnotationCaster.ray.freePool();\r\n      this.intersects.length = 0;\r\n\r\n      var intersects = VAPI.AnnotationCaster.intersectObjects(scene.children, true).filter(canHideFilter);\r\n      //var intersects = VAPI.AnnotationCaster.intersectObjects(scene.children, true, this.intersects).filter(canHideFilter);\r\n      var show = intersects.length === 0;\r\n\r\n      if(show){\r\n        this.showNote();\r\n      }\r\n      else {\r\n        this.hideNote();\r\n      }\r\n\r\n      this.nRaySteps = 0;\r\n\r\n      this.pinObject.visible = this.Pin.visible || this.bIsEditor;\r\n\r\n      //since this doesn\'t happen very often, we\'ll update offsets here, as well\r\n      this.offsetWidth = this.renderContainer.offsetWidth;\r\n      this.offsetHeight = this.renderContainer.offsetHeight;\r\n      this.elOffsetWidth = this.el.offsetWidth;\r\n      this.elOffsetHeight = this.el.offsetHeight;\r\n    }\r\n    else {\r\n\r\n      //percentage based offsets in screen space\r\n      var offsetX = this.Offset.x * this.offsetWidth;\r\n      var offsetY = this.Offset.y * this.offsetHeight;\r\n\r\n      if(!this.bDragging) {\r\n\r\n        if(!this.elCSSObj) {\r\n          this.elCSSObj = {\r\n            \'left\': \'\',\r\n            \'top\': \'\',\r\n          };\r\n        }\r\n\r\n        this.elCSSObj.left = (screenPos.x + offsetX - this.elOffsetWidth * 0.5) + \'px\';\r\n        this.elCSSObj.top = (screenPos.y - offsetY - this.elOffsetHeight * 0.5) + \'px\';\r\n\r\n        this.css(this.el, this.elCSSObj);\r\n      }\r\n\r\n      this.tempVec.set((screenPos.x + offsetX), (screenPos.y - offsetY));\r\n      var length = this.getLength(screenPos.x, this.tempVec.x, screenPos.y, this.tempVec.y);\r\n      var angle  = this.getAngle(screenPos.x, this.tempVec.x, screenPos.y, this.tempVec.y);\r\n\r\n      if(!this.lineCSSObj) {\r\n        this.lineCSSObj = {\r\n          \'transform\': \'\',\r\n          \'left\': \'\',\r\n          \'top\': \'\',\r\n          \'width\': \'\'\r\n        };\r\n      }\r\n\r\n      this.lineCSSObj.transform = \'rotate(\'+angle+\'deg)\';\r\n      this.lineCSSObj.left = (screenPos.x << 0) + \'px\';\r\n      this.lineCSSObj.top = (screenPos.y << 0) + \'px\';\r\n      this.lineCSSObj.width = length + \'px\';\r\n\r\n      this.css(this.line, this.lineCSSObj);\r\n\r\n    }\r\n\r\n    this.nRaySteps++;\r\n\r\n\r\n    //for ball scaling\r\n    if(this.pinObject && this.Pin.autoScale && this.pinObject.visible){\r\n      var scale = 0.0;\r\n      this.tempVec.setFromMatrixScale( this.getThreeData().matrixWorld );\r\n      var parentWorldScale = this.tempVec.x;\r\n      this.tempVec.setFromMatrixPosition( this.pinObject.matrixWorld );\r\n      scale = this.tempVec.distanceTo( camera.position ) / 12;\r\n\r\n      this.pinObject.scale.x = this.pinObject.scale.y = this.pinObject.scale.z = scale/parentWorldScale;\r\n    }\r\n  }\r\n\r\n  //if update and needs attributes changed run\r\n  if(this.bNeedsUpdate){\r\n    this.bNeedsUpdate = false;\r\n    this.attributesChanged();\r\n  }\r\n\r\n};\r\n\r\nAnnotation.prototype.worldToScreen = function(worldPosition, camera ) {\r\n\r\n  var halfWidth = (( this.offsetWidth * this.DVP ) / 2) << 0,\r\n    halfHeight = (( this.offsetHeight * this.DVP ) / 2) << 0;\r\n\r\n  this.tempVec.copy(worldPosition);\r\n\r\n  //check to see if object lies in view angle\r\n  this.camForward.set( 0, 0, -1 ).applyQuaternion( camera.quaternion ).normalize();\r\n  this.tempWorldPos.copy(worldPosition).sub(camera.position).normalize();//test point\r\n  var dot = this.camForward.dot(this.tempWorldPos);//going to get the unsigned value\r\n\r\n  var liesInView = Math.cos(camera.fov*0.0174532922222222) < dot;\r\n  if(!liesInView){\r\n    this.posVec.set(0,-1000000,0);\r\n  }\r\n  else {\r\n    this.tempVec.project( camera );\r\n    this.posVec.x = Math.round(this.tempVec.x * halfWidth + halfWidth) / this.DVP;\r\n    this.posVec.y = Math.round(-this.tempVec.y * halfHeight + halfHeight) / this.DVP;\r\n  }\r\n  this.isInFOV = liesInView;\r\n  return this.posVec;\r\n};\r\n\r\nAnnotation.prototype.getLength = function(x1, x2, y1, y2){\r\n  return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\r\n};\r\n\r\nAnnotation.prototype.getAngle = function(x1, x2, y1, y2){\r\n  return Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;\r\n};\r\n\r\nAnnotation.prototype.attributesChanged = function(){\r\n\r\n  var color, textColor;\r\n\r\n  var styleIndex = this.Colors.styles >= 0 ? this.Colors.styles : 0;//if style is set to custom, use the first style\r\n\r\n  var style = Annotation.StylePresets[styleIndex];\r\n  color = style.bg;\r\n  textColor = style.color;\r\n\r\n\r\n  this.bgColor = color;\r\n\r\n  //title html attributes\r\n  if(this.title) {\r\n    this.css(this.title, \'color\', textColor);\r\n    this.title.innerHTML = VAPI.safeHTML( this.Title );\r\n  }\r\n\r\n  //description html attributes\r\n  if(this.desc) {\r\n    if(this.ShowDescription  && this.isEnabled()){\r\n      showEl(this.desc, 100);\r\n    }\r\n    else {\r\n      hideEl(this.desc, 100);\r\n    }\r\n    this.css(this.desc, \'color\', textColor);\r\n    this.desc.innerHTML = VAPI.safeHTML( this.Description );\r\n  }\r\n\r\n  if(this.line){\r\n    this.css(this.line, \'display\', this.ShowLine && this.isEnabled() ? \'block\' : \'none\');\r\n    this.css(this.line, \'background\', color);\r\n    this.css(this.cap, \'background\', color);\r\n  }\r\n\r\n  if(this.pinObject){\r\n    this.pinObject.visible = (this.Pin.visible || this.bIsEditor) && this.isEnabled();//if in editor, just show it!\r\n\r\n    if(!this.Pin.autoScale){\r\n      this.pinObject.scale.set(0.3,0.3,0.3);\r\n    }\r\n\r\n    if(this.bIsEditor && !this.Pin.visible) {\r\n      this.setPinMaterial(Annotation.editor_mat_json.id);\r\n      this.pinObject.children[1].visible = false;\r\n    }\r\n    else if(this.Pin.material) {\r\n      this.setPinMaterial(this.Pin.material.id);\r\n      this.pinObject.children[1].visible = true;\r\n    }\r\n    else {\r\n      this.setPinMaterial(Annotation.head_mat_json.id)\r\n      this.pinObject.children[1].visible = true;\r\n    }\r\n  }\r\n\r\n  this.css(this.ellipsis, \'color\', this.shadeColor2(this.bgColor, 0.4));\r\n\r\n  //hide or show annotation, depending if content is available\r\n  if(this.el){\r\n    var show = this.m_bTagIsVisible && this.isEnabled();\r\n    if(show){\r\n      showEl(this.el, 0);\r\n    }\r\n    else {\r\n      hideEl(this.el, 0);\r\n    }\r\n    this.css(this.el, \'background\', color);\r\n  }\r\n\r\n  //hide/show ellipses if a description exists\r\n  if( this.Description ){\r\n    showEl(this.ellipsis);\r\n    this.css(this.title, \'padding-right\', \'40px\');\r\n  }\r\n  else {\r\n    hideEl(this.ellipsis);\r\n    this.css(this.title, \'padding-right\', \'10px\');\r\n  }\r\n\r\n  //if we\'ve disabled the component, hide it!\r\n  if( !this.isEnabled() || !this.bSceneLoaded ){\r\n    this.hideNote(false);\r\n  }\r\n  else {\r\n    this.showNote(false);\r\n  }\r\n};\r\n\r\n//taken from this awesome post(it\'s my favorite)\r\n//http://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors\r\nAnnotation.prototype.shadeColor2 = function(color, percent) {\r\n  if(color === \'#fff\' || color === \'#ffffff\')return color;\r\n  var f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;\r\n  return \'#\'+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);\r\n};\r\n\r\nAnnotation.prototype.shutdown = function() {\r\n  this.el.removeEventListener(\'mouseenter\', this.onHoverIn);\r\n  this.el.removeEventListener(\'mouseexit\', this.onHoverOut);\r\n\r\n  this.cap.remove();\r\n  this.line.remove();\r\n  this.title.remove();\r\n  this.desc.remove();\r\n  this.el.remove();\r\n\r\n  if(this.pinObject){\r\n    this.getThreeData().remove(this.pinObject);\r\n    var children = this.pinObject.children;\r\n    for(var child in children){\r\n      if( children.hasOwnProperty( child ) ) {\r\n        this.getEngine().globalEvents.trigger( \'studioApp::unregisterPickingObject\', this.pinObject, children[child]);\r\n        this.getEngine().globalEvents.trigger( \'unregisterPickingObject\', this.pinObject, children[child]);\r\n        children[child].geometry.dispose();\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nAnnotation.head_mat_json = {\r\n  \'id\':\'pin_head_material\',\r\n  \'type\':\'material\',\r\n  \'name\':\'Pin Head Material\',\r\n  \'payload\':{\'polygonOffset\':false,\'depthTest\':true,\'fog\':true,\'depthWrite\':true,\'side\':0,\'blending\':1,\'diffuseColor\':15344585, \'Features\':{\'Lighting\':{\'enabled\':false},\'Diffuse Color\':{\'enabled\':true},\'Rim Lighting\':{\'enabled\':false},\'Specular\':{\'enabled\':false},\'Reflections\':{\'enabled\':false},\'Emissive\':{\'enabled\':false}},\'visible\':true,\'materialType\':\'Simple\',\'colorOpacity\':1.0,\'specularColor\':16777215,\'specularIntensity\':9.565217391304348,\'gloss\':0.7739130434782608}\r\n};\r\n\r\nAnnotation.editor_mat_json = {\r\n  \'id\':\'pin_editor_material\',\r\n  \'type\':\'material\',\r\n  \'name\':\'Pin Editor Material\',\r\n  \'payload\':{\'polygonOffset\':false,\'depthTest\':true,\'fog\':true,\'depthWrite\':true,\'side\':0,\'blending\':1,\'diffuseColor\':0xCAC1CC, \'Features\':{\'Lighting\':{\'enabled\':true},\'Diffuse Color\':{\'enabled\':true},\'Rim Lighting\':{\'enabled\':false},\'Specular\':{\'enabled\':false},\'Reflections\':{\'enabled\':false},\'Emissive\':{\'enabled\':false}},\'visible\':true,\'materialType\':\'Simple\',\'colorOpacity\':1.0,\'specularColor\':16777215,\'specularIntensity\':9.565217391304348,\'gloss\':0.7739130434782608}\r\n};\r\n\r\nTHREE.Ray.prototype.at = function(){\r\n  var vec3 = new THREE.Vector3();\r\n\r\n  return function ( t, optionalTarget ) {\r\n\r\n    var result = optionalTarget || vec3.set(0,0,0);\r\n\r\n    return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n  };\r\n\r\n}();\r\n\r\nreturn Annotation;\r\n';});


define('text!VeroldEngine/Components/BuiltIn/Exploder.js',[],function () { return '/*\n@vname Exploder\n@vdescription Explodes your objects and their hierarchies into different formations. Great for showing off parts in a model!\n@vfilter object\n@vcategory Animation\n@vattr float Time {default: 1.5, \'description\': \'The amount of time to explode and contract the child meshes\' }\n@vattr v3 Scale {default: { \'x\' : 2.0, \'y\' : 2.0, \'z\' : 2.0 }, \'description\': \'The scale of the explosion\'}\n@vattr dd Formation {\n  \'description\' : \'Formation to use when exploding the hierarchy of this object.\',\n  \'default\' : \'Scale\',\n  \'options\': { \'Circle\' : \'Circle\', \'Square Grid\': \'Grid\', \'Scale Out\' : \'Scale\' },\n}\n@vevent local playExplode { \'action\':true, \'category\':\'Exploder\', \'parameters\' : [] }\n@vevent local playContract { \'action\':true, \'category\':\'Exploder\', \'parameters\' : [] }\n@vevent local toggleExploder { \'action\':true, \'category\':\'Exploder\', \'parameters\' : [] }\n@vevent local resetExploder { \'action\':true, \'category\':\'Exploder\', \'parameters\' : [] }\n@vevent local useCircleExplode { \'action\':true, \'category\':\'Exploder\', \'parameters\' : [ {\'name\':\'Scale\',\'type\':\'v3\', \'description\':\'The scale to apply to the explosion\', \'default\':{ \'x\':1, \'y\':1, \'z\':1 } } ] }\n@vevent local useGridExplode { \'action\':true, \'category\':\'Exploder\', \'parameters\' : [ {\'name\':\'Scale\',\'type\':\'v3\', \'description\':\'The scale to apply to the explosion\', \'default\':{ \'x\':1, \'y\':1, \'z\':1 } } ] }\n@vevent local useScaleOutExplode { \'action\':true, \'category\':\'Exploder\', \'parameters\' : [ {\'name\':\'Scale\',\'type\':\'v3\', \'description\':\'The scale to apply to the explosion\', \'default\':{ \'x\':2, \'y\':2, \'z\':2 } } ] }\n@vevent other beginExplode { \'action\':false, \'category\':\'Exploder\', \'parameters\' : [] }\n@vevent other endExplode { \'action\':false, \'category\':\'Exploder\', \'parameters\' : [] }\n@vevent other beginContract { \'action\':false, \'category\':\'Exploder\', \'parameters\' : [] }\n@vevent other endContract { \'action\':false, \'category\':\'Exploder\', \'parameters\' : [] }\n*/\nvar tmpVec = new THREE.Vector3();\n\nfunction Component() {\n  this.m_fTime = 99999999.0;\n  this.m_vDestTest = null;\n\n  //dest and src positions\n  this.m_objects = [];\n  this.m_sources = [];\n  this.m_destinations = [];\n\n  this.m_nDirection = -1;\n}\n\nComponent.prototype = new VAPI.VeroldComponent();\n\nComponent.prototype.init = function() {\n  //event listeners\n  this.listenTo(this.getEntity(), \'playExplode\', this.explode.bind(this));\n  this.listenTo(this.getEntity(), \'playContract\', this.contract.bind(this));\n  this.listenTo(this.getEntity(), \'toggleExploder\', this.toggle.bind(this));\n  this.listenTo(this.getEntity(), \'resetExploder\', this.reset.bind(this));\n  this.listenTo(this.getEntity(), \'useCircleExplode\', this.explode.bind(this, \'Circle\'));\n  this.listenTo(this.getEntity(), \'useGridExplode\', this.explode.bind(this, \'Grid\'));\n  this.listenTo(this.getEntity(), \'useScaleOutExplode\', this.explode.bind(this, \'Scale\'));  \n};\n\nComponent.prototype.update = function(delta) {\n  var threeData;\n  if (this.hasThreeData() && this.m_fTime < this.Time ) {\n    threeData = this.getThreeData();\n\n    this.m_fTime += delta;\n\n    var percent = this.m_fTime > this.Time ? 1.0 : makeEaseInOut(Math.max(0.0, Math.min(1.0, this.m_fTime/this.Time)));\n\n\n    for(var i = 0; i < this.m_objects.length; ++i) {\n\n      var obj = this.m_objects[i];\n\n      var dst =  obj.threeData.parent.worldToLocal( tmpVec.copy(this.m_destinations[i]) ).clone();\n      var srcPos = this.m_nDirection > 0 ? this.m_sources[i] : dst;\n      var destPos = this.m_nDirection > 0 ? dst : this.m_sources[i]; \n      this.lerpVec( srcPos, destPos, percent, tmpVec );\n\n      obj.alignToPosition( tmpVec,{ x:0.0, y:0.0, z:0.0 } );\n    }\n\n    if(this.m_fTime > this.Time) {\n      this.getEntity().trigger( this.m_nDirection > 0 ? \'endExplode\' : \'endContract\' );\n    }\n\n  }\n};\n\nComponent.prototype.reset = function(){\n  for(var i = 0; i < this.m_objects.length; ++i) {\n    var obj = this.m_objects[i];\n    obj.alignToPosition( this.m_sources[i], { x:0.0, y:0.0, z:0.0 } );\n  }\n\n  this.m_objects.length = 0;\n  this.m_sources.length = 0;\n  this.m_destinations.length = 0;\n  this.m_fTime = this.Time;//KILL IT\n};\n\nComponent.prototype.contract = function() {\n  if(!this.isEnabled()) return;\n\n  this.m_nDirection = -1;\n  this.m_fTime = 0;\n  this.getEntity().trigger(\'beginContract\');\n};\n\nComponent.prototype.explode = function(formation, scale){\n  if(!this.isEnabled()) return;\n\n  this.reset();\n\n  var children = this.getEntity().getObjects({ "type" : "mesh" });\n  var center = this.getEntity().getCenterInWorldSpace();\n  var rotation = this.getEntity().getQuaternionInWorldSpace();\n  var length = children.length;\n  var formationFunc = this.getFormationFunc( formation||this.Formation, center, rotation, length, scale||this.Scale ).bind(this);\n\n  // Explode each child mesh...\n  for (var i=0;i<length;++i) {\n\n    formationFunc(i, tmpVec, children[i]);\n\n    this.m_objects.push( children[i] );\n    this.m_sources.push( children[i].getCenterInParentSpace() );\n    this.m_destinations.push( tmpVec.clone() );\n\n  }\n\n  this.m_fTime = 0;\n  this.m_nDirection = 1;\n  this.getEntity().trigger(\'beginExplode\');\n};\n\nComponent.prototype.toggle = function(){\n  if(this.m_nDirection > 0){\n    this.contract();\n  }\n  else {\n    this.explode();\n  }\n};\n\nComponent.prototype.getFormationFunc = function(formation, center, rotation, length, scale){\n  var func = null;\n\n  switch(formation) {\n    case \'Grid\' :\n      //get the length of both sides of the grid! All grids want to be square\n      var square = Math.floor( Math.sqrt( length ) );\n      var xInc = 1/square;\n      var yInc = 1/square;\n      var startX = -xInc * (square - 1)*0.5;\n      var startY = (square - 1) / 2 * yInc;\n      var row = 0;\n      func = function(index, outVec, child){\n        var x = startX + (index % square * xInc);\n        var y = startY - row*yInc;\n        outVec.set(x,y, 0).applyQuaternion(rotation);\n\n        outVec.copy( center.clone().add(outVec.multiply( scale )) );\n\n        if(index % square === square-1) row++;\n      };\n      break;\n    case \'Scale\' : \n\n      func = function(index, outVec, child) {\n\n        child.getCenterInWorldSpace( outVec );\n\n        var distVec = outVec.clone().sub(center);\n\n        outVec.copy( center ).add( distVec.multiply( scale ) );\n      };\n      break;\n    case \'Circle\' :\n    default :\n      func = function(index, outVec, child){\n        var x = center.x + ( scale.x * Math.cos(2 * Math.PI * index / length) );\n        var y = center.y + ( scale.y * Math.sin(2 * Math.PI * index / length) );\n        outVec.set(x,y,center.z).applyQuaternion(rotation);\n      };\n\n  }\n\n  return func;\n};\n\nComponent.prototype.lerpVec = function(src, dst, val, out){\n\n  var x = src.x + (dst.x - src.x) * val;\n  var y = src.y + (dst.y - src.y) * val;\n  var z = src.z + (dst.z - src.z) * val;\n\n  out.set(x,y,z);\n};\n\nfunction back(progress, x) {\n    return Math.pow(progress, 2) * ((x + 1) * progress - x)\n}\n\nfunction makeEaseInOut(progress) { \n  if (progress < .5)\n    return back(2*progress, 2.0) / 2\n  else\n    return (2 - back(2*(1-progress), 2.0)) / 2\n}\n\n\n//check to see if threejs parent traversal is present\nTHREE.Object3D.prototype.traverseAncestors = THREE.Object3D.prototype.traverseAncestors  || function( callback ){\n\n  if( this.parent ){\n\n    callback( this.parent );\n    this.parent.traverseAncestors( callback );\n\n  }\n\n};\n\nComponent.prototype.shutdown = function() {\n};\n\n\nreturn Component;\n';});

/*
* NAMING CONVENTION FOR EVENTS
* play  <-- to start an event, is an action
* pause <-- to pause an event, is an action
* stop  <-- to stop an event, is an action
*
* enable  <-- , is an action
* disable <-- , is an action
* toggle  <-- , is an action
*
* begin  <-- triggered when event started, not an action
* end    <-- triggered when event complete, not an action
*
* Naming convention goes as follows
* <one of the above or one of your own><describing the event>
*
* Examples:
* playAnimateAlongCurve <-- start the curve animation
* stopKeyframeAnimation <-- stop a keyframe animation from playing
* pauseAudio            <-- pause a sound
* enableFreeCameraController   <-- turn on the free camera controller
* disableOrbitCameraController <-- turn off the orbit camera controller
* toggleVisibility             <-- toggle the visibility of an object
* beginShot                    <-- a shot has begun
* endExplode                   <-- the exploder has finished animating
*
* hideAnnotationPin    <-- hides just the pin for the annotation
* setViewport
*/
define('VeroldEngine/AssetRegistry/ScriptRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/ScriptAsset'
       , 'text!VeroldEngine/Components/BuiltIn/Animation.js'
       , 'text!VeroldEngine/Components/BuiltIn/AudioListener.js'
       , 'text!VeroldEngine/Components/BuiltIn/AudioSource.js'
       , 'text!VeroldEngine/Components/BuiltIn/FreeCameraController.js'
       , 'text!VeroldEngine/Components/BuiltIn/OrbitCameraController.js'
       , 'text!VeroldEngine/Components/BuiltIn/SkyboxRenderer.js'
       , 'text!VeroldEngine/Components/BuiltIn/DefaultRenderer.js'
       , 'text!VeroldEngine/Components/BuiltIn/DefaultFilters.js'
       , 'text!VeroldEngine/Components/BuiltIn/RenderFilters.js'
       , 'text!VeroldEngine/Components/BuiltIn/RenderView.js'
       , 'text!VeroldEngine/Components/BuiltIn/HMDRenderEffect.js'
       , 'text!VeroldEngine/Components/BuiltIn/DebugTextureRender.js'
       , 'text!VeroldEngine/Components/BuiltIn/RenderTargetViewer.js'
       , 'text!VeroldEngine/Components/BuiltIn/RenderModes.js'
       , 'text!VeroldEngine/Components/BuiltIn/ReflectionCapturePlane.js'
       , 'text!VeroldEngine/Components/BuiltIn/CubeMapCapture.js'
       , 'text!VeroldEngine/Components/BuiltIn/PanoramaToCubeMap.js'
       , 'text!VeroldEngine/Components/BuiltIn/SphereMapCapture.js'
       , 'text!VeroldEngine/Components/BuiltIn/SimplexNoiseGenerator.js'
       , 'text!VeroldEngine/Components/BuiltIn/NormalMapGenerator.js'
       , 'text!VeroldEngine/Components/BuiltIn/SceneLoader.js'
       , 'text!VeroldEngine/Components/BuiltIn/Rotate.js'
       , 'text!VeroldEngine/Components/BuiltIn/LookAt.js'
       , 'text!VeroldEngine/Components/BuiltIn/TextRenderer2D.js'
       , 'text!VeroldEngine/Components/BuiltIn/TextLabel2D.js'
       , 'text!VeroldEngine/Components/BuiltIn/EventHandler.js'
       , 'text!VeroldEngine/Components/BuiltIn/CustomControl.js'
       , 'text!VeroldEngine/Components/BuiltIn/KeyboardController.js'
       , 'text!VeroldEngine/Components/BuiltIn/MouseController.js'
       , 'text!VeroldEngine/Components/BuiltIn/ObjectPicker.js'
       , 'text!VeroldEngine/Components/BuiltIn/Curve.js'
       , 'text!VeroldEngine/Components/BuiltIn/ShotManager.js'
       , 'text!VeroldEngine/Components/BuiltIn/ObjectAnimator.js'
       , 'text!VeroldEngine/Components/BuiltIn/Annotation.js'
       , 'text!VeroldEngine/Components/BuiltIn/Exploder.js'

  ],
  function(_, THREE, ScriptAsset
    , AnimationJS
    , AudioListenerJS
    , AudioSourceJS
    , FreeCameraControllerJS
    , OrbitCameraControllerJS
    , SkyboxRendererJS
    , DefaultRendererJS
    , DefaultFiltersJS
    , RenderFiltersJS
    , RenderViewJS
    , HMDRenderEffectJS
    , DebugTextureRenderJS
    , RenderTargetViewerJS
    , RenderModesJS
    , ReflectionCapturePlaneJS
    , CubeMapCaptureJS
    , PanoramaToCubeMapJS
    , SphereMapCaptureJS
    , SimplexNoiseGeneratorJS
    , NormalMapGeneratorJS
    , SceneLoaderJS
    , RotateJS
    , LookAtJS
    , TextRendererJS
    , TextLabelJS
    , EventHandlerJS
    , CustomControlJS
    , KeyboardControllerJS
    , MouseControllerJS
    , ObjectPickerJS
    , CurveJS
    , ShotManagerJS
    , ObjectAnimatorJS
    , AnnotationJS
    , ExploderJS) {

    var globalUserScripts = {};

    var VAPI = window.VAPI = window.VAPI || {};

    var ScriptRegistry = function( properties ) {
      this.assets = undefined;

      //Reserved components are never available to add in the Studio UI. They are added to entities only via code.
      //i.e. these components are not selectable in the Studio UI unless the user has beta access.
      //They are, however, displayed if they're assigned to an entity, though non-beta users can't remove them.
      this.reservedComponents = {

        "Render Settings" : {
          id: "verold_renderer",
          name: "Renderer",
          type: "script",
          advanced: true,
          limitPerEntity: 1,
          alwaysOn: true,
          payload: {
            filter: ["application"],
            "description": "",
            "category": "Rendering",
            "attributes": {
              "renderOnDemand": { type: 'b', "description": "When this is enabled, rending will only happen when requested instead of every frame.", default: false },
              "antialias": { type: 'b', "description": "Enable or disable antialiasing of the rendered scene.", default: true, "advanced": true },
              "preserveDrawingBuffer": { type: 'b', "description": "Tells the browser to preserve drawing buffers between frames so that they are available to be read by the application.", default: true, "advanced": true },
              "autoClear": { type: 'b', "description": "Automatically clear the render target before each render.", default: false, "advanced": true },
              "devicePixelRatio": {
                type: 'dd',
                default: 0.0,
                options: { "Device Default" : 0.0, "One": 1.0, "Two": 2.0 },
                description: "Override the default pixel ratio of the system. Higher values will cause rendering at higher resolution while lower values will force rendering at lower resolutions. You can also set this to use the device default (mobile devices usually have values greater than 1).",
                "advanced": false
              },
              "clearColor": { type: 'c', "description": "When the render target is cleared, this colour will be used", default: 0x000000, "advanced": false },
              "clearAlpha": { type: 'f', "description": "When the render target is cleared, this value will be used to clear the transparency", default: 0, min: 0.0, max: 1.0, step: 0.001, "advanced": false },
              "precision": { type: 'dd', "description": "The default floating point and integer precision to be used by the GPU.", default: "mediump", options: { "Low" : "lowp", "Medium" : "mediump", "High" : "highp" }, "advanced": true },

              "shadowMapEnabled": { type: 'b', "description": "Enable or disable rendering of shadows.", default: true },
              "shadowMapEnabledMobile": { type: 'b', "description": "Enable or disable rendering of shadows on mobile devices.", default: false, "advanced": true },
              "shadowMapType": { type: 'dd', options: { "Soft PCF" : THREE.PCFSoftShadowMap, "PCF" : THREE.PCFShadowMap, "No Filtering" : THREE.BasicShadowMap }, default: THREE.PCFSoftShadowMap, "advanced": true },
              "shadowMapAutoUpdate": { type: 'b', "description": "Shadows will or will not automatically be updated every frame.", default: true, "advanced": true },
              "shadowMapCullFace": { type: 'dd', "description": "Shadows will or will not automatically be updated every frame.", options: {
                "None" : THREE.CullFaceNone,
                "Front" : THREE.CullFaceFront,
                "Back" : THREE.CullFaceBack }, default: THREE.CullFaceBack, "advanced": true },
              // "shadowMapCascade" : { type: 'b', "description": "Enable or disable cascade shadow maps.", default: false },
              "shadowMapDebug" : { type: 'b', "description": "Enable or disable debug rendering, showing the different shadow cascade sizes.", default: false, "advanced": true },
              // "gammaInput": { type: 'b', "description": "Enable or disable gamma correction on input values (colours, textures, lighting).", default: true, "advanced": true },
              // "gammaOutput": { type: 'b', "description": "Enable or disable gamma correction for final output.", default: true, "advanced": true },
              "logarithmicDepthBuffer": { type: 'b', "description": "Use logarithmic z values while rendering.", default: true, "advanced" : true },

            },
            "script": DefaultRendererJS
          }
        },

        "Default Filters" : {
          id: "render_filters_component",
          name: "Default Filters",
          type: "script",
          limitPerEntity: 1,
          payload: {
            "script": DefaultFiltersJS
          }
        },

        "Render Filters" : {
          id: "camera_filters_script",
          name: "Render Filters",
          type: "script",
          limitPerEntity: 1,
          payload: {
            "script": RenderFiltersJS
          }
        },

        "Render View" : {
          id: "render_view_component",
          name: "Render View",
          type: "script",
          payload: {
            "description": "",
            "category": "Rendering",
            "filter": ["camera"],
            //"requires": "scene_composer_component",
            "attributes": {
              //"enabled" : { "description": "", type: "b", "default": true },
              "viewportLeft" : { "description": "Left position of the viewport to be rendered by this camera.", type: "s", "default" : "0px" },
              "viewportBottom" : { "description": "Bottom position of the viewport to be rendered by this camera.", type: "s", "default" : "0px" },
              "viewportWidth" : { "description": "Width of the viewport to be rendered by this camera.", type: "s", "default" : "100%" },
              "viewportHeight" : { "description": "Height of the viewport to be rendered by this camera.", type: "s", "default" : "100%" },
              "renderGroup" : { "description": "Render passes are done in order, based on the 'render group' value. Lower numbers render first.", type: "i", default: 0 },
              "clearColor" : { "description": "", type: "b", "default" : false, "advanced": false },
              "clearDepth" : { "description": "", type: "b", "default" : true, "advanced": false },
              "renderTarget" : { "description": "", type: "asset", "filter": { "renderTexture2D": true }, default: null, "advanced": false },
              "enablePreRenderFunctions" : { "description": "Run pre-render functions with this view. These include things like real-time reflections, which need to be rendered for each view separately.", type: "b", "default" : true, "advanced": true },
              "enableShadows" : { "description": "Render shadows for this view.", type: "b", "default" : true, "advanced": true },
            },
            "script": RenderViewJS,
            "events" : {
              "enableRenderView" : {'scope': 'local', 'category': 'Rendering', 'parameters': [{'name': 'fade', 'type': 'f', 'description': 'Defined in seconds', 'default': 0.0}]},
              "setViewport" : {'scope': 'local', 'category': 'Rendering', 'parameters': [
                {'name': "viewportLeft", "description": "Left position of the viewport to be rendered by this camera.", "type": "s", "default" : "0px" },
                {'name': "viewportBottom", "description": "Bottom position of the viewport to be rendered by this camera.", "type": "s", "default" : "0px" },
                {'name': "viewportWidth", "description": "Width of the viewport to be rendered by this camera.", "type": "s", "default" : "100%" },
                {'name': "viewportHeight", "description": "Height of the viewport to be rendered by this camera.", "type": "s", "default" : "100%" },
                {'name': 'animationTime', 'type': 'f', 'description': 'Animate the change in viewport over this many seconds.', 'default': 0.0}]},
              "disableRenderView" : {'scope': 'local', 'category': 'Rendering', 'parameters': [{'name': 'fade', 'type': 'f', 'description': 'Defined in seconds', 'default': 0.0}]},
              "toggleRenderView" : {'scope': 'local', 'category': 'Rendering', 'parameters': [{'name': 'fade', 'type': 'f', 'description': 'Defined in seconds', 'default': 0.0}]},

            },
          }
        },

        "Render Modes" : {
          id: "render_modes",
          name: "Render Modes",
          type: "script",
          limitPerEntity: 1,
          payload: {
            filter: ["application"],
            "description": "A simple component to add filters to the rendering.",
            "category": "Rendering",
            "attributes": {
            },
            "script": RenderModesJS,
            "events" : {
              //"enableRenderView" : {'scope': 'local', 'parameters': [{'name': 'fade', 'type': 'f', 'description': 'Defined in seconds', 'default': 0.0}]},
            }
          }
        },

        "Scene Loader" : {
          id: "loader_component",
          name: "Scene Loader",
          type: "script",
          limitPerEntity: 1,
          payload: {
            filter: ["application"],
            "description": "A simple component to load a scene and display progress for it.",
            "category": "Loading",
            "attributes": {
              "scene": { type: 'asset', "description": "The scene to load.", default: null, "filter" : { "scene": true }},
            },
            "script": SceneLoaderJS
          }
        },

        "Reflection Capture Plane" : {
          id: "reflection_capture_planar",
          name: "Reflection Capture Plane",
          type: "script",
          payload: {
            filter: ['object'],
            "description": "",
            "category": "Rendering",
            "attributes": {
              // "sceneCamera": { type: 'object', "description": "The camera used when viewing the scene.", default: null, "filter" : { "camera": true }},
              "reflectionTexture": { type: 'asset', "description": "The RenderTexture2D to render the reflection to.", "filter" : { "renderTexture2D": true }, default: null },
              "clipBias" : { type: 'f', "description": "Pushes the rendered scene forward or backwards to adjust clipping with reflection plane.", default: 0.01 },
              "updateFrameInterval": { type: 'i', "description": "The number of frames to skip in between updates of the reflection. Default is 0.", default: 0 },
            },
            "script": ReflectionCapturePlaneJS
          }
        },

        "Cube-Map Capture" : {
          id: "cubemap_capture",
          name: "Cube-Map Capture",
          type: "script",
          payload: {
            filter: ['object'],
            "description": "",
            "category": "Rendering",
            "attributes": {
              // "sceneCamera": { type: 'object', "description": "The camera used when viewing the scene.", default: null, "filter" : { "camera": true }},
              "cubeTexture": { type: 'asset', "description": "The RenderTextureCube to render the reflection to.", "filter" : { "renderTextureCube": true }, default: null },
              "near" : { type: 'f', "description": "The closest distance to this object to render. Adjust this to avoid rendering local geometry to the texture.", default: 0.25 },
              "far" : { type: 'f', "description": "The furthest distance from this object to render.", default: 14000.00 },
              "updateFrameInterval": { type: 'i', "description": "The number of frames to skip in between updates of the reflection. Default is 0.", default: 0 },
              'renderPosX' : { type: 'b', 'description': 'Render this side of the cube.', default: true },
              'renderNegX' : { type: 'b', 'description': 'Render this side of the cube.', default: true },
              'renderPosY' : { type: 'b', 'description': 'Render this side of the cube.', default: true },
              'renderNegY' : { type: 'b', 'description': 'Render this side of the cube.', default: true },
              'renderPosZ' : { type: 'b', 'description': 'Render this side of the cube.', default: true },
              'renderNegZ' : { type: 'b', 'description': 'Render this side of the cube.', default: true },
            },
            "script": CubeMapCaptureJS
          }
        },

        "Sphere-Map Capture" : {
          id: "spheremap_capture",
          name: "Sphere-Map Capture",
          type: "script",
          payload: {
            filter: ['object'],
            "description": "",
            "category": "Rendering",
            "attributes": {

              "sphereTexture": { type: 'asset', "description": "The RenderTexture2D to render the reflection to.", "filter" : { "renderTexture2D": true }, default: null },
              "near" : { type: 'f', "description": "The closest distance to this object to render. Adjust this to avoid rendering local geometry to the texture.", default: 0.25 },
              "far" : { type: 'f', "description": "The furthest distance from this object to render.", default: 14000.00 },
              "updateFrameInterval": { type: 'i', "description": "The number of frames to skip in between updates of the reflection. Default is 0.", default: 0 },
            },
            "script": SphereMapCaptureJS
          }
        },

        "Curve" : {
          id: "curve_component",
          name: "Curve",
          type: "script",
          payload: {
            filter: ["object"],
            "description": "Creates a spline curve that can be used for various things, including making objects follow it. Add controls points to shape the curve.",
            "category": "General",
            "attributes": {
              "controlPoints" : { "description": "The list of objects that define the curve shape.", "type" : 'a', 'subType' : { "type": "object" } },
              "closed": { "description": "If toggled, the start and end of the curve will be smoothly joined.", "default": false, "type": "b"},
            },
            "script": CurveJS
          }
        },

        "Annotation" : {
          id : "annotation_component",
          type : "script",
          limitPerEntity: 1,
          payload : {
            "script" : AnnotationJS
          }

        },

        'Exploder' : {
          id: 'exploder_component',
          type: 'script',
          payload: {
            'script': ExploderJS
          }
        },

        "Render Target Viewer" : {
          id: "render_target_viewer",
          name: "Render Target Viewer",
          type: "script",
          payload: {
            filter: ["application"],
            "description": "",
            "category": "Debug",
            "attributes": {
              "viewportLeft" : { "description": "Left position of the viewport to be rendered by this camera.", type: "s", "default" : "50%" },
              "viewportBottom" : { "description": "Bottom position of the viewport to be rendered by this camera.", type: "s", "default" : "0px" },
              "viewportWidth" : { "description": "Width of the viewport to be rendered by this camera.", type: "s", "default" : "50%" },
              "viewportHeight" : { "description": "Height of the viewport to be rendered by this camera.", type: "s", "default" : "50%" },
              "renderGroup" : { "description": "Render passes are done in order, based on the 'render group' value. Lower numbers render first.", type: "i", default: 9 },
            },
            "script": RenderTargetViewerJS,

          }
        },

      },

      //Simple components are available in all application types
      this.simpleComponents = {

        "Shots" : {
          id: "shot_manager_component",
          name: "Shots",
          type: "script",
          limitPerEntity: 1,
          payload: {
            filter: ["scene"],
            "description": "This component allows you to define a series of cinematic camera shots.",
            "category": "Interaction",
            "attributes": {
              "fadeIn" : { "name": "fadeIn", "description": "The percentage of the animation spent fading in.", "type" : 'f', "slider": true, "default" : 0.25, "min": 0.0, "max": 1.0 },
              //"cameras" : { "description": "The list of cameras that define each shot.", "hidden": true, "type" : 'a', 'subType' : { "type": "object", "filter": { "camera": true } } },
              "cameras" : { "description": "The list of cameras that define each shot.", "hidden": true, "type" : 'a',
                'subType' : { "type": "custom",
                  "attributes": {
                    "cameraObject" : {"type": "object", "filter": { "camera": true }},
                    "name" : {"type": "s"},
                    "description" : {"type": "s"}
                  }
                }
              },
            },
            "events" : {
              "beginShot" : {'scope': 'other', 'filter': ['camera'], 'action': false, 'category': 'General', 'parameters': []},
              "endShot" : {'scope': 'other', 'filter': ['camera'], 'action': false, 'category': 'General', 'parameters': []},
              "shotManager::play" : { 'scope': 'global', 'action': true, 'category': 'General', 'parameters': [ {'name': 'shotNumber', 'type': 'i', 'description': 'The index of shot that you want to play.', 'default': 0}]},
              "playShot" : {'scope': 'local', 'action': true, 'category': 'General', 'parameters': [ {'name': 'shotNumber', 'type': 'i', 'description': 'The index of shot that you want to play.', 'default': 0} ]},
            },
            "script": ShotManagerJS
          }
        },

        'Object Animator' : {
          id: 'object_animator_component',
          name: 'Object Animator',
          type: 'script',
          limitPerEntity: 1,
          payload: {
            filter: ['object'],
            'description': '',
            'category': 'Animation',
            'attributes': {
            },
            'events': {
              'playAnimateAlongCurve': {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': [
                {'name': 'curve', 'type' : 'object', 'description': '', 'default': null, 'componentFilter': { 'Curve' : true }},
                {'name': 'animationTime', 'type': 'f', 'description': 'Time to animate to object. Defined in seconds', 'default': 3},
                {'name': 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'orientation', 'description': 'Orient the object following the curve to either the direction of the curve or to the objects defining the curve.', 'type': 'dd', 'default': 'toCurve', 'options' : { 'None': 'None', 'To Curve' : 'toCurve', 'To Nodes' : 'toNode'}},
                {'name': 'loop', 'type' : 'b', 'description': '', 'default': false}
              ]},
              'playAnimateToObject': {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': [
                {'name': 'object', 'type' : 'object', 'description': '', 'default': null},
                {'name': 'animationTime', 'type': 'f', 'description': 'Total time that the animation will take. Defined in seconds', 'default': 3},
                {'name': 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'update orientation', 'type' : 'b', 'description': '', 'default': true}
              ]},
              'playAnimateTranslation': {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': [
                {'name': 'animationTime', 'type': 'f', 'description': 'Time to animate to object. Defined in seconds', 'default': 3},
                {'name': 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'velocity', 'description': '', 'type': 'v3', 'default': {x:0,y:0,z:1.0}, 'min': -1.0, 'max': 1.0},
                {'name': "objectUsage", 'type' : 'dd', "description": "Specify what part of the animation the current object's position represents.", 'default': 'beginning', "options": { "Beginning": "beginning", "Middle": "middle", "End": "end" } },
              ]},
              'playAnimateRotation': {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': [
                {'name': 'animationTime', 'type': 'f', 'description': 'Time to animate to object. Defined in seconds', 'default': 3},
                {'name': 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'angularVelocity', 'description': '', 'type': 'v3', 'default': {x:0,y:0,z:1.0}, 'min': -100.0, 'max': 100.0},
                {'name': "objectUsage", 'type' : 'dd', "description": "Specify what part of the animation the current object's rotation represents.", 'default': 'beginning', "options": { "Beginning": "beginning", "Middle": "middle", "End": "end" } },
                {'name': "axisOrder", 'type' : 'dd', "description": "Specify the axis order that the angular velocity will be applied in.", 'default': 'YXZ', "options": {
                  "XYZ": "XYZ",
                  "YXZ": "YXZ",
                  "ZXY": "ZXY",
                  "XZY": "XZY",
                  "YZX": "YZX",
                  "ZYX": "ZYX"}
                },
              ]},
              'playAnimateScale': {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': [
                {'name': 'animationTime', 'type': 'f', 'description': 'Time to animate to object. Defined in seconds', 'default': 3},
                {'name': 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
                {'name': 'velocity', 'description': '', 'type': 'v3', 'default': {x:0,y:0,z:1.0}, 'min': -10.0, 'max': 10.0},
                {'name': "objectUsage", 'type' : 'dd', "description": "Specify what part of the animation the current object's scale represents.", 'default': 'beginning', "options": { "Beginning": "beginning", "Middle": "middle", "End": "end" } },
              ]},
              "pauseCurveAnimation" : {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': []},
              'stopCurveAnimation': {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': []},
              "unpauseCurveAnimation" : {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': []},
              'endAnimateAlongCurve': {'scope': 'local', 'action': false, 'category': 'Animation', 'parameters': []},
              'endAnimateToObject': {'scope': 'local', 'action': false, 'category': 'Animation', 'parameters': []},
              'endAnimateTranslation': {'scope': 'local', 'action': false, 'category': 'Animation', 'parameters': []}
            },
            'script': ObjectAnimatorJS
          },
        },

        "EventHandler" : {
          id: 'event_handler_component',
          name: 'Event Handler',
          type: 'script',
          payload: {
            'description': '',
            'category': 'Interaction',
            'attributes': {
              'listen': {'name': 'listen', 'description': 'The event to listen for. When this event is captured, all of the defined trigger events will be fired.', 'type': 'event'},
              'triggers': {'name': 'triggers', 'description': 'Fire each of these events in response to the captured listen event.', 'type': 'a', 'subType': { 'type': 'event' }}
            },
            'attributesOrder': [ 'listen', 'triggers' ],
            'script': EventHandlerJS
          },
        },

        "CustomControl" : {
          id: 'custom_control_component',
          name: 'Custom Control',
          type: 'script',
          payload: {
            filter: ['scene'],
            'description': '',
            'category': 'Interaction',
            'attributes': {
              'name': {name: 'name', type: 's'},
              'control': {name: 'control', type: 'control', default: '', options: { 'Button': 'button', 'Toggle': 'toggle', 'List': 'list' }, subType: { 'type': 's' }}
            },
            'script': CustomControlJS
          },
        },

        "Keyframe Animation" : {
          id: "animation",
          name: "Keyframe Animation",
          type: "script",
          payload: {
            filter: ["object"],
            "description": "Attach keyframe animations to models and control their playback",
            "category": "Animation",
            "attributes": {
              "autoPlay": { "description": "Play the animation once loaded", "default": true, "type": "b" },
              "loop": { "description": "Continuously replay the animation", "default": true, "type": "b" },
              "speed": { "description": "Playback speed", "default": 1.0, "min": 0.0, "max": 100.0, "type": "f" },
              "startTime": { "description": "Begin playback at this time offset", "default": 0.0, "min": 0.0, "type": "f" },
              "weight": { "description": "Blending weight", "default": 1.0, "min": 0.0, "max": 1.0, "type": "f" },
              "asset": {
                "description": "Animation asset",
                "default": null,
                "type": "asset",
                "filter": { "animation": true }
              },
              "take": {
                "description": "The name of the animation take",
                "default": null,
                "type": "ddfn",
                "optionsFn": "getTakes"
              }
            },
            "events" : {
              "playKeyframeAnimation" : {
                'scope': 'local',
                'action': true,
                'category': 'Animation',
                'parameters': [{
                  'name': 'asset',
                  'type': 'asset',
                  'description': 'The animation asset to play.',
                  'default': null,
                  'filter': { 'animation': true }
                }, {
                  'name': 'take',
                  'type': 's',
                  'description': 'The animation take to play.',
                  'default': null
                }, {
                  'name': 'loop',
                  'type': 'b',
                  'description': 'Continuously replay the animation.',
                  'default': true
                }, {
                  'name': 'speed',
                  'type': 'f',
                  'description': 'Playback speed.',
                  'default': 1.0,
                  'min': 0.0,
                  'max': 100.0
                }, {
                  'name': 'startTime',
                  'type': 'f',
                  'description': 'Begin playback at this time offset.',
                  'default': 0.0,
                  'min': 0.0
                }]
              },
              'endKeyframeAnimation': {'scope': 'local', 'action': false, 'category': 'Animation', 'parameters': []},
              "pauseKeyframeAnimation" : {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': []},
              "stopKeyframeAnimation" : {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': []},
              "toggleKeyframeAnimation" : {'scope': 'local', 'action': true, 'category': 'Animation', 'parameters': []}
            },
            "script": AnimationJS
          }
        },

        "Audio Listener" : {
          id: "audio_listener",
          name: "Audio Listener",
          type: "script",
          payload: {
            filter: ["object", "scene"],
            "description": "Audio listener for 3D, positional sound effects",
            "category": "Audio",
            "attributes": {},
            "script": AudioListenerJS
          }
        },

        "Audio Source" : {
          id: "audio_source",
          name: "Audio Source",
          type: "script",
          payload: {
            filter: ["object", "scene"],
            "description": "Controls playback of audio assets",
            "category": "Audio",
            "attributes": {
              "gain": { "description": "Volume control", "default": 1.0, "min": 0.0, "max": 100.0, type: "f" },
              "autoPlay": { "description": "Play the audio once loaded", "default": true, "type": "b" },
              "loop": { "description": "Continuously replay the audio", "default": true, "type": "b" },
              "preload": { "description": "Load the audio when the component is initialized", "default": true, "type": "b" },
              "positional": { "description": "Enable/disable 3D, positional audio effects", "default": false, "type": "b" },
              "stream": { "description": "Stream the audio", "default": false, "type": "b" },
              "asset": {
                "description": "Audio or video asset",
                "default": null,
                "type": "asset",
                "filter": { "audio": true, "textureVideo": true }
              },
            },
            "events" : {
              "playAudio" : {'scope': 'local', 'action': true, 'category': 'Audio', 'parameters': [
                {'name': 'offset', 'type': 'f', 'description': 'Defined in seconds', 'default': 0}
              ]},
              "pauseAudio" : {'scope': 'local', 'action': true, 'category': 'Audio', 'parameters': []},
              "stopAudio" : {'scope': 'local', 'action': true, 'category': 'Audio', 'parameters': []},
              "toggleAudio" : {'scope': 'local', 'action': true, 'category': 'Audio', 'parameters': []}
            },
            "script": AudioSourceJS
          }
        },

        "Panorama To Cube-Map" : {
          id: "panorama_to_cubemap_script",
          name: "Panorama To Cube-Map",
          type: "script",
          payload: {
            filter: ['renderTextureCube'],
            "script": PanoramaToCubeMapJS
          }
        },

        "Simplex Noise Generator" : {
          id: "simplex_noise_component",
          name: "Simplex Noise Generator",
          type: "script",
          payload: {
            filter: ["renderTexture2D"],
            "description": ".",
            "category": "Rendering",
            "attributes": {
              "layerAmplitude" : { "description": "", "type" : 'v4', default: { x: 0.5, y: 0.4, z: 0.3, w: 0.125 } },
              "layerScale" : { "description": "", "type" : 'v4', default: { x: 0.5, y: 2.0, z: 3.0, w: 4.0 } },
              "scale" : { "description": "", "type" : 'v2', default: { x: 1.0, y: 1.0 } },
              "offset" : { "description": "", "type" : 'v2', default: { x: 0.0, y: 0.0 } },
              "autoLoad" : { "description": "", "type" : 'b', default: true },
            },
            "events" : {
              "renderNoise" : {'scope': 'local', 'action': true, 'category': 'Rendering', 'parameters': []},
              "changeNoiseValues" : {'scope': 'local', 'action': true, 'category': 'Rendering', 'parameters': [
                {'name': 'layerAmplitude', 'type': 'v4', 'description': '', default: { x: 0.5, y: 0.4, z: 0.3, w: 0.125 }},
                {'name': 'layerScale', 'type': 'v4', 'description': '', default: { x: 0.5, y: 2.0, z: 3.0, w: 4.0 }},
                {'name': 'scale', 'type': 'v2', 'description': '', default: { x: 1.0, y: 1.0 }},
                {'name': 'offset', 'type': 'v2', 'description': '', default: { x: 0.0, y: 0.0 }}
              ]},

            },
            "script": SimplexNoiseGeneratorJS
          }
        },

        "Normal Map Generator" : {
          id: "normal_map_generator_component",
          name: "Normal Map Generator",
          type: "script",
          payload: {
            filter: ["renderTexture2D"],
            "description": ".",
            "category": "Rendering",
            "attributes": {
              "bumpTexture" : { "description": "", "type" : 'asset', "filter": { "renderTexture2D": true, "texture2D": true }, default: null },
              // "layerScale" : { "description": "", "type" : 'v4', default: { x: 0.5, y: 2.0, z: 3.0, w: 4.0 } },
              // "scale" : { "description": "", "type" : 'v2', default: { x: 1.0, y: 1.0 } },
              "smoothness" : { "description": "", "type" : 'f', "slider": true, default: 0.25, 'min': 0.0001, 'max': 1.0 },
              "spread" : { "description": "", "type" : 'f', "slider": true, default: 4, 'min': 1, 'max': 10 },
              "autoLoad" : { "description": "", "type" : 'b', default: true },
            },
            "events" : {
              "renderNormalMap" : {'scope': 'local', 'action': true, 'category': 'Rendering', 'parameters': []},
              // "changeNoiseValues" : {'scope': 'local', 'action': true, 'category': 'Rendering', 'parameters': [
              //   {'name': 'layerAmplitude', 'type': 'v4', 'description': '', default: { x: 0.5, y: 0.4, z: 0.3, w: 0.125 }},
              //   {'name': 'layerScale', 'type': 'v4', 'description': '', default: { x: 0.5, y: 2.0, z: 3.0, w: 4.0 }},
              //   {'name': 'scale', 'type': 'v2', 'description': '', default: { x: 1.0, y: 1.0 }},
              //   {'name': 'offset', 'type': 'v2', 'description': '', default: { x: 0.0, y: 0.0 }}
              // ]},

            },
            "script": NormalMapGeneratorJS
          }
        },
        
        "2D Text Renderer" : {
          id: "text_renderer_component",
          type: "script",
          payload : {
            "script": TextRendererJS
          }
        },

        "2D Text Label" : {
          id: "text_label_component",
          name: "2D Text Label",
          type: "script",
          payload: {
            filter: ["object"],
            "description": "Simply render some text to the screen using HTML.",
            "category": "Text",
            "attributes": {
              // "fontColor" : { default: 0xffffff, description: "Color for the font to be!", type: "c" },
              // "fontFamily": { default: "Calibri", description: "The font family to render", type: "s"},
              // "pointSize": { default: 32, description: "Font point size.", max: null, min: null, type: "i" },
              "text": { default: "2D Font Label", description: "The text to render", type: "s" },
              // "wrapWidth": { default: 100, description: "The number of characters to render before starting a new line.", type: "f" },
              // "billboard": { default: true, description: "Always make the text face the camera."}
            },
            "script": TextLabelJS
          }
        },

        "Orbit Camera" : {
          id: "orbit_camera_controller",
          name: "Orbit Camera Controller",
          type: "script",
          limitPerEntity: 1,
          payload: {
            "script": OrbitCameraControllerJS
          }
        },

        "Free Camera" : {
          id: "free_camera_controller",
          name: "Free Camera Controller",
          type: "script",
          limitPerEntity: 1,
          payload: {
            filter: ["camera"],
            "description": "",
            "category": "Camera Controllers",
            "attributes": {
              "inertialDamping" : { "default" : 0.20, "min" : 0.0, "max" : 1.0, "type" : "f" },
              "usePointerLock": { "description": "", "default": false, "type": "b"},
              "invertX": { "description": "", "default": false, "type": "b" },
              "invertY": {"description": "","default": false,"type": "b"},
              "invertZoom": { "description": "", "default": false, "type": "b" },
              "lookSpeed": { "description": "", "default": 1.0, "max": 1000, "min": 0.0001, "type": "f"},
              "movementSpeed": { "description": "", "default": 3, "max": 1000, "min": 0.0001, "type": "f" },
              "pitchAngleBounds": { "description": "","default": {"max": 75.0, "min": -75.0 }, "max": { "max": 90.0, "min": 90.0 }, "min": { "max": -90.0, "min": -90.001 }, "type": "v3" },
              "enablePan": { "description": "", "default": true, "type": "b" },
              "enableZoom": { "description": "", "default": true, "type": "b" },
              // "controlConfig": { "description": "The control configuration to use.", "type": "dd", "default" : "Verold", "options": { "Verold" : "Verold", "Unity3D" : "Unity3D", "UnrealEd" : "UnrealEd"}},
              // "customControlConfig": { "description": "Button and key mappings", "type": "json", "default": {
              //     "look" : [{ "buttons" : ["left"] } ],
              //     "pan" : [{ "buttons" : ["middle"] }, { "buttons" : ["left", "right"]} ],
              //     "zoomLook" : [{ "buttons": ["right"] }, {"keys" : ["ctrl"] }],
              //   }
              // }
            },
            "events" : {
              "enableFreeCameraController" : {'scope': 'local', 'parameters': []},
              "disableFreeCameraController" : {'scope': 'local', 'parameters': []},
              "toggleFreeCameraController" : {'scope': 'local', 'parameters': []},
              // "freeCameraLookAt" : {'scope': 'local', 'parameters': []},
            },
            "script": FreeCameraControllerJS
          },
        },

        "Skybox" : {
          id: "skybox_renderer",
          name: "Skybox",
          type: "script",
          payload: {
            filter: ["scene"],
            "description": "",
            "category": "Rendering",
            "attributes": {
              "size" : { "default" : 1000, "min" : 1.0, "max" : 100000.0, "type" : "f" },
              "skyboxTexture": { "description": "", "type": "asset",
                "filter": {
                  "textureCube": true,
                  "texture2D": true,
                  "renderTexture2D": true,
                  "renderTextureCube": true,
                }, "default": "white_cube"},
              "skyboxFogPower": { "description": "Controls the rate that fog decreases with height in the skybox.", "default": 0.8, "min": 0.0, "max": 1.0,"type": "f" },
              "skyboxFogScale": { "description": "Uniformly scales the amount of fog in the skybox.", "default": 0.5, "min": 0.0, "max": 1.0,"type": "f" },
            },
            "events" : {
              "setSkyboxTexture" : {'scope': 'local', 'action': true, 'parameters': [ {'name': 'texture', 'type': 'asset', 'filter': {
                "textureCube": true,
                "texture2D": true,
                "renderTexture2D": true,
                "renderTextureCube": true }, 'description': 'The new skybox texture to use.', 'default': null} ]},
            },
            "script": SkyboxRendererJS
          }
        },

        "Rotator" : {
          id: "rotate_component",
          name: "Rotator",
          type: "script",
          payload: {
            filter: ["object"],
            "script": RotateJS,
            "category": "Animation"
          }
        },

        "LookAt" : {
          id: "lookat_component",
          name: "Look At Target",
          type: "script",
          payload: {
            filter: ["object"],
            "description": "A component that automatically points the object at a target. This can be used for billboarding an object to the camera, making a character look at another, etc.",
            "category": "General",
            "attributes": {
              "target" : { "description": "The object that you want this object to point towards. e.g. for billboarding, this would be the camera used to render the scene.", "default": null, "type" : "object" },
              "local": { "description": "If toggled, whatever rotation you have already applied to this object will be taken into account.", "default": false, "type": "b"},
              "showPreview": { "description": "Run the lookAt in the editor.", "default": true, "type": "b"},
            },
            "script": LookAtJS
          }
        },

        "Object Picker" : {
          id: "object_picker",
          name: "Object Picker",
          type: "script",
          advanced: false,
          limitPerEntity: 1,
          payload: {
            filter: ["scene"],
            "description": "",
            "category": "General",
            "attributes": {
              "pickTrigger" : { 'type': 'dd', 'description': 'What mouse action will trigger the pick?', 'default': 'leftMouseClick', 'options': {
                'Left Mouse Click': 'leftMouseClick',
                'Middle Mouse Click': 'middleMouseClick',
                'Right Mouse Click': 'rightMouseClick',
                'Left Mouse Down': 'leftMouseDown',
                'Middle Mouse Down': 'middleMouseDown',
                'Right Mouse Down': 'rightMouseDown',
                'Left Mouse Up': 'leftMouseUp',
                'Middle Mouse Up': 'middleMouseUp',
                'Right Mouse Up': 'rightMouseUp',
              }},
              "enableHoverByDefault" : { 'type': 'b', 'default': false, 'advanced': true, 'description': 'Enable hover detection when mouse cursor is over a mesh. Note that this has a potential performance impact.' },
              "hoverFrameSkip" : { 'type': 'i', 'default': 1, 'description': 'Skip this many frames inbetween hover checks.', 'min': 0, 'max': 60 }
            },
            "events": {
              "pick": {'scope': 'other', 'action': false, 'category': 'General', 'parameters': []},
              "beginHover": {'scope': 'other', 'action': false, 'category': 'General', 'parameters': []},
              "endHover": {'scope': 'other', 'action': false, 'category': 'General', 'parameters': []},
            },

            "script": ObjectPickerJS
          }
        },

        "HMD Render Effect" : {
          id: "hmd_renderer_script",
          name: "HMD Effect",
          type: "script",
          limitPerEntity: 1,
          payload: {
            filter: ["camera"],
            "description": "Enables a head-mounted display effect (e.g. for Oculus Rift) on this camera.",
            "category": "Rendering",
            "attributes": {
              "interpupillaryDistance": { "description": "Distance between viewer's eyes (in metres).", "default": 0.064, "min": 0.05, "max": 0.1, type: "f" },
              "lensSeparationDistance": { "description": "Distance between lenses in head-mounted display (in metres)", "default": 0.064, "min": 0.05, "max": 0.1, "type": "f" },
              "eyeToScreenDistance": { "description": "Distance between eyes and screen in head-mounted display (in metres)", "default": 0.041, "min": 0.02, "max": 0.1, "type": "f" },
            },
            "events" : {
            },
            "script": HMDRenderEffectJS
          }
        },
      },

      //Advanced components are available when building a full application.
      this.advancedComponents = {

        "Mouse" : {
          id: "mouse_controller_component",
          name: "Mouse",
          type: "script",
          limitPerEntity: 1,
          advanced: true,
          payload: {
            filter: ["application"],
            "description": "",
            "category": "Input",
            "attributes": {

            },
            "events": {
              "mouse_down_left" : {'scope': 'global', 'action': false, 'parameters': []},
              "mouse_down_right" : {'scope': 'global', 'action': false, 'parameters': []},
              "mouse_down_middle" : {'scope': 'global', 'action': false, 'parameters': []},
              "mouse_up_left" : {'scope': 'global', 'action': false, 'parameters': []},
              "mouse_up_right" : {'scope': 'global', 'action': false, 'parameters': []},
              "mouse_up_middle" : {'scope': 'global', 'action': false, 'parameters': []}
            },
            "script": MouseControllerJS
          }
        },

        "Keyboard" : {
          id: "keyboard_controller_component",
          name: "Keyboard",
          type: "script",
          limitPerEntity: 1,
          advanced: true,
          payload: {
            filter: ["application"],
            "description": "",
            "category": "Input",
            "attributes": {

            },
            "events": {
              "keypress_a" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_b" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_c" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_d" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_e" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_f" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_g" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_h" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_i" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_j" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_k" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_l" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_m" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_n" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_o" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_p" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_q" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_r" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_s" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_t" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_u" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_v" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_w" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_x" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_y" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_z" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_up_arrow" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_down_arrow" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_left_arrow" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_right_arrow" : {'scope': 'global', 'action': false, 'parameters': []},
              "keypress_space" : {'scope': 'global', 'action': false, 'parameters': []}
            },
            "script": KeyboardControllerJS
          }
        },

        "Debug Texture Render" : {
          id: "debug_texture_render",
          name: "Debug Texture Render",
          type: "script",
          payload: {
            filter: ["texture2D", "renderTexture2D"],
            "description": "",
            "category": "Debug",
            "attributes": {
              "viewportLeft" : { "description": "Left position of the viewport to be rendered by this camera.", type: "s", "default" : "0px" },
              "viewportBottom" : { "description": "Bottom position of the viewport to be rendered by this camera.", type: "s", "default" : "0px" },
              "viewportWidth" : { "description": "Width of the viewport to be rendered by this camera.", type: "s", "default" : "100%" },
              "viewportHeight" : { "description": "Height of the viewport to be rendered by this camera.", type: "s", "default" : "100%" },
              "renderGroup" : { "description": "Render passes are done in order, based on the 'render group' value. Lower numbers render first.", type: "i", default: 0 },
              // bottom, left, and scale
              // "texture2D" : { "description": "", type: "asset", "filter": { "renderTexture2D": true, "texture2D": true }, default: null },
            },
            "script": DebugTextureRenderJS,

          }
        },

      };

    };

    ScriptRegistry.addScript = function(id, options, constructionScript) {
      globalUserScripts[id] = { options: options, constructionScript: constructionScript };
    };

    ScriptRegistry.prototype = {

      constructor: ScriptRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.projectId = properties.projectId;
        this.veroldEngine = properties.veroldEngine;

        this.veroldEngine.globalEvents.on('VAPI:addScript', this.addScript, this);
      },

      uninitialize: function() {
        
        this.veroldEngine.globalEvents.off('VAPI:addScript', this.addScript, this);
        _.each( this.assets, function( asset, id ) {
          asset.uninitialize();
          delete this.assets[ id ];
        }, this );
        this.assets = undefined;
        this.veroldEngine = undefined;
        this.projectId = undefined;
      },

      addScript: function(id, options, constructionScript) {
        if (arguments.length === 2) {
          constructionScript = options;
          options = {};
        }

        options = options || {};

        var scriptText = constructionScript.toString();

        // Replace the outer function wrapper, as we sub in a more performant version with arguments
        scriptText = scriptText.replace(/^function.*\{/, '');
        scriptText = scriptText.replace(/\}\s*$/, '');

        var componentDef = {
          id: id,
          name: options.name,
          type: 'script',
          payload: {
            description: options.description,
            category: options.category,
            filter: options.filter,
            script: scriptText
          }
        };

        this.veroldEngine.assetRegistry.createAsset( componentDef, {
            success: function( scriptAsset ) {
              scriptAsset.entityModel.filter = options.filter;
              scriptAsset.entityModel.limitPerEntity = options.limitPerEntity;
              scriptAsset.entityModel.isAdvanced = _.isUndefined(options.isAdvanced) ? false : options.isAdvanced;
              scriptAsset.entityModel.isBuiltIn = _.isUndefined(options.isBuiltIn) ? true : options.isBuiltIn;
              scriptAsset.entityModel.isReserved = _.isUndefined(options.isReserved) ? true : options.isReserved;
              scriptAsset.entityModel.isPersistent = _.isUndefined(options.isPersistent) ? false : options.isPersistent;
            }
          });
      },

      initSystemAssets: function() {
        _.each( this.advancedComponents, function( componentDef ) {
          if ( this.veroldEngine.isPrimaryEngine() ) {
            this.veroldEngine.assetRegistry.createAsset( componentDef, {
              success: function( scriptAsset ) {
                scriptAsset.entityModel.filter = componentDef.filter;
                scriptAsset.entityModel.isAdvanced = true;
                scriptAsset.entityModel.isBuiltIn = true;
                scriptAsset.entityModel.limitPerEntity = componentDef.limitPerEntity;
                scriptAsset.entityModel.alwaysOn = componentDef.alwaysOn;
              }
            } );
          }
        }, this );

        _.each( this.simpleComponents, function( componentDef ) {
          if ( this.veroldEngine.isPrimaryEngine() ) {
            this.veroldEngine.assetRegistry.createAsset( componentDef, {
              success: function( scriptAsset ) {
                scriptAsset.entityModel.filter = componentDef.filter;
                scriptAsset.entityModel.isAdvanced = false;
                scriptAsset.entityModel.isBuiltIn = true;
                scriptAsset.entityModel.limitPerEntity = componentDef.limitPerEntity;
                scriptAsset.entityModel.alwaysOn = componentDef.alwaysOn;
              }
            } );
          }
        }, this );

        _.each( this.reservedComponents, function( componentDef ) {
          if ( this.veroldEngine.isPrimaryEngine() ) {
            this.veroldEngine.assetRegistry.createAsset( componentDef, {
              success: function( scriptAsset ) {
                scriptAsset.entityModel.isReserved = true;
                scriptAsset.entityModel.filter = componentDef.filter;
                scriptAsset.entityModel.isBuiltIn = true;
                scriptAsset.entityModel.isAdvanced = componentDef.advanced ? true : false;
                scriptAsset.entityModel.limitPerEntity = componentDef.limitPerEntity;
                scriptAsset.entityModel.alwaysOn = componentDef.alwaysOn;
              }
            } );
          }
        }, this );

        _.each( globalUserScripts, function(globalScript, id) {
          this.addScript(id, globalScript.options, globalScript.constructionScript);
        }, this );
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      // getAllAssets: function( options ) {
      //   if ( options && options.filter ) {
      //     var newOptions = { filter: {} };
      //     _.extend( newOptions.filter, options.filter, { 'script': true } );
      //     return this.veroldEngine.assetRegistry.getAllAssets( newOptions );
      //   }
      //   if ( options && options.autoLoad ) {
      //     for ( var x in this.assets ) {
      //       if ( this.assets[ x ].state_base === "pending" ) {
      //         this.assets[ x ].load( options );
      //       }
      //     }
      //   }
      //   return this.assets;
      // },

      //Returns the asset specified. null if invalid
      //options
        //autoLoad - boolean that's set to true to make this call automatically load the asset's data
        //success - callback on successful load of the data. Not valid if autoLoad is false
        //failure - callback on failure while loading the data. Not valid if autoLoad is false
        //progress - callback on loading progress. Not valid if autoLoad is false
      // getAsset: function( assetID, options ) {
      //   return this.veroldEngine.assetRegistry.getAsset( assetID, options );
      // },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {

        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {
        if (!entityModel) { console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model."); }

        var newAsset = new ScriptAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;

      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
        this.veroldEngine.trigger("scriptDeleted", assetID );
      },

      update: function( delta ) {

      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

      find: function(properties) {
        var matches = [];

        _.filter(this.assets, function(asset) {
          var match = true;
          _.each(properties, function(v, path) {
            if (asset.entityModel.get(path) !== v) {
              match = false;
            }
          }, this);
          if (match) {
            matches.push(asset);
          }
        }, this);

        return matches;
      }
    };

    VAPI.ScriptRegistry = ScriptRegistry;

    return ScriptRegistry;
  });

define(
  'VeroldEngine/AssetRegistry/FragmentShaderAsset',[
    'underscore',
    'VeroldEngine/AssetRegistry/VeroldAsset'
  ],
  function(_, VeroldAsset) {
    var FragmentShaderAsset = function(properties) {
      VeroldAsset.call(this);
    };

    FragmentShaderAsset.prototype = new VeroldAsset();

    _.extend(FragmentShaderAsset.prototype, {

      update: function() {
      }
    });

    window.VAPI = window.VAPI || {};
    window.VAPI.FragmentShaderAsset = FragmentShaderAsset;

    return FragmentShaderAsset;
  });


define(
  'VeroldEngine/AssetRegistry/VertexShaderAsset',[
    'underscore',
    'VeroldEngine/AssetRegistry/VeroldAsset'
  ],
  function(_, VeroldAsset) {
    var VertexShaderAsset = function(properties) {
      VeroldAsset.call(this);
    };

    VertexShaderAsset.prototype = new VeroldAsset();

    _.extend(VertexShaderAsset.prototype, {

      update: function() {
      }
    });

    window.VAPI = window.VAPI || {};
    window.VAPI.VertexShaderAsset = VertexShaderAsset;

    return VertexShaderAsset;
  });


define('VeroldEngine/AssetRegistry/ShaderRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/FragmentShaderAsset'
       , 'VeroldEngine/AssetRegistry/VertexShaderAsset'

  ],
  function(_, THREE, ShaderAsset ) {

    var ShaderRegistry = function( properties ) {
      this.assets = undefined;
    };

    ShaderRegistry.prototype = {

      constructor: ShaderRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.projectId = properties.projectId;
        this.veroldEngine = properties.veroldEngine;

      },

      uninitialize: function() {

        _.each( this.assets, function( asset, id ) {
          asset.uninitialize();
          delete this.assets[ id ];
        }, this );
        this.assets = undefined;
        this.veroldEngine = undefined;
        this.projectId = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      // getAllAssets: function( options ) {
      //   if ( options && options.filter ) {
      //     var newOptions = { filter: {} };
      //     _.extend( newOptions.filter, options.filter, { 'video': true } );
      //     return this.veroldEngine.assetRegistry.getAllAssets( newOptions );
      //   }
      //   if ( options && options.autoLoad ) {
      //     for ( var x in this.assets ) {
      //       if ( this.assets[ x ].state_base === "pending" ) {
      //         this.assets[ x ].load( options );
      //       }
      //     }
      //   }
      //   return this.assets;
      // },

      //Returns the asset specified. null if invalid
      //options
        //autoLoad - boolean that's set to true to make this call automatically load the asset's data
        //success - callback on successful load of the data. Not valid if autoLoad is false
        //failure - callback on failure while loading the data. Not valid if autoLoad is false
        //progress - callback on loading progress. Not valid if autoLoad is false
      // getAsset: function( assetID, options ) {
      //   return this.veroldEngine.assetRegistry.getAsset( assetID, options );
      // },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {

        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) { console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model."); }

        var newAsset = new ShaderAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;
      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
        this.veroldEngine.trigger("shaderDeleted", assetID );
      },

      update: function( delta ) {

      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    };

    return ShaderRegistry;
  });

define(
  'VeroldEngine/AssetRegistry/HTMLAsset',[
    'underscore',
    'VeroldEngine/AssetRegistry/VeroldAsset'
  ],
  function(_, VeroldAsset) {
    var HTMLAsset = function(properties) {
      VeroldAsset.call(this);
    };

    HTMLAsset.prototype = new VeroldAsset();

    _.extend(HTMLAsset.prototype, {

      update: function() {
      }
    });

    window.VAPI = window.VAPI || {};
    window.VAPI.HTMLAsset = HTMLAsset;

    return HTMLAsset;
  });


define('VeroldEngine/AssetRegistry/HTMLRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/HTMLAsset'

  ],
  function(_, THREE, HTMLAsset ) {

    var HTMLRegistry = function( properties ) {
      this.assets = undefined;
    };

    HTMLRegistry.prototype = {

      constructor: HTMLRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.projectId = properties.projectId;
        this.veroldEngine = properties.veroldEngine;

      },

      uninitialize: function() {

        _.each( this.assets, function( asset, id ) {
          asset.uninitialize();
          delete this.assets[ id ];
        }, this );
        this.assets = undefined;
        this.veroldEngine = undefined;
        this.projectId = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      // getAllAssets: function( options ) {
      //   if ( options && options.filter ) {
      //     var newOptions = { filter: {} };
      //     _.extend( newOptions.filter, options.filter, { 'video': true } );
      //     return this.veroldEngine.assetRegistry.getAllAssets( newOptions );
      //   }
      //   if ( options && options.autoLoad ) {
      //     for ( var x in this.assets ) {
      //       if ( this.assets[ x ].state_base === "pending" ) {
      //         this.assets[ x ].load( options );
      //       }
      //     }
      //   }
      //   return this.assets;
      // },

      //Returns the asset specified. null if invalid
      //options
        //autoLoad - boolean that's set to true to make this call automatically load the asset's data
        //success - callback on successful load of the data. Not valid if autoLoad is false
        //failure - callback on failure while loading the data. Not valid if autoLoad is false
        //progress - callback on loading progress. Not valid if autoLoad is false
      // getAsset: function( assetID, options ) {
      //   return this.veroldEngine.assetRegistry.getAsset( assetID, options );
      // },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {

        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) { console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model."); }

        var newAsset = new HTMLAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;

       // entityModel.trigger( "registered", this );
      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
        this.veroldEngine.trigger("htmlDeleted", assetID );
      },

      update: function( delta ) {

      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    };

    return HTMLRegistry;
  });

define(
  'VeroldEngine/AssetRegistry/CSSAsset',[
    'underscore',
    'VeroldEngine/AssetRegistry/VeroldAsset'
  ],
  function(_, VeroldAsset) {
    var CSSAsset = function(properties) {
      VeroldAsset.call(this);
    };

    CSSAsset.prototype = new VeroldAsset();

    _.extend(CSSAsset.prototype, {

      update: function() {
      }
    });

    window.VAPI = window.VAPI || {};
    window.VAPI.CSSAsset = CSSAsset;

    return CSSAsset;
  });


define('VeroldEngine/AssetRegistry/CSSRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/CSSAsset'

  ],
  function(_, THREE, CSSAsset ) {

    var CSSRegistry = function( properties ) {
      this.assets = undefined;
    };

    CSSRegistry.prototype = {

      constructor: CSSRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.projectId = properties.projectId;
        this.veroldEngine = properties.veroldEngine;

      },

      uninitialize: function() {

        _.each( this.assets, function( asset, id ) {
          asset.uninitialize();
          delete this.assets[ id ];
        }, this );
        this.assets = undefined;
        this.veroldEngine = undefined;
        this.projectId = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      // getAllAssets: function( options ) {
      //   if ( options && options.filter ) {
      //     var newOptions = { filter: {} };
      //     _.extend( newOptions.filter, options.filter, { 'video': true } );
      //     return this.veroldEngine.assetRegistry.getAllAssets( newOptions );
      //   }
      //   if ( options && options.autoLoad ) {
      //     for ( var x in this.assets ) {
      //       if ( this.assets[ x ].state_base === "pending" ) {
      //         this.assets[ x ].load( options );
      //       }
      //     }
      //   }
      //   return this.assets;
      // },

      //Returns the asset specified. null if invalid
      //options
        //autoLoad - boolean that's set to true to make this call automatically load the asset's data
        //success - callback on successful load of the data. Not valid if autoLoad is false
        //failure - callback on failure while loading the data. Not valid if autoLoad is false
        //progress - callback on loading progress. Not valid if autoLoad is false
      // getAsset: function( assetID, options ) {
      //   return this.veroldEngine.assetRegistry.getAsset( assetID, options );
      // },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {

        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) { console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model."); }

        var newAsset = new CSSAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;

      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
        this.veroldEngine.trigger("cssDeleted", assetID );
      },

      update: function( delta ) {

      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    };

    return CSSRegistry;
  });

/*jslint browser: true, indent: 2, nomen: true*/
/*global define*/


define('VeroldEngine/AssetRegistry/AudioAsset',[
  'underscore',
  'VeroldEngine/AssetRegistry/VeroldAsset',
  'VeroldEngine/Loaders/MediaLoader'
], function (_, VeroldAsset, MediaLoader) {
  var AudioAsset = function () {
    VeroldAsset.call(this);
  };

  AudioAsset.prototype = new VeroldAsset();

  _.extend(AudioAsset.prototype, {
    uninitialize: function () {
      if (this.threeData) {
        // TODO: should we be doing more here?
        this.threeData.pause();
      }

      VeroldAsset.prototype.uninitialize.call(this);
    },

    _loadThreeData: function (changes, options) {
      var that = this,
        json = this.entityModel.toJSON(),
        loader = new MediaLoader(),
        paths;

      function _onAudioLoaded(audio) {
        var payload = that.entityModel.get('payload');

        console.log('Audio ready to play:', json.name);

        that.threeData = audio;

        // Play/pause the audio, based on autoPlay.
        payload.state = payload.autoPlay ? 'play' : 'pause';

        that.applyPayloadSettings_loaded(changes.payload, options);

        that.trigger('load_progress', that);
        that.trigger('load_base', that);
      }

      changes.payload.loop = true;
      changes.payload.state = true;

      paths = this.getResources({ sampleRate: 44100 });
      loader.loadAudio(paths, _onAudioLoaded);

      console.log('Loading audio:', json.name);
    },

    applyPayloadSettings_loaded: function (changes) {
      if (this.threeData && changes) {
        var payload = this.entityModel.get('payload');

        if (changes.loop) {
          this.threeData.loop = payload.loop;
        }

        if (changes.state) {
          switch (payload.state) {
          case 'pause':
            this.threeData.pause();
            break;

          case 'play':
            this.threeData.play();
            break;
          }
        }
      }
    },

    /**
     * Returns an array of resources that match the provided filters.
     * @method getResources
     * @param  {object} filters An object with properties to filter by
     * @return {array} Array of resources that match the filters
     */
    getResources: function (filters) {
      var resources = this.entityModel.getResources();

      filters = filters || {};

      if (filters.sampleRate !== undefined) {
        resources = _.filter(resources, function (resource) {
          return resource.properties.sampleRate === filters.sampleRate;
        });
      }

      return resources;
    }
  });

  window.VAPI = window.VAPI || {};
  window.VAPI.AudioAsset = AudioAsset;

  return AudioAsset;
});


/**
 * VAPI
 */
define('VeroldEngine/AssetRegistry/AudioRegistry',[ 'underscore'
       , 'VeroldEngine/AssetRegistry/AudioAsset'

  ],
  function(_, AudioAsset ) {

    /**
     * Audio is registered and managed here
     * @class AudioRegistry
     * @param {Object} properties Audio Manager properties 
     * @constructor
     */
    var AudioRegistry = function( properties ) {
      this.assets = undefined;
    };

    AudioRegistry.prototype = {

      constructor: AudioRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.projectId = properties.projectId;
        this.veroldEngine = properties.veroldEngine;

      },

      uninitialize: function() {

        _.each( this.assets, function( asset, id ) {
          asset.uninitialize();
          delete this.assets[ id ];
        }, this );
        this.assets = undefined;
        this.veroldEngine = undefined;
        this.projectId = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      // getAllAssets: function( options ) {
      //   if ( options && options.filter ) {
      //     var newOptions = { filter: {} };
      //     _.extend( newOptions.filter, options.filter, { 'audio': true } );
      //     return this.veroldEngine.assetRegistry.getAllAssets( newOptions );
      //   }
      //   if ( options && options.autoLoad ) {
      //     for ( var x in this.assets ) {
      //       if ( this.assets[ x ].state_base === "pending" ) {
      //         this.assets[ x ].load( options );
      //       }
      //     }
      //   }
      //   return this.assets;
      // },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {

        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) { console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model."); }

        var newAsset = new AudioAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;
      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
        this.veroldEngine.trigger("audioDeleted", assetID );
      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    };

    return AudioRegistry;
  });

define('VeroldEngine/AssetRegistry/VideoAsset',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/VeroldAsset'

  ],
  function(_, THREE, VeroldAsset ) {
    var VideoAsset = function( properties ) {
      VeroldAsset.call( this );
    };

    VideoAsset.prototype = new VeroldAsset();

    _.extend( VideoAsset.prototype, {

      initialize: function( properties ) {
        VeroldAsset.prototype.initialize.call( this, properties);
      },

      update: function() {
      }
    });
    
    window.VAPI.VideoAsset = VideoAsset;

    return VideoAsset;
  });

define('VeroldEngine/AssetRegistry/VideoRegistry',[ 'underscore'
       , 'three'
       , 'VeroldEngine/AssetRegistry/VideoAsset'

  ],
  function(_, THREE, VideoAsset ) {

    var VideoRegistry = function( properties ) {
      this.assets = undefined;
    };

    VideoRegistry.prototype = {

      constructor: VideoRegistry,

      initialize: function( properties ) {
        this.assets = {};
        this.projectId = properties.projectId;
        this.veroldEngine = properties.veroldEngine;

      },

      uninitialize: function() {

        _.each( this.assets, function( asset, id ) {
          asset.uninitialize();
          delete this.assets[ id ];
        }, this );
        this.assets = undefined;
        this.veroldEngine = undefined;
        this.projectId = undefined;
      },

      _initAssetDependencies: function() {
        _.each( this.assets, function( asset, id ) {
          asset._initDependenciesList();
        }, this );
      },

      // _initAssetDataSizes: function() {
      //   _.each( this.assets, function( asset, id ) {
      //     asset.update_dataSize_hierarchy();

      //   }, this );
      // },

      /**
       * Returns the asset with the provided Id, if it exists in the current asset.
       * @method getAssetById
       * @param  {String} assetId The ID of the object
       * @return {object} The asset or null if not found.
       */
      getAssetById: function( assetID ) {
        return this.veroldEngine.assetRegistry.getAssetById.call( this, assetID );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters ) {
        return this.veroldEngine.assetRegistry.getAssets.call( this, filters, this.assets );
      },

      // getAllAssets: function( options ) {
      //   if ( options && options.filter ) {
      //     var newOptions = { filter: {} };
      //     _.extend( newOptions.filter, options.filter, { 'video': true } );
      //     return this.veroldEngine.assetRegistry.getAllAssets( newOptions );
      //   }
      //   if ( options && options.autoLoad ) {
      //     for ( var x in this.assets ) {
      //       if ( this.assets[ x ].state_base === "pending" ) {
      //         this.assets[ x ].load( options );
      //       }
      //     }
      //   }
      //   return this.assets;
      // },

      //Returns the asset specified. null if invalid
      //options
        //autoLoad - boolean that's set to true to make this call automatically load the asset's data
        //success - callback on successful load of the data. Not valid if autoLoad is false
        //failure - callback on failure while loading the data. Not valid if autoLoad is false
        //progress - callback on loading progress. Not valid if autoLoad is false
      // getAsset: function( assetID, options ) {
      //   return this.veroldEngine.assetRegistry.getAsset( assetID, options );
      // },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {

        this.veroldEngine.assetRegistry.createAsset( json, options );
      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        this.veroldEngine.assetRegistry.destroyAsset( assetID, options );
      },

      registerEntityAsAsset: function( entityModel ) {

        if (!entityModel) { console.error( this.veroldEngine.engineName + " - Trying to create an asset with no backbone model."); }

        var newAsset = new VideoAsset();
        newAsset.initialize( {
          entityModel: entityModel,
          veroldEngine: this.veroldEngine,
          projectId: this.veroldEngine.assetRegistry.projectId,
          registry: this,
        });

        this.veroldEngine.assetRegistry.assets[ newAsset.id ] = newAsset;
        this.veroldEngine.entities[ newAsset.id ] = newAsset;
        this.assets[ newAsset.id ] = newAsset;

       // entityModel.trigger( "registered", this );
      },

      unregisterEntityAsAsset: function( assetID ) {
        this.veroldEngine.assetRegistry.unregisterEntityAsAsset( assetID );
        delete this.assets[ assetID ];
        this.veroldEngine.trigger("videoDeleted", assetID );
      },

      update: function( delta ) {

      },

      set: function( json, options ) {
        this.veroldEngine.assetRegistry.set( json, options );
      },

      unset: function( json, options ) {
        this.veroldEngine.assetRegistry.unset( json, options );
      },

    };

    return VideoRegistry;
  });

/**
 * @module VAPI
 */
define('VeroldEngine/AssetRegistry/AssetRegistry',[ 'underscore'
       , 'three'
       , 'async'
       , 'VeroldEngine/models/entity'
       , 'VeroldEngine/libs/uuid'
       , 'VeroldEngine/AssetRegistry/ApplicationRegistry'
       , 'VeroldEngine/AssetRegistry/SceneRegistry'
       , 'VeroldEngine/AssetRegistry/PrefabRegistry'
       , 'VeroldEngine/AssetRegistry/GeometryRegistry'
       , 'VeroldEngine/AssetRegistry/MaterialRegistry'
       , 'VeroldEngine/AssetRegistry/TextureRegistry'
       , 'VeroldEngine/AssetRegistry/AnimationRegistry'
       , 'VeroldEngine/AssetRegistry/PoseRegistry'
       , 'VeroldEngine/AssetRegistry/ScriptRegistry'
       , 'VeroldEngine/AssetRegistry/ShaderRegistry'
       , 'VeroldEngine/AssetRegistry/HTMLRegistry'
       , 'VeroldEngine/AssetRegistry/CSSRegistry'
       , 'VeroldEngine/AssetRegistry/AudioRegistry'
       , 'VeroldEngine/AssetRegistry/VideoRegistry'
  ],
  function(_, THREE, async, EntityModel, uuid, ApplicationRegistry, SceneRegistry, PrefabRegistry, 
    GeometryRegistry, MaterialRegistry, TextureRegistry, AnimationRegistry, PoseRegistry, 
    ScriptRegistry, ShaderRegistry, HTMLRegistry, CSSRegistry, AudioRegistry, VideoRegistry ) {
    /**
     * All assets that exist in the project are accessible, created and destroyed here.
     * This is where you'll want to retrieve any and all assets from
     * @class AssetRegistry
     * @param {Object} properties  Asset Registry properties
     * @constructor
     */
    var AssetRegistry = function( properties ) {
      this.assets = undefined;
      this.veroldEngine = undefined;
      this.entityCollection = undefined;
      this.Scripts = new ScriptRegistry( properties );
      this.Applications = new ApplicationRegistry( properties );
      this.Scenes = new SceneRegistry( properties );
      this.Prefabs = new PrefabRegistry( properties );
      this.Models = this.Prefabs;
      this.Geometries = new GeometryRegistry( properties );
      this.Materials = new MaterialRegistry( properties );
      this.Textures = new TextureRegistry( properties );
      this.Animations = new AnimationRegistry( properties );
      this.Poses = new PoseRegistry( properties );
      this.Audio = new AudioRegistry( properties );
      this.Video = new VideoRegistry( properties );
      this.HTML = new HTMLRegistry( properties );
      this.CSS = new CSSRegistry( properties );
      this.Shaders = new ShaderRegistry( properties );
      this.waitingForEntities = {};
    };

    AssetRegistry.prototype = {

      constructor: AssetRegistry,

      initialize: function( properties, callback ) {
        //console.time("AssetRegistry Initialization");
        var that = this;
        this.assets = {};
        this.veroldEngine = properties.veroldEngine;

        //Initialize the asset collection
        this.entityCollection = properties.entities;

        this.Scripts.initialize( properties );
        this.Textures.initialize( properties );
        this.Materials.initialize( properties );
        this.Applications.initialize( properties );
        this.Scenes.initialize( properties );
        this.Prefabs.initialize( properties );
        //this.Models.initialize( properties );
        this.Geometries.initialize( properties );
        this.Animations.initialize( properties );
        this.Poses.initialize( properties );
        this.Audio.initialize( properties );
        this.Video.initialize( properties );
        this.CSS.initialize( properties ); 
        this.HTML.initialize( properties );
        this.Shaders.initialize( properties );

        if ( this.entityCollection ) {
          this.entityCollection.on( "reset", this.onEntityCollectionReset, this );
          this.entityCollection.on( "add", this.onEntityAssetAdded, this );
          this.entityCollection.on( "remove", this.onEntityAssetRemoved, this );
        }

        //Initialize scripts first so that other assets can use them
        //console.time("_initProjectScriptAssets");
        this._initProjectScriptAssets(properties.entities);
        this.Scripts.initSystemAssets();
        //console.timeEnd("_initProjectScriptAssets");

        setTimeout( function() {
          //console.time("_initProjectAssets");
          that._initProjectAssets(properties.entities);
          //console.timeEnd("_initProjectAssets");
          setTimeout( function() {
            //console.time("_initProjectObjects");
            that._initProjectObjects(properties.entities);
            //console.timeEnd("_initProjectObjects");
            setTimeout( function() {
              //console.time("initSystemAssets");
              that.Materials.initSystemAssets();
              that.Scenes.initSystemAssets();
              that.Prefabs.initSystemAssets();
              //console.timeEnd("initSystemAssets");

              //console.time("_initAssetDependencies");
              that._initAssetDependencies();
              //console.timeEnd("_initAssetDependencies");

              //console.time("_initComponents");
              that._initComponents();
              //console.timeEnd("_initComponents");

              that.veroldEngine.globalEvents.on('remoteScene:saveEntity', that.onRemoteEntitySave, that );
              that.veroldEngine.globalEvents.on('remoteScene:removeEntity', that.onRemoteEntityDelete, that );
              //console.timeEnd("AssetRegistry Initialization");
              if ( typeof callback === 'function' ) {
                callback();
              }
            }, 0 );
          }, 0 );
        }, 0 );
      },

      uninitialize: function() {

        console.log( this.veroldEngine.engineName + " - Uninitializing AssetRegistry." );
        
        this.Scenes.uninitialize();
        this.Scenes = undefined;
        this.Prefabs.uninitialize();
        this.Prefabs = undefined;
        this.Models = undefined;
        this.Geometries.uninitialize();
        this.Geometries = undefined;
        this.Materials.uninitialize();
        this.Materials = undefined;
        this.Textures.uninitialize();
        this.Textures = undefined;
        this.Animations.uninitialize();
        this.Animations = undefined;
        this.Poses.uninitialize();
        this.Poses = undefined;
        this.Audio.uninitialize();
        this.Audio = undefined;
        this.Video.uninitialize();
        this.Video= undefined;
        this.CSS.uninitialize();
        this.CSS = undefined;
        this.HTML.uninitialize();
        this.HTML = undefined;
        this.Shaders.uninitialize();
        this.Shaders = undefined;
        this.Applications.uninitialize();
        this.Applications = undefined;
        this.Scripts.uninitialize();
        this.Scripts = undefined;
        
        if ( this.entityCollection ) {
          this.entityCollection.off( "reset", this.onEntityCollectionReset, this );
          this.entityCollection.off( "add", this.onEntityAssetAdded, this );
          this.entityCollection.off( "remove", this.onEntityAssetRemoved, this );
          this.entityCollection = undefined;
        }

        this.veroldEngine.globalEvents.off('remoteScene:saveEntity', this.onRemoteEntitySave, this );
        this.veroldEngine.globalEvents.off('remoteScene:removeEntity', this.onRemoteEntityDelete, this );

        _.each( this.assets, function( asset, id ) {
          delete this.assets[ id ];
        }, this );

        this.assets = undefined;
        this.veroldEngine = undefined;
      },

      _initProjectScriptAssets: function(collection) {
        for ( var x = 0; x < collection.models.length; x++ ) {
          var entityModel = collection.models[x];
          //Some models could already have been added to the collection through the
          //initialization process of the other asset registries. So, if the asset
          //already seems to exist, we'll just skip it.
          if ( entityModel.get("type") === "script" ) {
            var newName = this.generateUniqueAssetName( entityModel.get("name") );
            entityModel.set({"name" : newName}, {silent: true});
            var registry = this.getRegistryByType( entityModel.get("type"));
            if ( registry ) {
              registry.registerEntityAsAsset( entityModel );
            }
          }
        }
      },

      _initProjectAssets: function(collection) {
        for ( var x = 0; x < collection.models.length; x++ ) {
          var entityModel = collection.models[x];
          //Some models could already have been added to the collection through the
          //initialization process of the other asset registries. So, if the asset
          //already seems to exist, we'll just skip it.
          if ( entityModel.isAsset() && !this.assets[ entityModel.get("id") ] && entityModel.get("type") !== 'folder') {
            var newName = this.generateUniqueAssetName( entityModel.get("name") );
            entityModel.veroldEngine = this.veroldEngine;
            entityModel.set({"name" : newName}, {silent: true});
            var registry = this.getRegistryByType( entityModel.get("type"));
            if ( registry ) {
              registry.registerEntityAsAsset( entityModel );
            }
          }
        }
      },

      _initProjectObjects: function(collection) {

        //Build a temporary structure to allow fast access to asset entities
        var tmpAssetList = {};
        var entityModel;
        var x;
        for ( x = 0; x < collection.models.length; x++ ) {
          entityModel = collection.models[ x ];
          if ( entityModel.isAsset() ) {
            tmpAssetList[ entityModel.get("id") ] = entityModel;
          }
        }

        //Go through the entire list of entities and add sub entities to their parent asset
        var tmpObjectList = [];
        for ( x = 0; x < collection.models.length; x++ ) {
          entityModel = collection.models[ x ];

          if ( !entityModel.isAsset() ) {
            entityModel.veroldEngine = this.veroldEngine;
            var parentAsset = tmpAssetList[ entityModel.get("parentAssetId") ];
            if ( parentAsset ) {
              tmpObjectList.push( entityModel );
              parentAsset.subEntities.add( entityModel );
              entityModel.collection = parentAsset.subEntities;
            }
            else {
              console.warn("The parent asset, " + entityModel.get("parentAssetId") + ", of entity, " + entityModel.id + ", doesn't exist." );
              if ( this.veroldEngine.isWritable ) {
                entityModel.destroy({silent: true, save: true});
              }
            }
          }
        }

        //Remove sub entities from the main asset collection
        for ( x = 0; x < tmpObjectList.length; x++ ) {
          collection.remove( tmpObjectList[x], {silent: true} );
        }

        tmpAssetList = null;
        tmpObjectList = null;
      },

      _initAssetDependencies: function() {
        this.Textures._initAssetDependencies( );
        this.Audio._initAssetDependencies( );
        this.Video._initAssetDependencies( );
        this.Materials._initAssetDependencies( );
        this.Prefabs._initAssetDependencies( );
        this.Geometries._initAssetDependencies( );
        this.Animations._initAssetDependencies( );
        this.Poses._initAssetDependencies( );
        this.Scripts._initAssetDependencies( );
        this.Scenes._initAssetDependencies();
        this.Applications._initAssetDependencies();
        this.HTML._initAssetDependencies();
        this.CSS._initAssetDependencies();
        this.Shaders._initAssetDependencies();
      },

      _initComponents: function() {
        _.each( this.assets, function( asset, id ) {
          asset.initializeComponents();
          _.each( asset.objects, function( obj, id ) {
            obj.initializeComponents();
          }, this );
        }, this );
      },

      
      /**
       * Returns the asset with the provided Id.
       * @method getAssetById
       * @param  {String} assetId The ID of the asset.
       * @return {Object} The asset or null if not found.
       */
      getAssetById: function( assetId ) {

        if ( this.assets[ assetId ] ) {
          return this.assets[ assetId ];
        }
        return null;
      },

      /**
       * Returns the first asset found with the provided name, if it exists.
       * Note: Care should be taken when calling this function often (such as every frame)
       * because it is not build for high performance.
       * @method getAssetByName
       * @param  {String} assetName The name of the asset
       * @return {Object} The asset, if found, or null if not found.
       */
      getAssetByName: function( assetName ) {
        var results = this.getAssets( { name: assetName } );
        if ( results && results.length ) {
          return results[0];
        }
        else {
          return null;
        }
      },

      /**
       * Returns all assets found with the provided name, if they exist.
       * Note: Care should be taken when calling this function often (such as every frame)
       * because it is not build for high performance.
       * @method getAssetsByName
       * @param  {String} assetName The name of the asset
       * @return {Array} The assets with the matching name.
       */
      getAssetsByName: function( assetName ) {
        return this.getAssets( { name: assetName } );
      },

      /**
       * Returns an array of assets that match any of the provided filters.
       * @method getAssets
       * @param  {object} filters An object with keys to match. Keys can be 'name' or 'type' and
       * can be either single options or arrays of multiple values to match.
       * @return {array} Array of assets that match at least one of the querries
       */
      getAssets: function( filters, registryArray ) {
        var registry = registryArray ? registryArray : this.assets;
        if ( _.isObject( filters ) ) {
          var results = [];
          _.each( registry, function( asset, id ) {
            if ( asset.isMatch( filters ) ) {
              results.push( asset );
            }
          }, this );
          return results;
        }
        else {
          return registry;
        }
      },

      /**
       * Creates a new asset and stores it in the registry.
       * @method createAsset
       * @param  {Object} json    The definition of the asset. Needs to at least include and "id" and a "type" (e.g. "material", "prefab", etc.)
       * @param  {Object} options The standard options object.
       */
      createAsset: function( json, options ) {

        if ( !options ) { options = {}; }
        var failMessage;
        if ( !json.id && !options.persistent ) {
          failMessage = this.veroldEngine.engineName + " - AssetRegistry.createAsset : You must specify a unique id for non-persistent assets.";
        }
        var registry = this.getRegistryByType( json.type );
        if ( !registry ) {
          failMessage = this.veroldEngine.engineName + " - AssetRegistry.createAsset : Trying to create asset of unsupported type, " + json.type;
        }
        else if ( this.assets[ json.id ] ) {
          var newId = uuid();
          console.warn( this.veroldEngine.engineName + " - AssetRegistry.createAsset : Trying to create asset with id, " + json.id + ", that already exists. Changing the is to " + newId );
          json.id = newId;
        }
        if ( failMessage ) {
          console.error( failMessage );
          if ( options.failure ) {
            options.failure( failMessage );
          }
          return;
        }

        if (!json.name) { json.name = ""; }

        json.name = this.generateUniqueAssetName( json.name );

        var entityModel = new EntityModel( json );
        entityModel.veroldEngine = this.veroldEngine;
        entityModel.isPersistent = options.persistent || options.alreadyInDatabase ? true : false;
        if ( options.alreadyInDatabase || !entityModel.isPersistent ) {
          this._addEntityAsset( entityModel, options );
        }
        else {
          this._addNewEntityAsset( entityModel, options );
        }

      },

      //Force-unloads the asset, if it is loaded.
      //Removes the backbone model from the collection, which triggers the 'remove' event
      //Event Removes the asset from the registry
      //If the asset is persisten, deletes it from the database
      destroyAsset: function( assetID, options ) {
        var asset = this.assets[ assetID ];
        var that = this;
        if ( !asset ) {
          console.warn( this.veroldEngine.engineName + " - AssetRegistry.destroy : You must specify a valid asset ID to destroy.");
          if ( options && options.failure ) {
            options.failure();
          }
          return;
        }
        if ( !options ) {
          options = {};
        }
        asset.unload();
        asset.flaggedForDelete = true;
        var entityModel = asset.entityModel;

        if ( entityModel.isPersistent && options.save ) {
          var tmuStuff = {};
          if ( window.socket ) {
            tmuStuff.connectionId = window.socket.io.engine.id;
          }
          else {
            tmuStuff.connectionId = null;
          }
          tmuStuff.syncObjects = { stream1: 'sceneUpdates' };
          tmuStuff.success = function() {
            if ( options.success ) {
              options.success();
            }
          };
          entityModel.veroldEngine = undefined;
          entityModel.destroy( tmuStuff );
        }
        else {
          var objects = _.values( asset.objects );
          async.forEach( objects, function( obj, next ) {
            asset.destroyObject( obj.id );
            next();
          }, function() {
            that.entityCollection.remove( entityModel );
            if ( options.success ) {
              options.success();
            }
          });
        }
      },

      whenAssetRegistered: function( assetId, callback ) {
        var asset = this.getAssetById( assetId );
        if ( asset && callback ) {
          callback.call( this, asset );
        }
        else if ( callback ) {
          if ( !this.waitingForEntities[ assetId ] ) {
            this.waitingForEntities[ assetId ] = [];
          }
          this.waitingForEntities[ assetId ].push( callback );
        }
      },

      _addNewEntityAsset: function( entityModel, options ) {
        var that = this;

        var json = entityModel.toJSON();
        delete json.id;
        entityModel.unset("id", {silent : true});
        delete entityModel.id;
        entityModel.set( {"projectId": this.entityCollection.project.id}, {silent : true});

        if (window.socket && window.socket.socket ) {
          json.connectionId = window.socket.io.engine.id;
        }

        entityModel.save( json, {wait: true,
          success: function(model, response) {
            console.log( that.veroldEngine.engineName + " - New Asset saved: ", json);
            that._addEntityAsset( model, options );
          },
          error: function(model, response) {
            if ( options && options.failure ) {
              options.failure( model, response );
            }
          }
        });

      },

      _addEntityAsset: function( entityModel, options ) {
        var that = this;
        entityModel.set({"parentAssetId" : entityModel.id }, {silent: true});
        entityModel.collection = this.entityCollection;
        
        if ( this.assets[ entityModel.id ] ) {

          if ( options.success ) {
            options.success( that.assets[ entityModel.id ] );
          }
        }
        else {
          this.whenAssetRegistered( entityModel.id, options.success );
          
          this.entityCollection.add( entityModel );
        }

      },

      onEntityCollectionReset: function() {
        console.log( this.veroldEngine.engineName + " - TODO - Entities Reset ", arguments);

        //this.unloadAll();

        //this.initEntityAssets();
      },

      onEntityAssetAdded: function( entityModel ) {
        var registry = this.getRegistryByType( entityModel.get("type"));
        if(registry) {
          registry.registerEntityAsAsset( entityModel );
          var newAsset = this.getAssetById( entityModel.get("id") );
          if ( newAsset ) {
            //newAsset.initializeComponents();
            var callbacks = this.waitingForEntities[ newAsset.id ];
            if ( callbacks ) {
              for ( var i = 0; i < callbacks.length; i++ ) {
                callbacks[i].call( this, newAsset );
              }
            }
          }
        }
      },

      onEntityAssetRemoved: function( entityModel ) {
        var registry = this.getRegistryByType( entityModel.get("type"));
        if(registry) {
          registry.unregisterEntityAsAsset( entityModel.id );
          this.veroldEngine.trigger("assetDeleted", entityModel.id );
        }
      },

      unregisterEntityAsAsset: function( assetID ) {
        if ( this.veroldEngine.assetRegistry.assets[ assetID ] ) {
          this.veroldEngine.assetRegistry.assets[ assetID ].uninitialize();
          delete this.veroldEngine.assetRegistry.assets[ assetID ];
        }

      },

      onRemoteEntitySave: function ( entityData ) {

        function addEntity( entityData ) {

          //console.warn("A new entity has just been added.", entityData);
          var asset = that.assets[ entityData.parentAssetId ];
          if ( asset ) {
            //entityData.name = asset.generateUniqueObjectName( entityData.name );
            //asset._addEntityObject( entityData, { remote: true } );
            asset.createObject( entityData, { alreadyInDatabase : true, remote: true } );
          }
          else {
            console.log("Adding remotely-created " + entityData.type + " asset, " + entityData.id );
            entityData.parentAssetId = entityData.id;
            that.createAsset( entityData, { alreadyInDatabase : true, remote: true } );
          }
        }

        var that = this;
        var asset;

        if ( this.veroldEngine.isPrimaryEngine() && entityData && entityData.id) {

          //If the entity is an asset.
          if ( entityData.id === entityData.parentAssetId || !entityData.parentAssetId ) {
            //console.warn("Remote entity has changed with data: ", entityData);
            asset = that.assets[ entityData.id ];
            //If the asset already exists, update it.
            if ( asset ) {
              //console.warn("Update to an existing asset, " + entityData.id );
              asset.hardSet( entityData, { remote: true } );
            }
            //Otherwise, the entity is a new asset.
            else {
              //console.warn("A new asset, " + entityData.id );
              addEntity( entityData );
            }
          }
          //Otherwise, it's an object within an asset.
          else {
            asset = that.assets[ entityData.parentAssetId ];
            //If the parent asset exists, get the object and update it.
            if ( asset ) {
              var object = asset.getObjectById( entityData.id );
              //If the object exists, update it.
              if ( object ) {
                //console.warn("Update to an existing object, " + entityData.id );
                //object.set( { "payload.position" : { x: 0, y:0, z:0 } });
                object.hardSet( entityData, { remote: true } );
              }
              //Otherwise, it's new so create it.
              else {
                addEntity( entityData );
              }
            }
            //Otherwise, error out yo.
            else {
              console.warn( "Received an update for an object, ", entityData, ", that is part of an asset, " + entityData.parentAssetId + ", that doesn't exist." );
            }
          }
        }
        else if ( this.veroldEngine.isPrimaryEngine() ) {
          console.warn("Oops. We're not handling this: ", entityData );
        }
      },

      onRemoteEntityDelete: function ( entityData ) {
        if ( this.veroldEngine.isPrimaryEngine() && entityData && entityData.id) {
          //console.warn("An entity has just been deleted.", entityData);
          var asset = this.assets[ entityData.parentAssetId ];
          if ( asset && entityData.id !== entityData.parentAssetId ) {
            var object = asset.getObjectById( entityData.id );
            //This object may already have been removed if the source asset was deleted remotely and we already received that message
            if ( object ) {
              asset.entityModel.subEntities.remove( object.entityModel );
            }
          }
          else {
            asset = this.assets[ entityData.id ];
            if ( asset ) {
              this.entityCollection.remove( asset.entityModel );
            }
          }
        }
      },

      getPrototypeForType: function( type ) {
        switch ( type ) {
          case 'application': {
            return VAPI.ApplicationAsset.prototype;
          }
          case 'object': {
            return VAPI.VeroldObject.prototype;
          }
          case 'asset': {
            return VAPI.VeroldAsset.prototype;
          }
          case 'prefab': {
            return VAPI.CameraObject.prototype;
          }
          case 'material': {
            return VAPI.CameraObject.prototype;
          }
          case 'geometry': {
            return VAPI.CameraObject.prototype;
          }
          case 'texture2D': {
            return VAPI.Texture2DAsset.prototype;
          }
          case 'renderTexture2D': {
            return VAPI.RenderTexture2DAsset.prototype;
          }
          case 'textureCube': {
            return VAPI.TextureCubeAsset.prototype;
          }
          case 'renderTextureCube': {
            return VAPI.RenderTextureCubeAsset.prototype;
          }
          case 'model': {
            return VAPI.ModelObject.prototype;
          }
          case 'mesh': {
            return VAPI.BaseMeshObject.prototype;
          }
          case 'camera': {
            return VAPI.CameraObject.prototype;
          }
          case 'light': {
            return VAPI.LightObject.prototype;
          }
          case 'node': {
            return VAPI.VeroldObject.prototype;
          }
        }
      },

      getRegistryByType: function( type ) {
        if ( type === "application") {
          return this.Applications;
        }
        else if ( type === "scene") {
          return this.Scenes;
        }
        else if ( type === "model" || type === "prefab" ) {
          return this.Prefabs;
        }
        else if ( type === "geometry" ) {
          return this.Geometries;
        }
        else if ( type === "material") {
          return this.Materials;
        }
        else if ( type === "texture2D" || type === "textureCube" || type === "textureVideo" || type === "renderTexture2D" || type === "renderTextureCube" ) {
          return this.Textures;
        }
        else if ( type === "animation") {
          return this.Animations;
        }
        else if ( type === "pose") {
          return this.Poses;
        }
        else if ( type === "script") {
          return this.Scripts;
        }
        else if ( type === "audio") {
          return this.Audio;
        }
        else if ( type === "video") {
          return this.Video;
        }
        else if ( type === 'css') {
          return this.CSS;  
        }
        else if ( type === 'html') {
          return this.HTML;
        }
        else if ( type === 'vertexShader' || type === 'fragmentShader') {
          return this.Shaders;  
        }
        else if ( type === "folder" ) {
          return;
        }
        else {
          console.error("Request made for non-existent asset type, " + type);
          return null;
        }
      },

      update: function( delta ) {
        this.Scenes.update( delta );
        // this.Prefabs.update( delta );
        // this.Models.update( delta );
        this.Materials.update( delta );
        // this.Textures.update( delta );
        this.Animations.update( delta );
        // this.Poses.update( delta );
      },

      set: function( json, options ) {
        var asset = this.assets[ json.id ];
        if ( asset ) {
          asset.set( json, options );
        }
        else {
          console.error( this.veroldEngine.engineName + " - Trying to 'set' properties without specifying a valid asset ID.");
        }
      },

      unset: function( json, options ) {
        var asset = this.assets[ json.id ];
        if ( asset ) {
          asset.unset( json, options );
        }
        else {
          console.error( this.veroldEngine.engineName + " - Trying to 'unset' properties without specifying a valid asset ID.");
        }
      },

      //Given an input ID, we'll create a unique one based on it.
      //The resulting ID isn't valid for a persistent object but is
      //intended for temporary ones only.
      generateUniqueAssetID: function( assetID ) {
        var newID = assetID;
        var counter = 1;
        while ( this.assets[ newID ]) {
          newID = assetID + "_" + counter++;
        }
        return newID;
      },

      generateUniqueAssetName: function( assetName, asset ) {
        var newName = assetName;
        var counter = 0;
        var found = false;
        do {
          if ( found ) {
            newName = assetName + "_" + counter++;
          }
          found = false;
          for ( var x in this.assets ) {
            var name = this.assets[x].entityModel.get("name");
            if ( name === newName && !( asset && asset.id === x ) ) {
              found = true;
              break;
            }
          }

        } while ( found );

        return newName;
      },

    };

    return AssetRegistry;
  });

define('detector',[], function() {
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */

Detector = {

	canvas : !! window.CanvasRenderingContext2D,
	webgl : ( function () { try { return !! window.WebGLRenderingContext && !! document.createElement( 'canvas' ).getContext( 'experimental-webgl' ); } catch( e ) { return false; } } )(),
	workers : !! window.Worker,
	fileapi : window.File && window.FileReader && window.FileList && window.Blob,

	getWebGLErrorMessage : function () {

		var domElement = document.createElement( 'div' );

		domElement.style.fontFamily = 'monospace';
		domElement.style.fontSize = '13px';
		domElement.style.textAlign = 'center';
		domElement.style.background = '#eee';
		domElement.style.color = '#000';
		domElement.style.padding = '1em';
		domElement.style.width = '475px';
		domElement.style.margin = '5em auto 0';

		if ( ! this.webgl ) {

			domElement.innerHTML = window.WebGLRenderingContext ? [
				'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br />',
				'Find out how to get it <a href="http://get.webgl.org/">here</a>.'
			].join( '\n' ) : [
				'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br/>',
				'Find out how to get it <a href="http://get.webgl.org/">here</a>.'
			].join( '\n' );

		}

		return domElement;

	},

	addGetWebGLMessage : function ( parameters ) {

		var parent, id, domElement;

		parameters = parameters || {};

		parent = parameters.parent !== undefined ? parameters.parent : document.body;
		id = parameters.id !== undefined ? parameters.id : 'oldie';

		domElement = Detector.getWebGLErrorMessage();
		domElement.id = id;

		parent.appendChild( domElement );

	}

};

  return Detector;
});

define('VeroldEngine/BaseRenderer',[ 'underscore'
        , 'three'
        , 'detector'
    ],
  function(_, THREE, Detector ) {

    var BaseRenderer = function( veroldEngine ) {
      
      this.canvas = undefined;
      this.threeRenderer = undefined;
      this.veroldEngine = veroldEngine;
      this.caps = {};
      
      this.antialias = true;
      this.preserveDrawingBuffer = true;
      this.premultipliedAlpha = false;
      this.devicePixelRatio = 1;
      this.alpha = true;
      this.depth = true;
      this.stencil = false;
    };

    BaseRenderer.prototype = {

      constructor: BaseRenderer,

      initialize: function( canvas, options ) {
        
        if ( !options ) {
          options = {};
        }
        this.canvas = canvas;
        this.antialias = options.antialias !== undefined ? options.antialias : this.antialias;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer !== undefined ? options.preserveDrawingBuffer : this.preserveDrawingBuffer;
        this.premultipliedAlpha = options.premultipliedAlpha !== undefined ? options.premultipliedAlpha : this.premultipliedAlpha;
        this.alpha = options.alpha !== undefined ? options.alpha : this.alpha;
        this.depth = options.depth !== undefined ? options.depth : this.depth;
        this.stencil = options.stencil !== undefined ? options.stencil : this.stencil;

        this.glContext = canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' );
        if( VAPI.browserCaps.isWebGLEnabled() ){
          this.threeRenderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias    : this.antialias,
            preserveDrawingBuffer  : this.preserveDrawingBuffer,
            premultipliedAlpha : this.premultipliedAlpha,
            alpha: this.alpha,
            depth: this.depth,
            stencil: this.stencil,
            logarithmicDepthBuffer: this.logarithmicDepthBuffer
          });
          this.threeRenderer.setPixelRatio( this.devicePixelRatio );
        }
        else{
          console.warn("WebGL not supported so falling back to canvas renderer.");
          this.threeRenderer = new THREE.CanvasRenderer();
        }
        // this.threeRenderer = {};

        this.storeGPUCaps();

        // //This is a temporary check to force a maximum number of lights if the hardware supports a very low number of uniforms
        if ( this.getGPUCapability("MAX_FRAGMENT_UNIFORM_VECTORS") < 29 || VAPI.isMobile() ) {
          this.threeRenderer.maxDirLights = Math.min( this.maxDirLights, 1 );
          this.threeRenderer.maxPointLights = Math.min( this.maxPointLights, 1 );
          this.threeRenderer.maxShadows = Math.min( this.maxShadows, 1 );
        }
        this.threeRenderer.autoClear = false;
        this.threeRenderer.gammaInput = true;
        this.threeRenderer.gammaOutput = true;
      },

      uninitialize: function() {

        this.veroldEngine = undefined;
        
        this.threeRenderer = undefined;
        this.canvas = undefined;
        this.caps = undefined;
      },

      storeGPUCaps: function( ) {

        // var _gl = this.threeRenderer.getContext();
        console.log( "WebGL VENDOR is " + this.glContext.getParameter(this.glContext.VENDOR));
        console.log( "WebGL SHADING_LANGUAGE_VERSION is " + this.glContext.getParameter(this.glContext.SHADING_LANGUAGE_VERSION));
        console.log( "WebGL RENDERER is " + this.glContext.getParameter(this.glContext.RENDERER));

              
        if ( !navigator.isCocoonJS ) {
          this.caps.MAX_COMBINED_TEXTURE_IMAGE_UNITS = this.glContext.getParameter(this.glContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
          this.caps.MAX_CUBE_MAP_TEXTURE_SIZE = this.glContext.getParameter(this.glContext.MAX_CUBE_MAP_TEXTURE_SIZE);
          this.caps.MAX_FRAGMENT_UNIFORM_VECTORS = this.glContext.getParameter(this.glContext.MAX_FRAGMENT_UNIFORM_VECTORS);
          this.caps.MAX_RENDERBUFFER_SIZE = this.glContext.getParameter(this.glContext.MAX_RENDERBUFFER_SIZE);
          this.caps.MAX_TEXTURE_IMAGE_UNITS = this.glContext.getParameter(this.glContext.MAX_TEXTURE_IMAGE_UNITS);
          this.caps.MAX_TEXTURE_SIZE = this.glContext.getParameter(this.glContext.MAX_TEXTURE_SIZE);
          this.caps.MAX_VARYING_VECTORS = this.glContext.getParameter(this.glContext.MAX_VARYING_VECTORS);
          this.caps.MAX_VERTEX_ATTRIBS = this.glContext.getParameter(this.glContext.MAX_VERTEX_ATTRIBS);
          this.caps.MAX_VERTEX_TEXTURE_IMAGE_UNITS = this.glContext.getParameter(this.glContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
          this.caps.MAX_VERTEX_UNIFORM_VECTORS = this.glContext.getParameter(this.glContext.MAX_VERTEX_UNIFORM_VECTORS);
          this.caps.MAX_VIEWPORT_DIMS = this.glContext.getParameter(this.glContext.MAX_VIEWPORT_DIMS);
          this.caps.ALIASED_POINT_SIZE_RANGE = this.glContext.getParameter(this.glContext.ALIASED_POINT_SIZE_RANGE);
          this.caps.ALIASED_LINE_WIDTH_RANGE = this.glContext.getParameter(this.glContext.ALIASED_LINE_WIDTH_RANGE);

          //this.caps.SAMPLES = this.glContext.getParameter(this.glContext.SAMPLES);
          this.caps.SAMPLE_BUFFERS = this.glContext.getParameter(this.glContext.SAMPLE_BUFFERS);
          this.caps.RED_BITS = this.glContext.getParameter(this.glContext.RED_BITS);
          this.caps.GREEN_BITS = this.glContext.getParameter(this.glContext.GREEN_BITS);
          this.caps.BLUE_BITS = this.glContext.getParameter(this.glContext.BLUE_BITS);
          this.caps.ALPHA_BITS = this.glContext.getParameter(this.glContext.ALPHA_BITS);
          this.caps.DEPTH_BITS = this.glContext.getParameter(this.glContext.DEPTH_BITS);
          //this.caps.STENCIL_BITS = this.glContext.getParameter(this.glContext.STENCIL_BITS);
          //this.caps.SUBPIXEL_BITS = this.glContext.getParameter(this.glContext.SUBPIXEL_BITS);
          this.caps.EXTENSIONS = this.glContext.getSupportedExtensions();
          this.caps.COMPRESSED_TEXTURE_FORMATS = this.glContext.getParameter( this.glContext.COMPRESSED_TEXTURE_FORMATS );
      
          var _glExtensionTextureFloat = this.glContext.getExtension( 'OES_texture_float' );
          var _glExtensionTextureFloatLinear = this.glContext.getExtension( 'OES_texture_float_linear' );
          var _glExtensionStandardDerivatives = this.glContext.getExtension( 'OES_standard_derivatives' );
          var _glExtensionHardwareInstancing = this.glContext.getExtension( 'ANGLE_instanced_arrays' );

          var _glExtensionTextureFilterAnisotropic = this.glContext.getExtension( 'EXT_texture_filter_anisotropic' ) || this.glContext.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || this.glContext.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );

          var _glExtensionCompressedTextureS3TC = this.glContext.getExtension( 'WEBGL_compressed_texture_s3tc' ) || this.glContext.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || this.glContext.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );

          var _glExtensionCompressedTextureATC = this.glContext.getExtension( 'WEBGL_compressed_texture_atc' ) ||
                            this.glContext.getExtension( 'MOZ_WEBGL_compressed_texture_atc' ) ||
                            this.glContext.getExtension( 'WEBKIT_WEBGL_compressed_texture_atc' );

          var _glExtensionCompressedTexturePVRTC = this.glContext.getExtension( 'WEBGL_compressed_texture_pvrtc' ) ||
                            this.glContext.getExtension( 'MOZ_WEBGL_compressed_texture_pvrtc' ) ||
                            this.glContext.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );

          var _glExtensionElementIndexUint = this.glContext.getExtension( 'OES_element_index_uint' );

          this.caps.maxAnisotropy = _glExtensionTextureFilterAnisotropic ? this.glContext.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

          this.caps.supportsVertexTextures = ( this.getGPUCapability("MAX_VERTEX_TEXTURE_IMAGE_UNITS") > 0 );
          this.caps.supportsBoneTextures = this.caps.supportsVertexTextures && _glExtensionTextureFloat;

          this.caps.compressedTextureFormats = {};
          this.caps.compressedTextureFormats.S3TC = _glExtensionCompressedTextureS3TC ? true : false;
          this.caps.compressedTextureFormats.ATC = _glExtensionCompressedTextureATC ? true : false;
          this.caps.compressedTextureFormats.PVRTC = _glExtensionCompressedTexturePVRTC ? true : false;
          
          for ( var x in this.caps ) {
            console.log( "GPU Capabilities: " + x + " : " + this.caps[x] );
          }
        }
      },

      /**
       * Given the name of a GPU device capability (e.g. MAX_VERTEX_TEXTURE_IMAGE_UNITS ), return the current system's
       * value for this capability.
       * @param  {String} cap The capability name
       * @return {Integer}     The value of the capability
       */
      getGPUCapability: function( cap ) {
        return this.caps[ cap ];
      },

      supportsCompressedTextureS3TC: function() {
        return this.caps.compressedTextureFormats["S3TC"];
      },

      supportsCompressedTexturePVRTC: function() {
        return this.caps.compressedTextureFormats["PVRTC"];
      },

      supportsCompressedTextureATC: function() {
        return this.caps.compressedTextureFormats["ATC"];
      },

      /**
       * Returns the width of the page element containing the canvas
       * @method getWidth
       * @return {Int} The width that the canvas is displayed on the webpage.
       */
      getWidth: function() {
        return this.canvas.clientWidth;
      },

      /**
       * Returns the height of the page element containing the canvas
       * @method getHeight
       * @return {Int} The height that the canvas is displayed on the webpage.
       */
      getHeight: function() {
        return this.canvas.clientHeight;
      },

      /**
       * Returns the width of the render target in device-independent pixels (dips)
       * @method getCanvasWidth
       * @return {Int} The width of the render target.
       */
      getCanvasWidth: function() {
        return this.canvas.width;
      },

      /**
       * Returns the height of the render target in device-independent pixels (dips)
       * @method getCanvasHeight
       * @return {Int} The height of the render target.
       */
      getCanvasHeight: function() {
        return this.canvas.height;
      },

      getCanvas: function() {
        return this.canvas;
      },

      // resize: function( width, height ) {
      //   if ( this.threeRenderer ) {
      //     this.canvas.width = width;
      //     this.canvas.height = height;
      //   }
      // }

    };

    return BaseRenderer;
  });

/**
 * @module VAPI
 */
define('VeroldEngine/Input',[ 'underscore' , 'three' ],
  function( _, THREE ) {
      function VeroldMouseVector(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    }

    function VeroldInputEvent(event, name) {
      this.event = event;
      this.name = name;
    }

    function offset(el) {
      var rect = el.getBoundingClientRect();

      return {
        top: rect.top + document.body.scrollTop,
        left: rect.left + document.body.scrollLeft
      };
    }

    /**
     * The Verold Input handler
     * @class Input
     * @constructor
     * @param {Object} properties
     */
    var Input = function( properties ) {
      this.veroldEngine = undefined;
      this.inputQueue = [];
      this.mouseButtonState = new Array(3);
      this.mouseButtonStatePrevious = new Array(3);
      this.mouseButtons = {
        "left" : 0,
        "middle" : 1,
        "right" : 2,
      };
      this.mousePosition = new VeroldMouseVector();
      this.mousePositionPercent = new VeroldMouseVector();
      this.mousePreviousPosition = new VeroldMouseVector();

      this.mouseDragState = new Array(3);
      this.mouseDragStatePrevious = new Array(3);
      this.mouseDragDistance = [{},{},{}];

      this.touchPosition = new VeroldMouseVector();
      this.touchPositionPercent = new VeroldMouseVector();
      this.touchPreviousPosition = new VeroldMouseVector();
      this.touchDragState = false;
      this.touchDragStatePrevious = false;

      this.keyState = new Array(256);
      this.keyStatePrevious = new Array(256);
      this.keyCodes = {
        "tab" : 9,
        "shift" : 16,
        "ctrl" : 17,
        "alt" : 18,
        "esc" : 27,
        "space" : 32,
        "rightArrow" : 39,
        "leftArrow" : 37,
        "upArrow" : 38,
        "downArrow" : 40,
        "delete" : 46,
        "0" : 48,
        "1" : 49,
        "2" : 50,
        "3" : 51,
        "4" : 52,
        "5" : 53,
        "6" : 54,
        "7" : 55,
        "8" : 56,
        "9" : 57,
        "a" : 65,
        "b" : 66,
        "c" : 67,
        "d" : 68,
        "e" : 69,
        "f" : 70,
        "g" : 71,
        "h" : 72,
        "i" : 73,
        "j" : 74,
        "k" : 75,
        "l" : 76,
        "m" : 77,
        "n" : 78,
        "o" : 79,
        "p" : 80,
        "q" : 81,
        "r" : 82,
        "s" : 83,
        "t" : 84,
        "u" : 85,
        "v" : 86,
        "w" : 87,
        "x" : 88,
        "y" : 89,
        "z" : 90,
        "A" : 65,
        "B" : 66,
        "C" : 67,
        "D" : 68,
        "E" : 69,
        "F" : 70,
        "G" : 71,
        "H" : 72,
        "I" : 73,
        "J" : 74,
        "K" : 75,
        "L" : 76,
        "M" : 77,
        "N" : 78,
        "O" : 79,
        "P" : 80,
        "Q" : 81,
        "R" : 82,
        "S" : 83,
        "T" : 84,
        "U" : 85,
        "V" : 86,
        "W" : 87,
        "X" : 88,
        "Y" : 89,
        "Z" : 90,
        "cmd" : 91,
        "numpad_0" : 96,
        "numpad_1" : 97,
        "numpad_2" : 98,
        "numpad_3" : 99,
        "numpad_4" : 100,
        "numpad_5" : 101,
        "numpad_6" : 102,
        "numpad_7" : 103,
        "numpad_8" : 104,
        "numpad_9" : 105,
        ">" : 187,
        "<" : 188,
        "_" : 189,
        ">" : 190,
        "/" : 191,
        "[" : 219,
        "]" : 221,
      }
      this.defaultSettings = {
        enable: true,
        mouseEvents: {
          enable: true,
          scroll: true,
          scroll_preventDefault: false,
          move: true,
          down: true,
          up: true,
          leave: true,
          recordState: true,
          contextmenu: true,
          contextmenu_preventDefault: true,
        },
        touchEvents: {
          enable: true,
          start: true,
          start_preventDefault: true,
          end: true,
          cancel: true,
          leave: true,
          move: true,
          move_preventDefault: true,
        },
        keyEvents: {
          enable: true,
          down: true,
          up: true,
          recordState: true,
          preventDefault: false,
        }
      };
    };

    Input.prototype = {

      constructor: Input,

      /**
       * Initialize the input handler
       * @method initialize
       * @param {Object} properties the input handler initialization properties
       */
      initialize: function( properties ) {
        /*
        this.mouseButtonState = {};
        this.mouseButtonStatePrevious = {};
        this.mouseDragState = {};
        this.mouseDragStatePrevious = {};
        */
        this.mousePosition = new VeroldMouseVector();
        this.mousePreviousPosition = new VeroldMouseVector();

        this.touchPosition = new VeroldMouseVector();
        this.touchPreviousPosition = new VeroldMouseVector();
        /*
        this.keyState = {};
        this.keyStatePrevious = {};
        */
        this.veroldEngine = properties.veroldEngine;

        this.veroldEngine.on("preUpdate", this.preUpdate, this );
        this.veroldEngine.on("postUpdate", this.postUpdate, this );

        this.veroldEngine.globalEvents.trigger("veroldEngine:")
        
        this.canvas = this.veroldEngine.canvas;
        this.pointerLockElement = this.canvas;

        this.pointerLockElement.requestPointerLock = this.pointerLockElement.requestPointerLock || this.pointerLockElement.mozRequestPointerLock || this.pointerLockElement.webkitRequestPointerLock;
        //document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock || document.body.webkitRequestPointerLock;
        document.pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement;
        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;

        // document.body.addEventListener( 'pointerlockchange', this.pointerlockchange, false );
        // document.body.addEventListener( 'mozpointerlockchange', this.pointerlockchange, false );
        // document.body.addEventListener( 'webkitpointerlockchange', this.pointerlockchange, false );

        properties.inputSettings = properties.inputSettings ? properties.inputSettings : this.defaultSettings;

        properties.inputSettings.mouseEvents = properties.inputSettings.mouseEvents ? properties.inputSettings.mouseEvents : this.defaultSettings.mouseEvents;
        properties.inputSettings.touchEvents = properties.inputSettings.touchEvents ? properties.inputSettings.touchEvents : this.defaultSettings.touchEvents;
        properties.inputSettings.keyEvents = properties.inputSettings.keyEvents ? properties.inputSettings.keyEvents : this.defaultSettings.keyEvents;
        this.settings = properties.inputSettings;
        this.settings.enable = this.settings.enable !== undefined ? this.settings.enable : this.defaultSettings.enable;

        this.settings.mouseEvents.enable = this.settings.mouseEvents.enable !== undefined ? this.settings.mouseEvents.enable : this.defaultSettings.mouseEvents.enable;
        this.settings.mouseEvents.up = this.settings.mouseEvents.up !== undefined ? this.settings.mouseEvents.up : this.defaultSettings.mouseEvents.up;
        this.settings.mouseEvents.down = this.settings.mouseEvents.down !== undefined ? this.settings.mouseEvents.down : this.defaultSettings.mouseEvents.down;
        this.settings.mouseEvents.move = this.settings.mouseEvents.move !== undefined ? this.settings.mouseEvents.move : this.defaultSettings.mouseEvents.move;
        this.settings.mouseEvents.scroll = this.settings.mouseEvents.scroll !== undefined ? this.settings.mouseEvents.scroll : this.defaultSettings.mouseEvents.scroll;
        this.settings.mouseEvents.scroll_preventDefault = this.settings.mouseEvents.scroll_preventDefault !== undefined ? this.settings.mouseEvents.scroll_preventDefault : this.defaultSettings.mouseEvents.scroll_preventDefault;
        this.settings.mouseEvents.leave = this.settings.mouseEvents.leave !== undefined ? this.settings.mouseEvents.leave : this.defaultSettings.mouseEvents.leave;
        this.settings.mouseEvents.recordState = this.settings.mouseEvents.recordState !== undefined ? this.settings.mouseEvents.recordState : this.defaultSettings.mouseEvents.recordState;
        this.settings.mouseEvents.contextmenu = this.settings.mouseEvents.contextmenu !== undefined ? this.settings.mouseEvents.contextmenu : this.defaultSettings.mouseEvents.contextmenu;
        this.settings.mouseEvents.contextmenu_preventDefault = this.settings.mouseEvents.contextmenu_preventDefault !== undefined ? this.settings.mouseEvents.contextmenu_preventDefault : this.defaultSettings.mouseEvents.contextmenu_preventDefault;

        this.settings.keyEvents.up = this.settings.keyEvents.up !== undefined ? this.settings.keyEvents.up : this.defaultSettings.keyEvents.up;
        this.settings.keyEvents.down = this.settings.keyEvents.down !== undefined ? this.settings.keyEvents.down : this.defaultSettings.keyEvents.down;
        this.settings.keyEvents.recordState = this.settings.keyEvents.recordState !== undefined ? this.settings.keyEvents.recordState : this.defaultSettings.keyEvents.recordState;
        this.settings.keyEvents.down_preventDefault = this.settings.keyEvents.down_preventDefault !== undefined ? this.settings.keyEvents.down_preventDefault : this.defaultSettings.keyEvents.down_preventDefault;

        this.settings.touchEvents.enable = this.settings.touchEvents.enable !== undefined ? this.settings.touchEvents.enable : this.defaultSettings.touchEvents.enable;
        this.settings.touchEvents.start = this.settings.touchEvents.start !== undefined ? this.settings.touchEvents.start : this.defaultSettings.touchEvents.start;
        this.settings.touchEvents.end = this.settings.touchEvents.end !== undefined ? this.settings.touchEvents.end : this.defaultSettings.touchEvents.end;
        this.settings.touchEvents.cancel = this.settings.touchEvents.cancel !== undefined ? this.settings.touchEvents.cancel : this.defaultSettings.touchEvents.cancel;
        this.settings.touchEvents.leave = this.settings.touchEvents.leave !== undefined ? this.settings.touchEvents.leave : this.defaultSettings.touchEvents.leave;
        this.settings.touchEvents.move = this.settings.touchEvents.move !== undefined ? this.settings.touchEvents.move : this.defaultSettings.touchEvents.move;

        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseWheel = this.onMouseWheel.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onContextMenu = this.onContextMenu.bind(this);
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onTouchCancel = this.onTouchCancel.bind(this);
        this.onTouchLeave = this.onTouchLeave.bind(this);
        this.onTouchMove = this.onTouchMove.bind(this); 

        if ( this.settings.enable || properties.handleInput ) {

          var mouseEvents = this.settings.mouseEvents;
          if ( mouseEvents.enable ) {
            if ( mouseEvents.move ) {
              this.canvas.addEventListener('mousemove', this.onMouseMove );
            }

            //if ( mouseEvents.up ) this.canvas.addEventListener('mouseup', { context: this }, this.onMouseUp );
            if ( mouseEvents.down ) {
              this.canvas.addEventListener('mousedown', this.onMouseDown);
            }

            if ( mouseEvents.scroll ) {
              this.canvas.addEventListener('wheel', this.onMouseWheel);
            }

            document.body.addEventListener('mouseleave', this.onMouseLeave );

            this.canvas.addEventListener('contextmenu', this.onContextMenu );
          }
          var keyEvents = this.settings.keyEvents;
          if ( keyEvents.enable ) {
            if ( keyEvents.down ) {
              document.addEventListener('keydown', this.onKeyDown );
            }
            if ( keyEvents.up ) {
              document.addEventListener('keyup', this.onKeyUp );
            }
          }

          var touchEvents = this.settings.touchEvents;
          if ( touchEvents.enable ) {
            if ( touchEvents.start ) {
              this.canvas.addEventListener("touchstart", this.onTouchStart);
            }

            if ( touchEvents.end ) {
              this.canvas.addEventListener("touchend", this.onTouchEnd);
            }

            if ( touchEvents.cancel ) {
              this.canvas.addEventListener("touchcancel", this.onTouchCancel);
            }

            if ( touchEvents.leave ) {
              this.canvas.addEventListener("touchleave", this.onTouchLeave);
            }

            if ( touchEvents.move ) {
              this.canvas.addEventListener("touchmove", this.onTouchMove);
            }
          }

        }

        this.onBlur = this.clearKeyStates.bind(this);

        window.addEventListener( 'blur', this.onBlur, false);
      },

      /**
       * Shut down the input handler
       * @method uninitialize
       */
      uninitialize: function() {
        window.removeEventListener( 'blur', this.onBlur, false);

        if ( this.canvas ) {
          this.canvas.removeEventListener("touchstart", this.onTouchStart);
          this.canvas.removeEventListener("touchend", this.onTouchEnd);
          this.canvas.removeEventListener("touchcancel", this.onTouchCancel, this);
          this.canvas.removeEventListener("touchleave", this.onTouchLeave, this);
          this.canvas.removeEventListener("touchmove", this.onTouchMove);

          this.canvas.removeEventListener('mousemove', this.onMouseMove);
          document.removeEventListener( 'mouseup', this.onMouseUp);
          this.canvas.removeEventListener('mousedown', this.onMouseDown);
          this.canvas.removeEventListener('wheel', this.onMouseWheel);
          document.removeEventListener('keydown', this.onKeyDown);
          document.removeEventListener('keyup', this.onKeyUp);
          document.body.removeEventListener('mouseleave', this.onMouseLeave);
          this.canvas.removeEventListener( 'contextmenu', this.onContextMenu);
        }

        this.veroldEngine.off("preUpdate", this.preUpdate, this );
        this.veroldEngine.off("postUpdate", this.postUpdate, this );

        this.mouseButtonState = undefined;
        this.mouseButtonStatePrevious = undefined;
        this.mouseDragState = undefined;
        this.mouseDragStatePrevious = undefined;
        this.mousePosition = undefined;
        this.mousePreviousPosition = undefined;
        this.touchPosition = undefined;
        this.touchPreviousPosition = undefined;
        this.keyState = undefined;
        this.keyStatePrevious = undefined;
        this.veroldEngine = undefined;
      },

      //Callback for a keyup event. Sets the key state.
      onKeyUp: function( event ) {
        //console.log("Key released: ", event.keyCode);
        this.keyState[ event.keyCode ] = false;
        //this.veroldEngine.trigger('keyUp', event );
        this.inputQueue.push(new VeroldInputEvent(event, "keyUp"));
      },

      //Callback for a keydown event. Sets the key state.
      onKeyDown: function( event ) {
        if (document.activeElement && (
            document.activeElement.getAttribute('contenteditable') === 'true' ||
            document.activeElement.tagName === 'DIV' ||
            document.activeElement.tagName === 'INPUT' ||
            document.activeElement.tagName === 'SELECT' ||
            document.activeElement.tagName === 'OPTION' ||
            document.activeElement.tagName === 'TEXTAREA'
            )
        ) {
          return;  
        }

        if ( this.settings.keyEvents.preventDefault ) {
          event.preventDefault();
        }
        //console.log("Key pressed: ", event.keyCode);
        this.keyState[ event.keyCode ] = true;
        //this.veroldEngine.trigger("keyDown", event );
        this.inputQueue.push(new VeroldInputEvent(event, "keyDown"));
      },

      /**
       * Clear the input handler's key states
       * @method clearKeyStates
       */
      clearKeyStates: function() {
        //_.each( this.keyCodes, function( code ) {
        for (var code = 0; code < this.keyState.length; code++) {
          this.keyState[ code ] = false;
        }
        //}, this );
      },

      onContextMenu: function( event ) {
        if ( this.settings.mouseEvents.contextmenu_preventDefault ) {
        //if ( event.target === this.canvas ) {
          event.preventDefault();
        }
        //this.veroldEngine.trigger("contextmenu", event );
        this.inputQueue.push(new VeroldInputEvent(event, "contextMenu"));
        //else {
          //console.log("Cleared the keyboard!!!")
          //this.clearKeyStates();
        //}
      },

      onMouseLeave: function( event ) {
        //event.preventDefault();
        //event.stopPropagation();
        //console.log(event);
        //_.each( this.mouseButtonState, function( state, b ) {
        for (var b = 0; b < this.mouseButtonState.length; b++) {
          //If a button is down, force the up event
          if ( this.mouseButtonState[b] ) {
            event.button = b;
            this.onMouseUp( event );
          }
        }
        //}, this );
        //Clear the keyboard state as well.
        //Outside of the canvas, we don't have control over focus and may or may not receive keyup events.
        //So, to be safe, we set the key state to up.
        this.clearKeyStates();
      },

      onMouseDown: function( event ) {

        var scenePos = offset(event.target);
        event.sceneX = event.clientX - scenePos.left;
        event.sceneY = event.clientY - scenePos.top;
        event.scenePercentX = event.sceneX / this.veroldEngine.getBaseRenderer().getWidth();
        event.scenePercentY = event.sceneY / this.veroldEngine.getBaseRenderer().getHeight();

        this.mouseDragDistance[ event.button ] = new VeroldMouseVector();
        if ( !this.mouseUpBound ) {
          this.mouseUpBound = true;
          document.addEventListener('mouseup', this.onMouseUp);
        }

        [].forEach.call(document.querySelectorAll("input, textarea, select, option"), function(el) {
          el.blur();
        });

        if ( this.settings.mouseEvents.down_preventDefault ) {
          event.preventDefault();
        }

        this.mouseButtonState[ event.button ] = true;
        //this.veroldEngine.trigger('mouseDown', event );
        this.inputQueue.push(new VeroldInputEvent(event, "mouseDown"));
      },

      onMouseUp: function( event ) {

        var scenePos = offset(event.target);
        event.sceneX = event.pageX - scenePos.left;
        event.sceneY = event.pageY - scenePos.top;
        event.scenePercentX = event.sceneX / this.veroldEngine.getBaseRenderer().getWidth();
        event.scenePercentY = event.sceneY / this.veroldEngine.getBaseRenderer().getHeight();

        this.mouseButtonState[ event.button ] = false;
        this.mouseDragState[ event.button ] = false;
        //console.log( "Mouse button " + event.button + " was dragged ", this.mouseDragDistance[ event.button ] );
        this.mouseDragDistance[ event.button ].x = 0;
        this.mouseDragDistance[ event.button ].y = 0;

        if ( this.mouseButtonUp( "left" ) &&
          this.mouseButtonUp( "right" ) &&
          this.mouseButtonUp( "middle" )) {

          this.mouseUpBound = false;
          document.removeEventListener('mouseup', this.onMouseUp);

        }
        //event.stopPropagation();
        //this.veroldEngine.trigger('mouseUp', event );
        this.inputQueue.push(new VeroldInputEvent(event, "mouseUp"));
      },


      onMouseMove: function( event ) {
        //console.log("Mouse moved: X: " + event.sceneX + ", Y: " + event.sceneY );
        var that = this;//event.data.context;
        var scenePos = offset(event.target);
        event.sceneX = event.clientX - scenePos.left;
        event.sceneY = event.clientY - scenePos.top;
        
        event.scenePercentX = event.sceneX / this.veroldEngine.getBaseRenderer().getWidth();
        event.scenePercentY = event.sceneY / this.veroldEngine.getBaseRenderer().getHeight();
        
        that.mousePosition.x = event.sceneX || event.clientX;
        that.mousePosition.y = event.sceneY || event.clientY;

        that.mousePositionPercent.x = event.scenePercentX;
        that.mousePositionPercent.y = event.scenePercentY;

        event.mouseDelta = {};
        event.mouseDelta.x = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        event.mouseDelta.y = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

        if ( !event.mouseDelta.y && !event.mouseDelta.x ) {
          event.mouseDelta.x = (that.mousePosition.x - that.mousePreviousPosition.x);
          event.mouseDelta.y = (that.mousePosition.y - that.mousePreviousPosition.y);
        }
        event.scenePercentDeltaX = event.mouseDelta.x / this.veroldEngine.getBaseRenderer().getWidth();
        event.scenePercentDeltaY = event.mouseDelta.y / this.veroldEngine.getBaseRenderer().getHeight();

        //_.each( this.mouseButtonState, function( state, b ) {
        for (var b = 0; b < this.mouseButtonState.length; b++) {
          if ( this.mouseButtonState[b] === true ) {
            //console.log("setting drag state to true for " + x );
            this.mouseDragDistance[ b ].x += event.mouseDelta.x;
            this.mouseDragDistance[ b ].y += event.mouseDelta.y;
            var distance = this.mouseDragDistance[ b ];
            if ( distance.x * distance.x + distance.y * distance.y > 12 ) {
              this.mouseDragState[ b ] = true;
            }
          }
          else {
            //console.log("setting drag state to false for " + x );
            this.mouseDragState[b] = false;
          }
        }

        //this.veroldEngine.trigger('mouseMove', event );
        this.inputQueue.push(new VeroldInputEvent(event, "mouseMove"));
      },

      onMouseWheel: function( event /*, delta*/ ) {
        if ( this.settings.mouseEvents.scroll_preventDefault ) {
          event.preventDefault();
        }
        var delta;
        if ( event.wheelDeltaY !== undefined ) {
          delta = 1/40 * event.wheelDeltaY;
        }
        else if ( VAPI.isIE() ) {
          delta = -event.deltaY / 40;
        }
        else {
          delta = -event.deltaY;
        }
        this.inputQueue.push(new VeroldInputEvent(delta, "mouseScroll"));
      },

      onTouchStart: function( ev ) {

        if ( this.settings.touchEvents.start_preventDefault ) {
          ev.preventDefault();
        }
        var event = {}; 
        event.originalEvent = ev;
        event.touches = [];
        var scenePos = offset(ev.target);
        _.each( ev.touches, function( touch ) {
          var touchObj = {};
          touchObj.scenePercentX = (touch.clientX - scenePos.left) / this.veroldEngine.getBaseRenderer().getWidth();
          touchObj.scenePercentY = (touch.clientY - scenePos.top) / this.veroldEngine.getBaseRenderer().getHeight();
          touchObj.originalTouch = touch;
          event.touches.push(touchObj);
        }, this );
        this.inputQueue.push(new VeroldInputEvent(event, "touchStart"));
      },

      onTouchLeave: function( ev ) {
        if ( this.settings.touchEvents.leave_preventDefault ) {
          ev.preventDefault();
        }
        this.touchDragState = false;
        var event = {};
        event.originalEvent = ev;
        event.touches = [];
        var scenePos = offset(ev.target);
        _.each( ev.touches, function( touch ) {
          var touchObj = {};
          touchObj.scenePercentX = (touch.clientX - scenePos.left) / this.veroldEngine.getBaseRenderer().getWidth();
          touchObj.scenePercentY = (touch.clientY - scenePos.top) / this.veroldEngine.getBaseRenderer().getHeight();
          touchObj.originalTouch = touch;
          event.touches.push(touchObj);
        }, this );
        this.inputQueue.push(new VeroldInputEvent(event, "touchLeave"));
      },

      onTouchEnd: function( ev ) {
        if ( this.settings.touchEvents.end_preventDefault ) {
          ev.preventDefault();
        }
        this.touchDragState = false;
        var event = {};
        event.originalEvent = ev;
        event.touches = [];
        var scenePos = offset(ev.target);
        _.each( ev.touches, function( touch ) {
          var touchObj = {};
          touchObj.scenePercentX = (touch.clientX - scenePos.left) / this.veroldEngine.getBaseRenderer().getWidth();
          touchObj.scenePercentY = (touch.clientY - scenePos.top) / this.veroldEngine.getBaseRenderer().getHeight();
          touchObj.originalTouch = touch;
          event.touches.push(touchObj);
        }, this );
        this.inputQueue.push(new VeroldInputEvent(event, "touchEnd"));
      },

      onTouchMove: function( ev ) {
        if ( this.settings.touchEvents.move_preventDefault ) {
          ev.preventDefault();
        }
        this.touchDragState = true;
        var event = {};
        event.originalEvent = ev;
        event.touches = [];
        var scenePos = offset(ev.target);
        _.each( ev.touches, function( touch ) {
          var touchObj = {};
          touchObj.scenePercentX = (touch.clientX - scenePos.left) / this.veroldEngine.getBaseRenderer().getWidth();
          touchObj.scenePercentY = (touch.clientY - scenePos.top) / this.veroldEngine.getBaseRenderer().getHeight();
          touchObj.originalTouch = touch;
          event.touches.push(touchObj);

          this.touchPosition.x = touch.clientX - scenePos.left;
          this.touchPosition.y = touch.clientY - scenePos.top;

          this.touchPositionPercent.x = touchObj.scenePercentX;
          this.touchPositionPercent.y = touchObj.scenePercentY;
        }, this );

        //TODO need touch drag distance state

        this.inputQueue.push(new VeroldInputEvent(event, "touchMove"));
      },

      onTouchCancel: function( ev ) {
        if ( this.settings.touchEvents.cancel_preventDefault ) {
          ev.preventDefault();
        }
        this.touchDragState = false;
        var event = {};
        event.originalEvent = ev;
        event.touches = [];
        // var scenePos = offset(event.target);
        // _.each( ev.touches, function( touch ) {
        //   var touchObj = {};
        //   touchObj.scenePercentX = (touch.clientX - scenePos.left) / this.veroldEngine.getBaseRenderer().getWidth();
        //   touchObj.scenePercentY = (touch.clientY - scenePos.top) / this.veroldEngine.getBaseRenderer().getHeight();

        //   event.touches.push(touchObj);
        // }, this );

        this.inputQueue.push(new VeroldInputEvent(event, "touchCancel"));
      },

      //flush the input from the previous frame
      preUpdate: function( delta ) {
        var inputEvent;
        //_.each( this.inputQueue, function( inputEvent ) {
        for (var i = 0; i < this.inputQueue.length; i++) {
          inputEvent = this.inputQueue[i];
          this.veroldEngine.trigger( inputEvent.name, inputEvent.event );
        }

        this.inputQueue.splice(0, this.inputQueue.length);
        //}, this );
      },

      //This update should be called at the end of a frame, after logic has been processed.
      postUpdate: function() {
        var code;

        if ( this.settings.keyEvents.recordState ) {

          //_.each( this.keyState, function( state, id ) {
          for (code = 0; code < this.keyState.length; code ++) {
            this.keyStatePrevious[ code ] = this.keyState[ code ];
          }
          //}, this );
        }
        if ( this.settings.mouseEvents.recordState ) {
          //_.each( this.mouseButtonState, function( state, id ) {
          for (var id = 0; id < this.mouseButtonState.length; id++) {
            this.mouseButtonStatePrevious[ id ] = this.mouseButtonState[ id ];
            this.mouseDragStatePrevious[ id ] = this.mouseDragState[ id ];
          }
          //}, this );
          this.mousePreviousPosition.x = this.mousePosition.x;
          this.mousePreviousPosition.y = this.mousePosition.y;

          // this.touchPreviousPosition.x = this.touchPosition.x;
          // this.touchPreviousPosition.y = this.touchPosition.y;
        }
        this.touchDragStatePrevious = this.touchDragState;
      },

      /**
       * Check if the specified has been pressed in this frame
       * @method keyPressed
       * @param  {Number} key
       * @return {Boolean}
       */
      keyPressed: function( key ) {
        return this.keyState[ this.keyCodes[key] ] && !this.keyStatePrevious[ this.keyCodes[key] ] ? true: false;
      },

      /**
       * Check if the specified key has been release in this frame
       * @method  keyReleased
       * @param  {Number} key
       * @return {Boolean}
       */
      keyReleased: function( key ) {
        return !this.keyState[ this.keyCodes[key] ] && this.keyStatePrevious[ this.keyCodes[key] ] ? true: false;
      },

      /**
       * Check if the specified key is currently down
       * @method keyDown
       * @param  {Number} key
       * @return {Boolean}
       */
      keyDown: function( key ) {
        /*
        if ( this.keyState[ this.keyCodes[key] ] == undefined ) {
          this.keyState[ this.keyCodes[key] ] = false;
        }
        */
        return !!this.keyState[ this.keyCodes[key] ];
      },

      /**
       * Check if the specified key is currently up
       * @method keyUp
       * @param  {Number} key
       * @return {Boolean}
       */
      keyUp: function( key ) {
        return !this.keyState[ this.keyCodes[key] ];
      },

      /**
       * Check if the specified mouse button is down
       * @method mouseButtonDown
       * @param  {String} button the button [ "left", "middle", "right" ]
       * @return {Boolean}
       */
      mouseButtonDown: function( button ) {
        if ( button === "any" ) {
          for ( var i in this.mouseButtons ) {
            if ( this.mouseButtonState[ this.mouseButtons[ i ] ] ) {
              return true;
            }
          }
          return false;
        }
        return this.mouseButtonState[ this.mouseButtons[ button ] ];
      },

      /**
       * Check if the specified mouse button is up
       * @method mouseButtonUp
       * @param  {String} button the button [ "left", "middle", "right" ]
       * @return {Boolean}
       */
      mouseButtonUp: function( button ) {
        return !this.mouseButtonState[ this.mouseButtons[ button ] ];
      },

      /**
       * Check if the specified mouse button was pressed in this frame
       * @method mouseButtonPressed
       * @param  {String} button the button [ "left", "middle", "right" ]
       * @return {Boolean}
       */
      mouseButtonPressed: function( button ) {
        return this.mouseButtonState[ this.mouseButtons[button] ] && !this.mouseButtonStatePrevious[ this.mouseButtons[button] ] ? true: false;
      },

      /**
       * Check if the specified mouse button was pressed in this frame
       * @method mouseButtonReleased
       * @param  {String} button the button [ "left", "middle", "right" ]
       * @return {Boolean}
       */
      mouseButtonReleased: function( button ) {
        return !this.mouseButtonState[ this.mouseButtons[button] ] && this.mouseButtonStatePrevious[ this.mouseButtons[button] ] ? true: false;
      },

    };

    return Input;
  });

/**
 * @module VAPI
 */
define('VeroldEngine/Engine',[ 'underscore'
       , 'backbone'
       , 'three'
       , 'VeroldEngine/libs/uuid'
       , 'VeroldEngine/AssetRegistry/AssetRegistry'
       , 'VeroldEngine/BaseRenderer'
       , 'VeroldEngine/Input'
       , 'VeroldEngine/Objects/CameraObject'
],
  function(_, Backbone, THREE, uuid, AssetRegistry, BaseRenderer, Input, CameraObject) {

    function getElement(obj) {
      var els;
      if (obj && obj.jquery) {
        return obj.get(0);
      } else if (_.isString(obj)) {
        els = document.querySelectorAll(obj);

        return els.length && els[0];
      } else {
        return obj;
      }
    }

    /**
     * This is the Verold Engine object.
     *
     * @class Engine
     * @param {Object} properties Engine properties
     * @mixin Backbone.Events
     * @constructor
     */
    var Engine = function( properties ) {
      if ( !Math.log2 ) {
        Math.log2 = function( val ) {
          return Math.log( val ) / Math.LN2;
        }
      }
      this.paths = _.extend({},
          window.VAPI.defaultPaths,
          properties.paths);

      this.global = properties.global || window;

      if ( properties.engineName ) {
        this.engineName = properties.engineName;
      }
      else {
        this.engineName = "Unnamed Instance of Verold Engine";
      }

      this.applicationName = properties.applicationName || uuid();

      this.isEditor = properties.isEditor ? true : false;
      this.isWritable = undefined;
      this.assetRegistry = new AssetRegistry( _.extend({ paths: this.paths }, properties));
      this.Input = new Input();
      this.renderOnDemand = false;
      this.needsRender = true;

      this.audioContext = undefined;

      this.activeCamera = null;
      this.container = getElement(properties.container);

      this.globalEvents = undefined;
      this.caps = {};
      this.entities = {};

    };

    Engine.prototype = {
      // DOM element

      constructor: Engine,

      /**
       * Initialize the engine with the provided properties.
       *
       * @method initialize
       * @param {Object} properties The engine properties
       */
      initialize: function( properties, callback ) {
        console.time("Engine Initialization");
        var that = this;

        this.componentSettings = _.extend({
            enabled: true,
            editor: false,
            runtime: true,
            persistent: true,
            nonPersistent: true
          },
          properties.componentSettings || {});

        this.globalEvents = (properties && properties.globalEvents) ||
            (window.VAPI && window.VAPI.globalEvents);

        if (!this.globalEvents) {
          throw new Error('No global event system found!');
        }

        console.info('Components settings:', JSON.stringify(this.componentSettings));

        this.state = "initializing";
        this.trigger("initialize_start", this );
        if ( !this.getApplicationContext().primaryEngineRef ) {
          this.getApplicationContext().primaryEngineRef = this;
        }
        //this.renderInterval = properties.renderInterval !== undefined ? properties.renderInterval : 0.0;
        properties.assetRegistry = this.assetRegistry;
        properties.veroldEngine = this;
        this.isWritable = properties.isWritable;

        // Initialize the BaseRenderer.
        this.container = this.container !== undefined ? this.container : getElement(properties.container);
        // properties.container = this.container;
        if ( !properties.canvas && this.container ) {
          properties.canvas = document.createElement( 'canvas' );
          this.container.appendChild( properties.canvas );
          this.canvasCreatedByEngine = true;
        }

        this.canvas = getElement(properties.canvas);

        if (!(this.canvas instanceof HTMLCanvasElement) ) {
          console.error("Engine not passed a reference to a valid canvas element.");
          return;
        }

        //First break during engine initialization.
        setTimeout( function() {
          console.time("Renderer Initialization");
          that._baseRenderer = new BaseRenderer( that );
          that._baseRenderer.initialize( that.canvas );
          console.timeEnd("Renderer Initialization");

          //Second break during initialization to allow main thread to continue.
          setTimeout( function() {

            that.assetRegistry.initialize( properties, function() {

              that.handleInput = properties.handleInput !== undefined ? properties.handleInput : true;
              if ( that.handleInput ) {
                that.Input.initialize( properties );
              }

              that.clock = new THREE.Clock();
              that.elapsedSinceRender = 0.0;
              that.frameDelta = 0;
              that.updateTime = 0;
              that.renderTime = 0;
              that.frameDeltaAgregate = 0;
              that.frameCount = 0;
              that.lastFrameDelta = that.getTimeNow();
              that.avgFrameTime = 0;
              that.currentFrame = 0.0;

              that.paused = false;
              that.documentVisible = true;

              //Setup render loop
              that.update= function() {

                if ( !that.paused ) { //remember to put visible check

                  that.animationRequestID = window.requestAnimationFrame( that.update );

                  if ( !that.documentVisible ) {
                    return;
                  }

                  that.frameCount++;

                  that.frameDelta = that.getTimeNow() - that.lastFrameDelta;
                  that.lastFrameDelta = that.getTimeNow();

                  that.frameDeltaAgregate += that.frameDelta;
                  that.avgFrameTime = that.frameDeltaAgregate / that.frameCount;

                  that.trigger( "preUpdate", that.frameDelta );
                  that.trigger( "update", that.frameDelta );
                  that.trigger( "postUpdate", that.frameDelta );

                  if ( !that.renderOnDemand || that.needsRender ) {
                    that.needsRender = false;
                    that.trigger( "preRender", that.frameDelta );
                    that.trigger( "render", that.frameDelta );
                    that.trigger( "renderGroup1", that.frameDelta );
                    that.trigger( "renderGroup2", that.frameDelta );
                    that.trigger( "renderGroup3", that.frameDelta );
                    that.trigger( "renderGroup4", that.frameDelta );
                    that.trigger( "renderGroup5", that.frameDelta );
                    that.trigger( "renderGroup6", that.frameDelta );
                    that.trigger( "renderGroup7", that.frameDelta );
                    that.trigger( "renderGroup8", that.frameDelta );
                    that.trigger( "renderGroup9", that.frameDelta );
                    that.trigger( "renderGroup10", that.frameDelta );
                    that.trigger( "postRender", that.frameDelta );

                  }
                }
              };

              window[ that.engineName ] = that;

              that.update( 0 );

              that.on("update", that.onUpdate, that );

              that.globalEvents.on("requestVeroldEngine", that.onRequestEngine, that );
              //this.on( 'veroldEngine:getDefaultRenderer', this.getDefaultRenderer, this );

              that.state = "initialized";
              that.trigger("initialize_finish", that );

              console.timeEnd("Engine Initialization");
              that.trigger('resize');

              if ( typeof callback === 'function' ) {
                callback();
              }
            }, 1 );
          }, 1 );
        }, 1 );

        var onResize = function() {
          that.trigger('resize');
        };

        var onBlur = function() {
          that.trigger('blur');
        };

        var onFocus = function() {
          that.trigger('focus');
        };

        var onVisibilityChange = function() {
          if( that.documentVisible && (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden) ) {
            that.trigger('document_hidden');
            that.documentVisible = false;
          }
          else if( !that.documentVisible ) {
            that.trigger('document_visible');
            that.elapsedSinceRender = 0.0;
            that.frameDelta = 0;
            that.updateTime = 0;
            that.lastFrameDelta = that.getTimeNow();//reset delta calculations
            that.documentVisible = true;
          }
        };

        window.addEventListener('blur', onBlur);
        window.addEventListener('focus', onFocus);
        window.addEventListener('resize', onResize);
        document.addEventListener('visibilitychange', onVisibilityChange);

        this.listenToOnce(this, 'shutdown', function() {
          window.removeEventListener('blur', onBlur);
          window.removeEventListener('focus', onFocus);
          window.removeEventListener('resize', onResize);
          document.removeEventListener('visibilitychange', onVisibilityChange);
        });
      },

      /**
       * Returns the current active application.
       * @method getApplication
       * @return {Asset} The application asset
       */
      getApplication: function() {
        var assets = this.assetRegistry.Applications.getAssets();
        for ( var appId in assets ) {
          if ( assets[ appId ].state_base === "loaded") {
            return assets[ appId ];
          }
        }
      },

      getBaseRenderer: function() {
        return this._baseRenderer;
      },

      setBaseRenderer: function( newBaseRenderer ) {
        if ( _.isFunction( this._baseRenderer.uninitialize ) ) {
          this._baseRenderer.uninitialize();
        }
        this._baseRenderer = newBaseRenderer;
        this._threeRenderer = newBaseRenderer.threeRenderer;
      },

      getThreeRenderer: function() {
        return this._baseRenderer.threeRenderer;
      },

      /**
       * Uninitialize the engine
       * @method uninitialize
       */
      uninitialize: function() {
        delete window[ this.engineName ];

        this.trigger( "shutdown" );
        this.state = "uninitializing";
        this.trigger("uninitialize_start", this );
        this.off("update", this.onUpdate, this );

        this.entities = undefined;
        this.globalEvents.off( "requestVeroldEngine", this.onRequestEngine, this );

        window.cancelAnimationFrame( this.animationRequestID );
        this.update = undefined;

        if ( this.Input ) {
          this.Input.uninitialize();
          this.Input = null;
        }

        if ( this.canvasCreatedByEngine ) {
          this.canvas.parentNode.removeChild( this.canvas );
        }

        if ( this.isPrimaryEngine() ) {
          this.getApplicationContext().primaryEngineRef = null;
        }

        console.log( this.engineName + " - Uninitializing engine." );

        if (this.assetRegistry) {
          this.assetRegistry.uninitialize();
        }

        if (this._threeRenderer) {
          this._threeRenderer.dispose();
        }

        this.clock = undefined;
        this.assetRegistry = null;
        this.update = undefined;
        this.canvas = undefined;
        this.activeCamera = undefined;
        this._threeRenderer = undefined;
        this._baseRenderer = undefined;
        this.engineName = undefined;
        this.isWritable = undefined;

        this.state = "uninitialized";
        this.trigger("uninitialize_finish", this );
      },

      getPrimaryEngine: function() {
        return this.getApplicationContext().primaryEngineRef;
      },

      isPrimaryEngine: function() {
        return this.getApplicationContext().primaryEngineRef === this;
      },

      /**
       * Given the name of a GPU device capability (e.g. MAX_VERTEX_TEXTURE_IMAGE_UNITS ), return the current system's
       * value for this capability.
       * @param  {String} cap The capability name
       * @return {Integer}     The value of the capability
       */
      getGPUCapability: function( cap ) {
        return this._baseRenderer.caps[ cap ];
      },

      supportsCompressedTextureS3TC: function() {
        return this._baseRenderer.caps.compressedTextureFormats["S3TC"];
      },

      supportsCompressedTexturePVRTC: function() {
        return this._baseRenderer.caps.compressedTextureFormats["S3TC"];
      },

      supportsCompressedTextureATC: function() {
        return this._baseRenderer.caps.compressedTextureFormats["S3TC"];
      },

      /**
       * Returns the entity with the provided Id. This includes ALL entities, both assets and objects
       * @method getEntityById
       * @param  {String} entityId The ID of the entity.
       * @return {Object} The entity or null if not found.
       */
      getEntityById: function( entityId ) {

        if ( this.entities[ entityId ] ) {
          return this.entities[ entityId ];
        }
        return null;
      },

      /**
       * @method getAudioContext
       * @return {AudioContext}
       */
      getAudioContext: function() {

        if(!this.audioContext) {
          //moved this from engine startup to here this stops the engine
          //from going down if too many audio contexts have been created
          //as a bonus, it's only created when it's needed
          var audioContext = window.AudioContext || window.webkitAudioContext;
          if(audioContext) {
            this.audioContext = new audioContext();
            if(!this.audioContext) console.warn( that.engineName + " - Failed to create Web Audio API context" );

          }
        }

        return this.audioContext;
      },

      onRequestEngine: function() {
        this.globalEvents.trigger("sendVeroldEngine", this );
      },

      /**
       * Pause the engine
       * @method pause
       */
      pause: function( ) {
        if ( !this.paused ) {
          this.paused = true;
          this.clock.stop();
          console.warn( this.engineName + " engine has been paused.");
        }
      },

      /**
       * Unpause the engine
       * @method unpause
       */
      unpause: function( ) {
        if ( this.paused ) {
          this.paused = false;
          this.elapsedSinceRender = 0.0;
          this.frameDelta = 0;
          this.updateTime = 0;
          this.lastFrameDelta = this.getTimeNow();
          this.clock.start();
          console.warn( this.engineName + " engine has been unpaused.");
          this.update();
        }
      },

      onUpdate: function( delta ) {
        if ( this.assetRegistry ) {
          this.assetRegistry.update( delta );
        }

      },

      setCurrentApp: function( appId ) {
        var app = this.assetRegistry.Applications.getAssetById( appId );
        if ( app ) {
          if ( this.currentApplication ) {
            console.warn("There is already an application running in this engine. Stopping it before starting the " + app.getName() + " application.");
            this.currentApplication.unload();
          }
          this.currentApplication = app;
        }
      },

      getTimeNow: function() {
        return ((!!window.performance && !!window.performance.now ) ? window.performance.now() : Date.now()) * 0.001;
      },

      getApplicationContext: function() {
        return VAPI.getApplicationContext(this.applicationName);
      }

    };

    _.extend(Engine.prototype, Backbone.Events);

    window.VAPI = window.VAPI || {};
    window.VAPI.Engine = Engine;

    return Engine;
  });

// Backbone.NativeAjax.js 0.3.2
// ---------------

//     (c) 2014 Adam Krebs, Paul Miller, Exoskeleton Project
//     Backbone.NativeAjax may be freely distributed under the MIT license.
//     For all details and documentation:
//     https://github.com/akre54/Backbone.NativeAjax

//     Modification for Verold CSRF/CORS and cookie support

(function (factory) {
  if (typeof define === 'function' && define.amd) { define('VeroldEngine/libs/backbone/backbone.nativeajax',factory);
  } else if (typeof exports === 'object') { module.exports = factory();
  } else { Backbone.ajax = factory(); }
}(function() {
  var pluses = /\+/g;

  function raw(s) {
    return s;
  }

  function decoded(s) {
    return decodeURIComponent(s.replace(pluses, ' '));
  }

  var $cookie = function (key, value, options) {
    options = options || {};

    // write
    if (value !== undefined) {
      if (value === null) {
        options.expires = -1;
      }

      if (typeof options.expires === 'number') {
        var days = options.expires, t = options.expires = new Date();
        t.setDate(t.getDate() + days);
      }

      value = options.json ? JSON.stringify(value) : String(value);

      return (document.cookie = [
        encodeURIComponent(key), '=', options.raw ? value : encodeURIComponent(value),
        options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
        options.path    ? '; path=' + options.path : '',
        options.domain  ? '; domain=' + options.domain : '',
        options.secure  ? '; secure' : ''
      ].join(''));
    }

    // read
    var decode = options.raw ? raw : decoded;
    var cookies = document.cookie.split('; ');
    for (var i = 0, l = cookies.length; i < l; i++) {
      var parts = cookies[i].split('=');
      if (decode(parts.shift()) === key) {
        var cookie = decode(parts.join('='));
        return options.json ? JSON.parse(cookie) : cookie;
      }
    }

    return null;
  };

  var $removeCookie = function (key, options) {
    if ($cookie(key) !== null) {
      $cookie(key, null, options);
      return true;
    }
    return false;
  };


  function sameOrigin(url) {
    // url could be relative or scheme relative or absolute
    var host = document.location.host; // host + port
    var protocol = document.location.protocol;
    var sr_origin = '//' + host;
    var origin = protocol + sr_origin;
    // Allow absolute or scheme relative URLs to same origin
    return (url === origin || url.slice(0, origin.length + 1) === origin + '/') ||
      (url === sr_origin || url.slice(0, sr_origin.length + 1) === sr_origin + '/') ||
      // or any other URL that isn't scheme relative or absolute i.e relative.
      !(/^(\/\/|http:|https:).*/.test(url));
  }

  function safeMethod(method) {
    return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
  }

  // Make an AJAX request to the server.
  // Usage:
  //   var req = Backbone.ajax({url: 'url', type: 'PATCH', data: 'data'});
  //   req.then(..., ...) // if Promise is set
  var ajax = (function() {
    var xmlRe = /^(?:application|text)\/xml/;
    var jsonRe = /^application\/json/;

    var getData = function(accepts, xhr) {
      if (accepts == null) accepts = xhr.getResponseHeader('content-type');
      if (xmlRe.test(accepts)) {
        return xhr.responseXML;
      } else if (jsonRe.test(accepts) && xhr.responseText !== '') {
        return JSON.parse(xhr.responseText);
      } else {
        return xhr.responseText;
      }
    };

    var isValid = function(xhr) {
      return (xhr.status >= 200 && xhr.status < 300) ||
        (xhr.status === 304) ||
        (xhr.status === 0 && window.location.protocol === 'file:')
    };

    var end = function(xhr, options, resolve, reject) {
      return function() {
        if (xhr.readyState !== 4) return;

        var status = xhr.status;
        var data = getData(options.headers && options.headers.Accept, xhr);

        // Check for validity.
        if (isValid(xhr)) {
          if (options.success) options.success(data);
          if (resolve) resolve(data);
        } else {
          var error = new Error('Server responded with a status of ' + status);
          if (options.error) options.error(xhr, status, error);
          if (reject) reject(xhr);
        }
      }
    };

    return function(options) {
      if (options == null) throw new Error('You must provide options');
      if (options.type == null) options.type = 'GET';

      var resolve, reject, xhr = new XMLHttpRequest();
      var PromiseFn = ajax.Promise || (typeof Promise !== 'undefined' && Promise);
      var promise = PromiseFn && new PromiseFn(function(res, rej) {
        resolve = res;
        reject = rej;
      });

      if (options.contentType) {
        if (options.headers == null) options.headers = {};
        options.headers['Content-Type'] = options.contentType;
      }

      // Stringify GET query params.
      if (options.type === 'GET' && typeof options.data === 'object') {
        var query = '';
        var stringifyKeyValuePair = function(key, value) {
          return value == null ? '' :
            '&' + encodeURIComponent(key) +
            '=' + encodeURIComponent(value);
        };
        for (var key in options.data) {
          query += stringifyKeyValuePair(key, options.data[key]);
        }

        if (query) {
          var sep = (options.url.indexOf('?') === -1) ? '?' : '&';
          options.url += sep + query.substring(1);
        }
      }

      xhr.addEventListener('readystatechange', end(xhr, options, resolve, reject));
      xhr.open(options.type, options.url, true);

      var allTypes = "*/".concat("*");
      var xhrAccepts = {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      };
      xhr.setRequestHeader(
        "Accept",
        options.dataType && xhrAccepts[options.dataType] ?
          xhrAccepts[options.dataType] + (options.dataType !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
          xhrAccepts["*"]
      );

      if (!safeMethod(options.type) && sameOrigin(options.url)) {
        xhr.setRequestHeader("X-CSRF-Token", $cookie('_csrftoken'));
      }

      if (options.headers) for (var key in options.headers) {
        xhr.setRequestHeader(key, options.headers[key]);
      }
      if (options.beforeSend) options.beforeSend(xhr);
      xhr.send(options.data);

      return promise;
    };
  })();
  return ajax;
}));

define('VeroldEngine/Util/DOMUtilities',[ ], function() {
  var VAPI = window.VAPI = window.VAPI || {};

  // http://stackoverflow.com/a/6660151
  VAPI.safeHTML = function safeHTML(s) {
    var div = document.createElement('div');
    div.innerHTML = s;
    var scripts = div.getElementsByTagName('script');
    var i = scripts.length;
    while (i--) {
      scripts[i].parentNode.removeChild(scripts[i]);
    }
    return div.innerHTML;
  };

  return VAPI;
});

define('VeroldEngine/Loaders/JSONLoader',[ 'underscore', 'VeroldEngine/collections/entity' ] , 
      function(_, EntityCollection) {
  function JSONLoader(veroldEngine, url) {
    this.veroldEngine = veroldEngine;
    this.url = url;
  }

  JSONLoader.prototype.load = function(options) {
    var entities = new (EntityCollection.extend({ url: this.url }));
  
    entities.fetch({ reset: true });
    
    entities.once('reset', _.bind(this.patchLoadedResources, this, options), this); 
  };

  JSONLoader.prototype.patchLoadedResources = function(options, collection) {
    options = options || {};

    collection.each(function(model) {
      if (model.has('children')) {
        // processor exports children as an array in the form of [ id1, id2, id3 ], but runtime 
        // expects children to be an object in the form of { id1: true, id2: true, id3: true }
        var invertedChildren = {};
        _.each(model.get('children'), function(id) {
          invertedChildren[id] = true;    
        });
        model.attributes.children = invertedChildren;
      }     
      
      // override default path
      model.attributes.overridePrefix = collection.url.substr(0,collection.url.lastIndexOf('/')) + '/';
    });
    
    this.veroldEngine.assetRegistry._initProjectAssets(collection);
    this.veroldEngine.assetRegistry._initProjectObjects(collection);

    if (_.isFunction(options.success)) {
      options.success(collection);
    }
  };

  window.VAPI = window.VAPI || {};
  window.VAPI.JSONLoader = JSONLoader; 
});

define('VeroldEngine/VAPI',[ 'underscore', 'backbone', 'async', 'VeroldEngine/collections/entity',
            'VeroldEngine/Engine', 'VeroldEngine/Components/VeroldComponent',
            'VeroldEngine/libs/backbone/backbone.nativeajax',
            'VeroldEngine/Util/APIUtilities', 'VeroldEngine/Util/DOMUtilities',
            'VeroldEngine/Loaders/JSONLoader'
             ],
    function(_, Backbone, async, EntityCollection, VeroldEngine, VeroldComponent, ajax ) {

      // Temp fix for running in verold editor without jquery, if we have the VAPI
      // version of backbone, assume we are running without the studio and use a 
      // standalone version of ajax, otherwise configure jquery to properly send headers.
      if (!Backbone.View) {
        Backbone.ajax = ajax;
      } else {
        var $ = require('jquery');
        $.support.cors = true;

        // https://docs.djangoproject.com/en/1.2/ref/contrib/csrf/#csrf-ajax
        $(document).ajaxSend(function(event, xhr, settings) {
          function sameOrigin(url) {
            // url could be relative or scheme relative or absolute
            var host = document.location.host; // host + port
            var protocol = document.location.protocol;
            var sr_origin = '//' + host;
            var origin = protocol + sr_origin;
            // Allow absolute or scheme relative URLs to same origin
            return (url === origin || url.slice(0, origin.length + 1) === origin + '/') ||
              (url === sr_origin || url.slice(0, sr_origin.length + 1) === sr_origin + '/') ||
              // or any other URL that isn't scheme relative or absolute i.e relative.
              !(/^(\/\/|http:|https:).*/.test(url));
          }

          function safeMethod(method) {
            return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
          } 

          if (!safeMethod(settings.type) && sameOrigin(settings.url)) {
            xhr.setRequestHeader("X-CSRF-Token", $.cookie('_csrftoken'));
          }
        });
      }

      _.noConflict();
      Backbone.noConflict();

      var VAPI = window.VAPI;

      VAPI.require = require;
      VAPI.define = define;

      VAPI.getBrowser = function() {
        var ua= navigator.userAgent, tem, 
        M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        if(/trident/i.test(M[1])){
            tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
            return 'IE '+(tem[1] || '');
        }
        if(M[1]=== 'Chrome'){
            tem= ua.match(/\bOPR\/(\d+)/);
            if(tem!= null) return 'Opera '+tem[1];
        }
        M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
        if((tem= ua.match(/version\/(\d+)/i))!= null) M.splice(1, 1, tem[1]);
        return M.join(' ');
      };

      var isMobile = /iphone|ipad|ipod|android|blackberry|bb10|mini|windows\sce|palm/i.test(navigator.userAgent.toLowerCase());
      VAPI.isMobile = function() {
        return isMobile;
      };

      var isIOS = /iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase());
      VAPI.isIOS = function() {
        return isIOS;
      };

      var isAndroid = /android/i.test(navigator.userAgent.toLowerCase());
      VAPI.isAndroid = function() {
        return isAndroid;
      };

      var isMac = /mac/i.test(navigator.userAgent.toLowerCase());
      VAPI.isMac = function() {
        return isMac;
      };

      var isLinux = /linux/i.test(navigator.userAgent.toLowerCase());
      VAPI.isLinux = function() {
        return isLinux;
      };

      var isUnix = /x11/i.test(navigator.userAgent.toLowerCase());
      VAPI.isUnix = function() {
        return isUnix;
      };

      var isWindows = /windows/i.test(navigator.userAgent.toLowerCase());
      VAPI.isWindows = function() {
        return isWindows;
      };

      var isChrome = /chrome/i.test(navigator.userAgent.toLowerCase());
      VAPI.isChrome = function() {
        return isChrome;
      };

      var isFirefox = /firefox/i.test(navigator.userAgent.toLowerCase());
      VAPI.isFirefox = function() {
        return isFirefox;
      };

      var isSafari = /safari/i.test(navigator.userAgent.toLowerCase());
      VAPI.isSafari = function() {
        return isSafari;
      };

      var isOpera = /opera/i.test(navigator.userAgent.toLowerCase());
      VAPI.isOpera = function() {
        return isOpera;
      };

      var isIE = /ie/i.test(VAPI.getBrowser().toLowerCase());
      VAPI.isIE = function() {
        return isIE;
      };

      var isIE11 = /ie 11/i.test(VAPI.getBrowser().toLowerCase());
      VAPI.isIE11 = function() {
        return isIE11;
      };

      VAPI.defaultPaths = VAPI.defaultPaths || {
        apiBaseUrl: window.verold && window.verold.apiBaseUrl || '',
        staticBaseUrl: window.verold && window.verold.staticBaseUrl || '',
        glAssetsBaseUrl: window.verold && window.verold.glAssetsBaseUrl || '',
        assetsBaseUrl: window.verold && window.verold.assetsBaseUrl || ''
      };

      VAPI.globalEvents = VAPI.globalEvents ||
          (window.verold && window.verold.veroldEvents) ||
          _.extend({}, Backbone.Events);

      var projectData = {

      };

      // backwards compatibility
      VAPI.VeroldEngine = VeroldEngine;

      VAPI.addProjectData = function(data) {
        projectData[data.project.id] = {};
        projectData[data.project.id].project = new Backbone.Model(data.project);
        projectData[data.project.id].entities = new EntityCollection(data.entities, { project: projectData[data.project.id].project });
        projectData[data.project.id].settings = data.settings || {};
      };

      var log = VAPI.log = function(s) {
        var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1,
            style = "color:#009BDF;font-size: 12pt";

        if (isChrome) {
          console.log("%c%s", style, s);
        } else if (console.log) {
          console.log(s);
        }
      };

      VAPI.help = function() {
        log('Verold API Devtools');
        log('VAPI.help() - show these instructions');
        log('window.Default - your VeroldEngine object');
      };

      var applicationContexts = {};

      VAPI.getApplicationContext = function(name) {
        if (!applicationContexts[name]) {
          applicationContexts[name] = {};
        }

        return applicationContexts[name];
      };

      VAPI.addScript = function(id, options, constructionScript) {
        VAPI.ScriptRegistry.addScript(id, options, constructionScript);

        // add to existing engines
        VAPI.globalEvents.trigger('VAPI:addScript', id, options, constructionScript);
      };

      VAPI.loadProject = function(projectId, callback, opts) {
        var project = new Backbone.Model(),
            paths = opts && opts.paths || VAPI.defaultPaths,
            entities;

        project.url = paths.apiBaseUrl + '/projects/' + projectId;
        project.id = projectId;

        var error = function(){
          callback(new Error('Failed to load project'));
        };

        if (projectData[projectId]) {
          return callback(null, projectData[projectId].project, projectData[projectId].entities,
              projectData[projectId].settings);
        }

        var entitiesLoaded = function(entities) {
          callback(null, project, entities);
        };

        var projectLoaded = function() {
          entities = new EntityCollection([], { project: project, paths: paths });
          entities.fetch({ reset: true, success: entitiesLoaded, error: error });
        };

        project.fetch({ success: projectLoaded, error: error });
      };

      VAPI.startProject = function(projectId, selector, options) {
        var engineOptions,
            load,
            error = function(err) {
              alert(err);
            };

        if (_.isFunction(options)) {
          load = options;
          options = {};
        } else {
          options = options || {};

          if (_.isFunction(options.load)) {
            load = options.load;
          }

          if (_.isFunction(options.error)) {
            error = options.error;
          }
        }

        engineOptions = options.options || {};

        var veroldEngine = new VeroldEngine(_.extend({
          "engineName": options.name || "VeroldEngine",
          "container": selector
        }, engineOptions));

        VAPI.loadProject(projectId, function (err, project, entities) {
          if (err) {
            return error(err);
          }

          veroldEngine.initialize(_.extend({
            "entities": entities,
            "projectId": projectId
          }, engineOptions));

          veroldEngine.loadScene(project.get('entityId'), {
            load: load
          });
        });

        return veroldEngine;
      };

      VAPI.browserCaps = (function() {
        var webGLContext;

        try {
          webGLContext = (!!window.WebGLRenderingContext) ? document.createElement('canvas').getContext('experimental-webgl') : null;
        } catch(e) {}
        var webGLEnabled = !!webGLContext;
        var floatingPointTexturesEnabeled = (webGLEnabled) ? !!webGLContext.getExtension('OES_texture_float') : false;
        var vertexTexturesEnabeled = (webGLEnabled) ? !!(webGLContext.getParameter(webGLContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS) !== 0) : false;

        webGLContext = null;

        return {
          isWebGLEnabled : function() {
            return webGLEnabled;
          },

          isFloatingPointTexturesEnabeled : function() {
            return floatingPointTexturesEnabeled;
          },

          isVertexTexturesEnabeled : function() {
            return vertexTexturesEnabeled;
          }
        };
      }());

      return VAPI;
    });

  return require('VeroldEngine/VAPI');
}));
